        .TITLE  CVRTM
        .IDENT  /02/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 02
;
; D. N. CUTLER 12-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;
; MODIFIED BY:
;
;+
; **-$CVRTM-CONVERT TIME
;
; THIS ROUTINE IS CALLED TO CONVERT A TIME INTERVAL-TIME UNITS PAIR
; TO A CLOCK TICKS COUNT.
;
; INPUTS:
;
;       R3=ADDRESS OF TIME INTERVAL-TIME UNITS PAIR.
;
; OUTPUTS:
;
;       IF AN ILLEGAL TIME INTERVAL (GREATER THAN 15 BITS) OR
;       ILLEGAL TIME UNITS (ZERO OR GREATER THAN 4) IS SPECIFIED,
;       THEN A DIRECTIVE STATUS OF 'D.RS93' IS RETURNED. ELSE THE
;       TICKS COUNT IS RETURNED WITH THE HIGH ORDER PART IN R0 AND
;       THE LOW ORDER PART IN R1. R3 IS ADVANCED BY 4 THUS POINTING
;       PAST THE TIME INTERVAL-TIME UNITS PAIR.
;-
 
$CVRTM::MOV     (R3)+,R1        ;GET TIME INTERVAL
        BMI     70$             ;IF MI ILLEGAL TIME INTERVAL
        MOV     (R3)+,R0        ;GET TIME UNITS
        DEC     R0              ;BACK OFF BY ONE
        CMP     R0,#3           ;LEGAL UNITS?
        BHI     70$             ;IF HI NO
        ASL     R0              ;CONVERT TO DISPATCH INDEX
        ADD     R0,PC           ;DISPATCH
10$:    BR      50$             ;1=TICKS
        BR      30$             ;2=SECONDS
        BR      20$             ;3=MINUTES
        MOV     #60.,R0         ;4=HOURS
        CALL    $MUL            ;CALCULATE NUMBER OF MINUTES
        TST     R0              ;OVERFLOW 16 BITS?
        BNE     70$             ;IF NE YES
20$:    CMP     R1,#1440.       ;MORE THAN ONE DAY OF MINUTES?
        BHI     70$             ;IF HI YES
        MOV     #30.,R0         ;MULTIPLY BY 60. SECONDS/2
        CALL    $MUL            ;PRODUCT CANNOT OVERFLOW 16 BITS.
        MOV     $TKPS,R0        ;GET TICKS PER SECOND
        ASL     R0              ;MULTIPLY BY 2
        BR      40$             ;
30$:    MOV     $TKPS,R0        ;GET TICKS PER SECOND
40$:    CALL    $MUL            ;CALCULATE TICKS COUNT
50$:    MOV     R0,R2           ;TICKS COUNT ZERO?
        BIS     R1,R2           ;
        BNE     60$             ;IF NE NO
        INC     R1              ;MAKE TICKS COUNT 1
60$:    RETURN                  ;
70$:    DRSTS   D.RS93          ;SET DIRECTIVE STATUS
 
        .END
        .TITLE  ADDRV
        .IDENT  /04/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 04
;
; D. N. CUTLER 24-NOV-73
;
; AD01-D ANALOG TO DIGITAL CONVERTER CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  PKTDF$
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
 
;
; LOCAL DATA
;
; DRIVER DISPATCH TABLE
;
 
$ADTBL::.WORD   ADINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   ADCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   ADCAN           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   ADCAN           ;POWERFAIL ENTRY POINT
 
;+
; **-ADINI-AD01-D ANALOG TO DIGITAL CONVERTER CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS RECEIVED FOR THE AD01-D ANALOG TO DIGITAL CONVERTOR. THE AD01-D HAS SUCH A
; FAST CONVERSION RATE (APPROXIMATELY 30US) THAT CONVERSIONS ARE PROGRAM
; RATHER THAN INTERRUPT DRIVEN. THUS REQUESTS ARE NOT QUEUED BY THE QUEUE I/O
; DIRECTIVE AND THE QUEUING/DEQUEUING OVERHEAD IS BYPASSED.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLER TO BE INITIATED.
;
; AD01-D I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RBC).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER.
;       WD. 13 -- DATA BUFFER ADDRESS.
;       WD. 14 -- NUMBER OF BYTES IN DATA BUFFER.
;       WD. 15 -- VIRTUAL ADDRESS OF CONTROL BUFFER.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;
; THE DATA BUFFER RECEIVES CONVERTED VALUES AND THE CONTROL BUFFER CONTAINS
; CONTROL WORDS THAT CONTROL THE CONVERSION PROCESS. EACH WORD IN THE CONTROL
; BUFFER HAS THE FORMAT:
;
;       BITS 15-12 -- GAIN CODE.
;
;               LEGAL GAIN CODES ARE:
;
;               0000=GAIN OF 1.
;               0001=GAIN OF 2.
;               0010=GAIN OF 4.
;               0011=GAIN OF 8.
;
;       BITS 11-0 -- CHANNEL NUMBER.
;
;               EACH AD01-D MAY HAVE 64. CHANNELS. THE LEGALITY OF
;               A PARTICULAR CHANNEL NUMBER IS DETERMINED BY THE
;               SECOND DEVICE CHARACTERISTICS WORD.
;
; OUTPUTS:
;
;       EACH CHANNEL IS CONVERTED ACCORDING TO THE CORRESPONDING WORD IN
;       THE CONTROL BUFFER AND THE RESULTANT VALUE IS PLACED IN THE
;       DATA BUFFER. IF AN ILLEGAL CONTROL WORD OR AD01-D ERROR IS DE-
;       TECTED, THEN THE CONVERSION PROCESS IS TERMINATED. THE SECOND I/O
;       STATUS WORD SPECIFIES THE NUMBER OF CHANNELS THAT WERE CONVERTED.
;-
 
ADINI:  MOV     R1,R3           ;COPY ADDRESS OF I/O PACKET
        MOV     I.PRM+6(R3),R0  ;GET VIRTUAL ADDRESS OF CONTROL BUFFER
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     I.PRM+4(R3),R1  ;SET LENGTH OF BUFFER TO CHECK
        CALL    $ACHCK          ;ADDRESS CHECK CONTROL BUFFER
        BCS     50$             ;IF CS ADDRESS CHECK FAILURE
 
        .IFTF
 
        CALL    $RELOC          ;RELOCATE CONTROL BUFFER ADDRESS
        MOV     R5,R0           ;COPY ADDRESS OF UCB
        ADD     #U.BUF,R0       ;POINT TO BUFFER RELOCATION BIAS
        MOV     I.PRM(R3),(R0)+ ;INSERT DATA BUFFER RELOCATION BIAS
        MOV     I.PRM+2(R3),(R0)+ ;INSERT DATA BUFFER ADDRESS
        CLR     (R0)+           ;CLEAR NUMBER OF SAMPLES PERFORMED
        MOV     R1,(R0)+        ;INSERT CONTROL BUFFER RELOCATION BIAS
        MOV     R2,(R0)         ;INSERT CONTROL BUFFER ADDRESS
        MOV     S.CSR(R4),R4    ;GET ADDRESS OF CONTROL STATUS REGISTER
 
;
; INITIATE I/O OPERATION
;
 
10$:    CALL    $GTCWD          ;GET NEXT WORD FROM CONTROL BUFFER
        MOV     (SP)+,R1        ;RETRIEVE CONTROL WORD
        BIT     #147700,R1      ;BAD GAIN OR CHANNEL?
        BNE     60$             ;IF NE YES
        CMPB    R1,U.CW2(R5)    ;LEGAL CHANNEL THIS CONTROLLER?
        BHIS    60$             ;IF HIS NO
        SWAB    R1              ;SWAP CHANNEL AND GAIN FIELDS
        RORB    R1              ;ADJUST GAIN TO PROPER POSITION
        MOV     R1,(R4)         ;START CONVERSION
        MOV     #6,R2           ;SET REPEAT COUNT
20$:    BIT     #100200,(R4)    ;ERROR OR READY?
        BMI     30$             ;IF MI ERROR
        BNE     40$             ;IF NE READY
        DEC     R2              ;TIMEOUT?
        BGT     20$             ;IF GT NO
30$:    MOV     #IE.DNR&377,R0  ;SET DEVICE NOT READY STATUS
        BR      70$             ;
40$:    INC     U.CNT(R5)       ;INCREMENT NUMBER OF SAMPLES TAKEN
        MOV     2(R4),-(SP)     ;GET CONVERTED VALUE
        CALL    $PTWRD          ;PUT VALUE IN DATA BUFFER
        SUB     #2,I.PRM+4(R3)  ;ANY MORE SAMPLES TO TAKE?
        BGT     10$             ;IF GT YES
        MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS
        BR      70$             ;
 
        .IFT
 
50$:    MOV     #IE.SPC&377,R0  ;SET ILLEGAL BUFFER STATUS
        BR      70$             ;
 
        .ENDC
 
 
60$:    MOV     #IE.BAD&377,R0  ;SET BAD PARAMETER STATUS
70$:    MOV     U.CNT(R5),R1    ;SET NUMBER OF CHANNELS SAMPLED
        CALL    $IOFIN          ;FINISH I/O OPERATION
 
;
; CANCEL I/O OPERATION, DEVICE TIMEOUT, AND POWERFAIL ARE NOP'ED.
;
 
ADCAN:  RETURN                  ;
 
        .END
        .TITLE  AFDRV
        .IDENT  /06/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 06
;
; D. N. CUTLER 30-NOV-73
;
; PREVIOUSLY MODIFIED BY:
;
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
; AFC11 ANALOG TO DIGITAL CONVERTER CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
 
;
; LOCAL DATA
;
; CONTROLLER IMPURE TABLES (INDEXED BY CONTROLLER NUMBER)
;
 
CNTBL:  .BLKW   A$$F11          ;ADDRESS OF UNIT CONTROL BLOCK
 
 
        .IF GT  A$$F11-1
 
TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER
 
        .ENDC
 
        
;
; HARDWARE GAIN CODE TABLE
;
 
GAINTB: .BYTE   160             ;GAIN OF 1
        .BYTE   140             ;GAIN OF 2
        .BYTE   100             ;GAIN OF 10
        .BYTE   120             ;GAIN OF 20
        .BYTE   60              ;GAIN OF 50
        .BYTE   40              ;GAIN OF 100
        .BYTE   20              ;GAIN OF 200
        .BYTE   0               ;GAIN OF 1000
 
;
; DRIVER DISPATCH TABLE
;
 
$AFTBL::.WORD   AFCHK           ;DEVICE INITIATOR ENTRY POINT
        .WORD   AFCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   AFOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   AFPWF           ;POWERFAIL ENTRY POINT
 
;+
; **-AFCHK-AFC11 ANALOG TO DIGITAL CONVERTER CONTROLLER PARAMETER CHECKING
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS RECEIVED FOR THE AFC11 ANALOG TO DIGITAL CONVERTOR. AFC11 I/O REQUESTS
; CONTAIN DEVICE DEPENDENT INFORMATION THAT MUST BE CHECKED IN THE CONTEXT
; OF THE ISSUING TASK. THEREFORE THE I/O REQUEST IS NOT QUEUED BEFORE CALLING
; THE DRIVER.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLER TO BE INITIATED.
;
; OUTPUTS:
;
;       THE CONTROL BUFFER IS ADDRESS CHECKED TO DETERMINE WHETHER IT LIES
;       WITHIN THE ISSUING TASK'S ADDRESS SPACE. IF THE ADDRESS CHECK
;       SUCCEEDS, THEN THE CONTROL BUFFER ADDRESS IS RELOCATED AND STORED
;       IN THE I/O PACKET, THE I/O PACKET IS INSERTED IN THE CONTROLLER
;       QUEUE, AND THE DEVICE INITIATOR IS ENTERED TO START THE CONTROLLER.
;       ELSE AN ILLEGAL BUFFER STATUS IS RETURNED AS THE FINAL I/O STATUS
;       OF THE REQUEST.
;-
 
AFCHK:  MOV     R1,R3           ;COPY ADDRESS OF I/O PACKET
        MOV     I.PRM+6(R3),R0  ;GET VIRTUAL ADDRESS OF CONTROL BUFFER
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     I.PRM+4(R3),R1  ;SET LENGTH OF BUFFER TO CHECK
        CALL    $ACHCK          ;ADDRESS CHECK CONTROL BUFFER
        BCC     10$             ;IF CC ADDRESS OKAY
        MOV     #IE.SPC&377,R0  ;SET ILLEGAL BUFFER STATUS
        CALLR   $IOFIN          ;FINISH I/O OPERATION
 
        .ENDC
 
 
10$:    CALL    $RELOC          ;RELOCATE CONTROL BUFFER ADDRESS
        MOV     R1,I.PRM+6(R3)  ;SET RELOCATION BIAS OF CONTROL BUFFER
        MOV     R2,I.PRM+10(R3) ;SET ADDRESS OF CONTROL BUFFER
        MOV     R3,R1           ;SET ADDRESS OF I/O PACKET
        MOV     R4,R0           ;SET ADDRESS OF I/O QUEUE LISTHEAD
        CALL    $QINSP          ;INSERT I/O PACKET IN REQUEST QUEUE
 
;+
; **-AFINI-AFC11 ANALOG TO DIGITAL CONVERTOR CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-
 
        .ENABL  LSB
AFINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     AFCAN           ;IF CS CONTROLLER BUSY OR NO REQUEST
 
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; AFC11 I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RBC).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER.
;       WD. 13 -- DATA BUFFER ADDRESS.
;       WD. 14 -- NUMBER OF BYTES IN DATA BUFFER.
;       WD. 15 -- RELOCATION BIAS OF CONTROL BUFFER.
;       WD. 16 -- CONTROL BUFFER ADDRESS.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;
; THE DATA BUFFER RECEIVES CONVERTED VALUES AND THE CONTROL BUFFER CONTAINS
; CONTROL WORDS THAT CONTROL THE CONVERSION PROCESS. EACH WORD IN THE CONTROL
; BUFFER HAS THE FORMAT:
;
;       BITS 15-12 -- GAIN CODE.
;
;               LEGAL GAIN CODES ARE:
;
;               0000=GAIN OF 1.
;               0001=GAIN OF 2.
;               0100=GAIN OF 10.
;               0101=GAIN OF 20.
;               1000=GAIN OF 50.
;               1001=GAIN OF 100.
;               1100=GAIN OF 200.
;               1101=GAIN OF 1000.
;
;       BITS 11-0 -- CHANNEL NUMBER.
;
;               EACH AFC11 MAY HAVE 2048. CHANNELS. THE LEGALITY OF
;               A PARTICULAR CHANNEL NUMBER IS DETERMINED BY THE
;               SECOND DEVICE CHARACTERISTICS WORD.
;
; EACH CHANNEL IS CONVERTED ACCORDING TO THE CORRESPONDING WORD IN THE CONTROL
; BUFFER AND THE RESULTANT VALUE IS PLACED IN THE DATA BUFFER. IF AN ILLEGAL
; CONTROL WORD IS DETECTED THEN THE CONVERSION PROCESS IS TERMINATED. THE SECOND
; I/O STATUS WORD SPECIFIES THE NUMBER OF CHANNELS THAT WERE CONVERTED.
;-
 
        MOV     R5,CNTBL(R3)    ;SAVE UCB ADDRESS
        MOV     I.PRM+6(R1),U.CBF(R5) ;SET RELOCATION BIAS OF CONTROL BUFFER
        MOV     I.PRM+10(R1),U.CBF+2(R5) ;SET ADDRESS OF CONTROL BUFFER
 
;
; INITIATE I/O OPERATION
;
 
10$:    CALL    $GTCWD          ;GET NEXT WORD FROM CONTROL BUFFER
        MOV     #IE.BAD&377,R0  ;ASSUME ILLEGAL GAIN OR CHANNEL
        MOV     (SP)+,R1        ;RETRIEVE CONTROL WORD
        MOV     R1,R2           ;COPY CONTROL WORD
        BIC     #170000,R1      ;CLEAR GAIN CODE BITS
        CMP     R1,U.CW2(R5)    ;LEGAL CHANNEL THIS CONTROLLER?
        BHIS    AFOUT           ;IF HIS NO
        BIC     #7777,R2        ;CLEAR CHANNEL NUMBER
        ASL     R2              ;ISOLATE HARDWARE GAIN
        ROL     R2              ;
        ROL     R2              ;
        BCS     AFOUT           ;IF CS ILLEGAL GAIN CODE
        ASRB    R2              ;DROP BIT 13 OF SOFTWARE GAIN
        ROL     R2              ;RETRIEVE REMAINING GAIN BITS
        ROL     R2              ;   FOR GAIN TABLE OFFSET
        SWAB    R1              ;GET HIGH BYTE OF GAIN COMMAND
        BISB    GAINTB(R2),R1   ;SET GAIN CODE
        SWAB    R1              ;RESTORE COMMAND
        MOVB    S.ITM(R4),S.CTM(R4) ;SET CURRENT DEVICE TIMEOUT COUNT
        MOV     S.CSR(R4),R4    ;GET ADDRESS OF CONTROL STATUS REGISTER
        MOV     R1,4(R4)        ;LOAD CHANNEL AND GAIN REGISTER
        MOV     #100,(R4)       ;ENABLE INTERRUPT
 
;
; CANCEL I/O OPERATION IS A NOP FOR THE AFC11.
;
 
AFCAN:                          ;REF LABEL
 
;
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE.
;
 
AFPWF:  RETURN                  ;
 
;+
; **$AFINT-AFC11 ANALOG TO DIGITAL CONVERTOR CONTROLLER INTERRUPTS
;-
 
$AFINT::                        ;REF LABEL
        INTSV$  AF,PR5,A$$F11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOV     S.CSR(R4),R3    ;GET ADDRESS OF CONTROL STATUS REGISTER
        MOV     2(R3),-(SP)     ;GET CONVERTED DIGITAL VALUE
        CALL    $PTWRD          ;PUT CONVERTED VALUE IN DATA BUFFER
        SUB     #2,U.CNT(R5)    ;ANY MORE TO CONVERT?
        BGT     10$             ;IF GT YES
        MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS
 
;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING TERMINATED WITH A FINAL
; I/O STATUS OF DEVICE NOT READY. THE SECOND I/O STATUS WORD CONTAINS THE
; NUMBER OF CHANNELS THAT WERE SAMPLED BEFORE THE TIMEOUT OCCURRED. TIMEOUTS
; ARE USUALLY CAUSED BY POWERFAILURE BUT MAY ALSO BE THE RESULT OF A
; HARDWARE FAILURE.
;
 
AFOUT:  CLR     @S.CSR(R4)      ;;;CLEAR INTERRUPT ENABLE
        CLRB    PS              ;;;ALLOW INTERRUPTS
        MOV     S.PKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        MOV     I.PRM+4(R3),R1  ;GET SIZE OF ORIGINAL BUFFER
        SUB     U.CNT(R5),R1    ;CALCULATE NUMBER OF BYTES PROCESSED
        ROR     R1              ;CONVERT TO NUMBER OF SAMPLES PROCESSED
        CALL    $IODON          ;FINISH I/O OPERATION
        BR      AFINI           ;GO AGAIN
        .DSABL  LSB
 
        .END
        .TITLE  ARDRV
        .IDENT  /04.1/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 04
;
; D.N. CUTLER / C.A. D'ELIA  1-JAN-75
;
; PREVIOUSLY MODIFIED BY:
;
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       C. A. D'ELIA 24-MAR-77
;
;               CD037 -- REPLACE MISTYPED CONDITIONAL THAT CAUSES CRASH.
;
;       B. SCHREIBER 2-NOV-77
;
;               BS033 -- CLEAR I.PRM+16 BEFORE CALLING $IOFIN
;
;       B. SCHREIBER    19-MAY-78
;
;               BS049 -- FIX HANDLING OF DIGITAL INPUT WD. AT INTERRUPT
;
; AR11 LABORATORY PERIPHERAL SYSTEM CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,PKTDF$,TCBDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;
; EQUATED SYMBOLS
;
; SAMPLE CONTROL BLOCK OFFSET DEFINITIONS
;

        .PSECT  ARCTLQ,D,ABS

SLINK:  .BLKW   1               ;SAMPLE QUEUE THREAD WORD
RQPKT:  .BLKW   1               ;ADDRESS OF I/O REQUEST PACKET
STATE:  .BLKW   1               ;CURRENT SAMPLE STATE
RSTAT:  .BLKB   1               ;SAMPLE STATUS BYTE
FINST:  .BLKB   1               ;FINAL I/O STATUS
IOSB2:  .BLKW   2               ;SECOND I/O STATUS WORD ADDRESS AND REL BIAS
STRBF:  .BLKW   1               ;STARTING BUFFER ADDRESS AND RELOCATION BIAS
CURBF:  .BLKW   3               ;CURRENT BUFFER ADDRESS AND RELOCATION BIAS
FULBF:  .BLKW   1               ;SIZE OF FULL BUFFER IN WORDS
SMCNT:  .BLKW   1               ;SPACE REMAINING TO END OF BUFFER
HAFBF:  .BLKW   1               ;SIZE OF HALF BUFFER IN WORDS


        .IF DF  D$$R11

DBMSK:  .BLKW   1               ;DIGITAL INPUT/OUTPUT START MASK
DSMSK:  .BLKW   1               ;DIGITAL INPUT STOP MASK

        .ENDC


CYCNT:  .BLKW   1               ;NUMBER OF CLOCK TICKS TO NEXT SAMPLE
CRSET:  .BLKW   1               ;RESET VALUE FOR CLOCK TICKS TO NEXT SAMPLE
SAMCT:  .BLKW   1               ;NUMBER OF SAMPLE BUFFERS BEFORE BUFFER RUNOUT
DATAW:  .BLKW   1               ;FUNCTION DEPENDENT DATA WORD
STRST:  .BLKW   1               ;STARTING SAMPLE STATE
SLGTH:                          ;LENGTH OF SAMPLE CONTROL BLOCK


        .PSECT

;
; SAMPLE CONTROL BLOCK STATUS BYTE BIT DEFINITIONS
;

SPARE=200                       ;SPARE BIT
STROT=100                       ;SET DIGITAL OUTPUT BIT AT START (1=YES)
STPIN=40                        ;STOP ON DIGITAL INPUT BIT CLEAR (1=YES)
STPBR=20                        ;STOP ON BUFFER RUNOUT (1=YES)
GAINR=10        ;(LPS11 ONLY)   ;AUTOGAIN RANGING REQUESTED (1=YES)
SPARE=4                         ;SPARE BIT
RQEFN=2                         ;REQUEST EFN SETTING (1=YES)
STPRQ=1                         ;STOP SAMPLE REQUEST (1=YES)

;
; A/D TIMEOUT LOOP COUNT
;

TMOCNT=20.

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   A$$R11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK


        .IF DF  D$$R11

DGIWD:  .BLKW   A$$R11          ;DIGITAL INPUT WORD LAST SYNCHRONOUS SAMPLE

        .ENDC


TEMP:   .BLKW   1               ;TEMPORARY STORAGE

;
; FORK REQUEST FLAG
;

FKFLG:  .WORD   0

;
; LEGAL FUNCTION VECTOR
;

LGFCN:  .BYTE   IO.SDO/256.     ;WRITE DIGITAL OUTPUT REGISTER
        .BYTE   IO.SDI/256.     ;READ DIGITAL INPUT REGISTER
        .BYTE   IO.STP/256.     ;STOP IN-PROGRESS REQUEST
        .BYTE   IO.ADS/256.     ;SYNCHRONOUS A/D SAMPLING
        .BYTE   IO.MDA/256.     ;SYNCHRONOUS D/A OUTPUT
        .BYTE   IO.MDO/256.     ;SYNCHRONOUS DIGITAL OUTPUT
        .EVEN

;
; DRIVER DISPATCH TABLE
;

$ARTBL::.WORD   ARINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   ARCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   AROUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   ARPWF           ;POWERFAIL ENTRY POINT

;+
; **-ARINI-AR11 LABORATORY PERIPHERAL SYSTEM CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS RECEIVED FOR THE AR11 LABORATORY PERIPHERAL SYSTEM. SEVEN FUNCTIONS ARE
; RECOGNIZED BY THE AR11 DRIVER. FUNCTIONS ARE EITHER EXECUTED IMMEDITATELY
; OR PLACED IN A SAMPLE REQUEST QUEUE THAT IS MAINTAINED BY THE DRIVER.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; FUNCTION INDEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE.
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;
; OUTPUTS:
;
;       IF THE FUNCTION IS STOP IN-PROGRESS REQUEST, WRITE DIGITAL OUTPUT
;       REGISTER, OR READ DIGITAL INPUT REGISTER, THEN THE FUNCTION IS
;       EXECUTED IMMEDIATELY. ELSE A SECONDARY CONTROL BLOCK IS
;       CONSTRUCTED AND LINKED INTO THE SAMPLE REQUEST QUEUE.
;-

ARINI:  MOV     R4,R2           ;GET ADDRESS OF SCB
        MOV     R1,R3           ;SAVE I/O PACKET ADDRESS
        ADD     #I.PRM,R1       ;POINT TO FIRST PARAMETER
        MOV     S.CSR(R2),R4    ;GET ADDRESS OF CONTROL STATUS REGISTER
        MOV     #LGFCN,R0       ;POINT TO LEGAL FUNCTION VECTOR
        MOVB    I.FCN+1(R3),-(SP) ;GET I/O FUNCTION CODE
        CMPB    (SP),(R0)+      ;WRITE DIGITAL OUTPUT REGISTER?


        .IF DF  D$$R11

        BEQ     DIGIO           ;IF EQ YES
        CMPB    (SP),(R0)+      ;READ DIGITAL INPUT REGISTER?
        BEQ     RDDIN           ;IF EQ YES

        .IFF

        BEQ     ARONP           ;IF EQ YES
        CMPB    (SP),(R0)+      ;READ DIGITAL INPUT REGISTER?
        BEQ     ARONP           ;IF EQ YES

        .ENDC


        CMPB    (SP),(R0)+      ;STOP IN-PROGRESS REQUEST?
        BNE     ARFCN           ;IF NE NO

;
; **-STOPR-STOP IN-PROGRESS REQUEST
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- BUFFER ADDRESS OF PREVIOUS REQUEST.
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;       WD. 21 -- NOT USED.
;

STOPR:  MOV     (R1),R0         ;GET ADDRESS OF BUFFER
        MOV     R2,R4           ;SAVE ADDRESS OF SCB
        CALL    $RELOC          ;RELOCATE BUFFER ADDRESS
        MOV     R3,-(SP)        ;SAVE I/O PACKET ADDRESS
        MOV     R5,R3           ;CALCULATE ADDRESS OF SAMPLE QUEUE LISTHEAD
        ADD     #U.BUF,R3       ;
        MOVB    S.PRI(R4),PS    ;;;LOCK OUT DEVICE INTERRUPTS
10$:    MOV     (R3),R3         ;;;GET ADDRESS OF NEXT ENTRY
        BEQ     20$             ;;;IF EQ DONE
        MOV     RQPKT(R3),R0    ;;;GET ADDRESS OF I/O PACKET
        CMP     $TKTCB,I.TCB(R0) ;;;REQUEST FOR CURRENT TASK?
        BNE     10$             ;;;IF NE NO
        CMP     R1,STRBF(R3)    ;;;RELOCATION BIAS MATCH?
        BNE     10$             ;;;IF NE NO
        CMP     R2,STRBF+4(R3)  ;;;BUFFER ADDRESS MATCH?
        BNE     10$             ;;;IF NE NO
        MOVB    #IE.ABO,FINST(R3) ;;;SET FINAL STATUS ABORT
        CALL    TERMS           ;;;TERMINATE SAMPLE REQUEST
20$:    CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        MOV     (SP)+,R3        ;RESTORE I/O PACKET ADDRESS
        BR      ARSUC           ;TAKE COMMON EXIT


        .IF DF  D$$R11

;
; **-RDDIN-READ DIGITAL INPUT REGISTER
;
; INPUTS:
;
;       R1=POINTS TO WD. 12 OF I/O PACKET
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- DIGITAL INPUT MASK WORD.
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;       WD. 21 -- NOT USED.
;

RDDIN:  SEC                     ;INDICATE DIGITAL INPUT REQUEST
DIGIO:  BITB    #20,U.CW2+1(R5) ;DR11-K PRESENT?
        BEQ     ARONP           ;IF EQ NO
        MOV     U.CNT+4(R5),R4  ;GET ITS CSR ADDRESS
        BCC     WRDOT           ;BRANCH IF DIGITAL OUTPUT REQUESTED


        .IF GT  A$$R11-1

        MOVB    S.CON(R2),R2    ;GET CONTROLLER INDEX
        MOV     DGIWD(R2),R2    ;GET DIGITAL INPUT WORD LAST SYNCHRONOUS SAMPLE

        .IFF

        MOV     DGIWD,R2        ;GET DIGITAL INPUT WORD LAST SYNCHRONOUS SAMPLE

        .ENDC


        TSTB    U.STS(R5)       ;UNIT BUSY?
        BMI     10$             ;IF MI YES
        MOV     2(R4),R2        ;READ DIGITAL INPUT REGISTER
        MOV     R2,2(R4)        ;CLEAR BITS IN DIGITAL INPUT REGISTER
10$:    COM     (R1)            ;COMPLEMENT MASK WORD
        BIC     (R1),R2         ;CLEAR UNWANTED BITS IN DATA WORD
        MOV     R2,R1           ;SET SECOND I/O STATUS WORD
        BR      ARSUC1          ;TAKE COMMON EXIT

;
; **-WRDOT-WRITE DIGITAL OUTPUT REGISTER
;
; INPUTS:
;
;       R1=POINTS TO WD. 12 OF I/O PACKET
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- DIGITAL OUTPUT MASK WORD.
;       WD. 13 -- DIGITAL OUTPUT VALUE.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;       WD. 21 -- NOT USED.
;

WRDOT:  BIT     (R1),U.CNT+2(R5) ;DIGITAL OUTPUT BITS IN USE?
        BNE     ARRSU           ;IF NE YES
        ADD     #4,R4           ;POINT TO DIGITAL OUTPUT REGISTER
        COM     (R1)            ;COMPLEMENT MASK WORD
        BIC     (R1)+,(R1)      ;CLEAR EXCESS BITS IN DATA WORD
        BIS     (R1),(R4)       ;SET BITS IN DIGITAL OUTPUT REGISTER
        COM     (R1)            ;COMPLEMENT DATA WORD
        BIC     -2(R1),(R1)     ;CLEAR EXCESS BITS IN DATA WORD
        BIC     (R1),(R4)       ;CLEAR BITS IN DIGITAL OUTPUT REGISTER
        MOV     (R4),R1         ;SET SECOND I/O STATUS WORD
        BR      ARSUC1          ;TAKE COMMON EXIT

        .ENDC



;
; SUCCESS COMPLETION OF FUNCTION
;

ARSUC:  CLR     R1              ;CLEAR SECOND I/O STATUS WORD
ARSUC1: MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS CODE
        BR      ARCMN1          ;

;
; BAD PARAMETER
;

ARBAD:  MOV     #IE.BAD&377,R0  ;SET BAD PARAMETER STATUS CODE
        BR      ARCMN           ;


        .IF DF  D$$R11

;
; RESOURCE IN USE
;

ARRSU:  MOV     #IE.RSU&377,R0  ;SET RESOURCE IN USE STATUS CODE
        BR      ARCMN           ;

        .ENDC


;
; PRIVILEGE VIOLATION
;

ARPRI:  MOV     #IE.PRI&377,R0  ;SET PRIVILEGE VIOLATION STATUS
        BR      ARCMN           ;

;
; OPTION NOT PRESENT
;

ARONP:  MOV     #IE.ONP&377,R0  ;SET OPTION NOT PRESENT STATUS
        BR      ARCMN           ;

;
; DYNAMIC MEMORY NOT AVAILABLE
;

ARNOD:  MOV     #IE.NOD&377,R0  ;SET MEMORY NOT AVAILABLE STATUS

;
; COMMON STATUS EXIT
;

ARCMN:  CLR     R1              ;CLEAR SECOND I/O STATUS WORD
ARCMN1: TST     (SP)+           ;REMOVE FUNCTION CODE FROM STACK
        CLR     I.PRM+16(R3)    ;CLEAR BLOCK LOCKING WORD FOR $IOFIN
        CALLR   $IOFIN          ;FINISH I/O OPERATION

;
; ALL REMAINING FUNCTIONS REQUIRE THE REQUESTING TASK TO BE EITHER FIXED
; IN MEMORY OR NOT CHECKPOINTABLE AND AN I/O STATUS DOUBLEWORD TO BE
; SPECIFIED.
;
; INPUTS:
;
;       R1=POINTS TO WD. 12 OF I/O PACKET
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF BUFFER.
;       WD. 13 -- BUFFER ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 14 -- BUFFER SIZE IN BYTES.
;       WD. 15 -- DIGITAL INPUT/OUTPUT POINT NUMBERS.
;       WD. 16 -- AR11 CLOCK TICKS BETWEEN SAMPLES.
;       WD. 17 -- NUMBER OF BUFFERS.
;       WD. 20 -- FUNCTION DEPENDENT DATA WORD.
;       WD. 21 -- SCRATCH.
;

ARFCN:  MOV     I.TCB(R3),R2    ;GET REQUESTING TASK TCB ADDRESS
        BIT     #T2.CHK!T2.FXD,T.ST2(R2) ;TASK FXED OR NOT CHKPOINTABLE?
        BEQ     ARPRI           ;IF EQ NO
        TST     I.IOSB+4(R3)    ;I/O STATUS DOUBLEWORD SPECIFIED?
        BEQ     ARBAD           ;IF EQ NO
        ADD     #6,R1           ;POINT TO DIGITAL I/O BIT NUMBERS
        BITB    #340,I.FCN(R3)  ;DIGITAL I/O SUB-FUNCTION REQUESTED?


        .IF DF  D$$R11

        BEQ     35$             ;IF EQ NO
        BITB    #20,U.CW2+1(R5) ;DR11-K PRESENT?
        BEQ     ARONP           ;IF EQ NO
        MOVB    I.FCN(R3),R2    ;GET SUBFUNCTION MODIFIER BITS
        BPL     10$             ;IF PL START IMMEDIATELY
        CMPB    (R1),#16.       ;LEGAL DIGITAL POINT NUMBER?
        BHIS    ARBAD           ;IF HIS NO
10$:    ASLB    R2              ;SET DIGITAL OUTPUT ON START?
        BPL     20$             ;IF PL NO
        CMPB    (R1),#16.       ;LEGAL DIGITAL POINT NUMBER?
        BHIS    ARBAD           ;IF HIS NO
        MOVB    (R1),R4         ;GET DIGITAL OUTPUT POINT NUMBER
        ASL     R4              ;CONVERT TO WORD INDEX
        BIT     $BTMSK(R4),U.CNT+2(R5) ;DIGITAL OUTPUT BIT IN USE?
        BNE     ARRSU           ;IF NE YES
20$:    ASLB    R2              ;STOP ON DIGITAL INPUT?
        BPL     30$             ;IF PL NO
        CMPB    1(R1),#16.      ;LEGAL DIGITAL POINT NUMBER?
        BHIS    ARBAD           ;IF HIS NO
30$:    ASL     (R1)            ;CONVERT BOTH POINT NUMBERS TO WORD INDICES

        .IFF

        BNE     ARONP           ;IF NE YES

        .ENDC


35$:    ADD     #8.,R1          ;POINT TO LAST (SCRATCH) WORD IN I/O PACKET
        CMPB    (SP),(R0)+      ;SYNCHRONOUS A/D SAMPLING?
        BEQ     60$             ;IF EQ YES
        CMPB    (SP),(R0)+      ;SYNCHRONOUS D/A OUTPUT?


        .IF DF  A$$RDA

        BEQ     50$             ;IF EQ YES

        .IFF

        BEQ     ARONP           ;D/A NOT PRESENT

        .ENDC


        .IF DF  D$$R11

        BITB    #20,U.CW2+1(R5) ;DR11-K SUPPORT?
        BEQ     ARONP           ;IF EQ NO
        CMPB    (SP),(R0)+      ;SYNCHRONOUS DIGITAL OUTPUT?
        BNE     40$             ;IF NE NO (SYNCHRONOUS DIGITAL INPUT)

;
; SYNCHRONOUS DIGITAL OUTPUT
;
; CONTENTS OF FUNCTION DEPENDENT WORD IN I/O PACKET
;       WD. 20 -- DIGITAL OUTPUT BIT MASK.
;

        MOV     #SYNDO,(R1)     ;SET SYNCHRONOUS DIGITAL OUTPUT STATE
        BIT     -(R1),U.CNT+2(R5) ;ANY DIGITAL OUTPUT BITS IN USE?
        BR      45$             ;CONTINUE IN COMMON CODE

;
; SYNCHRONOUS DIGITAL INPUT
;
; CONTENTS OF FUNCTION DEPENDENT WORD IN I/O PACKET
;       WD. 20 -- DIGITAL INPUT BIT MASK.
;

40$:    MOV     #SYNDI,(R1)     ;SET SYNCHRONOUS DIGITAL INPUT STATE
        BIT     -(R1),U.CNT(R5) ;ANY DIGITAL INPUT BITS IN USE?
45$:    BNE     ARRSU           ;IF NE YES
        BR      120$            ;CONTINUE IN COMMON CODE

        .IFF

        BR      ARONP           ;DIGITAL I/O NOT PRESENT

        .ENDC



;
; SYNCHRONOUS D/A OUTPUT
;
; CONTENTS OF FUNCTION DEPENDENT WORD IN I/O PACKET
;       WD. 20 -- D/A CHANNELS.
;


        .IF DF  A$$RDA

50$:    MOV     #SYNDA,(R1)     ;SET SYNCHRONOUS D/A OUTPUT STATE
        MOVB    U.CW2+1(R5),R0  ;GET OPTION FLAGS AND NUMBER OF D/A'S
        BIT     #100,R0         ;D/A OPTION PRESENT?
        BEQ     ARONP           ;IF EQ NO
        BIC     #^C<17>,R0      ;CLEAR ALL BUT NUMBER OF D/A'S
        MOVB    -(R1),R2        ;GET NUMBER OF OUTPUT D/A'S
        MOVB    -(R1),R4        ;GET STARTING D/A NUMBER
        BR      90$             ;FINISH IN COMMON CODE

        .ENDC


;
; SYNCHRONOUS A/D SAMPLING
;
; CONTENTS OF FUNCTION DEPENDENT WORD IN I/O PACKET
;       WD. 20 -- A/D CHANNELS.
;

60$:    MOV     #SYNAD,(R1)     ;SET SYNCHRONOUS A/D SAMPLING STATE
        MOVB    -(R1),R2        ;GET NUMBER OF CHANNELS
        MOVB    -(R1),R4        ;GET STARTING CHANNEL
        MOVB    U.CW2(R5),R0    ;GET NUMBER OF A/D CHANNELS
90$:    DEC     R2              ;REDUCE NUMBER OF CHANNELS
        ADD     R2,R4           ;CALCULATE HIGHEST CHANNEL
        BCS     ARBAD           ;IF CS BAD RANGE
        CMP     R4,R0           ;LEGAL CHANNEL?
        BHIS    ARBAD           ;IF HIS NO

120$:   MOV     R3,R4           ;SAVE I/O PACKET ADDRESS
        MOV     #SLGTH,R1       ;SET LENGTH OF SECONDARY CONTROL BLOCK
        CALL    $ALOCB          ;ALLOCATE SECONDARY CONTROL BLOCK
        MOV     R4,R3           ;RESTORE I/O PACKET ADDRESS
        BCS     ARNOD           ;IF CS NO MEMORY AVAILABLE
        MOV     R0,R1           ;COPY SECONDARY CONTROL BLOCK ADDRESS
        CLR     (R1)+           ;CLEAR LINK WORD
        MOV     R3,(R1)+        ;INSERT I/O PACKET ADDRESS
        ADD     #I.FCN,R3       ;POINT TO SUBFUNCTION MODIFIER BITS


        .IF DF  D$$R11

        MOV     #SDOUT,(R1)+    ;ASSUME INITIAL STATE IS DIGITAL OUTPUT

        .IFF

        MOV     I.PRM+14.(R4),(R1)+ ;SET INITIAL STATE TO CONVERT REQUEST

        .ENDC


        MOV     (R3),(R1)       ;INSERT SUBFUNCTION MODIFIER BITS
        BIC     #^C<STROT!STPIN!STPBR!GAINR>,(R1)+ ;CLEAR EXTRANEOUS BITS
        ADD     #I.IOSB+2,R4    ;POINT TO I/O STATUS DOUBLEWORD ADDRESS
        MOV     (R4)+,(R1)+     ;INSERT RELOCATION BIAS
        MOV     (R4)+,(R1)      ;INSERT DISPLACEMENT ADDRESS
        ADD     #2,(R1)+        ;CALCULATE ADDRESS OF SECOND I/O STATUS
        TST     (R4)+           ;BYPASS AST ADDRESS AND CLEAR CARRY
        MOV     (R4),(R1)+      ;INSERT BUFFER RELOCATION BIAS
        MOV     (R4)+,(R1)+     ;
        MOV     (R4),(R1)+      ;INSERT BUFFER DISPLACEMENT ADDRESS
        MOV     (R4)+,(R1)+     ;
        MOV     (R4)+,(R1)      ;INSERT SIZE OF BUFFER IN BYTES
        ROR     (R1)            ;CONVERT TO SIZE IN WORDS
        MOV     (R1)+,(R1)      ;INSERT SIZE OF BUFFER IN WORDS
        MOV     (R1)+,(R1)      ;INSERT SIZE OF BUFFER IN WORDS
        ASR     (R1)+           ;CONVERT TO SIZE IN DOUBLEWORDS


        .IF DF  D$$R11

        MOVB    (R4)+,R2        ;GET DIGITAL INPUT/OUTPUT POINT INDEX
        CLR     (R1)            ;ASSUME NO DIGITAL INPUT/OUTPUT POINT
        ASLB    (R3)            ;START ON DIGITAL INPUT POINT?
        BCC     130$            ;IF CC NO
        MOV     #SWAIT,STATE(R0) ;ALTER STATE TO WAIT ON DIGITAL INPUT
        BR      140$            ;
130$:   BPL     150$            ;IF PL NO DIGITAL OUTPUT ON START
140$:   MOV     $BTMSK(R2),(R1) ;INSERT DIGITAL INPUT/OUTPUT POINT MASK
        TSTB    (R3)            ;SET DIGITAL OUTPUT POINT AT START?
        BPL     150$            ;IF PL NO
        BIS     (R1),U.CNT+2(R5) ;SET DIGITAL OUTPUT POINT IN USE
150$:   TST     (R1)+           ;ADVANCE TO NEXT WORD
        CLR     (R1)            ;ASSUME NO DIGITAL INPUT POINT
        MOVB    (R4)+,R2        ;GET DIGITAL INPUT POINT INDEX
        ASLB    (R3)            ;STOP ON DIGITAL INPUT POINT?
        BPL     160$            ;IF PL NO
        MOV     $BTMSK(R2),(R1) ;INSERT DIGITAL INPUT POINT MASK
160$:   CMP     (R1)+,(SP)+     ;ADVANCE TO NEXT WORD AND CLEAN STACK

        .IFF

        CMP     (R4)+,(SP)+     ;SKIP DIGITAL I/O WORD AND CLEAN STACK

        .IFTF

        MOV     #1,(R1)+        ;INSERT INITIAL CLOCK TICKS TO NEXT SAMPLE
        MOV     (R4)+,(R1)+     ;INSERT CLOCK TICKS RESET VALUE
        MOV     (R4)+,(R1)+     ;INSERT NUMBER OF BUFFERS TO COLLECT
        MOV     (R4)+,(R1)+     ;INSERT FUNCTION DEPENDENT (CHANNELS) DATA WORD
        MOV     (R4),(R1)       ;INSERT STARTING SAMPLE STATE

        .IFT

        CMP     #SYNDO,(R1)     ;SYNCHRONOUS DIGITAL OUTPUT?
        BEQ     170$            ;IF EQ YES
        CMP     #SYNDI,(R1)     ;SYNCHRONOUS DIGITAL INPUT?
        BNE     190$            ;IF NE NO
        BIS     -(R1),U.CNT(R5) ;SET DIGITAL INPUT BITS IN USE
        BR      180$            ;
170$:   BIS     -(R1),U.CNT+2(R5) ;SET DIGITAL OUTPUT BITS IN USE
180$:   COM     (R1)            ;COMPLEMENT MASK WORD

        .ENDC


190$:   MOV     U.BUF(R5),(R0)  ;INSERT REQUEST IN SAMPLE QUEUE
        MOV     R0,U.BUF(R5)    ;
        MOVB    I.EFN-<I.PRM+16>(R4),R0 ;GET SPECIFIED EVENT FLAG NUMBER
        MOV     R5,-(SP)        ;SAVE UCB ADDRESS
        MOV     I.TCB-<I.PRM+16>(R4),R5 ;GET TCB ADDRESS OF REQUESTER TASK
        CALL    $CEFI           ;CONVERT EFN TO MASK AND ADDRESS
        MOV     R1,(R4)         ;INSERT EFN MASK ADDRESS
        MOV     R0,-(R4)        ;INSERT EFN MASK WORD
        MOV     (SP)+,R5        ;RETRIEVE UCB ADDRESS
        MOV     U.SCB(R5),R3    ;GET ADDRESS OF SCB
        TSTB    U.STS(R5)       ;UNIT BUSY?
        BMI     200$            ;IF MI YES
        MOV     S.CSR(R3),R2    ;GET ADDRESS OF CONTROL STATUS REGISTER
        CMP     (R2)+,(R2)+     ;POINT TO CLOCK STATUS REGISTER
        MOV     #506,(R2)+      ;SET REPEAT MODE, 10KHZ, AND ENABLE INT
        MOV     U.CW4(R5),(R2)  ;LOAD COUNTER PRESET REGISTER
        NEG     (R2)            ;NEGATE PRESET VALUE
        INC     -(R2)           ;START CLOCK RUNNING
200$:   BISB    #US.BSY,U.STS(R5) ;SET UNIT BUSY
        MOVB    #1,S.STS(R3)    ;SET CONTROLLER BUSY
        MOVB    S.ITM(R3),S.CTM(R3) ;SET CURRENT TIMEOUT COUNT
        RETURN                  ;

;+
;
; **-$ARCLK-AR11 LABORATORY PERIPHERAL SYSTEM CLOCK INTERRUPT
;
;-

$ARCLK::                        ;;;REF LABEL
$ARINT::                        ;;;REF LABEL
        INTSV$  AR,PR6,A$$R11   ;;;GENERATE INTERRUPT SAVE CODE
        MOV     R3,-(SP)        ;;;SAVE R3 AND R2
        MOV     R2,-(SP)        ;;;


        .IF GT  A$$R11-1

        MOV     R1,-(SP)        ;;;SAVE R1
        MOV     R4,R1           ;;;PUT CONTROLLER INDEX IN R1

        .ENDC


        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET TIMEOUT COUNT
        MOV     S.CSR(R4),R4    ;;;GET ADDRESS OF CONTROL STATUS REGISTER


        .IF DF  D$$R11

        MOV     R0,-(SP)        ;;;SAVE R0
        MOV     U.CNT+4(R5),R0  ;;;GET CSR ADDRESS OF DR11-K

        .IF GT  A$$R11-1

        BEQ     10$             ;;;SKIP IF NO DR11-K FOR THIS CONTROLLER

        .IFTF

        MOV     2(R0),R3        ;;;READ DIGITAL INPUT REGISTER

        .IFT

        MOV     R3,DGIWD(R1)    ;;;SAVE DIGITAL INPUT WORD

        .IFF

        MOV     R3,DGIWD        ;;;SAVE DIGITAL INPUT WORD

        .ENDC


        MOV     R3,TEMP         ;;;SAVE COMPLEMENT OF DIGITAL INPUT WORD
        COM     TEMP            ;;;
        MOV     R3,2(R0)        ;;;CLEAR BITS IN DIGITAL INPUT REGISTER         ;**-1
10$:                            ;;;REF LABEL

        .ENDC


        MOV     R5,R3           ;;;CALCULATE ADDRESS OF SAMPLE QUEUE LISTHEAD
        ADD     #U.BUF,R3       ;;;


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;;;SAVE CURRENT APR6 MAPPING

        .ENDC


;
; GET NEXT REQUEST FROM SAMPLE QUEUE AND PROCESS
;

        .ENABL  LSB
NXTRQ:  MOV     (R3),R3         ;;;GET ADDRESS OF NEXT SAMPLE REQUEST
        BEQ     20$             ;;;IF EQ END OF REQUEST QUEUE
        DEC     CYCNT(R3)       ;;;TIME TO SAMPLE?
        BNE     NXTRQ           ;;;IF NE NO
10$:    MOV     CRSET(R3),CYCNT(R3) ;;;RESET SAMPLE CYCLE COUNT
        JMP     @STATE(R3)      ;;;PROCESS SAMPLE REQUEST
20$:    JMP     ENDRQ           ;;;


        .IF DF  D$$R11

;
; START SAMPLING IF DIGITAL INPUT BIT SET
;

SWAIT:  MOV     #1,CYCNT(R3)    ;;;SET TO REPEAT TEST AT NEXT INTERVAL
        BIT     DBMSK(R3),TEMP  ;;;START SAMPLING?
        BNE     NXTRQ           ;;;IF NE NO
        BITB    #STROT,RSTAT(R3) ;;;SET DIGITAL OUTPUT BIT AT START?
        BEQ     30$             ;;;IF EQ NO

;
; SET DIGITAL OUTPUT BIT
;

SDOUT:  BIS     DBMSK(R3),4(R0) ;;;SET DIGITAL OUTPUT BIT
30$:    MOV     STRST(R3),STATE(R3) ;;;CHANGE STATE TO STARTING VALUE
        BR      10$             ;;;DISPATCH ON NEW STATE

;
; SYNCHRONOUS DIGITAL OUTPUT
;

SYNDO:                          ;;;REF LABEL
        CALL    RDWRD           ;;;READ WORD FROM USER BUFFER
        BCS     NXTRQ           ;;;IF CS BUFFER OVERRUN
        MOV     4(R0),-(SP)     ;;;READ DIGITAL OUTPUT REGISTER
        MOV     DATAW(R3),-(SP) ;;;GET OUTPUT MASK WORD
        BIC     (SP),R2         ;;;CLEAR EXCESS BITS IN DATA WORD
        COM     (SP)            ;;;COMPLEMENT MASK WORD
        BIC     (SP)+,(SP)      ;;;CLEAR FIELD BITS IN OUTPUT WORD
        BIS     (SP)+,R2        ;;;MERGE DATA AND OUTPUT WORD
        MOV     R2,4(R0)        ;;;WRITE VALUE INTO DIGITAL OUTPUT REGISTER
        BR      NXTRQ           ;;;CONTINUE SCAN

        .ENDC


        .DSABL  LSB


;
; SYNCHRONOUS A/D SAMPLING
;

SYNAD:  MOV     DATAW(R3),-(SP) ;;;SET COUNT AND STARTING CHANNEL


        .IF DF  U$$NIP

10$:    MOVB    (SP),R2         ;;;GET CHANNEL NUMBER
        ASL     R2              ;;;CONVERT NUMBER TO OFFSET
        BIT     $BTMSK(R2),U.CW3(R5) ;;;EXAMINE CHANNEL POLARITY
        BEQ     15$             ;;;IF EQ BIPOLAR
        BIS     #100,R2         ;;;SET UNIPOLAR
15$:    ASR     R2              ;;;CONVERT BACK TO CHANNEL NUMBER
        MOVB    R2,1(R4)        ;;;SET CHANNEL NUMBER AND POLARITY

        .IFF

10$:    MOVB    (SP),1(R4)      ;;;SET CHANNEL NUMBER (BIPOLAR SAMPLE)

        .ENDC


        MOVB    #1,(R4)         ;;;START CONVERSION
        MOV     #TMOCNT,R2      ;;;SET TIMEOUT LOOP COUNT
20$:    TSTB    (R4)            ;;;DONE?
        BMI     90$             ;;;IF MI DONE
        DEC     R2              ;;;TIMEOUT?
        BGT     20$             ;;;IF GT NO
70$:    MOV     #177777,R2      ;;;SET TIMEOUT ERROR VALUE
        BR      100$            ;;;
90$:    MOV     2(R4),R2        ;;;READ CONVERTED VALUE
100$:   CALL    WRWRD           ;;;WRITE WORD INTO USER BUFFER
        BCS     110$            ;;;IF CS BUFFER OVERRUN
        INCB    (SP)            ;;;INCREMENT CHANNEL NUMBER
        DECB    1(SP)           ;;;ANY MORE CHANNELS TO SAMPLE?
        BGT     10$             ;;;IF GT YES
110$:   TST     (SP)+           ;;;CLEAN STACK
        JMP     NXTRQ           ;;;CONTINUE SCAN


        .IF DF  A$$RDA

;
; SYNCHRONOUS D/A OUTPUT
;

SYNDA:  MOV     DATAW(R3),-(SP) ;;;SET COUNT AND STARTING D/A NUMBER
10$:    CALL    RDWRD           ;;;READ WORD FROM USER BUFFER
        BCS     60$             ;;;IF CS BUFFER OVERRUN
        BIC     #176000,R2      ;;;CLEAR D/A NUMBER FIELD
        MOVB    (SP),-(SP)      ;;;COPY D/A NUMBER
        DECB    (SP)            ;;;D/A 0 OR 1 ONLY
        BEQ     30$             ;;;IF EQ D/A 1 (Y-REG)
        MOV     R2,12(R4)       ;;;OUTPUT TO X-REG D/A
        BR      40$             ;;;
30$:    MOV     R2,14(R4)       ;;;OUTPUT TO Y-REG D/A
40$:    TST     (SP)+           ;;;CLEAN STACK
50$:    INC     (SP)            ;;;INCREMENT D/A NUMBER
        DECB    1(SP)           ;;;ANY MORE TO GO?
        BGT     10$             ;;;IF GT YES
60$:    TST     (SP)+           ;;;CLEAN STACK
        JMP     NXTRQ           ;;;CONTINUE SCAN

        .ENDC



        .IF DF  D$$R11

;
; SYNCHRONOUS DIGITAL INPUT SAMPLING
;

SYNDI:                          ;;;REF LABEL


        .IF GT  A$$R11-1

        MOV     DGIWD(R1),R2    ;;;GET SAVED DIGITAL INPUT WORD

        .IFF

        MOV     DGIWD,R2        ;;;GET SAVED DIGITAL INPUT WORD

        .ENDC


        MOV     DATAW(R3),-(SP) ;;;GET INPUT MASK WORD
        BIC     (SP)+,R2        ;;;CLEAR EXCESS BITS IN DATA WORD               ;BS049
        CALL    WRWRD           ;;;WRITE WORD INTO USER BUFFER                  ;**-3
        JMP     NXTRQ           ;;;CONTINUE SCAN

        .ENDC


;
; END OF REQUEST QUEUE--CHECK IF FORK REQUIRED
;

ENDRQ:                          ;;;REF LABEL


        .IF DF M$$MGE

        MOV     (SP)+,KISAR6    ;;;RESTORE APR6 MAPPING

        .ENDC


        .IF DF  D$$R11

        MOV     (SP)+,R0        ;;;RESTORE R0

        .ENDC


        .IF GT  A$$R11-1

        MOV     (SP)+,R1        ;;;RESTORE R1

        .ENDC


        MOV     (SP)+,R2        ;;;RESTORE R2 AND R3
        MOV     (SP)+,R3        ;;;
        TST     FKFLG           ;;;FORK REQUESTED?
        BEQ     10$             ;;;IF EQ NO
        CLR     FKFLG           ;;;CLEAR FORK REQUESTED FLAG
        BITB    #US.FRK,U.STS(R5) ;;;FORK ALREADY IN PROGRESS?
        BEQ     ENDRQ1          ;;;IF EQ NO
10$:    JMP     $INTXT          ;;;EXIT INTERRUPT

;+
; **-ARCAN-CANCEL I/O REQUESTS
;
; THIS ROUTINE IS ENTERED TO CANCEL ALL I/O REQUESTS THAT ARE IN PROGRESS FOR
; THE CURRENT TASK. THE SAMPLE QUEUE IS SCANNED AND ALL REQUESTS FOR THE CURRENT
; TASK ARE MARKED FOR TERMINATION WITH A FINAL REQUEST STATUS OF 'IE.ABO'.
;
; INPUTS:
;
;       R0=ADDRESS OF THE CURRENT I/O PACKET (MEANINGLESS).
;       R1=ADDRESS OF THE TCB OF THE CURRENT TASK.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       ALL REQUESTS FOR THE CURRENT TASK ARE MARKED FOR TERMINATION WITH
;       A FINAL STATUS OF 'IE.ABO'.
;-

        .ENABL  LSB
ARCAN:  MOV     #IE.ABO&377,R0  ;;;SET FINAL STATUS CODE TO ABORT
        BR      10$             ;;;FINISH IN COMMON CODE

;+
; **-AROUT-DEVICE TIMEOUT
;
; THIS ROUTINE IS ENTERED WHEN AN AR11 OPERATION TIMES OUT. ALL REQUESTS IN THE
; SAMPLE QUEUE ARE MARKED FOR TERMINATION WITH A FINAL STATUS OF 'IE.DNR'.
; TIMEOUTS ARE USUALLY CAUSED BY A POWER FAILURE BUT MAY ALSO BE THE RESULT
; OF A HARDWARE FAILURE.
;
; INPUTS:
;
;       R0=DEVICE TIMEOUT STATUS 'IE.DNR'.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       ALL REQUESTS ARE MARKED FOR TERMINATION WITH A FINAL STATUS OF
;       'IE.DNR'.
;-

AROUT:  MOV     S.CSR(R4),R2    ;;;GET ADDRESS OF CONTROL STATUS REGISTER
        CLR     (R2)            ;;;CLEAR A/D INTERRUPTS
        CLR     4(R2)           ;;;CLEAR CLOCK INTERRUPTS
10$:    MOV     R5,R2           ;;;CALCULATE ADDRESS OF SAMPLE QUEUE LISTHEAD
        ADD     #U.BUF,R2       ;;;
20$:    MOV     (R2),R2         ;;;GET ADDRESS OF NEXT ENTRY
        BEQ     40$             ;;;IF EQ NONE
        CMPB    #IE.ABO,R0      ;;;CANCEL I/O?
        BNE     30$             ;;;IF NE NO
        MOV     RQPKT(R2),R3    ;;;GET ADDRESS OF I/O PACKET
        CMP     R1,I.TCB(R3)    ;;;REQUEST FOR CURRENT TASK?
        BNE     20$             ;;;IF NE NO
30$:    BISB    #STPRQ,RSTAT(R2) ;;;SET TO TERMINATE SAMPLE REQUEST
        MOVB    R0,FINST(R2)    ;;;SET FINAL REQUEST STATUS
        MOV     #NXTRQ,STATE(R2) ;;;SET STATE TO TERMINATION IN PROGRESS
        BR      20$             ;;;
40$:    CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        BR      ENDRQ2          ;FINISH IN COMMON CODE
        .DSABL  LSB

;+
; **-ARPWF-POWERFAIL
;
; THIS ROUTINE IS ENTERED AS THE RESULT OF A POWER FAILURE. POWERFAIL IS HANDLED
; VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES NO IMMEDIATE ACTION ON
; THE DEVICE. THE UNIT CONTROL BLOCK ADDRESS IS STORED IN THE DRIVER CONTROLLER
; TABLE.
;
; INPUTS:
;
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       THE UNIT CONTROL BLOCK ADDRESS IS STORED IN THE DRIVER CONTROLLER TABLE.
;-

ARPWF:  MOV     R5,CNTBL(R3)    ;SET ADDRESS OF UNIT CONTROL BLOCK
        RETURN                  ;

;
; FORK REQUESTED AND NO FORK IN PROGRESS
;

ENDRQ1: BISB    #US.FRK,U.STS(R5) ;;;SET FORK IN PROGRESS FLAG
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        BICB    #US.FRK,U.STS(R5) ;CLEAR FORK IN PROGRESS FLAG

;
; SCAN SAMPLE QUEUE FOR EVENT FLAG AND TERMINATION REQUESTS
;

ENDRQ2: MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOVB    S.PRI(R4),PS    ;;;LOCK OUT DEVICE INTERRUPTS
        MOV     R5,R4           ;;;CALCULATE ADDRESS OF SAMPLE QUEUE LISTHEAD
        ADD     #U.BUF,R4       ;;;
10$:    MOV     R4,R3           ;;;SAVE ADDRESS OF PREVIOUS ENTRY
        MOV     (R3),R4         ;;;GET ADDRESS OF NEXT ENTRY
        BEQ     70$             ;;;IF EQ NONE
        BITB    #STPRQ,RSTAT(R4) ;;;TERMINATE REQUEST?
        BNE     20$             ;;;IF NE YES
        BITB    #RQEFN,RSTAT(R4) ;;;REQUEST EFN SETTING?
        BEQ     10$             ;;;IF EQ NO
        BICB    #RQEFN,RSTAT(R4) ;;;CLEAR EFN REQUEST FLAG
        CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        MOV     RQPKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        MOV     I.TCB(R3),R0    ;GET TCB ADDRESS OF REQUESTING TASK
        BIT     #T2.ABO,T.ST2(R0) ;TASK BEING ABORTED?
        BNE     ENDRQ2          ;IF NE YES
        BIS     I.PRM+14(R3),@I.PRM+16(R3) ;SET SPECIFIED EVENT FLAG
        CALL    $SETCR          ;SET A CONDITIONAL SCHEDULE REQUEST
        BR      ENDRQ2          ;TRY AGAIN
20$:    MOV     (R4),(R3)       ;;;REMOVE ENTRY FROM QUEUE
30$:    CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS


        .IF DF  D$$R11

        MOV     DATAW(R4),R3    ;GET DATA MASK WORD
        COM     R3              ;CONVERT MASK TO IN USE BITS
        CMP     #SYNDO,STRST(R4) ;SYNCRHONOUS DIGITAL OUTPUT?
        BEQ     40$             ;IF EQ YES
        CMP     #SYNDI,STRST(R4) ;SYNCHRONOUS DIGITAL INPUT
        BNE     50$             ;IF NE NO
        BIC     R3,U.CNT(R5)    ;CLEAR INPUT BITS IN USE MASK
        BR      50$             ;
40$:    BIC     R3,U.CNT+2(R5)  ;CLEAR OUTPUT BITS IN USE MASK
50$:    BITB    #STROT,RSTAT(R4) ;SET DIGITAL OUTPUT BIT ON START?
        BEQ     60$             ;IF EQ NO
        BIC     DBMSK(R4),U.CNT+2(R5) ;CLEAR OUTPUT BIT IN USE MASK

        .ENDC


60$:    CLR     R0              ;PICKUP FINAL I/O STATUS
        BISB    FINST(R4),R0    ;


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;SAVE CURRENT APR6 MAPPING
        MOV     IOSB2(R4),KISAR6  ;MAP TO SECOND I/O STATUS WORD

        .IFTF

        MOV     @IOSB2+2(R4),R1 ;RETRIEVE CONTENTS OF SECOND I/O STATUS WORD

        .IFT

        MOV     (SP)+,KISAR6    ;RESTORE CURRENT APR6 MAPPING

        .ENDC


        MOV     RQPKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        MOV     R4,-(SP)        ;SAVE ADDRESS OF SECONDARY CONTROL BLOCK
        CLR     I.PRM+16(R3)    ;CLEAR BLOCK LOCKING WORD FOR $IOFIN
        CALL    $IOFIN          ;FINISH I/O OPERATION
        MOV     (SP)+,R0        ;RETRIEVE ADDRESS OF SECONDARY CONTROL BLOCK
        MOV     #SLGTH,R1       ;SET LENGTH OF SECONDARY CONTROL BLOCK
        CALL    $DEACB          ;RELEASE SECONDARY CONTROL BLOCK
        BR      ENDRQ2          ;GO AGAIN

;
; SCAN OF SAMPLE QUEUE COMPLETE--CHECK IF ANYTHING IS STILL ACTIVE
;

70$:    MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET DEVICE TIMEOUT COUNT
        TST     U.BUF(R5)       ;;;ANY REQUESTS IN SAMPLE QUEUE
        BNE     80$             ;;;IF NE YES
        MOV     S.CSR(R4),R3    ;;;GET ADDRESS OF CONTROL STATUS REGISTER
        CLR     (R3)            ;;;CLEAR A/D INTERRUPTS
        CLR     4(R3)           ;;;CLEAR CLOCK INTERRUPTS
        BICB    #US.BSY,U.STS(R5) ;;;CLEAR UNIT BUSY
        CLRB    S.STS(R4)       ;;;CLEAR CONTROLLER BUSY
80$:    CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        RETURN                  ;

;
; SUBROUTINE TO READ A VALUE FROM USER BUFFER
;

        .ENABL  LSB

RDWRD:                          ;;;REF LABEL


        .IF DF  M$$MGE

        MOV     IOSB2(R3),KISAR6  ;;;MAP TO SECOND I/O STATUS WORD

        .IFTF

        INC     @IOSB2+2(R3)    ;;;INCREMENT FREE POSITIONS IN BUFFER
        CMP     FULBF(R3),@IOSB2+2(R3) ;;;BUFFER OVERRUN?
        BLO     70$             ;;;IF LO YES

        .IFT

        MOV     CURBF(R3),KISAR6   ;;;MAP TO USER BUFFER

        .IFTF

        MOV     @CURBF+4(R3),R2 ;;;READ VALUE FROM USER BUFFER
        BR      10$             ;;;FINISH IN COMMON CODE

;
; SUBROUTINE TO WRITE A VALUE INTO USER BUFFER
;

WRWRD:                          ;;;REF LABEL

        .IFT

        MOV     IOSB2(R3),KISAR6   ;;;MAP TO SECOND I/O STATUS WORD

        .IFTF

        INC     @IOSB2+2(R3)    ;;;INCREMENT NUMBER OF ENTRIES IN BUFFER
        CMP     FULBF(R3),@IOSB2+2(R3) ;;;BUFFER OVERRUN?
        BLO     70$             ;;;IF LO YES

        .IFT

        MOV     CURBF(R3),KISAR6  ;;;MAP TO USER BUFFER

        .IFTF

        MOV     R2,@CURBF+4(R3) ;;;WRITE VALUE INTO USER BUFFER
10$:    ADD     #2,CURBF+4(R3)  ;;;UPDATE USER BUFFER ADDRESS

        .IFT

        BIT     #20000,CURBF+4(R3) ;;;OVERFLOW 4K BOUNDRY?
        BEQ     20$             ;;;IF EQ NO
        BIC     #20000,CURBF+4(R3) ;;;CLEAR OVERFLOW BIT
        ADD     #200,CURBF(R3)  ;;;ADVANCE TO NEXT 4K BOUNDRY

        .IFTF

20$:    DEC     SMCNT(R3)       ;;;END OF BUFFER?
        BNE     30$             ;;;IF NE NO

        .IFT

        MOV     STRBF(R3),CURBF(R3) ;;;RESET RELOCATION BIAS

        .ENDC


        MOV     STRBF+4(R3),CURBF+4(R3) ;;;RESET BUFFER ADDRESS
        MOV     FULBF(R3),SMCNT(R3) ;;;RESET SAMPLE BUFFER COUNT
        BITB    #STPBR,RSTAT(R3) ;;;STOP ON BUFFER RUNOUT?
        BEQ     40$             ;;;IF EQ NO
        DEC     SAMCT(R3)       ;;;DECREMENT BUFFER COUNT
        BEQ     60$             ;;;IF EQ BUFFER RUNOUT
        BR      40$             ;;;
30$:    CMP     SMCNT(R3),HAFBF(R3) ;;;EXACTLY AT HALF BUFFER?
        BNE     50$             ;;;IF NE NO
40$:    BISB    #RQEFN,RSTAT(R3) ;;;REQUEST EFN SETTING
        INC     FKFLG           ;;;SET FORK REQUEST
50$:    CLC                     ;;;CLEAR OVERRUN INDICATOR


        .IF DF  D$$R11

        BIT     DSMSK(R3),TEMP  ;;;STOP BIT CLEAR?
        BEQ     90$             ;;;IF EQ NO

        .IFF

        BR      90$             ;;;

        .ENDC


60$:    MOVB    #IS.SUC,FINST(R3) ;;;SET SUCCESSFUL COMPLETION STATUS
        BR      TERMS           ;;;
70$:    MOVB    #IE.DAO,FINST(R3) ;;;SET FINAL STATUS TO BUFFER OVERRUN
        DEC     @IOSB2+2(R3)    ;;;READJUST BUFFER FREE COUNT
TERMS:  BISB    #STPRQ,RSTAT(R3) ;;;SET TO TERMINATE SAMPLE REQUEST
        MOV     #NXTRQ,STATE(R3) ;;;SET STATE TO TERMINATION IN PROGRESS
        INC     FKFLG           ;;;SET FORK REQUEST
        SEC                     ;;;SET OVERRUN/TERMINATION INDICATOR
90$:    RETURN                  ;;;
        .DSABL  LSB

        .END
        .TITLE  BFCTL
        .IDENT  /07.2/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 07.2
;
; D. N. CUTLER 26-DEC-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 2-NOV-77
;
;               TM116 -- SAVE AND RESTORE MAPPING REGISTERS IN $BLXIO.
;
;       G. H. KUENNING  22-FEB-78
;
;               GK001 - ASSEMBLE $GTCWD IF AN IP11/IP300 NEEDS IT.
;
;       H. D. COFFMAN   3-NOV-78
;
;               HDC020 -- PREVENT ZERO INPUT OR INVALID TRANSFER SIZE
;                         IN BLXIO
;
;       M. S. HARVEY    17-APR-79
;
;               MSH011 -- DISALLOW ANY $GTWRD/$PTWRD PROCESSING IF THESE
;                         OPTIONS ARE NOT SUPPORTED
;
;
; BUFFER CONTROL ROUTINES
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS

;+
; **-$GTBYT-GET NEXT BYTE FROM USER BUFFER
;
; THIS ROUTINE IS CALLED TO GET THE NEXT BYTE FROM THE USER BUFFER
; AND RETURN IT TO THE CALLER ON THE STACK. AFTER THE BYTE HAS BEEN
; FETCHED, THE NEXT BYTE ADDRESS IS INCREMENTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB THAT CONTAINS THE BUFFER POINTERS.
;
; OUTPUTS:
;
;       THE NEXT BYTE IS FETCHED FROM THE USER BUFFER AND RETURNED
;       TO THE CALLER ON THE STACK. THE NEXT BYTE ADDRESS IS INCREMENTED.
;
;       ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-

        .ENABL  LSB
$GTBYT::MOV     (SP),-(SP)      ;DUPLICATE RETURN ADDRESS


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;SAVE CURRENT MAPPING
        MOV     U.BUF(R5),KISAR6 ;MAP TO USER BUFFER
        MOVB    @U.BUF+2(R5),4(SP) ;GET NEXT BYTE FROM USER BUFFER
        MOV     (SP)+,KISAR6    ;RESTORE CURRENT MAPPING

        .IFF

        MOVB    @U.BUF+2(R5),2(SP) ;GET NEXT BYTE FROM USER BUFFER

        .ENDC


        BR      20$             ;TAKE COMMON EXIT FOR ADDRESS UPDATE

;+
; **-$PTBYT-PUT NEXT BYTE IN USER BUFFER
;
; THIS ROUTINE IS CALLED TO PUT A BYTE IN THE NEXT LOCATION IN
; USER BUFFER. AFTER THE BYTE HAS BEEN STORED, THE NEXT BYTE ADDRESS
; IS INCREMENTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB THAT CONTAINS THE BUFFER POINTERS.
;       2(SP)=BYTE TO BE STORED IN THE NEXT LOCATION OF THE USER BUFFER.
;
; OUTPUTS:
;
;       THE BYTE IS STORED IN THE USER BUFFER AND REMOVED FROM
;       THE STACK. THE NEXT BYTE ADDRESS IS INCREMENTED.
;
;       ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-

$PTBYT::                        ;REF LABEL


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;SAVE CURRENT MAPPING
        MOV     U.BUF(R5),KISAR6 ;MAP TO USER BUFFER
        MOVB    4(SP),@U.BUF+2(R5) ;STORE BYTE IN USER BUFFER
        MOV     (SP)+,KISAR6    ;RESTORE CURRENT MAPPING

        .IFF

        MOVB    2(SP),@U.BUF+2(R5) ;STORE BYTE IN USER BUFFER

        .ENDC


        MOV     (SP)+,(SP)      ;COLLAPSE STACK REMOVING BYTE


        .IF DF  G$$WRD!P$$WRD

        BR      20$             ;TAKE COMMON EXIT FOR ADDRESS UPDATE

;+
; **-$GTWRD-GET NEXT WORD FROM USER BUFFER
;
; THIS ROUTINE IS CALLED TO GET THE NEXT WORD FROM THE USER BUFFER
; AND RETURN IT TO THE CALLER ON THE STACK. AFTER THE WORD HAS BEEN
; FETCHED, THE NEXT WORD ADDRESS IS CALCULATED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB THAT CONTAINS THE BUFFER POINTERS.
;
; OUTPUTS:
;
;       THE NEXT WORD IS FETCHED FROM THE USER BUFFER AND RETURNED
;       TO THE CALLER ON THE STACK. THE NEXT WORD ADDRESS IS CALCULATED.
;
;       ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-

        .IFTF

        .IF DF  G$$WRD                                                  ;**-3

$GTWRD::                        ;REF LABEL                              ;MSH011
        MOV     (SP),-(SP)      ;DUPLICATE RETURN ADDRESS


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;SAVE CURRENT MAPPING
        MOV     U.BUF(R5),KISAR6 ;MAP TO USER BUFFER
        MOV     @U.BUF+2(R5),4(SP) ;GET NEXT WORD FROM USER BUFFER
        MOV     (SP)+,KISAR6    ;RESTORE CURRENT MAPPING

        .IFF

        MOV     @U.BUF+2(R5),2(SP) ;GET NEXT WORD FROM USER BUFFER

        .ENDC


        BR      10$             ;TAKE COMMON EXIT FOR ADDRESS UPDATE

        .IFF                                                            ;MSH011
                                                                        ;MSH011
$GTWRD==-1                      ;CRASH IF REFERENCED                    ;MSH011
                                                                        ;MSH011
        .ENDC


;+
; **-$PTWRD-PUT NEXT WORD IN USER BUFFER
;
; THIS ROUTINE IS CALED TO PUT A WORD IN THE NEXT LOCATION IN
; USER BUFFER. AFTER THE WORD HAS BEEN STORED, THE NEXT WORD ADDRESS
; IS CALCULATED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB THAT CONTAINS THE BUFFER POINTERS.
;       2(SP)=WORD TO BE STORED IN THE NEXT LOCATION OF THE BUFFER.
;
; OUTPUTS:
;
;       THE WORD IS STORED IN THE USER BUFFER AND REMOVED FROM
;       THE STACK. THE NEXT WORD ADDRESS IS CALCULATED.
;
;       ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-

                                                                        ;**-2
        .IF DF  P$$WRD

$PTWRD::                        ;REF LABEL                              ;MSH011
        .IF DF  M$$MGE                                                  ;**-1

        MOV     KISAR6,-(SP)    ;SAVE CURRENT MAPPING
        MOV     U.BUF(R5),KISAR6 ;MAP TO USER BUFFER
        MOV     4(SP),@U.BUF+2(R5);STORE WORD IN USER BUFFER
        MOV     (SP)+,KISAR6    ;RESTORE CURRENT MAPPING

        .IFF

        MOV     2(SP),@U.BUF+2(R5) ;STORE WORD IN USER BUFFER

        .ENDC


        MOV     (SP)+,(SP)      ;COLLAPSE STACK REMOVING WORD

        .IFF                                                            ;MSH011
                                                                        ;MSH011
$PTWRD==-1                      ;CRASH IF REFERENCED                    ;MSH011
                                                                        ;MSH011
        .ENDC


        .IFT

10$:    INC     U.BUF+2(R5)     ;CALCULATE ADDRESS OF NEXT WORD

        .ENDC


20$:    INC     U.BUF+2(R5)     ;INCREMENT NEXT BYTE ADDRESS


        .IF DF  M$$MGE

        CMP     U.BUF+2(R5),#160000 ;OVERFLOW 28K BOUNDARY?
        BLO     30$             ;IF LO NO
        SUB     #20000,U.BUF+2(R5) ;REDUCE BY 4K
        ADD     #200,U.BUF(R5)  ;ADJUST RELOCATION BIAS

        .ENDC


30$:    RETURN
        .DSABL  LSB

;+
; **-$GTCWD-GET NEXT WORD FROM USER CONTROL BUFFER
;
; THIS ROUTINE IS CALLED TO GET THE NEXT WORD FROM THE USER CONTROL
; BUFFER AND RETURN IT TO THE CALLER ON THE STACK. AFTER THE WORD HAS
; BEEN FETCHED, THE NEXT WORD ADDRESS IS CALCULATED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB THAT CONTAINS THE BUFFER POINTERS.
;
; OUTPUTS:
;
;       THE NEXT WORD IS FETCHED FROM THE USER CONTROL BUFFER AND RETURNED
;       TO THE CALLER ON THE STACK. THE NEXT WORD ADDRESS IS CALCULATED.
;
;       ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-


        .IFDF   A$$D01!A$$F11!I$$CAD!I$$PAD!I$$P14!U$$ADM               ; GK001
                                                                        ;**-1
$GTCWD::MOV     (SP),-(SP)      ;DUPLICATE RETURN ADDRESS


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;SAVE CURRENT MAPPING
        MOV     U.CBF(R5),KISAR6 ;MAP TO USER CONTROL BUFFER
        MOV     @U.CBF+2(R5),4(SP) ;GET NEXT WORD FROM USER BUFFER
        MOV     (SP)+,KISAR6    ;RESTORE CURRENT MAPPING

        .IFF

        MOV     @U.CBF+2(R5),2(SP) ;GET NEXT WORD FROM USER BUFFER

        .IFTF

        ADD     #2,U.CBF+2(R5)  ;CALCULATE ADDRESS OF NEXT WORD

        .IFT

        BIT     #20000,U.CBF+2(R5) ;OVERFLOW 4K BOUNDRY?
        BEQ     10$             ;IF EQ NO
        BIC     #20000,U.CBF+2(R5) ;CLEAR OVERFLOW BIT
        ADD     #200,U.CBF(R5)  ;ADJUST RELOCATION BIAS

        .ENDC


10$:    RETURN                  ;

        .ENDC


;+
; **-$BLXIO-MOVE BLOCK OF DATA.
;
; THIS ROUTINE IS CALLED TO MOVE DATA IN MEMORY IN A MAPPED SYSTEM.
;
; INPUTS:
;
;       R0=NUMBER OF BYTES TO MOVE.
;       R1=SOURCE APR5 BIAS.
;       R2=SOURCE DISPLACEMENT.
;       R3=DESTINATION APR6 BIAS.
;       R4=DESTINATION DISPLACEMENT.
;
; OUTPUTS:
;
;       DESCRIBED MOVE IS ACCOMPLISHED.
;       R0 ALTERED.
;       R1,R3 PRESERVED
;       R2,R4 POINT TO LAST BYTE OF SOURCE AND DESTINATION + 1
;
;       NOTE:   THE COUNT INPUT IN R0 MUST NOT BE ZERO AND IT MUST NOT
;               BE LARGE ENOUGH TO CROSS APR BOUNDARIES (THIS TYPICALLY
;               MEANS A MAXIMUM OF 4K-63).
;                                                                       ; HDC020
;       NOTE2:  IF THE COUNT IN R0 EQUALS ZERO OR IS GREATER THAN       ; HDC020
;               4K-63. WORDS, A RETURN IS EXECUTED WITH NO REGISTERS    ; HDC020
;               ALTERED.                                                ; HDC020
;-


        .IF DF  M$$MGE

$BLXIO::TST     R0              ;ZERO BYTES TO MOVE?                    ; HDC020
        BEQ     100$            ;IF EQ YES -- RETURN                    ; HDC020
        CMP     #17701,R0       ;MOVING MORE THAN AN APR-63. WORDS?     ; HDC020
        BLOS    100$            ;IF LOS YES -- RETURN                   ; HDC020
        MOV     R5,-(SP)        ;SAVE R5                                ; HDC020
        MOV     #KISAR6,R5      ;POINT TO KERNEL APR6                   ;**-1
        MOV     (R5),-(SP)      ;SAVE KERNEL APR6
        MOV     R3,(R5)         ;SET UP KERNEL APR6 FOR TRANSFER
        MOV     -(R5),-(SP)     ;SAVE KERNEL APR5
        MOV     R1,(R5)         ;SET UP KERNEL APR5 FOR TRANSFER


        .IF NDF N$$MOV

10$:    MOVB    (R2)+,(R4)+     ;MOVE NEXT BYTE
        DEC     R0              ;MORE TO MOVE?
        BNE     10$             ;IF NE YES

        .IFF

        MOV     #1,-(SP)        ;PUSH LOW BIT MASK
        BIT     (SP),R2         ;SOURCE ADDRESS ODD?
        BEQ     10$             ;IF EQ NO
        MOVB    (R2)+,(R4)+     ;MOVE FIRST BYTE
        DEC     R0              ;REDUCE COUNT
10$:    BIT     (SP),R4         ;DESTINATION ADDRESS ODD?
        BNE     50$             ;IF NE YES, PERFORM BYTE MOVES
20$:    SUB     #N$$MOV*2,R0    ;MOVE ENTIRE BLOCK?
        BCC     40$             ;IF CC YES
        BIC     R0,(SP)         ;REMAINING COUNT ODD?
        BNE     30$             ;IF NE NO
        DEC     R0              ;ADJUST NEGATIVE COUNT
30$:    SUB     R0,PC           ;INDEX INTO MOVE INSTRUCTIONS
40$:                            ;REF LABEL


        .REPT   N$$MOV

        MOV     (R2)+,(R4)+     ;MOVE A WORD

        .ENDR


        BCC     20$             ;IF CC MORE TO GO
        BR      80$             ;EXIT THROUGH COMMON CODE
50$:    ASL     R0              ;DOUBLE COUNT
60$:    SUB     #N$$MOV*2,R0    ;MOVE ENTIRE BLOCK?
        BCC     70$             ;IF CC YES
        SUB     R0,PC           ;ELSE INDEX INTO MOVE INSTRUCTIONS
70$:                            ;REF LABEL


        .REPT   N$$MOV

        MOVB    (R2)+,(R4)+     ;MOVE A BYTE

        .ENDR


        BCC     60$             ;IF CC MORE TO GO
80$:    TST     (SP)+           ;POP CONSTANT
        BNE     90$             ;IF NE NO MORE TO MOVE
        MOVB    (R2)+,(R4)+     ;MOVE LAST BYTE
90$:                            ;REF LABEL

        .ENDC


        MOV     (SP)+,(R5)+     ;RESTORE KERNEL APR5
        MOV     (SP)+,(R5)      ;RESTORE KENREN APR6
        MOV     (SP)+,R5        ;RESTORE R5
100$:   RETURN                  ;                                       ; HDC020
                                                                        ;**-1
        .ENDC


        .END
        .TITLE  CODRV
        .IDENT  /01/
;
; COPYRIGHT (C) 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;         
; VERSION 01
;
; J. H. MATTHEWS        25-OCT-78
;
; MODIFIED BY:
;
;       J. H. MATTHEWS  26-FEB-79
;               JM027 -- CHANGE USE OF U.CW2 & U.CW3 TO CSTAT & BCNT
;
;       J. H. MATTHEWS  27-FEB-79
;               JM028 -- ADDED CHECK FOR READ FROM TASK COT...
;
;       J. H. MATTHEWS  27-FEB-79
;               JM029 -- ADDED DDT$ AND GTPKT$ FOR COMPATIBILITY W/ M+
;
; CONSOLE DRIVER
;
;
; MACRO CALLS
;

        .IF DF  DBUG

        .IFF

        .MCALL  ABODF$,HWDDF$,PKTDF$,TCBDF$
        ABODF$                  ; DEFINE TASK ABORT CODES
        HWDDF$                  ; DEFINE HARDWARE REGISTERS
        PKTDF$                  ; DEFINE I/O PACKET OFFSETS
        TCBDF$                  ; DEFINE TASK CONTROL BLOCK OFFSETS

        .IFT

        .MCALL  DIR$,QIOW$

        .IFTF

;
; EQUATED SYMBOLS
;
; CONSOLE STATUS WORD BIT DEFINITION
;
BUFENT=100000                   ; BUFFER ENTRY, SET = 1 IF THERE IS AT
                                ; LEAST ONE ENTRY, CLEARED IF THERE ARE
                                ; NO ENTRIES
WRARND=40000                    ; WRAP AROUND, SET = 1 IF AN ENTRY WRAPS
                                ; AROUND TO BEGINNING OF BUFFER, CLEARED
                                ; IF THE WRAP AROUND ENTRY IS REMOVED

        .IFF

BUFSIZ=1024.                    ; CO BUFFER SIZE

        .IFT

BUFSIZ=512.
        U.CNT=0                                                                 ;JM027
                                                                                ;**-3
        .IFF

;
; DRIVER DISPATCH TABLE
;
        DDT$    CO,1,NONE                                                       ;JM029
                                                                                ;**-4
        .IFTF

;+
;-
FIRREC: .WORD   BUFER           ; POINTS TO FIRST RECORD IN QUEUE
NXTREC: .WORD   BUFER           ; POINTS TO FIRST WORD OF THE FIRST
                                ; SPACE AVAILABLE FOR NEXT BLOCK
FREEB:  .WORD   BUFSIZ          ; TOTAL FREE BYTES LEFT IN BUFFER
BCNT:   .WORD   0               ; TEMP STORE FOR TRANSFER BYTE COUNT            ;JM027
CSTAT:  .WORD   0               ; CODRV STATUS WORD                             ;JM027
TSKNAM: .RAD50  /COT.../        ; NAME OF TASK FOR READ                         ;JM027
                                                                                ;**-1
        .IFT

UCB:    .WORD   0                       ; FAKE UCB FOR DEBUGGING                ;JM027
                                                                                ;**-1
        .IFTF

;+
; **-COINI-CONSOLE DRIVER INIATOR
;
;-

        .IFT
START:
        CLR     INBUF                   ; CLEAR FIRST WORD OF INBUF
        DIR$    #READ
        MOV     #UCB,R5
        CMPB    #'R,INBUF
        BNE     WRCH
        DIR$    #READ
        MOV     IOSTAT+2,U.CNT(R5)
        BR      RDST
WRCH:   CMPB    #'W,INBUF
        BEQ     WTST
        CMPB    #'P,INBUF
        BNE     10$
        CALL    PRINT
        BR      START
10$:    BPT
        BR      START

        .IFF

COINI:  GTPKT$  CO,1,,,NOKRB            ; GET AN I/O PACKET TO PROCESS          ;JM029
3$:     CMPB    I.FCN+1(R1),#IO.WLB/256. ; WRITE LOGICAL BLOCK FUNCTION         ;**-3
        BNE     50$                     ; IF NE, NO

        .IFT
RDST:
        .IFTF

        MOV     U.CNT(R5),R3            ; GET THE BYTE COUNT
        BNE     5$                      ; CHECK FOR ZERO BYTE COUNT
        MOV     #IS.SUC&377,R0          ; ALREADY SUCESSFUL
        CLR     R1                      ; ZERO SECOND STATUS WORD
        JMP     90$                     ; DONE
5$:     MOV     R3,BCNT                 ; SAVE BYTE COUNT                       ;JM027
        INC     R3                      ; ROUND BYTE COUNT UP TO WORD           ;**-1
        BIC     #1,R3                   ; TO CALC NUM OF BUFFER WORDS
        ADD     #4,R3                   ; FOR BLOCK & MESSAGE BYTE COUNTS
        CMP     FREEB,R3                ; IS THERE ROOM IN THE BUFFER
        BHIS    10$                     ; HIS-YES THERE IS ROOM

        .IFF

        MOV     #IE.NOD&377,R0          ; NO ROOM
        CLR     R1                      ; ZERO SECOND STATUS WORD
        JMP     90$

        .IFT


        MOV     #NOROOM,PRNT+Q.IOPL
        MOV     #NOSIZ,PRNT+Q.IOPL+2
        DIR$    #PRNT
        BR      START

        .IFTF

10$:

        .IFT

        MOV     #INBUF,R2
        CLR     R1                      ; FAKE KLOBBER R1 FOR CONSIST

        .IFF

        MOV     U.BUF+2(R1),R2          ; GET USER BUFFER ADDRESS (SET FOR PAR #6)
        SUB     #20000,R2               ; SET FOR PAR #5
        MOV     U.BUF(R1),R1            ; GET USER BUFFER BIAS

        .IFTF

        BIS     #BUFENT,CSTAT           ; SET BUFFER ENTRY BIT                  ;JM027
        MOV     NXTREC,R4               ; POINT TO BEGINNING OF BLOCK           ;**-1
        MOV     R3,(R4)+                ; SET BLOCK BYTE COUNT
        MOV     U.CNT(R5),(R4)+         ; SET RECORD BYTE COUNT
        SUB     R3,FREEB                ; SUB NUM OF BYTES USED
        ADD     NXTREC,R3               ; HOW CLOSE TO THE END WILL WE BE
        CMP     #BUFEND-4,R3            ; ARE WE IN THE YELLOW ZONE
        BHIS    30$                     ; IF HIS-NO, DON'T WORRY ABOUT WRAP AROUND
        CMP     #BUFEND,R3              ; ARE WE IN THE RED ZONE
        BLO     20$                     ; LO-YES, WRAP AROUND
                                        ; IN YELLOW ZONE, MAKE BLOCK END AT END OF BUF
        MOV     #BUFEND,R0              ; CALCULATE DIFFERENCE BETWEEN BLOCK
        SUB     R3,R0                   ; AND END OF BUFFER ( SHOULD BE <= 4 BYTES.)
        ADD     R0,-4(R4)               ; FORM BLOCK BYTE COUNT TO END OF BUFFER
        SUB     R0,FREEB                ; RE ADJUST FREE BYTE COUNT
        BR      30$
20$:    BIS     #WRARND,CSTAT           ; IN RED ZONE-SET WRAP AROUND BIT       ;JM027
        MOV     #BUFEND,R0              ; CALC NUMBER OF BYTES                  ;**-1
        SUB     R4,R0                   ; TO END OF BUFFER
        BEQ     25$                     ; IF EQ, MESS STARTS AT BEG OF BUF
        SUB     R0,U.CNT(R5)            ; LESS TO DO ON SECOND PASS

        .IFF

        .IF DF  L$$DRV & LD$CO
        MOV     KISAR5,R3               ; MAKE SURE I GET MY OWN PAR #5 BIAS
        ADD     #20000,R4               ; MAP MY BUFFER THRU PAR #6
        .ENDC
        CALL    $BLXIO                  ; MOVE BLOCK INTO DRIVER BUFFER

        .IFT

        CLR     R3                      ; FAKE KLOBBER R3
22$:    MOVB    (R2)+,(R4)+             ; MOVE BLOCK
        SOB     R0,22$

        .IFTF

25$:    MOV     #BUFER,R4               ; POINT TO BEG OF BUFFER
30$:    MOV     U.CNT(R5),R0            ; SET TRANSFER BYTE COUNT

        .IFF

        .IF DF  L$$DRV & LD$CO
        MOV     KISAR5,R3               ; MAKE SURE I GET MY OWN PAR #5 BIAS
        ADD     #20000,R4               ; MAP MY BUFFER THRU PAR #6
        .ENDC
        CALL    $BLXIO                  ; COPY FROM USER BUF TO CO BUF

        .IFT

        CLR     R3                      ; FAKE KLOBBER R3
35$:    MOVB    (R2)+,(R4)+             ; MOVE BLOCK
        SOB     R0,35$

        .IFTF

        MOV     NXTREC,R2               ; UPDATE POINTER TO NEXT RECORD
        ADD     (R2),NXTREC             ; POINT TO NEW NEXT RECORD
        CMP     #BUFEND,NXTREC          ; ARE WE AT THE END OF THE BUFFER
        BHI     40$                     ; IF HI, < BUFEND
        SUB     #BUFSIZ,NXTREC          ; WRAP AROUND
40$:    MOV     #TSKNAM,R3              ; GET ADD OF RAD50 TASK NAME

        .IFF

        MOV     R5,-(SP)                ; SAVE R5
        CALL    $SRSTD                  ; GET THE TCB IN R0
        BCS     45$                     ; IF CS, NO TCB
        MOV     R0,R5                   ; GET TCB ADDRESS IN R5
        MOV     #1,R0                   ; EVENT FLAG TO SET
        CALL    $SETF                   ; SET FLAG
        BIT     #T2.STP*2!T2.STP,T.ST2(R0)      ; IS THE TASK STOPPED
        BEQ     45$                     ; IF EQ, NO-
        CALL    $EXRQN                  ; UNSTOP TASK
45$:    MOV     (SP)+,R5                ; RESTORE R5

        .IFTF

        MOV     #IS.SUC&377,R0          ; INDICATE SUCESS
        MOV     BCNT,R1                 ; RETURN BYTE COUNT IN STATUS           ;JM027
        BR      90$                     ; FINISH AND LOOK FOR MORE              ;**-1

        .IFT

90$:    JMP     START

        .IFF

50$:    CMPB    I.FCN+1(R1),#IO.RLB/256. ; READ LOGICAL BLOCK FUNCTION
        BNE     80$                     ; IF NE THEN NOT A LEGAL FUNCTION
        MOV     I.TCB(R1),R2            ; GET TCB ADDRESS OF REQUESTING TASK
        BIT     #T3.PRV,T.ST3(R2)       ; IS THE TASK PRIVELEGED
        BEQ     80$                     ; IF EQ, NOT PRIV, ILLEGAL FUNCTION
        CMP     TSKNAM,T.NAM(R2)        ; CHECK FOR TASK COT...                 ;JM028
        BNE     80$                     ; IF NE, NOT COT                        ;JM028
        CMP     TSKNAM+2,T.NAM+2(R2)    ; FINISH CHECKING                       ;JM028
        BNE     80$                     ; IF NE NOT ...                         ;JM028
        MOV     U.CNT(R1),R0            ; GET THE BYTE COUNT

        .IFT

WTST:
        MOV     #80.,U.CNT(R5)          ; FAKE BYTE COUNT REQUEST

        .IFTF

        TST     CSTAT                   ; TEST FOR AN ENTRY                     ;JM027
        BMI     55$                     ; IF MI, THEN ENTRY                     ;**-1
        MOV     #IE.EOF&377,R0          ; INDICATE EOF
        CLR     R1                      ; CLEAR SECOND STATUS WORD
        BR      90$
55$:    MOV     U.CNT(R5),R0            ; GET REQUEST BYTE COUNT
        BNE     60$                     ; IF NOT ZERO, GO ON
        MOV     #IE.SPC&377,R0          ; INDICATE ZERO BYTE COUNT
        CLR     R1                      ; CLEAR SECOND STATUS WORD
        BR      90$
60$:    MOV     FIRREC,R2               ; GET POINTER TO FIRST ENTRY
        ADD     (R2)+,FREEB             ; UPDATE NUMBER OF FREE BYTES
        CMP     R0,(R2)                 ; CMP RECORD TO REQUEST SIZE
        BLOS    70$                     ; IF LOS THEN WE HAVE SMALLEST IN R0
        MOV     (R2),R0                 ; GET SMALLER BYTE COUNT
70$:    TST     (R2)+                   ; POINT TO FIRST BYTE OF RECORD
        MOV     R0,BCNT                 ; SAVE TRANSFER BYTE COUNT              ;JM027
                                                                                ;**-1
        .IFT

        MOV     #OUTBUF,R4
        CLR     R3                      ; FAKE KLOBBER R3

        .IFF

        MOV     U.BUF(R1),R3            ; GET USER BUFFER BIAS
        MOV     U.BUF+2(R1),R4          ; GET USER BUFFER ADDRESS (SET FOR PAR #6)

        .IFTF

        BIT     #WRARND,CSTAT           ; DOES THE BUFFER WRAP AROUND           ;JM027
        BEQ     74$                     ; IF EQ, NO WRAP AROUND                 ;**-1
        MOV     -2(R2),R1               ; GET BLOCK BYTE COUNT IN R3
        ADD     R2,R1                   ; CALC END OF RECORD
        SUB     #BUFEND,R1              ; IS IT BEYOND PHYSICAL EOB
        BLOS    74$                     ; IF LOS, NOT BEYOND PHYSICAL EOB
        BIC     #WRARND,CSTAT           ; WE'RE ABOUT TO REMOVE WRAP            ;JM027
        MOV     R1,U.CNT(R5)            ; RESET TRANSFER BYTE COUNT             ;**-1
        SUB     R1,R0                   ; UPDATE TRANSFER BYTE COUNT
        BEQ     72$                     ; IF EQ, MESS STARTS AT BEG OF BUF

        .IFF

        .IF DF  L$$DRV & LD$CO
        MOV     KISAR5,R1               ; MAKE SURE I GET MY OWN PAR #5
        .ENDC

        CALL    $BLXIO                  ; MOVE FIRST PART OF DATA

        .IFT

        CLR     R1                      ; FAKE KLOBBER R1
71$:    MOVB    (R2)+,(R4)+             ; MOVE BLOCK
        SOB     R0,71$

        .IFTF

72$:    MOV     #BUFER,R2               ; START AT BEGINNING
        MOV     U.CNT(R5),R0            ; GET REST OF BYTE COUNT
74$:

        .IFF

        .IF DF  L$$DRV & LD$CO
        MOV     KISAR5,R1               ; MAKE SURE I GET MY OWN PAR #5
        .ENDC

        CALL    $BLXIO                  ; MOV DATA

        .IFT

        CLR     R1                      ; FAKE KLOBBER R1
75$:    MOVB    (R2)+,(R4)+             ; MOVE BLOCK
        SOB     R0,75$

        .IFTF

        MOV     FIRREC,R2               ; GET POINTER TO CURRENT RECORD
        ADD     (R2),FIRREC             ; POINT TO NEW FIRST ENTRY
        CMP     #BUFEND,FIRREC          ; AT END OF BUFFER
        BHI     76$                     ; IF HIGHER, NOT PASSED PHY EOB
        SUB     #BUFSIZ,FIRREC          ; PASSED PHY EOB, WRAP AROUND
76$:    CMP     FIRREC,NXTREC           ; ARE THERE ANY ENTRIES IN BUFFER
        BNE     78$                     ; IF NE, THEN THERE IS AT LEAST 1 ENTRY
        BIC     #BUFENT!WRARND,CSTAT    ; CLEAR BUFFER ENTRY & WRAP BIT         ;JM027
        MOV     #BUFER,FIRREC           ; RESET BUF POINTER (NOT NECESSARY)     ;**-1
        MOV     #BUFER,NXTREC           ; RESET BUF POINTER (NOT NECESSARY)
78$:    MOV     #IS.SUC&377,R0          ; INDICATE SUCESS
        MOV     BCNT,R1                 ; INDICATE TRANSFER BYTE COUNT          ;JM027
        BR      90$                                                             ;**-1

        .IFF
80$:    MOV     #IE.IFC&377,R0          ; SET ILLEGAL FUNCTIO CODE ERROR
        CLR     R1                      ; CLEAR SECOND STATUS WORD
90$:    CALL    $IODON                  ; I/O COMPLETE
        JMP     COINI                   ; CHECK FOR ANOTHER REQUEST

        .IFT

80$:
90$:
        MOV     R1,WRIT+Q.IOPL+2        ; SET BYTE COUNT
        DIR$    #WRIT
        JMP     START

        .IFTF

COOUT:                                  ; DEVICE TIMEOUT ENTRY POINT
COCAN:                                  ; ENTRY POINT FOR CANCEL I/O
COPWF:  RETURN                          ; ENTRY POINT FOR POWERFAIL
;
BUFER:
        .BLKB   BUFSIZ                  ; INTERNAL MESSAGE BUFFER
BUFEND=.

        .IFT

PRINT:
        MOV     R0,-(SP)
        MOV     R1,-(SP)
        MOV     R2,-(SP)
        MOV     R3,-(SP)
        MOV     R4,-(SP)
        MOV     R5,-(SP)
        MOV     #20.,PRNT+Q.IOPL+2
        MOV     #LIST,PRNT+Q.IOPL
        DIR$    #PRNT
        MOV     #OUTBUF,PRNT+Q.IOPL
        MOV     #OUTBUF,R0
        MOV     #1,R2
        MOV     R2,R3
        MOV     FREEB,R1
        CALL    $CBOMG
        MOVB    #40,(R0)+
        MOV     R3,R2
        MOV     FIRREC,R1
        SUB     #BUFER,R1
        CALL    $CBOMG
        MOVB    #40,(R0)+
        MOV     R3,R2
        MOV     NXTREC,R1
        SUB     #BUFER,R1
        CALL    $CBOMG
        DIR$    #PRNT
        MOV     #64.,PRNT+Q.IOPL+2
        MOV     #BUFSIZ/64.,R1
        MOV     #BUFER,R3
10$:    MOV     #64.,R2
        MOV     #OUTBUF,R4
20$:    MOVB    (R3)+,R5
        CMPB    #37,R5
        BLO     30$
        BIS     #100,R5
30$:    MOVB    R5,(R4)+
        SOB     R2,20$
        DIR$    #PRNT
        SOB     R1,10$
        MOV     (SP)+,R5
        MOV     (SP)+,R4
        MOV     (SP)+,R3
        MOV     (SP)+,R2
        MOV     (SP)+,R1
        MOV     (SP)+,R0
        RETURN
;
READ:   QIOW$   IO.RLB,5,1,,IOSTAT,,<INBUF,80.>
WRIT:   QIOW$   IO.WLB,5,2,,IOSTAT,,<OUTBUF,80.,40>
PRNT:   QIOW$   IO.WLB,5,3,,,,<OUTBUF,80.,40>
INBUF:  .BLKB   80.
OUTBUF: .BLKB   80.
IOSTAT: .WORD   0,0
NOROOM: .ASCII  / NO MORE ROOM/
NOSIZ=.-NOROOM
LIST:   .ASCII  /FREEB  FIRREC NXTREC/
        .EVEN
        .ENDC

        .IIF DF DBUG    .END    START
        .IIF NDF DBUG   .END
        .TITLE  CORAL
        .IDENT  /7.3/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION  7.3
;
; D. N. CUTLER 3-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;
;       H.D. COFFMAN    14-NOV-78
;
;               HDC022 -- ENSURE PROPER POOL ALLOCATION IN $ALOCB
;
;
;       CHUCK SPITZ     12-JAN-79
;               CS025 -- CORRECT BUG IN ABOVE IF ENTRY AT $ALOC1
;
;       CHUCK SPITZ     16-MAY-79
;               CS052 -- DETECT ZERO LENGTH ALLOCATION REQUESTS
;
; CORE BUFFER ALLOCATION ROUTINES
;
; MACRO LIBRARY CALLS
;

        .MCALL  CLKDF$,PKTDF$
        CLKDF$                  ;DEFINE CLOCK QUEUE CONTROL BLOCK OFFSETS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS

;+
; **-$ALOCB-ALLOCATE CORE BUFFER
; **-$ALOC1-ALLOCATE CORE BUFFER (ALTERNATE ENTRY)
;
; THIS ROUTINE IS CALLED TO ALLOCATE AN EXEC CORE BUFFER. THE ALLOCATION
; ALGORITHM IS FIRST FIT AND BLOCKS ARE ALLOCATED IN MULTIPLES OF FOUR
; BYTES.
;
; INPUTS:
;
;       R0=ADDRESS OF CORE ALLOCATION LISTHEAD-2 IF ENTRY AT $ALOC1.
;       R1=SIZE OF THE CORE BUFFER TO ALLOCATE IN BYTES.
;
; OUTPUTS:
;
;       C=1 IF INSUFFICIENT CORE IS AVAILABLE TO ALLOCATE THE BLOCK.
;       C=0 IF THE BLOCK IS ALLOCATED.
;               R0=ADDRESS OF THE ALLOCATED BLOCK.
;               R1=LENGTH OF BLOCK ALLOCATED
;-

        .ENABL  LSB
$ALOCB::MOV     #$CRAVL-2,R0    ;POINT TO ALLOCATION MASK WORD


        .IF DF  Q$$OPT

        ADD     (R0),R1         ;ROUND TO NEXT BOUNDARY
        BIC     (R0)+,R1        ;
        BEQ     5$              ;IF EQ ZERO LENGTH REQUEST
        CMP     R1,#I.LGTH      ;REQUEST SIZE OF PACKET?
        BNE     5$              ;IF NE NO
        MOV     #$PKAVL,R2      ;POINT TO PACKET AVAILABLE POINTER
        MOV     (R2),R0         ;PICK UP PACKET POINTER
        BEQ     4$              ;IF EQ THERE IS NONE
        MOV     (R0),(R2)+      ;UNLINK PACKET FROM LIFO LIST
        DEC     (R2)            ;INDICATE ONE PACKET LESS IN LIST
        RETURN                  ;
4$:     MOV     #$CRAVL-2,R0    ;POINT BACK TO ALLOCATION MASK WORD

        .ENDC


$ALOC1::ADD     (R0),R1         ;ROUND TO NEXT BOUNDARY
        BIC     (R0)+,R1        ;CLEAR EXCESS
5$:     SEC                     ;ASSUME ZERO LENGTH REQUEST             ; CS052
        BEQ     35$             ;IF EQ, ZERO LENGTH REQUEST             ; CS052
                                                                        ; CS025
        .IF DF R$$DER                                                   ; CS025
                                                                        ; CS025
        MOV     R0,-(SP)        ;SAVE ADDRESS OF LISTHEAD               ; CS025
                                                                        ; CS025
        .ENDC   ;R$$DER                                                 ; CS025
                                                                        ; CS025
10$:    MOV     R0,R2           ;SAVE ADDRESS OF CURRENT BLOCK          ;**-2
        MOV     (R2),R0         ;GET ADDRESS OF NEXT BLOCK
        BEQ     30$             ;IF EQ END OF CHAIN
                                                                        ; HDC022
                                                                        ; HDC022
        .IF  DF,R$$DER                                                  ; HDC022
                                                                        ; HDC022
        CMP     R0,R2           ;BACKWARD REFERENCE?                    ; HDC022
        BLO     40$             ;IF LE YES                              ; HDC022
        CMP     #$CRAVL,(SP)    ;ALLOCATION IN EXEC'S POOL?             ; CS025
        BNE     15$             ;IF NE, NO                              ; CS025
        CMP     R0,#$POOL       ;ALLOCATION BEFORE EXEC POOL?           ; CS025
        BLO     40$             ;IF LO YES                              ; HDC022
        CMP     R0,$EXSIZ       ;ALLOCATION PAST END OF POOL?           ; HDC022
        BHI     40$             ;IF HI YES                              ; HDC022
15$:                            ;REF LABEL                              ; CS025
                                                                        ; HDC022
        .ENDC   ;R$$DER                                                 ; HDC022
                                                                        ; HDC022
                                                                        ; HDC022
        CMP     2(R0),R1        ;BLOCK BIG ENOUGH?
        BLO     10$             ;IF LO NO
        BEQ     20$             ;IF EQ BLOCK IS EXACT SIZE
        TST     (R0)+           ;POINT TO SIZE OF FREE BLOCK
        SUB     R1,(R0)         ;CALCULATE SIZE REMAINING
        ADD     R0,R1           ;POINT TO NEW FREE BLOCK
        MOV     (R0),(R1)       ;COPY SIZE
        MOV     -(R0),-(R1)     ;COPY LINK
        MOV     R1,(R0)         ;STORE LINK TO NEW FREE BLOCK
        SUB     R0,R1           ;RESTORE SIZE OF BLOCK
20$:    MOV     (R0),(R2)       ;UPDATE LINK TO NEW FREE BLOCK
30$:                            ;REF LABEL                              ; CS025
                                                                        ; CS025
        .IF DF R$$DER                                                   ; CS025
                                                                        ; CS025
        INC     (SP)+           ;CLEAN STACK W/O AFFECTING C-BIT        ; CS025
                                                                        ; CS025
        .ENDC   ;R$$DER                                                 ; CS025
                                                                        ; CS025
35$:    RETURN                  ;                                       ; CS052
                                                                        ; HDC022
                                                                        ; HDC022
        .IF  DF,R$$DER                                                  ; HDC022
                                                                        ; HDC022
40$:    CRASH                   ;POOL CLOBBERED                         ; HDC022
                                                                        ; HDC022
        .ENDC   ;R$$DER                                                 ; HDC022
                                                                        ; HDC022
        .DSABL  LSB                                                     ;**-1

;+
; **-$ALCLK-ALLOCATE CLOCK QUEUE CORE BLOCK
;
; THIS ROUTINE IS CALLED TO ALLOCATE A CORE BLOCK FOR A CLOCK QUEUE ENTRY.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       IF INSUFFICIENT CORE IS AVAILABLE TO ALLOCATE THE BLOCK, THEN A
;       DIRECTIVE STATUS OF 'D.RS1' IS RETURNED. ELSE THE ADDRESS OF
;       THE ALLOCATED BLOCK IS RETURNED TO THE CALLER IN R0.
;-

        .ENABL  LSB
$ALCLK::MOV     #C.LGTH,R1      ;PICK UP LENGTH OF CLOCK BLOCK
        BR      10$             ;

;+
; **-$DECLK-DEALLOCATE CLOCK QUEUE CORE BLOCK
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A CORE BLOCK THAT WAS BEING USED
; FOR A CLOCK QUEUE ENTRY.
;
; INPUTS:
;
;       R0=ADDRESS OF THE CORE BLOCK TO BE DEALLOCATED.
;
; OUTPUTS:
;
;       THE CLOCK QUEUE ENTRY CORE BLOCK IS DEALLOCATED.
;-

$DECLK::MOV     #C.LGTH,R1      ;PICK UP LENGTH OF CLOCK BLOCK
        BR      $DEACB          ;

;+
; **-$ALPKT-ALLOCATE SEND OR I/O REQUEST CORE BLOCK
;
; THIS ROUTINE IS CALLED TO ALLOCATE A CORE BLOCK FOR A SEND OR I/O
; REQUEST QUEUE ENTRY.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       IF INSUFFICIENT CORE IS AVAILABLE TO ALLOCATE THE BLOCK, THEN A
;       DIRECTIVE STATUS OF 'D.RS1' IS RETURNED. ELSE THE ADDRESS OF
;       THE ALLOCATED BLOCK IS RETURNED TO THE CALLER IN R0.
;-

$ALPKT::MOV     #I.LGTH,R1      ;SET LENGTH OF I/O PACKET
10$:    CALL    $ALOCB          ;ATTEMPT TO ALLOCATE BLOCK
        BCC     80$             ;IF CC SUCCESSFUL
        DRSTS   D.RS1           ;ALLOCATION FAILURE

;+
; **-$DEPKT-DEALLOCATE SEND OR I/O REQUEST CORE BLOCK
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A CORE BLOCK THAT WAS BEING USED
; FOR A SEND OR I/O REQUEST QUEUE ENTRY.
;
; INPUTS:
;
;       R0=ADDRESS OF THE CORE BLOCK TO BE DEALLOCATED.
;
; OUTPUTS:
;
;       THE SEND OR I/O REQUEST QUEUE ENTRY CORE BLOCK IS DEALLOCATED.
;-

$DEPKT::MOV     #I.LGTH,R1      ;SET LENGTH OF I/O PACKET

;+
; **-$DEACB-DEALLOCATE CORE BUFFER
; **-$DEAC1-DEALLOCATE CORE BUFFER (ALTERNATE ENTRY)
;
; THIS ROUTINE IS CALLED TO DEALLOCATE AN EXEC CORE BUFFER. THE BLOCK IS
; INSERTED INTO THE FREE BLOCK CHAIN BY CORE ADDRESS. IF AN ADJACENT
; BLOCK IS CURRENTLY FREE, THEN THE TWO BLOCKS ARE MERGED AND INSERTED
; IN THE FREE BLOCK CHAIN.
;
; INPUTS:
;
;       R0=ADDRESS OF THE CORE BUFFER TO BE DEALLOCATED.
;       R1=SIZE OF THE CORE BUFFER TO DEALLOCATE IN BYTES.
;       R3=ADDRESS OF CORE ALLOCATION LISTHEAD-2 IF ENTRY AT $DEAC1.
;
; OUTPUTS:
;
;       THE CORE BLOCK IS MERGED INTO THE FREE CORE CHAIN BY CORE
;       ADDRESS AND IS AGCOMERATED IF NECESSARY WITH ADJACENT BLOCKS.
;-

$DEACB::MOV     #$CRAVL-2,R3    ;POINT TO ALLOCATION MASK WORD


        .IF DF  Q$$OPT

        ADD     (R3),R1         ;ROUND TO NEXT BOUNDARY
        BIC     (R3)+,R1        ;
        BEQ     80$             ;IF EQ NO BLOCK TO RELEASE
        CMP     R1,#I.LGTH      ;LENGTH EQUAL TO I/O PACKET?
        BNE     30$             ;IF NE NO
        MOV     #$PKMAX,R2      ;PNT TO MAX # OF PACKETS TO PREALLOCATE
        CMPB    (R2),-(R2)      ;MAX NUMBER PREALLOCATED?
        BLOS    30$             ;IF LOS YES
        INC     (R2)            ;INDICATE ONE MORE AVAILABLE
        MOV     -(R2),(R0)      ;LINK PACKET INTO LIFO LIST
        MOV     R0,(R2)         ;
        RETURN                  ;

        .ENDC


$DEAC1::ADD     (R3),R1         ;ROUND TO NEXT BOUNDARY
        BIC     (R3)+,R1        ;CLEAR EXCESS
        BEQ     80$             ;IF EQ NO BLOCK TO RELEASE
30$:                            ;REF LABEL


        .IF DF  R$$DER

        MOV     R3,-(SP)        ;SAVE ADDRESS OF LISTHEAD

        .IFTF

40$:    MOV     R3,R2           ;SAVE ADDRESS OF CURRENT BLOCK
        MOV     (R2),R3         ;GET ADDRESS OF NEXT BLOCK
        BEQ     50$             ;IF EQ END OF CHAIN
        CMP     R0,R3           ;BLOCK GO HERE?
        BHIS    40$             ;IF HIS NO
50$:    MOV     R3,(R0)         ;ASSUME NO AGLOMERATION
        MOV     R0,-(SP)        ;CALCULATE ADDRESS OF NEW BLOCK
        ADD     R1,(SP)         ;

        .IFT

        BCS     100$            ;IF CS ILLEGAL DEALLOCATION
        CMP     2(SP),#$CRAVL   ;DEALLOCATION IN EXECUTIVE POOL?
        BNE     55$             ;IF NE NO
        CMP     R0,#$POOL       ;DEALLOCATION BEFORE FRONT OF LIST?
        BLO     100$            ;IF LO YES
        CMP     (SP),$EXSIZ     ;DEALLOCATION PAST END OF POOL?
        BHI     100$            ;IF HI YES
55$:                            ;REFERENCE LABEL

        .IFTF

        CMP     R3,(SP)+        ;EQUAL TO NEXT IN CHAIN?

        .IFT

        BLO     90$             ;IF LO, DEALLOCATION OVERLAPS

        .IFTF

        BNE     60$             ;IF NE NO
        MOV     (R3)+,(R0)      ;MOVE LINK WORD TO BLOCK RELEASED
        ADD     (R3),R1         ;MERGE TWO BLOCKS
60$:    MOV     R2,-(SP)        ;SAVE ADDRESS OF PREVIOUS BLOCK
        MOV     R0,(R2)+        ;ASSUME NO AGLOMERATION
        ADD     (R2),(SP)       ;CALCULATE ADDRESS OF NEXT BLOCK
        CMP     R0,(SP)+        ;EQUAL TO BLOCK BEING RELEASED?

        .IFT

        BHIS    65$             ;IF HIS, NO OVERLAP
        CMP     (SP),#$CRAVL    ;DEALLOCATION IN EXECUTIVE CORE POOL?
        BEQ     100$            ;IF EQ YES (ELSE NOT SURE OF OVERLAP)
65$:                            ;REF LABEL

        .IFTF

        BNE     70$             ;IF NE NO
        ADD     (R2),R1         ;MERGE TWO BLOCKS
        MOV     (R0),-(R2)      ;MOVE LINK WORD TO PREVIOUS BLOCK
        MOV     R2,R0           ;SET NEW ADDRESS OF BLOCK
70$:    MOV     R1,2(R0)        ;SET SIZE OF BLOCK RELEASED

        .IFT

        TST     (SP)+           ;POP ADDRESS OF LISTHEAD

        .IFTF

80$:    RETURN                  ;

        .IFT

90$:    TST     R3              ;INSERT AT END OF LIST?
        BEQ     60$             ;IF EQ YES, OK
100$:   CRASH                   ;CRASH SYSTEM, BAD CORE DEALLOCATION

        .ENDC


        .DSABL  LSB

        .END
        .TITLE  CRASH
        .IDENT  /04.03/
;
;
; COPYRIGHT (C) 1977
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION
; OF  THE  ABOVE COPYRIGHT  NOTICE.  THIS SOFTWARE, OR  ANY  OTHER
; COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE  MADE AVAILABLE
; TO  ANY  OTHER PERSON  EXCEPT  FOR USE ON SUCH SYSTEM AND TO ONE
; WHO AGREES TO THESE LICENSE TERMS.  TITLE  TO  AND  OWNERSHIP OF
; THE SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE  INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A  COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO  RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;
;
; VERSION 04.03
;
; J. MASSE / P. J. BEZEREDI  24-OCT-77
;
; MODIFIED BY:
;
;       M. B. GROSSMAN 1-NOV-78
;
;               MG001 -- DUMP MEMORY TO BLOCK 1 OF DEVICE (INSTEAD OF 100)
;                       ADD CODE FOR RK06/07,RM02/03,RL01/02,TU-58,RP04
;
;       A. PROTIN       1-DEC-78
;
;               AP002 -- ADD SUPPORT FOR TS04
;
;       M. S. HARVEY    2-FEB-79
;
;               MSH024 -- CORRECT CONDITIONAL FOR PROPER JUMP TO PANIC
;
;
; CRASH DUMP ROUTINES
;


        .IF DF  C$$RSH

;
; MACRO LIBRARY CALLS
;
        .MCALL  HWDDF$
        HWDDF$

;
; LOCAL DATA
;

;
;
$CRUPC::.WORD   0               ; USER PC IS STORED HERE
$CRUST::.WORD   0               ; USER PS IS STORED HERE

        .IF DF  C$$CDA

IOERR:  .ASCIZ  <15><12><12>! I/O DEVICE ERROR!                         ; MG001
CRSMSG: .ASCII  <15><12><12>/CRASH -- CONT WITH SCRATCH MEDIA ON /

.IIF EQ C$$CDA-1,       .ASCII  /DT/
.IIF EQ C$$CDA-2,       .ASCII  /DK/
.IIF EQ C$$CDA-3,       .ASCII  /MT/
.IIF EQ C$$CDA-4,       .ASCII  /MM/
.IIF EQ C$$CDA-5,       .ASCII  /DB/                                    ; MG001
.IIF EQ C$$CDA-6,       .ASCII  /DM/                                    ; MG001
.IIF EQ C$$CDA-7,       .ASCII  /DL/                                    ; MG001
.IIF EQ C$$CDA-10,      .ASCII  /DD/                                    ; MG001
.IIF EQ C$$CDA-11,      .ASCII  /DR/                                    ; MG001
.IIF EQ C$$CDA-12,      .ASCII  /MS/                                    ; MG001

UNIT:   .ASCIZ  /0/<15><12><12>
        .EVEN

        .ENDC


        .IF DF  C$$TTY

MSG1:   .ASCIZ  <15><12><12>/SYSTEM CRASH AT LOCATION /
MSG2:   .ASCII  <15><12><12>/REGISTERS/<15><12><12>
        .ASCIZ  / R0=/
MSG3:   .ASCIZ  /R1=/
MSG4:   .ASCIZ  /R2=/
MSG5:   .ASCIZ  /R3=/
MSG6:   .ASCIZ  <15><12><12>/ R4=/
MSG7:   .ASCIZ  /R5=/
MSG8:   .ASCIZ  /SP=/
MSG9:   .ASCIZ  /PS=/<0>
MSG10:  .ASCII  <15><12><12>/SYSTEM STACK DUMP/
        .ASCIZ  <15><12><12>/ LOCATION CONTENTS/<15><12><12>
        .EVEN

        .ENDC


                                ; *** THE FOLLOWING MUST BE ADJACENT
$CRPBF::.BLKW   4               ;STACK AREA FOR SUBROUTINE CALLS
$CRSBF::.BLKW   14.             ;INTERNAL CRASH STACK ...
$CRPST::                        ;TOP OF PANIC STACK


        .IF DF  M$$MGE

        .BLKW   159.            ;... MAPPED STACK IS THIS LARGE

        .ENDC


$CRSST==.-2                     ;TOP OF CRASH STACK
                                ; *** ABOVE MUST BE ADJACENT


        .IF DF  C$$CDA

$CRSBN::.WORD   PBNH,PBNL       ;STARTING DEVICE ADDRESS
$CRSCS::.WORD   PBNH+PBNL       ;CHECKSUM OF DEVICE ADDRESS

;
; LOCAL MACROS
;
        .MACRO  PUSH    ARG
        SUB     #2,SP
        MOV     ARG,(SP)
        .ENDM   PUSH

        .ENDC


        .ENDC


;+
; **-$CRASH-SYSTEM CRASH DUMP ROUTINE
;
; THIS ROUTINE IS ENTERED VIA A JUMP WHENEVER A FATAL SYSTEM ERROR
; (IOT) IS DETECTED.
;
; THIS ROUTINE PERFORMS A MEMORY DUMP THAT CAN BE DIRECTED TO A
; HARD COPY DEVICE,DECTAPE,RK05,TU10,TU16,RP04,RP06,RK06                ; MG001
; RK07,RL01,RL02,TU58,RM02,RM03,TS04.                                   ; MG001
;       ONCE THE DUMP IS FINISHED THE SYSTEM MAY BE                     ; MG001
; RE-BOOTED OR ANOTHER DUMP MAY BE TAKEN.  IF THE DUMP IS DIRECTED      ;**-4
; TO A HARD COPY DEVICE THE DUMP WILL CONTAIN ONLY THE REGISTER
; CONTENTS AND THE SYSTEM STACK.
;
; INPUTS:
;
;       02(SP)=PS WORD AT CRASH.
;       00(SP)=PC WORD AT CRASH.
;
; OUTPUTS:
;
;       THE INTERNAL CRASH STACK AND A CORE IMAGE OF THE SYSTEM,
;       UP TO 128K, ARE DUMPED ONTO THE MASS STORAGE CRASH DUMP DEVICE.
;       THE REGISTER CONTENTS AND THE SYSTEM STACK ARE DUMPED IF A
;       HARD COPY DUMP IS REGUESTED.
;-

        .IF DF  C$$CDA                                                  ; MG001
                                                                        ; MG001
TRP04:  BIS     #1,2(SP)        ;SET CARRY ON TRAPS THROUGH 4           ; MG001
        RTI                     ;RETURN                                 ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
$CRASH::                        ;CRASH DUMP ROUTINE


        .IF DF  C$$RSH
;
        MOV     (SP)+,$CRUPC    ; SAVE USER PC FROM THE STACK
        MOV     (SP)+,$CRUST    ; SAVE USER PS FROM THE STACK
$CRALT::
;


        .IF DF  C$$TTY

        MOV     $CRUPC,$CRPBF   ;                                       ; MG001
        MOV     R0,$CRPBF+2     ;SAVE R0                                ;**-1
        MOV     #$CRPBF+4,R0    ;SET UP SAVE AREA
        MOV     R1,(R0)+        ;SAVE R1 THRU R5
        MOV     R2,(R0)+        ;
        MOV     R3,(R0)+        ;
        MOV     R4,(R0)+        ;
        MOV     R5,(R0)+        ;
        MOV     $CRUST,2(R0)    ;                                       ; MG001
        MOV     SP,(R0)         ;SAVE SP                                ;**-1
        MOV     #$CRPST,SP      ;SETUP TEMPORARY STACK
        MOV     #C$$TTY,R5      ;SPECIFY OUTPUT DEVICE CSR
        MOV     #$CRPBF,R1      ;POINT TO DATA VECTOR
        MOV     #MSG1,R4        ;POINT TO MESSAGE TEXT
1$:     MOVB    (R4)+,R2        ;GET A BYTE OF MESSAGE
        BEQ     5$              ;IF EQ AT MESSAGE BREAK
        BR      3$              ;ELSE ALREADY HAVE A BYTE
2$:     MOVB    (R4)+,R2        ;GET A BYTE OF MESSAGE
        BEQ     4$              ;IF EQ END OF THIS MESSAGE
3$:     CALL    $OUT            ;OUTPUT THIS CHARACTER
        BR      2$              ;GO AGAIN
4$:     MOV     (R1)+,R3        ;GET DATA WORD
        CALL    $EDIT           ;PRINT IN PLACE
        BR      1$              ;GET NEXT MESSAGE
5$:     MOVB    (R4)+,R2        ;GET NEXT CHARACTER TO OUTPUT
        BEQ     6$              ;IF EQ END OF STRING
        CALL    $OUT            ;OUTPUT CHARACTER
        BR      5$              ;GO AGAIN
6$:     MOV     $CRPBF+16,R1    ;POINT TO BOTTOM OF SYSTEM STACK
7$:     MOV     R1,R3           ;SET ADDRESS OF LOCATION TO EDIT
        CALL    8$              ;EDIT ADDRESS
        MOV     (R1)+,R3        ;GET CONTENTS OF LOCATION
        CALL    8$              ;EDIT CONTENTS
        CALL    $CRLF           ;ISSUE CARRIAGE RETURN, LINE FEED
        CMP     R1,#$STACK      ;END OF SYSTEM STACK?
        BLO     7$              ;IF LO NO
        MOV     #$CRPBF+16,R0   ;POINT TO SAVED STACK POINTER
        MOV     (R0),SP         ;RESTORE SP
        MOV     -(R0),R5        ;RESTORE R5 THRU R0
        MOV     -(R0),R4        ;
        MOV     -(R0),R3        ;
        MOV     -(R0),R2        ;
        MOV     -(R0),R1        ;
        MOV     -(R0),R0        ;
        BR      9$              ;BR AROUND SUBROUTINE
8$:     CALL    $OUTB           ;OUTPUT TWO BLANKS
        CALL    $OUTB           ;
        CALLR   $EDIT           ;PRINT CONTENTS OF R3 AND RETURN
9$:                             ;REF LABEL

        .ENDC


        .IF DF  C$$CDA

        MOV     #TRP04,@#4      ;SET UP TO SET CARRY ON TRAPS THROUGH 4 ; MG001
                                                                        ;**-2

        .IF DF  L$$SI1

        CLR     $CRSST          ;CLEAR PS STORAGE WORD
        MFPS    $CRSST          ;STORE LOW BYTE OF PS
        MTPS    #PR7            ;LOCK OUT INTERRUPTS

        .IFF

        MOV     PS,$CRSST       ;STORE FULL PS
        MOVB    #PR7,PS         ;LOCK OUT INTERRUPTS

        .ENDC


        MOV     SP,$CRSST-2     ;;;SAVE SP
        MOV     $CRUPC,$CRSST-4 ;;;SAVE PC BEFORE IOT CRASH
        MOV     $CRUST,$CRSST-6 ;;;SAVE PS BEFORE IOT CRASH
        MOV     #$CRSST-6,SP    ;;;RESET SP TO INTERNAL STACK


        .IF DF  M$$MGE

        MFPI    SP              ;;;SAVE USER'S SP

        .IFF

        CLR     -(SP)           ;;;NO USER SP IF UNMAPPED

        .IFTF

        MOV     R0,-(SP)        ;;;SAVE REGISTER SET 1
        MOV     R1,-(SP)        ;;;
        MOV     R2,-(SP)        ;;;
        MOV     R3,-(SP)        ;;;
        MOV     R4,-(SP)        ;;;
        MOV     R5,-(SP)        ;;;

        .IFT

        PUSH    SR0             ;;;SAVE MEMORY MANAGEMENT REGISTERS
        PUSH    SR0+2           ;;;
        PUSH    SR0+4           ;;;
        PUSH    SR3             ;;;
        BIC     #67,SR3         ;;;DISABLE UNIBUS MAP AND D-SPACE
        MOV     #UISDR0,R0      ;;;SETUP TO SAVE FIRST SET OF APR'S
        MOV     #32.,R1         ;;;
10$:    PUSH    (R0)            ;;;SAVE APR
        ADD     #2,R0           ;;;MOVE TO NEXT ONE
        DEC     R1              ;;;DONE YET?
        BNE     10$             ;;;IF NE NO
        MOV     #SISDR0,R0      ;;;SETUP TO SAVE SECOND SET OF APR'S
        MOV     #64.,R1         ;;;
20$:    PUSH    (R0)            ;;;SAVE APR
        ADD     #2,R0           ;;;MOVE TO NEXT ONE
        DEC     R1              ;;;DONE YET?
        BNE     20$             ;;;IF NE NO
        MOV     #UBMPR,R0       ;;;GET ADDRESS OF FIRST UMR
        MOV     #62.,R1         ;;;NUMBER OF UMR'S TO SAVE
30$:    PUSH    (R0)            ;;;SAVE A UMR
        ADD     #2,R0           ;;;MOVE TO NEXT ONE
        DEC     R1              ;;;DONE YET?
        BNE     30$             ;;;IF NE NO

        .ENDC


;
; TYPE MESSAGE AND WAIT FOR USER
;

AGAIN:  MOV     $CRSUN,R0       ;;;GET CRASH UNIT NUMBER
        ADD     #'0,R0          ;;;ADD ASCII BIAS
        MOVB    R0,UNIT         ;;;MOVE IT INTO TEXT STRING
        MOV     #CRSMSG,R1      ;;;TYPE USER MESSAGE
        CALL    TYPE            ;;;TYPE OUT MESSAGE                     ; MG001
        BR      $CRSHT          ;;;BRANCH TO BEFORE UNIT # STORAGE      ; MG001
                                                                        ; MG001
TYPE:   MOV     #C$$RSH,R5      ;;;GET CSR ADD. OF PRINT DEVICE         ; MG001
10$:    MOVB    (R1)+,R2        ;;;GET CHARACTER                        ; MG001
        BEQ     20$             ;;;IF EQ FINISHED                       ; MG001
        CALL    $OUT            ;;;OUTPUT THE CHARACTER                 ;**-3
        BR      10$             ;;;LOOP FOR MORE                        ; MG001
20$:    RETURN                  ;;;RETURN TO CALLER                     ; MG001
                                                                        ; MG001
                                                                        ; MG001
$CRSHT::        HALT            ;;;WAIT FOR USER                        ; MG001
        BR      DUMP            ;;;AFTER CONTINUE - PROCEED WITH DUMP   ; MG001
                                                                        ;**-3
;
; FOR CONVENIENCE THE CRASH DEVICE UNIT NUMBER IS STORED
; HERE SO THAT THE CONSOLE DISPLAY +2 WILL GIVE THE
; ADDRESS OF THE NEXT WORD, THUS ALLOWING THE USER TO PATCH
; A DIFFERENT UNIT NUMBER (IGNORING THE PRINTOUT).
;

$CRSUN::.WORD   C$$RUN          ;;;CRASH UNIT NUMBER (DEFAULT=0)


;+
; **-CKSUM-VERIFY CHECKSUM OF DEVICE ADDRESS
;
; THIS ROUTINE WILL VERIFY THAT THE DEVICE ADDRESS FOR THE RK11
; AND TC11 HAS NOT BEEN CORRUPTED BY THE CRASH.
;-

CKSUM:  MOV     $CRSBN,-(SP)    ;;;GET HIGH ORDER BITS
        ADD     $CRSBN+2,(SP)   ;;;ADD LOW ORDER BITS
        CMP     (SP)+,$CRSCS    ;;;COMPARE WITH CHECKSUM
        BEQ     10$             ;;;IF EQ OK
        HALT                    ;;;WAIT FOR USER
        BR      CKSUM           ;;;TRY AGAIN
10$:    RETURN                  ;;;

;+
; **-DUMP-DUMP THE SYSTEM IMAGE
;
; THIS ROUTINE IS USED TO DUMP THE INTERNAL CRASH STACK
; AND THE SYSTEM IMAGE ONTO A SCTATCH DUMP MEDIA.  WHEN THE DUMP
; IS FINISHED THE SYSTEM IS EITHER RE-BOOTED OR THE USER IS ASKED
; IF HE WANTS TO DUMP ANOTHER COPY OF THE IMAGE.
;
; INPUTS:
;       NONE.
;
; OUTUTS:
;       IMAGE DUMPED.
;-

DUMP:                           ;;;DUMP IMAGE ONTO MEDIA
        MOV     #C$$CSR,R0      ;;;GET CSR ADDRESS OF DUMP DEVICE
        MOV     $CRSUN,R3       ;;;GET UNIT NUMBER


        .IF EQ  C$$CDA-1

                                                                        ; MG001
PBNH=   0                       ;;;HIGH ORDER TC11 BLOCK NUMBER         ; MG001
PBNL=   1                       ;;;LOW ORDER TC11 BLOCK NUMBER          ; MG001
                                                                        ;**-2
        CALL    CKSUM           ;;;CHECK BLOCK NUMBER AGAINST CHECKSUM
        SWAB    R3              ;;;POSITION UNIT BITS
        MOV     R3,R1           ;;;COPY
        BIS     #4003,R1        ;;;SET FOR READ LBN IN REVERSE
        MOV     R1,(R0)         ;;;START THE TAPE
10$:    BIT     #100200,(R0)    ;;;ERROR OR READY?
        BEQ     10$             ;;;IF EQ NO
        BPL     DUMP            ;;;IF PL MOVE UNTIL ENDZONE
20$:    MOV     R3,R1           ;;;RETREIVE UNIT BITS
        BIS     #3,R1           ;;;SET TO READ LBN FORWARD
        MOV     R1,(R0)         ;;;START THE TAPE
30$:    BIT     #100200,(R0)    ;;;ERROR OR READY?
        BMI     DUMP            ;;;IF MI ERROR, RESTART
        BEQ     30$             ;;;IF EQ WAIT
        SUB     $CRSBN+2,6(R0)  ;;;ARE WE AT THE BLOCK WE WANT?
        BNE     20$             ;;;IF NE NO
        CLR     2(R0)           ;;;SET TO WRITE ALL MEMORY              ; MG001
        CLR     4(R0)           ;;;                                     ; MG001
        MOV     R3,R1           ;;;RETREIVE UNIT BITS                   ;**-2
        BIS     #15,R1          ;;;SET TO WRITE DATA FORWARD
        MOV     R1,(R0)         ;;;WRITE THE BLOCK
50$:    CLR     2(R0)           ;;;KEEP WRITING                         ;**-8
        TST     (R0)            ;;;ANY ERRORS?
        BPL     50$             ;;;IF PL NO
        BIT     #400,-2(R0)     ;;;NON-EXISTANT MEMORY?
        BEQ     WERR            ;;;IF EQ NO, RETRY                      ; MG001
        BIS     #1,R3           ;;;SET TO STOP TAPE                     ;**-1
        MOV     R3,(R0)         ;;;STOP TAPE
        BR      $CRCMP          ;;;SUCCESS, FINISH                      ; MG001

        .ENDC


        .IF EQ  C$$CDA-2

PBNH=   0                       ;;;HIGH ORDER RK11 DISK ADDRESS         ; MG001
PBNL=   001                     ;;;LOW ORDER RK11 DISK ADDRESS          ; MG001
                                                                        ;**-2
        CALL    CKSUM           ;;;CHECK DISK ADDRESS AGAINST CHECKSUM
        CLC                     ;;;SET TO POSITION UNIT BITS
        ROR     R3              ;;;
        ROR     R3              ;;;
        ROR     R3              ;;;
        ROR     R3              ;;;
        MOV     #401,(R0)       ;;;RESET RK11 CONTROLLER
        BIS     $CRSBN+2,R3     ;;;SET STARTING DISK ADDRESS
        MOV     R3,6(R0)        ;;;SET DISK ADDRESS
                                                                        ; MG001
        .IF NDF M$$EXT                                                  ; MG001
                                                                        ; MG001
        CLR     4(R0)           ;;;SETUP TO WRITE ALL MEMORY            ; MG001
        CLR     2(R0)           ;;;                                     ; MG001
        MOV     #403,(R0)       ;;;START THE WRITE                      ; MG001
20$:    CLR     2(R0)           ;;;KEEP WRITING                         ; MG001
        TST     (R0)            ;;;ANY ERROR BITS SET?                  ; MG001
        BPL     20$             ;;;IF PL NO                             ; MG001
        BIT     #2000,-2(R0)    ;;;NON-EXISTANT MEMORY?                 ; MG001
        BNE     $CRCMP          ;;;IF NE YES, FINISHED                  ; MG001
                                                                        ; MG001
        .IFF                                                            ; MG001
                                                                        ; MG001
        CLR     UBMPR           ;;;INITIALIZE FIRST UNIBUS MAPPING REGIS; MG001
        CLR     UBMPR+2         ;;;                                     ; MG001
        CLR     KISAR0          ;;;                                     ; MG001
        BIS     #60,SR3         ;;;ENABLE 22 BIT MAPPING AND UNIBUS MAP ; MG001
        BIS     #1,SR0          ;;;MAKE SURE MEM MGMT IS ON             ; MG001
40$:    CLR     4(R0)           ;;;INITIALIZE TRANSFER ADDRESS          ; MG001
        MOV     #-10000,2(R0)   ;;;INITIALIZE COUNT TO DUMP 8K BYTES    ; MG001
        MOV     #403,(R0)       ;;;START THE WRITE                      ; MG001
45$:    BIT     #100200,(R0)    ;;;ERROR OR READY?                      ; MG001
        BEQ     45$             ;;;IF EQ NO                             ; MG001
        BMI     50$             ;;;IF MI ERROR                          ; MG001
        ADD     #20000,UBMPR    ;;;POINT TO NEXT 4K OF MEMORY           ; MG001
        ADC     UBMPR+2         ;;;DOUBLE WORD ADD                      ; MG001
        BR      40$             ;;;GO AGAIN UNTIL END OF MEMORY         ; MG001
50$:    BIT     #2000,-2(R0)    ;;;NON EXISTENT MEMORY?                 ; MG001
        BNE     $CRCMP          ;;;YES IF NE HALT                       ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ;**-14
        .ENDC


        .IF EQ  C$$CDA-3

PBNH=   0                       ;BLOCK NUMBER IGNORED FOR TM11
PBNL=   0                       ;

        SWAB    R3              ;;;POSITION UNIT SELECT BITS
        BIS     #60001,R3       ;;;MERGE DENSITY AND GO BITS
        MOV     R3,R2           ;;;COPY
        BIS     #16,R2          ;;;SET REWIND FUNCTION
        MOV     R2,(R0)         ;;;START THE REWIND
10$:    BIT     #100200,(R0)    ;;;ERROR OR READY?
        BMI     WERR            ;;;IF MI ERROR, RETRY                   ; MG001
        BEQ     10$             ;;;IF EQ NO                             ;**-1
        CLR     (R0)            ;;;CLEAR MTC REGISTER                   ; MG001
        CLR     4(R0)           ;;;START TO WRITE ALL OF MEMORY         ; MG001
        MOV     R3,R2           ;;;RETREIVE MTC BITS                    ;**-1
        BIS     #4,R2           ;;;SET WRITE DATA FUNCTION
        BIC     #1,R2           ;;;CLEAR GO BIT                         ; MG001
        MOV     R2,(R0)         ;;;START THE WRITE                      ;**-1
30$:    MOV     #-500,R1        ;;;WAIT FOR TAPE TO SETTLE DOWN         ;**-7
35$:    DEC     R1              ;;;WAIT
        BNE     35$             ;;;IF NE LOOP
        MOV     #-512.,2(R0)    ;;;SET 512. BYTE RECORDS
        BIS     #1,(R0)         ;;;START THE WRITE
40$:    BIT     #100200,(R0)    ;;;ERROR OR READY?
        BEQ     40$             ;;;IF EQ NO
        BPL     30$             ;;;IF PL WRITE FINISHED
        TSTB    -2(R0)          ;;;NON-EXISTANT MEMORY?
        BPL     WERR            ;;;IF PL NO, RETRY                      ;MG001
        MOV     R3,R2           ;;;RETREIVE MTC BITS                    ;**-1
        BIS     #10000,R2       ;;;SET CLEAR FUNCTION
        MOV     R2,(R0)         ;;;LOAD FUNCTION
50$:    TSTB    (R0)            ;;;READY?
        BPL     50$             ;;;IF PL NO
        BIS     #6,R3           ;;;SET WRITE EOF FUNCTION
        MOV     R3,(R0)         ;;;DO THE WRITE EOF
60$:    TSTB    (R0)            ;;;READY?
        BPL     60$             ;;;IF PL NO
        CLR     (R0)            ;;;CLEAR MTC REGISTER
        BR      $CRCMP          ;;;SUCCESSFUL COMPLETION                ; MG001

        .ENDC


        .IF EQ  C$$CDA-4

PBNH=   0                       ;BLOCK NUMBER IGNORED FOR TJU16
PBNL=   0                       ;

        BIS     (PC)+,R3        ;;;SET MODE AND DENSITY
$TDNSY: .WORD   1300            ;;;DEFAULT TO 1800 BPI, NORMAL MODE     ;MG001
        BIS     #40,10(R0)      ;;;RESET CONTROLLER                     ;**-1
10$:    TSTB    12(R0)          ;;;IS THE TAPE DRIVE READY?
        BPL     10$             ;;;IF PL NO
        MOV     R3,32(R0)       ;;;SET FORMAT BITS
        MOV     #7,(R0)         ;;;START THE TAPE REWINDING
        MOV     #40000,R1       ;;;PAUSE                                ;MG001
15$:    DEC     R1              ;;;                                     ;MG001
        BNE     15$             ;;;                                     ;MG001
20$:    BIT     #20000,12(R0)   ;;;POSITIONING STILL IN PROGRESS?
        BNE     20$             ;;;IF NE YES
        TSTB    12(R0)          ;;;DRIVE READY?
        BPL     20$             ;;;IF PL NO
        MOV     #60,(R0)        ;;;LOAD THE WRITE FUNCTION              ; MG001
        CLR     4(R0)           ;;;SET TO WRITE ALL OF MEMORY           ;**-8
40$:    MOV     #-256.,2(R0)    ;;;SET WORD COUNT
        MOV     #-512.,6(R0)    ;;;SET FRAME COUNT
        BIS     #1,(R0)         ;;;START TO WRITE ALL OF MEMORY
50$:    TSTB    12(R0)          ;;;DRIVE READY?
        BPL     50$             ;;;IF PL NO
        BIT     #40000,(R0)     ;;;TRANSFER ERRORS?
        BEQ     40$             ;;;IF EQ NO
        BIT     #4000,10(R0)    ;;;NON-EXISTANT MEMORY?
        BEQ     DUMP            ;;;IF EQ NO                             ; MG001
        BIS     #40,10(R0)      ;;;RESET CONTROLLER                     ;**-1
60$:    TSTB    12(R0)          ;;;DRIVE READY?
        BPL     60$             ;;;IF PL NO
        MOV     R3,32(R0)       ;;;RESET FORMAT BITS
        MOV     #27,(R0)        ;;;WRITE EOF ON TAPE
70$:    TSTB    12(R0)          ;;;IS DRIVE READY?
        BPL     70$             ;;;IF PL NO
        CLR     (R0)            ;;;CLEAR CONTROLLER REGISTER
        BR      $CRCMP          ;;;SUCCESSFUL COMPLETION                ; MG001

        .ENDC

        .IF EQ  C$$CDA-5                                                ; MG001
                                                                        ; MG001
PBNH=   0                       ;;;RP04,RM02,RM04 DEFAULT CYL. ADD.     ; MG001
PBNL=   1                       ;;;DEFAULT TRACK AND SECTOR ADD.        ; MG001
                                                                        ; MG001
        CALL    CKSUM           ;;;CHECK DISK ADDRESS AGAINST CHECKSUM  ; MG001
        ADD     #10,R0          ;;;POINT TO RCS2                        ; MG001
        MOV     #40,(R0)        ;;;CLEAR CONTROLLER                     ; MG001
        BIS     R3,(R0)         ;;;SELECT UNIT                          ; MG001
        MOV     #23,-10(R0)     ;;;DO A PACK ACKNOWLEDGE                ; MG001
        MOV     $CRSBN,24(R0)   ;;;SELECT CYLINDER                      ; MG001
        MOV     $CRSBN+2,-(R0)  ;;;SET SECTOR AND TRACK                 ; MG001
        CLR     -(R0)           ;;;ZERO BUFFER ADDRESS                  ; MG001
        MOV     #14000,26(R0)   ;;;SET 16 BIT FORMAT                    ; MG001
        CMP     -(R0),-(R0)     ;;;POINT TO CSR                         ; MG001
10$:    CLR     2(R0)           ;;;WORD COUNT =64K                      ; MG001
        BIC     #77,(R0)        ;;;CLEAR FUNCTION CODE                  ; MG001
        BIS     #61,(R0)        ;;;EXECUTE A WRITE                      ; MG001
20$:    BIT     #100200,(R0)    ;;;READY OR ERR?                        ; MG001
        BEQ     20$             ;;;IF EQ NEITHER                        ; MG001
        BIT     #40000,(R0)     ;;;TRANSFER ERROR?                      ; MG001
        BEQ     10$             ;;;IF EQ, NO                            ; MG001
        BIT     #4000,10(R0)    ;;;NON-EXISTENT MEMORY ERROR?           ; MG001
        BNE     $CRCMP          ;;;IF NE YES, ELSE I/O ERROR            ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF EQ  C$$CDA-6                                                ; MG001
                                                                        ; MG001
PBNH=   0                       ;;;RK06 DEFAULT CYLINDER ADDRESS        ; MG001
PBNL=   1                       ;;;DEFAULT SECTOR AND TRACK ADDRESS     ; MG001
                                                                        ; MG001
        CALL    CKSUM           ;;;CHECK BLOCK NUMBER AGAINST CHECKSUM  ; MG001
        CLR     R2              ;;;ASSUME DRIVE IS AN RK06              ; MG001
        MOV     #40,10(R0)      ;;;CLEAR THE RK611 SUBSYSTEM            ; MG001
        MOV     R3,10(R0)       ;;;SELECT THE UNIT                      ; MG001
        MOV     #1,(R0)         ;;;SELECT THE DRIVE FUNCTION            ; MG001
10$:    TSTB    (R0)            ;;;READY?                               ; MG001
        BPL     10$             ;;;IF PL NO                             ; MG001
        BIT     #400,12(R0)     ;;;IF THIS AN RK07?                     ; MG001
        BEQ     20$             ;;;IF EQ NO, IT'S AN RK06               ; MG001
        BIS     #2000,R2        ;;;SET RK07 BIT                         ; MG001
20$:    MOV     #40,10(R0)      ;;;CLEAR THE RK611 SUBSYSTEM            ; MG001
        MOV     R3,10(R0)       ;;;SELECT THE UNIT                      ; MG001
        MOV     R2,R1           ;;;COPY DRIVE TYPE BIT                  ; MG001
        BIS     #3,R1           ;;;GET PACK ACK FUNCTION CODE           ; MG001
        MOV     R1,(R0)         ;;;DO A PACK ACKNOWLEDGE                ; MG001
30$:    TSTB    (R0)            ;;;READY?                               ; MG001
        BPL     30$             ;;;IF PL NO                             ; MG001
        MOV     12(R0),R1       ;;;GET DRIVE STATUS                     ; MG001
        COM     R1              ;;;COMPLEMENT                           ; MG001
        BIT     #100301,R1      ;;;DRIVE READY TO GO?                   ; MG001
        BNE     WERR            ;;;IF NE NO, TRY AGAIN                  ; MG001
        MOV     $CRSBN,20(R0)   ;;;LOAD CYLINDER                        ; MG001
        MOV     $CRSBN+2,6(R0)  ;;;LOAD SECTOR/TRACK                    ; MG001
        BIS     #23,R2          ;;;SET WRITE FUNCTION                   ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF DF  M$$EXT                                                  ; MG001
                                                                        ; MG001
        CLR     UBMPR           ;;;INITIALIZE FIRST UNIBUS MAPPING REG. ; MG001
        CLR     UBMPR+2         ;;;                                     ; MG001
        CLR     KISAR0          ;;;                                     ; MG001
        BIS     #60,SR3         ;;;ENABLE 22 BIT MAPPING AND UNIBUS MAP ; MG001
        BIS     #1,SR0          ;;;MAKE SURE MEM MGMT IS ON             ; MG001
50$:    MOV     #-10000,2(R0)   ;;;SET TO WRITE 4K WORDS                ; MG001
        CLR     4(R0)           ;;;START AT BEGINNING OF MAPPED MEMORY  ; MG001
                                                                        ; MG001
        .IFF                                                            ; MG001
                                                                        ; MG001
        CLR     4(R0)           ;;;START AT BEGINNING OF MEMORY         ; MG001
50$:    CLR     2(R0)           ;;;SET TO WRITE 65K WORDS               ; MG001
                                                                        ; MG001
        .IFTF                                                           ; MG001
                                                                        ; MG001
        BIS     R2,(R0)         ;;;START WRITING                        ; MG001
60$:    BIT     #100200,(R0)    ;;;READY OR ERROR?                      ; MG001
        BEQ     60$             ;;;IF EQ NEITHER                        ; MG001
                                                                        ; MG001
        .IFT                                                            ; MG001
                                                                        ; MG001
        ADD     #20000,UBMPR    ;;;POINT TO NEXT 4K OF MEMORY           ; MG001
        ADC     UBMPR+2         ;;;                                     ; MG001
        TST     (R0)            ;;;ERROR?                               ; MG001
                                                                        ; MG001
        .IFTF                                                           ; MG001
                                                                        ; MG001
        BPL     50$             ;;;IF PL NO ERROR, CONTINUE TRANSFER    ; MG001
        BIT     #4000,10(R0)    ;;;NON-EXISTENT MEMORY?                 ; MG001
        BNE     $CRCMP          ;;;IF NE, YES                           ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF EQ  C$$CDA-7                                                ; MG001
                                                                        ; MG001
PBNH=   0                       ;;;NOT USED                             ; MG001
PBNL=   2                       ;;;DEFAULT CYLINDER,TRACK AND SECTOR -RL; MG001
                                                                        ; MG001
        CALL CKSUM                                                      ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF DF  M$$EXT                                                  ; MG001
                                                                        ; MG001
        CLR     UBMPR           ;;;INITIALIZE FIRST UNIBUS MAPPING REGS.; MG001
        CLR     UBMPR+2         ;;;                                     ; MG001
        CLR     KISAR0          ;;;                                     ; MG001
        BIS     #60,SR3         ;;;ENABLE 22 BIT MAPPING AND UNIBUS MAP ; MG001
        BIS     #1,SR0          ;;;MAKE SURE MEM MGMT IS ON             ; MG001
        MOV     #4*4,R5         ;;;STORE BLOCKS PER 4K WORDS            ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
        SWAB    R3              ;;;MOVE UNIT NUMBER TO HIGH BYTE        ; MG001
        BIS     #4,R3           ;;;SET GET STATUS FUNCTION              ; MG001
        MOV     #13,4(R0)       ;;;SET CODES TO CLEAR DRIVER            ; MG001
        MOV     R3,(R0)         ;;;EXECUTE THE FUNCTION                 ; MG001
10$:    BIT     #100200,(R0)    ;;;READY OR ERROR?                      ; MG001
        BEQ     10$             ;;;IF EQ NEITHER                        ; MG001
        BMI     WERR            ;;;IF MINUS I/O ERROR                   ; MG001
        ADD     #4,R3           ;;;CONVERT TO READ HEADER FUNCTION      ; MG001
        MOV     $CRSBN+2,R4     ;;;SAVE STARTING DISK ADDRESS           ; MG001
        CLR     2(R0)           ;;;SET BUFFER ADDRESS FOR FIRST WRITE   ; MG001
15$:    MOV     R3,(R0)         ;;;READ HEADER                          ; MG001
20$:    BIT     #100200,(R0)    ;;;DONE OR ERROR?                       ; MG001
        BEQ     20$             ;;;IF EQ NEITHER                        ; MG001
        BMI     WERR            ;;;IF MINUS I/O ERROR                   ; MG001
        MOV     6(R0),R1        ;;;GET HEADER INFORMATION               ; MG001
        MOV     R4,R2           ;;;COPY DESIRED DISK ADDRESS            ; MG001
        MOV     R1,-(SP)        ;;;STORE VALUE                          ; MG001
        MOV     R2,-(SP)        ;;; FORM A DIFF. XOR                    ; MG001
        BIC     R1,R2           ;;;                                     ; MG001
        BIC     (SP)+,R1        ;;;                                     ; MG001
        BIS     R1,R2           ;;;                                     ; MG001
        MOV     (SP)+,R1        ;;;RESTORE R1                           ; MG001
        BIC     #77,R2          ;;;IGNORE SECTOR BITS                   ; MG001
        BEQ     40$             ;;;IF EQ NO SEEK REQUIRED               ; MG001
        MOV     R4,R2           ;;;COPY DESIRED DISK ADDRESS            ; MG001
        BIC     #177,R1         ;;;ISOLATE CYLINDER ADDRESS             ; MG001
        BIC     #177,R2         ;;;ISOLATE CYLINDER ADDRESS DESIRED     ; MG001
        SUB     R2,R1           ;;;SUBTRACT DESIRED FROM ACTUAL         ; MG001
        BHIS    25$             ;;;IF HIS ACTUAL >=DESIRED              ; MG001
        NEG     R1              ;;;ACTUAL < DESIRED, MAKE POS. DIFF.    ; MG001
        BIS     #4,R1           ;;;SET SIGN FOR MOVE TO CENTER OF DISK  ; MG001
25$:    INC     R1              ;;;SET MARKER BIT                       ; MG001
        BIT     #100,R4         ;;;WHICH HEAD DO WE WANT                ; MG001
        BEQ     30$             ;;;IF EQ IT'S HEAD 0                    ; MG001
        BIS     #20,R1          ;;;SET HEAD 1                           ; MG001
30$:    MOV     R1,4(R0)        ;;;LOAD DIFFERENCE WORD                 ; MG001
        SUB     #2,R3           ;;;CONVERT TO SEEK FUNCTION             ; MG001
        MOV     R3,(R0)         ;;;START THE SEEK                       ; MG001
35$:    BIT     #100200,(R0)    ;;;READY OR ERROR?                      ; MG001
        BEQ     35$             ;;;IF EQ NEITHER                        ; MG001
        BMI     WERR            ;;;IF MI I/O ERROR                      ; MG001
40$:    MOV     R4,4(R0)        ;;;LOAD DESIRED DISK ADDRESS            ; MG001
        MOV     #-256.,6(R0)    ;;;LOAD ONE BLOCK WORD COUNT            ; MG001
        BIC     #17,R3          ;;;REMOVE FUNCTION BITS                 ; MG001
        BIS     #12,R3          ;;;SET WRITE FUNCTION                   ; MG001
        MOV     R3,(R0)         ;;;START THE WRITE                      ; MG001
45$:    BIT     #100200,(R0)    ;;;ERROR OR READY?                      ; MG001
        BEQ     45$             ;;;IF EQ NEITHER                        ; MG001
        BMI     70$             ;;;IF MINUS, ERROR                      ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF DF  M$$EXT                                                  ; MG001
                                                                        ; MG001
        DEC     R5              ;;;DECREMENT BLOCK COUNT                ; MG001
        BNE     60$             ;;;IF NE USE SAME UMR                   ; MG001
        ADD     #20000,UBMPR    ;;;POINT TO NEXT 4K OF MEMORY           ; MG001
        ADC     UBMPR+2         ;;;DOUBLE WORD ADD                      ; MG001
        MOV     #4*4,R5         ;;;RESET TO #BLOCKS PER 4K              ; MG001
        CLR     2(R0)           ;;;RESET BUS ADDRESS                    ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
60$:    MOV     (R0),R3         ;;;GET CSR                              ; MG001
        BIC     #^C<1460>,R3    ;;;ISOLATE UNIT AND EX MEM BITS         ; MG001
        ADD     #2,R4           ;;;MOVE TO NEXT SECTOR                  ; MG001
        MOV     R4,R1           ;;;COPY DISK ADDRESS                    ; MG001
        BIC     #^C<77>,R1      ;;;GET THE SECTOR BITS                  ; MG001
        CMP     #50,R1          ;;;OVERRUN COMING?                      ; MG001
        BNE     40$             ;;;IF NE, NO                            ; MG001
        BIS     #77,R4          ;;;INCREMENT TRACK...                   ; MG001
        INC     R4              ;;;...SET SECTOR TO 0                   ; MG001
        BIS     #10,R3          ;;;SET READ HEADER FUNCTION             ; MG001
        BR      15$             ;;;AND GO AGAIN                         ; MG001
70$:    BIT     #20000,(R0)     ;;;NON-EXISTENT MEMORY?                 ; MG001
        BNE     $CRCMP          ;;;IF NE YES, SUCCESS                   ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF EQ  C$$CDA-10                                               ; MG001
                                                                        ; MG001
PBNH=   0                       ;;;NOT USED BY TU-58 TAPE CARTRIDGE     ; MG001
PBNL=   1                       ;;;STARTING BLOCK NUMBER                ; MG001
                                                                        ; MG001
;THIS CODE INTERFACES WITH A TU-58 VIA A DL-11 ASYNCHRONOUS INTERFACE   ; MG001
                                                                        ; MG001
        CALL    CKSUM                                                   ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF NDF M$$MGE                                                  ; MG001
                                                                        ; MG001
        CLR     R1              ;;;POINT TO BEGINNING OF MEM.           ; MG001
                                                                        ; MG001
        .IFF                                                            ; MG001
                                                                        ; MG001
        CLR     KISAR6          ;;;CLEAR MAPPING REG.                   ; MG001
        CLR     KISAR0          ;;;                                     ; MG001
        MOV     #140000,R1      ;;;POINT TO BEGINNING OF MEM.           ; MG001
                                ;;;VIA MAPPING REG. 6                   ; MG001
        BIS     #1,SR0          ;;;ENSURE MAPPING TURNED ON             ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
;INITIALIZE TU-58                                                       ; MG001
                                                                        ; MG001
        MOV     R3,-(SP)        ;;;SAVE UNIT NUMBER                     ; MG001
        BIS     #1,4(R0)        ;;;SEND BREAK                           ; MG001
        MOV     #6,R2           ;;;SET TO SEND 6 NULLS                  ; MG001
5$:     CLRB    6(R0)           ;;;SEND A NULL                          ; MG001
        CALL    XWAIT                                                   ; MG001
        DEC     R2              ;;;6 NULLS SENT?                        ; MG001
        BNE     5$              ;;;IF NE, NO                            ; MG001
        CLR     4(R0)           ;;;CLEAR BREAK                          ; MG001
        TST     2(R0)           ;;;DUMP REC. BUFFER                     ; MG001
        MOVB    #4,6(R0)        ;;;SEND INIT.                           ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    #4,6(R0)        ;;;SEND ANOTHER INIT.                   ; MG001
        CALL    XWAIT                                                   ; MG001
10$:    TSTB    (R0)            ;;;RECEIVED A BYTE?                     ; MG001
        BPL     10$             ;;;IF PL NO                             ; MG001
        CMPB    #20,2(R0)       ;;;RECEIVED A CONTINUE?                 ; MG001
        BEQ     12$             ;;;IF EQ, YES                           ; MG001
        JMP     DEND1           ;;;ELSE I/O ERROR                       ; MG001
                                                                        ; MG001
;SEND COMMAND PACKET                                                    ; MG001
                                                                        ; MG001
12$:    MOV     $CRSBN+2,R2     ;;;SAVE STARTING TU-58 ADDRESS          ; MG001
15$:    CALL    XWAIT                                                   ; MG001
        MOVB    #2,6(R0)        ;;;SEND COMMAND FLAG                    ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    #12,6(R0)       ;;;SEND PACKET BYTE COUNT               ; MG001
        MOV     #5002,R4        ;;;CREATE 1ST CHECKSUM WD.              ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    #3,6(R0)        ;;;SEND WRITE OP CODE                   ; MG001
        CALL    XWAIT                                                   ; MG001
        CLRB    6(R0)                                                   ; MG001
        MOV     #3,R5           ;;;CREATE 2ND CHECKSUM WD.              ; MG001
        CALL    CKSM                                                    ; MG001
        MOVB    (SP),6(R0)      ;;;SEND UNIT NUMBER                     ; MG001
        MOV     #4,R3           ;;;SET COUNTER TO SEND 3 CLRS           ; MG001
20$:    CALL    XWAIT                                                   ; MG001
        CLR     6(R0)                                                   ; MG001
        DEC     R3                                                      ; MG001
        BNE     20$                                                     ; MG001
        MOV     (SP),R5         ;;;CHECKSUM                             ; MG001
        CALL    CKSM                                                    ; MG001
        MOVB    #40,6(R0)       ;;;4K WORD TRANSFER                     ; MG001
        MOV     #20000,R5       ;;;CREATE CHECKSUM WD.                  ; MG001
        CALL    CKSM                                                    ; MG001
        MOV     R2,R3           ;;;COPY TU-58 BLOCK NO.                 ; MG001
        MOVB    R3,6(R0)        ;;;SEND LOW ORDER BLOCK NO.             ; MG001
        SWAB    R3              ;;;SWAP BYTES                           ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    R3,6(R0)        ;;;SEND HIGH ORDER BLOCK NO.            ; MG001
        MOV     R2,R5           ;;;CHECKSUM                             ; MG001
        CALL    CKSM                                                    ; MG001
        MOVB    R4,6(R0)        ;;;SEND LOW ORDER BYTE OF CKSM          ; MG001
        SWAB    R4              ;;;SWAP BYTES                           ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    R4,6(R0)        ;;;SEND HIGH ORDER CKSM BYTE            ; MG001
                                                                        ; MG001
; SEND WRITE DATA TO TU-58                                              ; MG001
                                                                        ; MG001
        MOV     #100,-(SP)      ;;;STORE PACKETS/4K WORDS               ; MG001
30$:    BIT     #200,(R0)       ;;;RECEIVED A CHARACTER?                ; MG001
        BEQ     30$             ;;;IF EQ NO                             ; MG001
        CMPB    #20,2(R0)       ;;;REC. A CONTINUE?                     ; MG001
        BNE     DEND            ;;;IF NE NO                             ; MG001
        MOV     #64.,R3         ;;;STORE WORDS/PACKET                   ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    #1,6(R0)        ;;;SEND DATA PACKET COMMAND FLAG        ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    #200,6(R0)      ;;;SEND PACKET BYTE COUNT               ; MG001
        MOV     #100001,R4      ;;;CREATE FIRST CHECKSUM WORD           ; MG001
        CALL    XWAIT                                                   ; MG001
40$:    CLC                     ;;;CLEAR CARRY                          ; MG001
        MOV     (R1),R5         ;;;CREATE CHECKSUM                      ; MG001
                                ;;;IF CARRY SET WE TRAPPED              ; MG001
                                ;;;THROUGH NON-EXISTENT MEM. TRAP       ; MG001
        BCC     45$             ;;;IF CC ,MORE TO TRANSFER              ; MG001
        TST     (SP)+           ;;;RESTORE STACK                        ; MG001
        TST     (SP)+                                                   ; MG001
        JMP     $CRCMP          ;;;COMPLETE, SUCCESS                    ; MG001
45$:    MOVB    (R1)+,6(R0)     ;;;WRITE FIRST BYTE                     ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    (R1)+,6(R0)     ;;;SEND SECOND BYTE                     ; MG001
        CALL    CKSM                                                    ; MG001
        DEC     R3              ;;;DECREMENT PACKET COUNT               ; MG001
        BNE     40$             ;;;IF NE TRANSFER ANOTHER 2 BYTES       ; MG001
        MOVB    R4,6(R0)        ;;;SEND LOW ORDER CHECKSUM              ; MG001
        SWAB    R4              ;;;SWAP BYTES                           ; MG001
        CALL    XWAIT                                                   ; MG001
        MOVB    R4,6(R0)        ;;;SEND HIGH ORDER CHECKSUM             ; MG001
        DEC     (SP)            ;;;DECREMENT PACKET COUNT               ; MG001
        BNE     30$             ;;;IF NE SEND ANOTHER PACKET            ; MG001
        TST     (SP)+           ;;;ELSE RESTORE STACK                   ; MG001
                                                                        ; MG001
;CLEAR OUT END PACKET MESSAGE FROM TU-58                                ; MG001
                                                                        ; MG001
        MOV     #14.,R3         ;;;SET DUMP REC. BYTE COUNTER           ; MG001
50$:    BIT     #200,(R0)       ;;;RECEIVE END PACKET CHAR.             ; MG001
        BEQ     50$             ;;;IF EQ NO                             ; MG001
        CLR     2(R0)           ;;;DUMP CHAR.                           ; MG001
        DEC     R3              ;;;DECREMENT COUNT                      ; MG001
        BNE     50$             ;;;IF NE DUMP AGAIN                     ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF DF  M$$MGE                                                  ; MG001
                                                                        ; MG001
        MOV     #140000,R1      ;;;RESET CURRENT MEMORY ADDRESS         ; MG001
        ADD     #200,KISAR6     ;;;MAP TO NEXT 4K OF MEM.               ; MG001
                                                                        ; MG001
        .IFTF                                                           ; MG001
                                                                        ; MG001
        ADD     #16.,R2         ;;;INCREMENT TU-58 STARTING BLOCK ADD.  ; MG001
        JMP     15$             ;;;REPEAT 4K TRANSFER                   ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
CKSM:   ADD     R5,R4           ;;;ADD 2ND WORD TO FIRST                ; MG001
        ADC     R4              ;;;ADD CARRY -END AROUND CARRY CHECKSUM ; MG001
XWAIT:  BIT     #200,4(R0)      ;;;DL-11 TRANSMIT READY?                ; MG001
        BEQ     XWAIT           ;;;IF EQ NO                             ; MG001
        RETURN                                                          ; MG001
DEND:   TST     (SP)+           ;;;RESTORE STACK                        ; MG001
DEND1:  TST     (SP)+           ;;;RESTORE STACK                        ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF DF  M$$MGE                                                  ; MG001
                                                                        ; MG001
        CMP     R2,#497.        ;;;HAVE WE TRANSFERED ENOUGH DATA       ; MG001
                                ;;;TO PUT US AT THE END OF THE TAPE     ; MG001
        BEQ     $CRCMP          ;;;IF EQ YES, SUCCESSFUL TRANSFER       ; MG001
                                ;;;OF ALL MEMORY THAT WILL FIT ON TAPE  ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF EQ  C$$CDA-11                                               ; MG001
                                                                        ; MG001
PBNH=   0                       ;;;RP04,RM02,RM04 DEFAULT CYL. ADD.     ; MG001
PBNL=   1                       ;;;DEFAULT TRACK AND SECTOR ADD.        ; MG001
                                                                        ; MG001
        CALL    CKSUM           ;;;CHECK DISK ADDRESS AGAINST CHECKSUM  ; MG001
        ADD     #10,R0          ;;;POINT TO RCS2                        ; MG001
        MOV     #40,(R0)        ;;;CLEAR CONTROLLER                     ; MG001
        BIS     R3,(R0)         ;;;SELECT UNIT                          ; MG001
        MOV     #23,-10(R0)     ;;;DO A PACK ACKNOWLEDGE                ; MG001
        MOV     $CRSBN,24(R0)   ;;;SELECT CYLINDER                      ; MG001
        MOV     $CRSBN+2,-(R0)  ;;;SET SECTOR AND TRACK                 ; MG001
        CLR     -(R0)           ;;;ZERO BUFFER ADDRESS                  ; MG001
        MOV     #14000,26(R0)   ;;;SET 16 BIT FORMAT                    ; MG001
        CMP     -(R0),-(R0)     ;;;POINT TO CSR                         ; MG001
10$:    CLR     2(R0)           ;;;WORD COUNT =64K                      ; MG001
        BIC     #77,(R0)        ;;;CLEAR FUNCTION CODE                  ; MG001
        BIS     #61,(R0)        ;;;EXECUTE A WRITE                      ; MG001
20$:    BIT     #100200,(R0)    ;;;READY OR ERR?                        ; MG001
        BEQ     20$             ;;;IF EQ NEITHER                        ; MG001
        BIT     #40000,(R0)     ;;;TRANSFER ERROR?                      ; MG001
        BEQ     10$             ;;;IF EQ, NO                            ; MG001
        BIT     #4000,10(R0)    ;;;NON-EXISTENT MEMORY ERROR?           ; MG001
        BNE     $CRCMP          ;;;IF NE YES, ELSE I/O ERROR            ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .ENDC                                                           ; MG001
                                                                        ; MG001
                                                                        ; MG001
        .IF EQ  C$$CDA-12                                               ; AP002
                                                                        ; AP002
PBNH=   0                                                               ; AP002
PBNL=   0                                                               ; AP002
                                                                        ; AP002
                                                                        ; AP002
        BR      100$                                                    ; AP002
                                                                        ; AP002
1$:     .BLKW   5.              ;;;THE COMMAND BUFFER PLUS ONE.         ; AP002
                                                                        ; AP002
2$:                             ;;;THE CHARACTERISTICS DATA.            ; AP002
        .WORD   3$              ;;; LSW OF MESSAGE BUFFER ADDRESS.      ; AP002
        .WORD   0               ;;; MSW OF     "     "      "           ; AP002
        .WORD   14.             ;;; THE SIZE OF THE MESSAGE BUFFER.     ; AP002
        .WORD   0               ;;; THE FLAG WORD.                      ; AP002
                                                                        ; AP002
3$:     .BLKW   3               ;;;THE MESSAGE BUFFER.                  ; AP002
4$:     .BLKW   4               ;;; XSTAT0 WITHIN MESSAGE BUFFER.       ; AP002
                                                                        ; AP002
100$:   MOV     #1$+2,R4        ;;; WE NOW COMPUTE ADDRESS OF COMMAND   ; AP002
        BIC     #3,R4           ;;; BUFFER. (NEEDS DOUBLE WORD BOUNDARY); AP002
        MOV     R4,R5           ;;;MAKE ANOTHER COPY OF IT.             ; AP002
        MOV     #100004,(R5)+   ;;;PUT IN HEADER FOR "WRITE CHARACTERIST; AP002
        MOV     #2$,(R5)+       ;;;PUT IN ADDRESS OF C DATA.            ; AP002
        CLR     (R5)+           ;;; # HIGH 2 OF 18 BIT ADDRESS ASSUMED 0; AP002
        MOV     #8.,(R5)        ;;;SIZE OF C DATA.                      ; AP002
        MOV     R0,R1           ;;;COPY CSR POINTER TO CONVERT IT TO    ; AP002
        TST     -(R1)           ;;; COMMAND REGISTER ADDRESS.           ; AP002
        CLR     R5              ;;;CLEAR RETRY COUNT.                   ; AP002
        CALL    200$            ;;;ISSUE COMMAND, WAIT FOR SSR, TREAT ER; AP002
        MOV     #142010,(R4)    ;;; MAKE A REWIND COMMAND.              ; AP002
        CALL    200$            ;;;ISSUE, WAIT, TREAT ERRORS.           ; AP002
        MOV     R4,R5           ;;; MAKE COPY OF COMMAND POINTER.       ; AP002
        MOV     #100005,(R5)+   ;;; MAKE A WRITE COMMAND WITH HEADER    ; AP002
        CLR     (R5)+           ;;;  AND LOW ORDER 16 BIT OF ADDRESS    ; AP002
        CLR     (R5)+           ;;;  WITH HIGH 2       FOR DATA.        ; AP002
        MOV     #512.,(R5)+     ;;;  INCLUDE THE SIZE OF DATA RECORD.   ; AP002
                                ;;;(R5 NOT EQUAL R4 AS FLAG !!)         ; AP002
                                                                        ; AP002
                                                                        ; AP002
        .IF DF  M$$EXT                                                  ; AP002
                                                                        ; AP002
        CLR     UBMPR           ;;;INITIALIZE FIRST UNIBUS MAP REG.     ; AP002
        CLR     UBMPR+2         ;;;                                     ; AP002
        ;CLR    KISAR0          ;;;                                     ; AP002
        BIS     #60,SR3         ;;;ENABLE 22 BIT MAPPING AND UNIBUS MAP.; AP002
        BIS     #1,SR0          ;;;MAKE SURE MEMORY MANAGEMENT ENABLED. ; AP002
        MOV     #480.,R3        ;;; NOTE MAX NUMBER OF 8KB BLOCKS.      ; AP002
        MOV     #16.,R2         ;;; NOTE NUMBER OF RECORDS IN BLOCK.    ; AP002
                                                                        ; AP002
        .IFF                                                            ; AP002
                                                                        ; AP002
        MOV     #496.,R2        ;;; NOTE MAX NUMBER OF RECORDS.         ; AP002
                                                                        ; AP002
        .IFTF                                                           ; AP002
                                                                        ; AP002
50$:    CALL    200$            ;;;WRITE, WAIT, TEST & TREAT ERRORS.    ; AP002
        ADD     #512.,2(R4)     ;;;BUMP START ADDRESS OF DATA.          ; AP002
        ADC     4(R4)           ;;; (DOUBLE PRECISION ADDRESS.)         ; AP002
        DEC     R2              ;;;LIMIT CHECK ON RECORDS COUNT ?       ; AP002
        BNE     50$             ;;; LOOP TILL LIMIT (OR ERR IN 200$)    ; AP002
                                                                        ; AP002
                                                                        ; AP002
        .IFT                                                            ; AP002
                                                                        ; AP002
        ADD     #20000,UBMPR    ;;;BUMP START OF BLOCK ADDRESS.         ; AP002
        ADC     UMBPR+2         ;;;  (DOUBLE PRECISION ADDRESS.)        ; AP002
        CLR     2(R4)           ;;;RESET DATA POINTER WITHIN BLOCK.     ; AP002
        DEC     R3              ;;;LIMIT CHECK ON BLOCK COUNT ?         ; AP002
        BNE     50$             ;;; LOOP TILL LIMIT (OR ERR IN 200$)    ; AP002
                                                                        ; AP002
        .ENDC                                                           ; AP002
        BR      300$            ;;;WRITE TAPE MARK & EXIT.              ; AP002
                                                                        ; AP002
                                                                        ; AP002
150$:   BIS     #1000,(R4)      ;;;RETRY THE COMMAND.                   ; AP002
175$:   DEC     R5              ;;;TRIED ENOUGH ?                       ; AP002
        BMI     260$            ;;;YES=> QUIT; ELSE ...                 ; AP002
        TST     (SP)+           ;;; REMOVE OLD STATUS AND               ; AP002
200$:   MOV     R4,(R1)         ;;;SUBMIT  POINTER TO COMMAND BUFFER.   ; AP002
225$:   TSTB    (R0)            ;;;TEST FOR SSR (SUBSYSTEM READY) ?     ; AP002
        BPL     225$            ;;;NO=> LOOP; ELSE ....                 ; AP002
        MOV     (R0),-(SP)      ;;;TEST FOR "SPECIAL CONDITION" ?       ; AP002
        BMI     250$            ;;;PROBLEM=> GO CHECK OUT; ELSE ...     ; AP002
        RETURN                  ;;;  GO ON WITH THE DUMP.               ; AP002
                                                                        ; AP002
250$:   BIT     #1,4$           ;;;EOT SEEN ON THIS OPERATION ?         ; AP002
        BNE     275$            ;;; YES=> FINISH UP; ELSE ...           ; AP002
        BIT     #4000,(R0)      ;;;SC = NXM (NON-EXISTANT MEMORY) ?     ; AP002
        BNE     275$            ;;; YES=> NORMAL END; ELSE              ; AP002
        BIC     #^C<16>,(SP)    ;;; ISOLATE TERMINATION CODE.           ; AP002
        CMP     #12,(SP)        ;;;IMMEDIATE RETRY POSSIBLE ?           ; AP002
        BEQ     175$            ;;;YES=> TRY IT; ELSE ....              ; AP002
        CMP     #10,(SP)        ;;; REPOSITION RETRY POSSIBLE ?         ; AP002
        BEQ     150$            ;;;YES=> DO IT; ELSE QUIT.              ; AP002
260$:   CMP     (SP)+,(SP)+     ;;; POP BOTH STATUS & RETURN ADDR.      ; AP002
        BR      WERR            ;;; QUIT.                               ; AP002
                                                                        ; AP002
275$:   CMP     (SP)+,(SP)+     ;;;CLEAN UP STACK &                     ; AP002
        TST     R5              ;;; CHECK THE TRANSFER FLAG ?           ; AP002
        BEQ     WERR            ;;;NO=> NXM ON INIT=ERROR; ELSE         ; AP002
300$:   MOV     #100011,(R4)    ;;;SET COMMAND HEADER FOR TAPE MARK.    ; AP002
        MOV     R4,(R0)         ;;; WRITE TAPE MARK.                    ; AP002
350$:   TSTB    (R1)            ;;;SSR (SUBSYSTEM READY) ?              ; AP002
        BPL     350$            ;;; NO=> LOOP; ELSE                     ; AP002
        BR      $CRCMP          ;;; EXIT.                               ; AP002
                                                                        ; AP002
                                                                        ; AP002
        .ENDC                                                           ; AP002
                                                                        ; AP002
                                                                        ; AP002
WERR:   MOV     #IOERR,R1       ;;;INDICATE I/O ERROR                   ;MG001
        CALL    TYPE            ;;;TYPE OUT MESSAGE                     ;MG001
        JMP     AGAIN           ;;;WAIT FOR THE USER                    ;MG001
$CRCMP:                                                                 ;MG001
        .ENDC


        .IF DF P$$NIC                                                   ;MSH024
                                                                        ;**-1
        JMP     $PANIC          ;;;JUMP TO PANIC DUMP ROUTINE

        .ENDC                                                           ;MSH024

        .ENDC


;+
; IF B$$OOT IS DEFINED, RE-BOOT THE SYSTEM BY JUMPING TO THE
; BOOTSTRAP ROM ADDRESS SPECIFIED BY B$$OOT.  ELSE, RE-ISSUE
; THE CRASH MESSAGE IF THE USER WISHES ANOTHER DUMP.  IF NO
; CRASH DUMP WAS CONFIGURED, SIMPLY RE-BOOT OR HALT FOREVER.
;-

$BTSTP::                        ;;;RE-BOOT THE SYSTEM


        .IF DF  B$$OOT

        HALT                    ;;;WAIT FOR THE USER BEFORE BOOTING
        RESET                   ;;;RESET THE WORLD
        JMP     @#B$$OOT        ;RE-BOOT THE SYSTEM

        .IFF

        HALT                    ;;;WAIT FOR THE USER


        .IF DF  C$$RSH


        .IF DF  C$$CDA

        JMP     AGAIN           ;;;DO IT ALL OVER AGAIN

        .ENDC


        .IFF

        BR      .-2             ;;;LOOP FOREVER

        .ENDC


        .ENDC


        .END
        .TITLE  CRDRV
        .IDENT /06.02/
 
;
; COPYRIGHT (C) 1974, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 06.02
;
; D. N. CUTLER  3-MAR-74
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;
; MODIFIED BY:
;
;       E. L. BAATZ 9-30,SEP-77
;
;               EB081 -- ALLOW SYSGEN SPECIFIED INTERVAL BETWEEN DEVICE
;                       NOT READY MESSAGES AND REMOVE EXPLICIT PS REF
;
;       E. E. OUYANG 12-SEP-78
;
;               EO701 -- CODE FIX TO READ LAST CARD WHEN "STOP" BUTTON
;                       IS DEPRESSED OR WHEN HOPPER IS EMPTY
;
;       E. L. BAATZ 11-MAR-79
;
;               EB199 -- HANDLE TIMING ERROR (WAIT FOR ONLINE/OFFLINE/ONLINE
;                       TRANSITION DURING WHICH EFFECTED CARD SHOULD BE
;                       RETURNED TO INPUT HOPPER)
;
; CR11 CARD READER CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$,HWDDF$,PKTDF$,UCBDF$
        ABODF$                  ;DEFINE TASK ABORT CODES
        HWDDF$                  ;DEFINE HARDWARE  REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        UCBDF$                  ;DEFINE UCB OFFSETS

;
; EQUATED SYMBOLS
;
; CARD READER CONTROL BLOCK OFFSETS
;

STRBF=U.CNT+2                   ;STARTING ADDRESS OF DATA BUFFER
CURBF=U.CNT+4                   ;CURRENT ADDRESS IN DATA BUFFER
EOFCL=U.CNT+6                   ;NUMBER OF COLUMNS FOR VALID EOF
EOFCT=U.CNT+7                   ;NUMBER OF EOF PUNCHES ENCOUNTERED
CCOLC=U.CNT+10                  ;CURRENT COLUMN COUNTER
CCOL1=U.CNT+12                  ;CONTENTS OF CARD COLUMN ONE

;
; SPECIAL CARD PUNCH PATTERNS
;

CREOF=7417                      ;END OF FILE (12-11-0-1-6-7-8-9)
CR026=4242                      ;TRANSLATE 026 CODE (12-2-4-8)
CR029=5252                      ;TRANSLATE 029 CODE (12-0-2-4-6-8)

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   C$$R11          ;ADDRESS OF UNIT CONTROL BLOCK


        .IF GT  C$$R11-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC


;
; 029 TRANSLATION TABLE
;

TB029:  .BYTE   40              ;SPACE
        .BYTE   61              ;1
        .BYTE   62              ;2
        .BYTE   63              ;3
        .BYTE   64              ;4
        .BYTE   65              ;5
        .BYTE   66              ;6
        .BYTE   67              ;7
        .BYTE   70              ;8
        .BYTE   40              ;EMPTY
        .BYTE   72              ;:
        .BYTE   43              ;#
        .BYTE   100             ;@
        .BYTE   47              ;'
        .BYTE   75              ;=
        .BYTE   42              ;"
        .BYTE   71              ;9
        .BYTE   60              ;0
        .BYTE   57              ;/
        .BYTE   123             ;S
        .BYTE   124             ;T
        .BYTE   125             ;U
        .BYTE   126             ;V
        .BYTE   127             ;W
        .BYTE   130             ;X
        .BYTE   131             ;Y
        .BYTE   40              ;EMPTY
        .BYTE   134             ;\
        .BYTE   54              ;,
        .BYTE   45              ;%
        .BYTE   137             ;
        .BYTE   76              ;>
        .BYTE   77              ;?
        .BYTE   132             ;Z
        .BYTE   55              ;-
        .BYTE   112             ;J
        .BYTE   113             ;K
        .BYTE   114             ;L
        .BYTE   115             ;M
        .BYTE   116             ;N
        .BYTE   117             ;O
        .BYTE   120             ;P
        .BYTE   121             ;Q
        .BYTE   40              ;EMPTY
        .BYTE   135             ;]
        .BYTE   44              ;$
        .BYTE   52              ;*
        .BYTE   51              ;)
        .BYTE   73              ;;
        .BYTE   136             ;^
        .BYTE   122             ;R
        .BYTE   46              ;&
        .BYTE   101             ;A
        .BYTE   102             ;B
        .BYTE   103             ;C
        .BYTE   104             ;D
        .BYTE   105             ;E
        .BYTE   106             ;F
        .BYTE   107             ;G
        .BYTE   110             ;H
        .BYTE   40              ;EMPTY
        .BYTE   133             ;[
        .BYTE   56              ;.
        .BYTE   74              ;<
        .BYTE   50              ;(
        .BYTE   53              ;+
        .BYTE   41              ;!
        .BYTE   111             ;I
        .BYTE   173             ;LEFT CURLY BRACKET
        .BYTE   175             ;RIGHT CURLY BRACKET

;
; 026 TRANSLATION TABLE
;

TB026:  .BYTE   40              ;SPACE
        .BYTE   61              ;1
        .BYTE   62              ;2
        .BYTE   63              ;3
        .BYTE   64              ;4
        .BYTE   65              ;5
        .BYTE   66              ;6
        .BYTE   67              ;7
        .BYTE   70              ;8
        .BYTE   40              ;EMPTY
        .BYTE   137             ;
        .BYTE   75              ;=
        .BYTE   100             ;@
        .BYTE   136             ;^
        .BYTE   47              ;'
        .BYTE   134             ;\
        .BYTE   71              ;9
        .BYTE   60              ;0
        .BYTE   57              ;/
        .BYTE   123             ;S
        .BYTE   124             ;T
        .BYTE   125             ;U
        .BYTE   126             ;V
        .BYTE   127             ;W
        .BYTE   130             ;X
        .BYTE   131             ;Y
        .BYTE   40              ;EMPTY
        .BYTE   73              ;;
        .BYTE   54              ;,
        .BYTE   50              ;(
        .BYTE   42              ;"
        .BYTE   43              ;#
        .BYTE   45              ;%
        .BYTE   132             ;Z
        .BYTE   55              ;-
        .BYTE   112             ;J
        .BYTE   113             ;K
        .BYTE   114             ;L
        .BYTE   115             ;M
        .BYTE   116             ;N
        .BYTE   117             ;O
        .BYTE   120             ;P
        .BYTE   121             ;Q
        .BYTE   40              ;EMPTY
        .BYTE   72              ;:
        .BYTE   44              ;$
        .BYTE   52              ;*
        .BYTE   133             ;[
        .BYTE   76              ;>
        .BYTE   46              ;&
        .BYTE   122             ;R
        .BYTE   53              ;+
        .BYTE   101             ;A
        .BYTE   102             ;B
        .BYTE   103             ;C
        .BYTE   104             ;D
        .BYTE   105             ;E
        .BYTE   106             ;F
        .BYTE   107             ;G
        .BYTE   110             ;H
        .BYTE   40              ;EMPTY
        .BYTE   77              ;?
        .BYTE   56              ;.
        .BYTE   51              ;)
        .BYTE   135             ;]
        .BYTE   74              ;<
        .BYTE   41              ;!
        .BYTE   111             ;I
        .BYTE   173             ;LEFT CURLY BRACKET
        .BYTE   175             ;RIGHT CURLY BRACKET
        .EVEN

;
; DRIVER DISPATCH TABLE
;

$CRTBL::.WORD   CRINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   CRCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   CROUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   CRPWF           ;POWERFAIL ENTRY POINT

;+
; **-CRINI-CR11 CARD READER CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
CRINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     CRPWF           ;IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; CARD READER I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO THE SECOND WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF I/O BUFFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB
        CLR     STRBF(R5)       ;ASSUME ALLOCATION FAILURE
        MOV     #80.,R0         ;ASSUME ASCII OR PACKED HOLLERITH
        MOVB    I.FCN(R1),U.CW2(R5) ;SAVE SUBFUNCTION MODIFIER BITS
        BPL     10$             ;IF PL ASCII OR PACKED HOLLERITH
        ASL     R0              ;BINARY READ REQUIRES 160. BYTES
10$:    MOV     R0,R1           ;SET LENGTH OF BUFFER REQUIRED
        CALL    $ALOCB          ;ALLOCATE DATA BUFFER
        BCS     50$             ;IF CS NO BUFFER AVAILABLE
        MOV     R0,STRBF(R5)    ;SAVE STARTING BUFFER ADDRESS
        BICB    #US.ABO,U.STS(R5) ;CLEAR ABORT REQUEST FLAG

;
; INITIATE CARD READ
;

20$:    MOV     R5,R3           ;CALCULATE ADDRESS OF CARD READER
        ADD     #STRBF,R3       ;CONTROL BLOCK
        MOV     (R3)+,(R3)+     ;SET CURRENT ADDRESS IN DATA BUFFER
        MOVB    #1,(R3)         ;ASSUME ASCII OR PACKET HOLLERITH
        TSTB    U.CW2(R5)       ;BINARY READ?
        BPL     30$             ;IF PL NO
        MOVB    #8.,(R3)        ;SET EOF COUNT FOR BINARY READ
30$:    MOVB    (R3)+,(R3)+     ;SET EOF COLUMN COUNTER
        CLR     (R3)            ;CLEAR CARD COLUMN COUNTER
        MOV     S.CSR(R4),R2    ;GET CARD READER CSR ADDRESS
        BIT     #400,(R2)+      ;CARD READER ON LINE?
        BNE     CROUT           ;IF NE NO
        MOVB    S.ITM(R4),S.CTM(R4) ;SET DEVICE TIMEOUT COUNT
        MOV     (R2),R0         ;READ DATA BUFFER CLEAR DONE IF SET
        MOV     #101,-(R2)      ;START CARD MOTION

;
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE. THIS IS DONE TO AVOID A RACE CONDITION
; THAT COULD EXIST IN RESTARTING THE I/O OPERATION.
;

CRPWF:  RETURN                  ;

;
; CARD READ ERROR DURING A READ OPERATION
;

CRERR:  MOV     #T.NCRE,R0      ;SET FOR HARDWARE ERROR MESSAGE
        BR      40$             ;

;
; DEVICE TIMEOUT RESULTS IN A NOT READY MESSAGE BEING PUT OUT AT
; A SYSGEN SPECIFIED INTERVAL.  TIMEOUTS ARE CAUSED BY POWERFAILURE
; AND CARD READER FAULT CONDITIONS.
;

CROUT:                          ;;;
        CLR     @S.CSR(R4)      ;;;DISABLE CARD READER INTERRUPT
        MTPS    #0              ;;;ALLOW INTERRUPTS

        .IF DF  T$$KMG

38$:    MOV     #T.NDNR,R0      ;SET FOR NOT READY MESSAGE                      ; EB199
                                                                                ;**-1
        .IFTF

40$:    BITB    #US.ABO,U.STS(R5) ;ABORT REQUESTED?
        BNE     60$             ;IF NE YES
                                                                                ; EB199
        .IFT                                                                    ; EB199
                                                                                ; EB199
        BIT     #4000,U.CW3(R5) ;TIMING ERROR?                                  ; EB199
        BEQ     43$             ;IF EQ NO                                       ; EB199
        BIT     #400,@S.CSR(R4) ;OPERATOR PUT READER OFFLINE?                   ; EB199
        BEQ     45$             ;IF EQ NO                                       ; EB199
        BIC     #4000,U.CW3(R5) ;CLEAR OVERRUN STATUS BIT                       ; EB199
                                                                                ; EB199
        .IFTF                                                                   ; EB199
                                                                                ; EB199
43$:    BIT     #400,@S.CSR(R4) ;CARD READER ONLINE?                            ; EB199
        BEQ     20$             ;IF EQ YES                                      ;**-1
45$:    MOVB    #1,S.CTM(R4)    ;SET TIMEOUT FOR 1 SECOND                       ; EB199
                                                                                ;**-1
        .IFT

        DECB    S.STS(R4)       ;TIME TO PRINT MESSAGE?
        BNE     CRPWF           ;IF NE NO
        MOVB    #C$$RTO,S.STS(R4) ;SET TO OUTPUT NEXT MESSAGE IN
                                ;C$$RTO SECONDS
        BNE     47$             ;IF NE CR NOT READY MESSAGES ENABLED
        INCB    S.STS(R4)       ;CR NOT READY MESSAGES NOT WANTED, SO
        BR      CRPWF           ;REBUSY CONTROLLER
47$:    CALLR   $DVMSG          ;OUTPUT MESSAGE

        .IFF

        BR      CRPWF           ;

        .ENDC

;
; NO BUFFER SPACE AVAILABLE
;

50$:    MOV     #IE.NOD&377,R0  ;SET NO BUFFER AVAILABLE STATUS
        BR      80$

;
; ABORT REQUESTED
;

60$:    MOV     #IE.ABO&377,R0  ;SET TRANSFER ABORTED STATUS
        BR      80$

;
; END OF FILE
;

70$:    MOV     #IE.EOF&377,R0  ;SET END OF FILE STATUS
80$:    CLR     R1              ;CLEAR SECOND I/O STATUS WORD
        BR      160$            ;

;+
; **-$CRINT-CR11 CARD READER CONTROLLER INTERRUPTS
;-

$CRINT::                        ;;;REF LABEL
        INTSV$  CR,PR6,C$$R11   ;;;GENERATE INTERRUPT SAVE CODE
        MOV     R3,-(SP)        ;;;SAVE R3
        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOV     S.CSR(R4),R3    ;;;GET ADDRESS OF CSR
        BIT     #176000,(R3)+   ;;;EXCEPTION CONDITION?
        BEQ     190$            ;;;IF EQ NO
        MOV     -(R3),U.CW3(R5) ;;;SAVE CARD READER INTERRUPT STATUS
        CLR     (R3)            ;;;DISABLE CARD READER INTERRUPT
        MOV     (SP)+,R3        ;;;RESTORE R3
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        TSTB    EOFCT(R5)       ;END OF FILE?
        BEQ     70$             ;IF EQ YES
        MOV     U.CW3(R5),R0    ;GET CARD READER STATUS                         ; EO701
        BIT     #2000,(R0)      ;TRANSITION TO ONLINE?                          ; EO701
        BNE     180$            ;IF NE YES                                      ; EO701
                                                                                ; EB199
        .IF DF  T$$KMG                                                          ; EB199
                                                                                ; EB199
        BIT     #10000,(R0)     ;MOTION ERROR?                                  ; EB199
        BNE     CRERR           ;IF NE YES                                      ; EB199
        BIT     #4000,R0        ;TIMING ERROR?                                  ; EB199
        BNE     38$             ;IF NE YES                                      ; EB199
                                                                                ; EB199
        .IFF                                                                    ; EB199
                                                                                ; EB199
        BIT     #14000,(R0)     ;MOTION OR TIMING ERROR?                        ; EB199
        BNE     CRERR           ;IF NE YES                                      ; EB199
                                                                                ; EB199
        .ENDC                                                                   ; EB199
                                                                                ; EB199
        MOV     #80.*2,R0       ;ASSUME BINARY READ                             ;**-2
        MOVB    U.CW2(R5),R1    ;BINARY READ?
        BMI     90$             ;IF MI YES
        ASR     R0              ;SET FOR ASCII OR PACKED HOLLERITH
        TSTB    R1              ;PACKED HOLLERITH?
        BNE     90$             ;IF NE YES
        CMP     #CR026,CCOL1(R5) ;026 TRANSLATION CONTROL CARD?
        BEQ     230$            ;IF EQ YES
        CMP     #CR029,CCOL1(R5) ;029 TRANSLATION CONTROL CARD?
        BEQ     240$            ;IF EQ YES
        MOV     #TB029,R1       ;ASSUME 029 TRANSLATION
        BITB    #US.MDE,U.STS(R5) ;029 TRANSLATION?
        BNE     90$             ;IF NE YES
        MOV     #TB026,R1       ;SET FOR 026 TRANSLATION
90$:    MOV     STRBF(R5),R2    ;GET STARTING ADDRESS OF DATA BUFFER
        MOV     U.CNT(R5),-(SP) ;GET NUMBER OF BYTES TO TRANSFER
100$:   MOVB    (R2)+,R3        ;GET NEXT BYTE FROM DATA BUFFER
        BIT     #300,U.CW2(R5)  ;BINARY OR PACKED HOLLERITH READ?
        BNE     140$            ;IF NE YES
        MOV     #104,R4         ;ASSUME RPG SPECIAL
        CMPB    R3,#240         ;RPG SPECIAL?
        BEQ     130$            ;IF EQ YES
        INC     R4              ;INCREMENT CHARACTER CODE
        CMPB    R3,#140         ;RPG SPECIAL?
        BEQ     130$            ;IF EQ YES
        MOVB    R3,R4           ;SIGN EXTEND PACKED CODE
        BPL     110$            ;IF PL ZONE 12 NO PUNCHED
        ADD     #340,R4         ;ADJUST FOR ZONE 12 PUNCH
        MOV     R4,R3           ;COPY FOR ZONE COUNT DOWN
110$:   SUB     #40,R3          ;DECREMENT COUNT OF ZONE PUNCHES
        BMI     120$            ;IF MI DONE
        SUB     #17,R4          ;SUBTRACT 21 AND STRIP ZONE PUNCH
        BR      110$            ;
120$:   CMP     R4,#105         ;INDEX WITHIN RANGE?
        BLOS    130$            ;IF LOS YES
        CLR     R4              ;FORCE A BLANK
130$:   ADD     R1,R4           ;CALCULATE ADDRESS OF TRANSLATE CODE
        MOVB    (R4),R3         ;GET TRANSLATED ASCII CODE
140$:   MOV     R3,-(SP)        ;SET BYTE TO PUT IN USER BUFFER
        CALL    $PTBYT          ;PUT BYTE IN USER BUFFER
        DEC     (SP)            ;ANY MORE SPACE IN USER BUFFER?
        BLE     150$            ;IF LE NO
        DEC     R0              ;ANY MORE BYTES TO PROCESS?
        BGT     100$            ;IF GT YES
150$:   MOV     U.CNT(R5),R1    ;GET SIZE OF USER BUFFER
        SUB     (SP)+,R1        ;CALCULATE NUMBER OF BYTES TRANSFERED
        MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS
160$:   CALL    $IODON          ;FINISH I/O OPERATION
        MOV     STRBF(R5),R0    ;GET ADDRESS OF BUFFER TO RELEASE
        BEQ     180$            ;IF EQ NO BUFFER
        MOV     #80.,R1         ;ASSUME ASCII OR PACKED HOLLERITH READ
        TSTB    U.CW2(R5)       ;ASCII OR PACKED HOLLERITH?
        BPL     170$            ;IF PL YES
        ASL     R1              ;SET FOR BINARY READ BUFFER
170$:   CALL    $DEACB          ;DEALLOCATE DATA BUFFER
180$:   JMP     CRINI           ;GO AGAIN

;
; STORE DATA IN CARD BUFFER
;

190$:   MOV     (R3)+,R4        ;;;READ BINARY CARD COLUMN
        MOV     (R3),R3         ;;;READ PACKED HOLLERITH DATA
        MOVB    CCOLC(R5),-(SP) ;;;GET CURRENT COLUMN NUMBER
        BNE     200$            ;;;IF NE NOT COLUMN ONE
        MOV     R4,CCOL1(R5)    ;;;SAVE CARD COLUMN ONE DATA
200$:   CMPB    (SP)+,EOFCL(R5) ;;;PAST EOF COLUMNS?
        BHIS    210$            ;;;IF HIS YES
        CMP     R4,#CREOF       ;;;END OF FILE PUNCH?
        BNE     210$            ;;;IF NE NO
        DECB    EOFCT(R5)       ;;;DECREMENT EOF COUNTER
210$:   CMPB    CCOLC(R5),#80.  ;;;80. COLUMNS READ (BUFFER FULL)?              ; EO701
        BEQ     221$            ;;;IF EQ YES -- DO NOT EXCEED BUFFER            ; EO701
        INCB    CCOLC(R5)       ;;;INCREMENT COLUMN NUMBER                      ; EO701
        MOVB    R3,@CURBF(R5)   ;;;ASSUME ASCII OR PACKED HOLLERITH             ;**-1
        TSTB    U.CW2(R5)       ;;;ASCII OR PACKED HOLLERITH?
        BPL     220$            ;;;IF PL YES
        MOV     R4,@CURBF(R5)   ;;;STORE BINARY DATA
        INC     CURBF(R5)       ;;;UPDATE CURRENT BUFFER ADDRESS
220$:   INC     CURBF(R5)       ;;;UPDATE CURRENT BUFFER ADDRESS
221$:   MOV     (SP)+,R3        ;;;RESTORE R3                                   ;EO701
        RETURN                  ;;;EXIT INTERRUPT                               ; EB199
                                                                                ;**-2
;
; SET 026 TRANSLATION MODE
;

230$:   BICB    #US.MDE,U.STS(R5) ;CLEAR 029 TRANSLATION FLAG
        BR      250$            ;

;
; SET 029 TRANSLATION MODE
;

240$:   BISB    #US.MDE,U.STS(R5) ;SET 029 TRANSLATION FLAG
250$:   JMP     20$             ;READ ANOTHER CARD
        .DSABL  LSB

;
; CANCEL I/O OPERATION-FORCE I/O TO COMPLETE IS DEVICE IS NOT READY
;

CRCAN:  CMP     R1,I.TCB(R0)    ;;;REQUEST FOR CURRENT TASK?
        BNE     10$             ;;;IF NE NO
        BISB    #US.ABO,U.STS(R5) ;;;SET FOR ABORT IF DEVICE NOT READY
10$:    RETURN                  ;;;

        .END
        .TITLE  CTDRV
        .IDENT  /07/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 07
;
; D. N. CUTLER 13-MAR-74
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;       B. LYONS
;
; MODIFIED BY:
; 
;       P. J. BEZEREDI 04-MAR-77
;
;               PB019 -- FIX A BUG IN THE ERROR LOGGING LOGIC.
;
; TA11 TAPE CASSETTE CONTROLLER DRIVER
;
; NOTE: THIS IS A MINIMAL DRIVER AND CONTAINS NO ERROR RECOVERY.
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
 
;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLER NUMBER)
;
 
CNTBL:  .BLKW   T$$A11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
 
 
        .IF GT  T$$A11-1
 
TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER
 
        .ENDC
 
        
;
; ERROR PROCESSING CONTROL TABLE
;
        
ERRTB:  .BYTE   IE.DNR&377,1000/400 ;DEVICE NOT READY
        .BYTE   IE.WLK&377,10000/400 ;DRIVE WRITE LOCKED
        .BYTE   IE.EOT&377,20000/400 ;END OF TAPE
        .BYTE   IE.EOF&377,4000/400 ;END OF FILE
        .BYTE   IE.DAO&377,2000/400 ;DATA OVERRUN
        .BYTE   IE.VER&377,377  ;BLOCK CHECK ERROR
        
;
; LEGAL FUNCTION DISPATCH TABLE
;
 
LGFCN:  .WORD   IO.RLB          ;READ LOGICAL BLOCK
        .BYTE   105,10.         ;
        .WORD   RDBLK           ;
        .WORD   IO.WLB          ;WRITE LOGICAL BLOCK
        .BYTE   103,10.         ;
        .WORD   WRBLK           ;
        .WORD   IO.EOF          ;WRITE END OF FILE
        .BYTE   101,10.         ;
        .WORD   WREOF           ;
        .WORD   IO.RWD          ;REWIND
        .BYTE   117,34.         ;
        .WORD   WREOF           ;
        .WORD   IO.SPB          ;SPACE BLOCK
        .BYTE   115,128.        ;
        .WORD   SPCBK           ;
        .WORD   IO.SPF          ;SPACE FILE
        .BYTE   113,128.        ;
        .WORD   SPCBK           ;
 
;
; DRIVER DISPATCH TABLE
;
 
$CTTBL::.WORD   CTINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   CTCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   CTOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   CTPWF           ;POWERFAIL ENTRY POINT
 
;+
; **-CTINI-TA11 TAPE CASSETTE CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-
 
        .ENABL  LSB
CTINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     CTPWF           ;IF CS CONTROLLER BUSY OR NO REQUEST
 
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; TA11 TAPE CASSETTE FUNCTION INDEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO. RLB 1 IO.RWD/IO.SPB/IO.SPF/IO.EOF).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;
 
        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB
        MOV     #LGFCN,R3       ;POINT TO LEGAL FUNCTION TABLE
        MOV     #6,R0           ;SET NUMBER OF ENTRIES IN TABLE
10$:    CMP     I.FCN(R1),(R3)+ ;FUNCTION CODE MATCH?
        BEQ     20$             ;IF EQ YES
        CMP     (R3)+,(R3)+     ;POINT TO NEXT TABLE ENTRY
        DEC     R0              ;ANY MORE TABLE ENTRIES?
        BGT     10$             ;IF GT YES
        MOV     #IE.IFC&377,R0  ;SET ILLEGAL FUNCTION STATUS
        BR      50$             ;FINISH IN COMMON CODE
 
;
; FUNCTION CODE MATCH FOUND
;
 
20$:    SWAB    R2              ;SWAP UNIT NUMBER TO LEFT BYTE
        BISB    (R3)+,R2        ;MERGE FUNCTION CODE WITH UNIT
        MOVB    (R3)+,S.ITM(R4) ;SPACING FUNCTION?
        BPL     30$             ;IF PL NO
 
;
; SPACING FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- SPACING COUNT (POSITIVE=FORWARD, NEGATIVE=BACKWARD).
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;
 
        MOV     U.BUF(R5),I.PRM+4(R1) ;MOVE SPACING COUNT TO COMMON PLACE
        MOV     U.BUF(R5),U.CNT(R5) ;MOVE SPACING COUNT TO COMMON PLACE
        BEQ     40$             ;IF EQ NO SPACING REQUIRED
        BPL     30$             ;IF PL SPACE FORWARD
        NEG     U.CNT(R5)       ;CONVERT TO POSITIVE COUNT
        NEG     I.PRM+4(R1)     ;CONVERT TO POSITIVE COUNT
        SUB     #4,R2           ;CONVERT TO REVERSE FUNCTION
 
;
; READ/WRITE LOGICAL FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER.
;       WD. 13 -- DATA BUFFER ADDRESS.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;
; NO FUNCTION DEPENDENT PARAMETERS ARE REQUIRED FOR REWIND AND WRITE EOF
;
 
30$:    MOVB    S.ITM(R4),S.CTM(R4) ;SET CURRENT DEVICE TIMEOUT COUNT
        MOV     (R3),U.CW2(R5)  ;SET INITIAL INTERRUPT ADDRESS
 

        .IF DF  E$$DVC
 
        CALL    $BMSET          ; SET I/O ACTIVE IN BITMAP
 
        .ENDC
 

        MOV     R2,@S.CSR(R4)   ;INITIATE FUNCTION
 
;
; CANCEL I/O OPERATION IS A NOP FOR TA11 TAPE CASSETTES.
;
 
CTCAN:                          ;REF LABEL
 
;
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE. THIS IS DONE TO AVOID A RACE CONDITION
; THAT COULD EXIST IN RESTARTING THE I/O OPERATION.
;
 
CTPWF:  RETURN                  ;
 
;
; NO SPACING REQUIRED
;
 
40$:    MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS
50$:    BR      110$            ;
 
;+
; **-$CTINT-TA11 TAPE CASSETTE CONTROLLER INTERRUPTS
;-
 
        INTSE$  CT,PR6,T$$A11   ;;;GENERATE INTERRUPT SAVE CODE
        MOV     R3,-(SP)        ;;;SAVE R3
        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET CURRENT DEVICE TIMEOUT COUNT
        MOV     S.CSR(R4),R3    ;;;GET ADDRESS OF CSR
        BIT     #200,(R3)+      ;;;TRANSFER REQUEST?
        BNE     60$             ;;;IF NE YES
        MOV     -2(R3),U.CW3(R5) ;;;SAVE CURRENT STATUS
60$:    CALL    @U.CW2(R5)      ;;;CALL INTERRUPT ROUTINE
        MOV     (SP)+,U.CW2(R5) ;;;SAVE INTERRUPT RETURN ADDRESS
        MOV     (SP)+,R3        ;;;RESTORE R3
        JMP     $INTXT          ;;;EXIT FROM INTERRUPT
 
;
; SPACING FUNCTION (FILE AND BLOCK)
;
 
SPCBK:  BMI     70$             ;;;IF MI ERROR
        DEC     U.CNT(R5)       ;;;DECREMENT SPACING COUNT
        BLE     70$             ;;;IF LE DONE
        INC     -(R3)           ;;;INITIATE NEXT OPERATION
        CALL    @(SP)+          ;;;SET INTERRUPT RETURN ADDRESS
        BR      SPCBK           ;;;GO AGAIN
70$:    CLR     -(R3)           ;;;CLEAR INTERRUPT ENABLE
        TST     (SP)+           ;;;REMOVE RETURN FROM STACK
        MOV     (SP)+,R3        ;;;RESTORE R3
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     U.CW3(R5),R1    ;GET FINAL STATUS
        BPL     90$             ;IF PL SUCCESS
        BICB    #^C<7*2>,R1     ;CLEAR ALL BUT FUNCTION CODE
        CMPB    #5*2,R1         ;FORWARD OR REVERSE FUNCTION?
        BLE     100$            ;IF LE FORWARD
        BIC     #120777,R1      ;CLEAR ERROR, BOT, UNIT, AND FUNCTION
        BEQ     40$             ;IF EQ NO ERRORS
        BR      100$            ;ANALYZE ERROR
 
;
; READ LOGICAL FUNCTION
;
 
RDBLK:  BMI     WREOF           ;;;IF MI ERROR
        DEC     U.CNT(R5)       ;;;DECREMENT BYTE COUNT
        BLT     80$             ;;;IF LT NO MORE TO READ
        MOV     (R3),-(SP)      ;;;READ BYTE FROM DATA REGISTER
        CALL    $PTBYT          ;;;PUT BYTE IN USER BUFFER
        CALL    @(SP)+          ;;;SET INTERRUPT RETURN ADDRESS
        BR      RDBLK           ;;;GO AGAIN
 
;
; WRITE LOGICAL FUNCTION
;
 
WRBLK:  BMI     WREOF           ;;;IF MI ERROR
        DEC     U.CNT(R5)       ;;;DECREMENT BYTE COUNT
        BLT     80$             ;;;IF LT NO MORE TO WRITE
        CALL    $GTBYT          ;;;GET BYTE FROM USER BUFFER
        MOVB    (SP)+,(R3)      ;;;WRITE BYTE INTO DATA REGISTER
        CALL    @(SP)+          ;;;SET INTERRUPT RETURN ADDRESS
        BR      WRBLK           ;;;GO AGAIN
80$:    INC     U.CNT(R5)       ;;;ADJUST BYTE COUNT
        BIS     #20,-(R3)       ;;;INITIATE LAST BYTE SEQUENCE
        CALL    @(SP)+          ;;;SET INTERRUPT RETURN ADDRESS
 
;
; REWIND AND WRITE END OF FILE FUNCTIONS
;
 
WREOF:  CLR     -(R3)           ;;;CLEAR INTERRUPT ENABLE
        TST     (SP)+           ;;;REMOVE RETURN FROM STACK
        MOV     (SP)+,R3        ;;;RESTORE R3
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
90$:    MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL COMPLETION STATUS
        MOV     U.CW3(R5),R1    ;GET FINAL STATUS
        BPL     110$            ;IF PL SUCCESS
100$:   SWAB    R1              ;SWAP ERROR BITS TO LOW BYTE
        MOV     #ERRTB,R2       ;GET ADDRESS OF ERROR CONTROL TABLE
105$:   CLR     R0              ;PICKUP NEXT ERROR STATUS CODE
        BISB    (R2)+,R0        ;
        BITB    (R2)+,R1        ;ERROR BIT SET?
        BEQ     105$            ;IF EQ NO


        .IF DF  E$$DVC

        BITB    #26,R1          ;WRITE LOCK, TIMING OR OFF-LINE?
        BEQ     110$            ;IF EQ NO
        CALL    $DVERR          ;LOG DEVICE ERROR

        .ENDC


        BR      110$            ;FINISH I/O
 
;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING TERMINATED. TIMEOUTS ARE
; USUALLY CAUSED BY POWERFAILURE BUT ALSO MAY BE THE RESULT OF A HARD-
; WARE FAILURE.
;
 
CTOUT:  CALL    $DTOER          ;;;LOG DEVICE TIMEOUT
110$:   MOV     S.PKT(R4),R1    ;RETRIEVE ADDRESS OF I/O PACKET
        MOV     I.PRM+4(R1),R1  ;GET ORIGINAL COUNT VALUE
        SUB     U.CNT(R5),R1    ;SUBTRACT COUNT REMAINING
 

        .IF DF  E$$DVC
 
        MOV     #401,R2         ; SET CURRENT & FINAL RETRY COUNT TO 1
 
        .ENDC

 
        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     CTINI           ;GO AGAIN
        .DSABL  LSB
 
        .END
        .TITLE  CVRTM
        .IDENT  /02/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 02
;
; D. N. CUTLER 12-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;
; MODIFIED BY:
;
;+
; **-$CVRTM-CONVERT TIME
;
; THIS ROUTINE IS CALLED TO CONVERT A TIME INTERVAL-TIME UNITS PAIR
; TO A CLOCK TICKS COUNT.
;
; INPUTS:
;
;       R3=ADDRESS OF TIME INTERVAL-TIME UNITS PAIR.
;
; OUTPUTS:
;
;       IF AN ILLEGAL TIME INTERVAL (GREATER THAN 15 BITS) OR
;       ILLEGAL TIME UNITS (ZERO OR GREATER THAN 4) IS SPECIFIED,
;       THEN A DIRECTIVE STATUS OF 'D.RS93' IS RETURNED. ELSE THE
;       TICKS COUNT IS RETURNED WITH THE HIGH ORDER PART IN R0 AND
;       THE LOW ORDER PART IN R1. R3 IS ADVANCED BY 4 THUS POINTING
;       PAST THE TIME INTERVAL-TIME UNITS PAIR.
;-
 
$CVRTM::MOV     (R3)+,R1        ;GET TIME INTERVAL
        BMI     70$             ;IF MI ILLEGAL TIME INTERVAL
        MOV     (R3)+,R0        ;GET TIME UNITS
        DEC     R0              ;BACK OFF BY ONE
        CMP     R0,#3           ;LEGAL UNITS?
        BHI     70$             ;IF HI NO
        ASL     R0              ;CONVERT TO DISPATCH INDEX
        ADD     R0,PC           ;DISPATCH
10$:    BR      50$             ;1=TICKS
        BR      30$             ;2=SECONDS
        BR      20$             ;3=MINUTES
        MOV     #60.,R0         ;4=HOURS
        CALL    $MUL            ;CALCULATE NUMBER OF MINUTES
        TST     R0              ;OVERFLOW 16 BITS?
        BNE     70$             ;IF NE YES
20$:    CMP     R1,#1440.       ;MORE THAN ONE DAY OF MINUTES?
        BHI     70$             ;IF HI YES
        MOV     #30.,R0         ;MULTIPLY BY 60. SECONDS/2
        CALL    $MUL            ;PRODUCT CANNOT OVERFLOW 16 BITS.
        MOV     $TKPS,R0        ;GET TICKS PER SECOND
        ASL     R0              ;MULTIPLY BY 2
        BR      40$             ;
30$:    MOV     $TKPS,R0        ;GET TICKS PER SECOND
40$:    CALL    $MUL            ;CALCULATE TICKS COUNT
50$:    MOV     R0,R2           ;TICKS COUNT ZERO?
        BIS     R1,R2           ;
        BNE     60$             ;IF NE NO
        INC     R1              ;MAKE TICKS COUNT 1
60$:    RETURN                  ;
70$:    DRSTS   D.RS93          ;SET DIRECTIVE STATUS
 
        .END
        .TITLE  DBDRV
        .IDENT  /05.03/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION  05.03
;
; D. N. CUTLER 2-JUL-74
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;       D. N. CUTLER
;       C. A. D'ELIA
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 30-NOV-76
;
;               PB009 -- CORRECT OUT OF RANGE BRANCHES WHEN A
;                       MULTI-CONTROLLER DRIVER IS GENERATED.
;
;       P. J. BEZEREDI 07-FEB-77
;
;               PB013 -- ADDITION OF EXPANDED WRITE CHECK CAPABILITY.
;
;       P. J. BEZEREDI 14-FEB-77
;
;               PB014 -- LOAD SECOND STATUS WORD WITH BYTES ACTUALLY
;                       TRANSFERED BEFORE CALLING $IODON.
;
;       P. J. BEZEREDI 16-FEB-77
;
;               PB015 -- APPLY ECC CORRECTION AND OFFSET RECOVERY FOR
;                       READ FUNCTIONS ONLY.
;
;       P. J. BEZEREDI 22-FEB-77
;
;               PB016 -- LOAD PROPER ADDRESS EXTENSION REGISTER FOR
;                       MIXED MASSBUS CONFIGURATIONS.
;
;       P. J. BEZEREDI 16-MAY-77
;
;               PB030 -- POWERFAIL RECOVERY SUPPORT.
;
;       P. J. BEZEREDI 07-SEP-77
;
;               PB037 -- USE R1 FOR I/O PACKET ADDRESS IN FUNCTION
;                       INITIATION SECTION.
;
;       R. T. PERRON 05-SEP-78
;
;               RP004 -- CORRECTLY DECREMENT RETRY COUNT
;                       DURING OFFSET RECOVERY.
;
;       R. T. PERRON 15-JAN-79
;
;               RP007 -- ADDITION OF RH11 SUPPORT FOR 22-BIT ADDRESSING
;
;       R. T. PERRON 29-MAR-79
;
;               RP010 -- CORRECT OFFSET RECOVERY AND HEADER COMPARE ERRORS
;
; RH11-RP04/05/06 DISK PACK DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
 
;
; EQUATED SYMBOLS
;
; DEVICE REGISTER AND STATUS BIT DEFINITIONS
;
 
RPCS1=0                         ;CONTROL STATUS REGISTER 1
 
TRE=40000                       ;TRANSFER ERROR
MCPE=20000                      ;MASSBUS CONTROL PARITY ERROR
 
 
RPWC=2                          ;WORD COUNT REGISTER
RPBA=4                          ;BUFFER ADDRESS REGISTER
RPDA=6                          ;DESIRED TRACK/SECTOR REGISTER
 
RPCS2=10                        ;CONTROL STATUS REGISTER 2
 
DLT=100000                      ;DATA LATE ERROR
WCE=40000                       ;WRITE CHECK ERROR
UPE=20000                       ;UNIBUS PARITY ERROR
NED=10000                       ;NONEXISTENT DISK ERROR
NEM=4000                        ;NONEXISTENT MEMORY ERROR
PGE=2000                        ;PROGRAMMING ERROR
MXF=1000                        ;MISSED TRANSFER ERROR
MDPE=400                        ;MASSBUS DATA PARITY ERROR
 
RPDS=12                         ;DRIVE STATUS REGISTER
 
ERR=40000                       ;ERROR SUMMARY BIT
MOL=10000                       ;MEDIUM ONLINE
WRL=4000                        ;WRITE LOCKED DRIVE
DRY=200                         ;DRIVE READY
VV=100                          ;VOLUME VALID
 
 
RPER1=14                        ;ERROR SUMMARY REGISTER
 
DCK=100000                      ;DATA CHECK ERROR
UNS=40000                       ;DRIVE UNSAFE
OPI=20000                       ;OPERATION INCOMPLETE
DTE=10000                       ;DRIVE TIMING ERROR
WLE=4000                        ;WRITE LOCK ERROR
IAE=2000                        ;INVALID DISK ADDRESS
AOE=1000                        ;ADDRESS OVERFLOW
HCRC=400                        ;HEADER CRC ERROR
HCE=200                         ;HEADER COMPARE ERROR
ECH=100                         ;ECC HARD ERROR
WCF=40                          ;WRITE CLOCK FAILURE
FER=20                          ;FORMAT ERROR
CPE=10                          ;CONTROL BUS PARITY ERROR
RMR=4                           ;REGISTER MODIFY REFUSED
ILR=2                           ;ILLEGAL REGISTER
ILF=1                           ;ILLEGAL FUNCTION
 
 
RPAS=16                         ;ATTENTION SUMMARY REGISTER
RPLA=20                         ;LOOKAHEAD REGISTER
RPDBR=22                        ;DATA BUFFER REGISTER
RPMR=24                         ;MAINTENENCE REGISTER
RPDT=26                         ;DRIVE TYPE REGISTER
RPSN=30                         ;DRIVE SERIAL NUMBER
 
RPOF=32                         ;DRIVE OFFSET REGISTER
 
FMT22=10000                     ;FORMAT (1=16 BIT)
ECI=4000                        ;ECC INHIBIT
HCI=2000                        ;HEADER COMPARE INHIBIT
 
 
RPDC=34                         ;DESIRED CYLINDER NUMBER
RPER2=40                        ;ERROR REGISTER 2                       ; RP010
RPEC1=44                        ;ECC POSITION REGISTER
RPEC2=46                        ;ECC PATTERN REGISTER
RPBAE=50                        ;BUS ADDRESS EXTENSION REGISTER


        .IF DF  M$$IXD

RPBAE=74                        ;MIXED MASSBUS ADDRESS EXT. REGISTER

        .ENDC


;
; LOCAL EQUATED SYMBOLS                                                 ; RP004
;                                                                       ;**-1
RETRY=8.                        ;CONTROLLER ERROR RETRY COUNT
IHC=1                           ;INHIBIT HEADER COMPARE                 ; RP004
OFA=10                          ;OFFSET ACTIVE BIT                      ; RP004

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLER NUMBER)
;

CNTBL:  .BLKW   R$$JP1          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   R$$JP1          ;RETRY COUNT FOR CURRENT OPERATION


        .IF GT  R$$JP1-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC


        .IF DF  R$$JPO

OFFAD:  .BLKW   R$$JP1          ;ADDRESS OF CURRENT OFFSET VALUE

;
; OFFSET POSITIONING VALUE TABLE
;

OFFTB:  .WORD   FMT22!20        ;+400                                   ; RP004
        .WORD   FMT22!220       ;-400                                   ;**-2
        .WORD   FMT22!40        ;+800
        .WORD   FMT22!240       ;-800
        .WORD   FMT22!60        ;+1200
        .WORD   FMT22!260       ;-1200
        .WORD   0               ;RETURN TO CENTERLINE

        .ENDC


        .IF DF  D$$IAG

        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS

;
; DIAGNOSTIC FUNCTION TABLE
;
FUNTBL: .BYTE   107, IO.HMS!IQ.UMD&377
        .BYTE   105, IO.BLS!IQ.UMD&377
        .BYTE   115, IO.OFF!IQ.UMD&377
        .BYTE   173, IO.RDH!IQ.UMD&377
        .BYTE   163, IO.WDH!IQ.UMD&377
        .BYTE   151, IO.WCK!IQ.UMD&377
FUNTBE:

        .ENDC


;
; DRIVER DISPATCH TABLE
;

$DBTBL::.WORD   DBINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DBCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DBOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   DBPWF           ;POWERFAIL ENTRY POINT

;+
; **-DBINI-RH11-RP04/05/06 DISK PACK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
1$:     RETURN                  ;RETURN TO CALLER
DBINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     1$              ;IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; RH11-RP04/05/06 DISK PACK I/O REQUEST PACKET FORMAT
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB OR IO.WLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- MEMORY EXTENSION BITS (BITS 4 AND 5) OF I/O TRANSFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- DIAGNOSTIC SUPPLIMENTAL PARAMETER ELSE NOT USED.
;       WD. 16 -- HIGH PART OF LOGICAL BLOCK NUMBER AND HIGH BYTE NOT US
;       WD. 17 -- LOW PART OF LOGICAL BLOCK NUMBER OF I/O REQUEST.
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. BLK ADRS.
;       WD. 21 -- DIAGNOSTIC REG. BLK ADRS (REAL OR DISPL.+140000).
;

        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB


        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUS DEVICE?            ; RP007
        BNE     3$              ;IF NE YES -- DOES NOT USE UMR'S        ; RP007
        CALL    $STMAP          ;SET UP UNIBUS MAPPING ADDRESS          ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
        ASL     U.BUF(R5)       ;SHIFT ADDRESS EXTENSION BITS INTO PLACE; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
3$:                             ;REF LABEL                              ; RP007
                                                                        ; RP007
                                                                        ;**-8
        .IF DF  D$$IAG

        CMPB    #IO.HMS/^D<256>,I.FCN+1(R1)  ;DIAGNOSTIC FUNCTION?
        BNE     5$              ;IF NE NO
        MOV     #FUNTBL,R0      ;GET ADDRESS OF FUNCTION TABLE
4$:     MOVB    (R0)+,U.BUF(R5) ;LOAD CONTROLLER FUNCTION CODE
        CMPB    (R0)+,I.FCN(R1) ;IS IT THE CORRECT CODE?
        BEQ     10$             ;IF EQ YES
        CMP     #FUNTBE,R0      ;END OF FUNCTION TABLE?
        BNE     4$              ;IF NE NO

        .ENDC


5$:     MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        MOVB    #171,U.BUF(R5)  ;ASSUME READ LOGICAL FUNCTION
        CMPB    #IO.RLB/256.,I.FCN+1(R1) ;READ LOGICAL FUNCTION?
        BHIS    6$              ;IF HIS FUNCTION IS LEGAL
        JMP     80$             ;FUNCTION IS ILLEGAL
6$:     BEQ     10$             ;IF EQ FUNCTION IS READ
        SUB     #10,U.BUF(R5)   ;CONVERT TO WRITE LOGICAL FUNCTION
10$:    MOV     #RETRY,RTTBL(R3) ;SET RETRY COUNT


        .IF DF  R$$JPO

        CLRB    U.CW2+1(R5)     ;INITIALIZE RECOVERY VALUES             ; RP004
        CALL    210$            ;SET INITIAL OFFSET RECOVERY VALUES     ;**-1

        .ENDC


        CALL    $BLKCK          ;CHECK LOGICAL BLOCK NUMBER
        MOV     #16.,R1         ;SET DIVIDE LOOP COUNT
20$:    ASL     R0              ;DOUBLE LEFT SHIFT
        ROL     R2              ;
        CMP     R2,#19.*22.     ;PARTIAL REMAINDER LARGER THAN DIVISOR?
        BLO     30$             ;IF LO NO
        SUB     #19.*22.,R2     ;SUBTRACT OUT DIVISOR
        INC     R0              ;ACCUMULATE QUOTIENT
30$:    DEC     R1              ;ANY MORE PARTIAL DIVIDES?
        BGT     20$             ;IF GT YES
        MOV     R0,I.PRM+10(R3) ;SAVE DESIRED CYLINDER ADDRESS
        MOV     R2,R0           ;SET DIVIDEND TO TRACK/SECTOR REMAINDER
        MOV     #22.,R1         ;SET DIVISOR TO NUMBER OF SECTORS/TRACK
        CALL    $DIV            ;CALCULATE TRACK AND SECTOR
        SWAB    R0              ;SWAP TRACK TO HIGH BYTE
        BIS     R1,R0           ;MERGE TRACK
        MOV     R0,I.PRM+12(R3) ;SAVE DESIRED TRACK AND SECTOR ADDRESS


        .IF DF  M$$IXD

        CALL    $RQCH           ;REQUEST CHANNEL

        .ENDC


;
; INITIATE I/O OPERATION
;

40$:                            ;REF LABEL                              ; RP007
                                                                        ; RP007
                                                                        ; RP007
        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUS DEVIS?             ; RP007
        BNE     41$             ;IF NE YES -- DOES NOT USE UMR'S        ; RP007
        CALL    $MPUBM          ;MAP UNIBUS TO MEMORY                   ; RP007
41$:                            ;REF LABEL                              ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR                     ; RP007
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS                 ;**-1
        MOVB    S.ITM(R4),S.CTM(R4) ;SET CURRENT DEVICE TIMEOUT COUNT
        ADD     #10,R2          ;POINT TO SECOND CSR
        MOV     #40,(R2)        ;CLEAR RH11 CONTROLLER AND ALL DRIVES
        MOVB    U.UNIT(R5),(R2) ;SELECT PROPER DRIVE
        MOV     I.PRM+12(R1),-(R2)  ;INSERT TRACK/SECTOR ADDRESS
        MOV     U.BUF+2(R5),-(R2)  ;INSERT BUFFER ADDRESS
        MOV     U.CNT(R5),-(R2) ;INSERT NUMBER OF BYTES TO TRANSFER
        ROR     (R2)            ;CONVERT TO WORD COUNT
        NEG     (R2)            ;MAKE NEGATIVE WORD COUNT
        MOV     #23,-(R2)       ;EXECUTE PACK ACK FUNCTION TO SET VV


        .IF NDF R$$JPO!D$$IAG

        MOV     #FMT22,RPOF(R2) ;SET 16 BIT FORMAT

        .IFF

        MOV     #FMT22,-(SP)    ;GET FORMAT BIT


        .IF DF  D$$IAG

        CMP     #IO.OFF!IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC OFFSET FUNCTION?
        BNE     44$             ;IF NE NO
        BIS     I.PRM+6(R1),(SP)  ;YES, SET OFFSET VALUE
44$:                            ;REF LABEL

        .ENDC


        .IF DF  R$$JPO

        BITB    #IHC,U.CW2+1(R5)  ;INHIBIT HEADER COMPARE               ; RP004
        BEQ     45$             ;IF EQ NO                               ;**-1
        BIS     #HCI,(SP)       ;SET HEADER COMPARE INHIBIT

        .ENDC


45$:    MOV     (SP)+,RPOF(R2)  ;SET OFFSET REGISTER

        .ENDC


        MOV     #IE.DNR&377,R0  ;ASSUME DRIVE NOT READY
        MOV     I.PRM+10(R1),RPDC(R2)  ;SET DESIRED CYLINDER ADDRESS
        MOV     RPDS(R2),R3     ;GET CURRENT DRIVE STATUS
        COM     R3              ;COMPLEMENT STATUS
        BIT     #MOL!DRY!VV,R3  ;DRIVE READY AND ON-LINE?
        BNE     46$             ;IF NE NO
        BIT     #UNS,RPER1(R2)  ;DRIVE UNSAFE?
        BEQ     48$             ;IF EQ NO
46$:                            ;REF LABEL


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;IS DRIVE SPINNING UP?
        BNE     50$             ;IF NE YES

        .IFTF


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC OPERATION?
        BEQ     47$             ;IF EQ NO
        JMP     58$             ;PROCESS DIAGNOSTIC NOT READY
47$:                            ;REF LABEL

        .ENDC


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DRIVE NOT READY ERROR

        .ENDC


        JMP     80$             ;FINISH UP
48$:                            ;REF LABEL

        .IFT

        BICB    #US.SPU,U.STS(R5)  ;RESET DRIVE SPINNING UP

        .ENDC


        .IF DF E$$DVC                                                   ; RP007
                                                                        ; RP007
        CALL    $BMSET          ;SET I/O ACTIVE IN BIT MAP              ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
        .IF DF M$$EXT                                                   ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;;;IS IT A MASS BUS DEVICE?          ; RP007
        BEQ     49$             ;;;IF EQ NO -- DOES USE UMR'S           ; RP007
        MOVB    U.BUF+1(R5),RPBAE(R2)  ;;;SET ADDRESS EXTENSION BITS    ; RP007
        MOVB    U.BUF(R5),(R2)  ;;;START FUNCTION                       ; RP007
        RETURN                  ;;;                                     ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
49$:    MOV     U.BUF(R5),(R2)  ;;;START FUNCTION                       ; RP007
                                                                        ;**-23

;
; CANCEL I/O OPERATION IS A NOP FOR FILE STRUCTURED DEVICES.
;

DBCAN:  RETURN                  ;;;NOP FOR RP04/05/06

;+
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND
; CAUSES NO IMMEDIATE ACTION ON THE UNIT.  THE CURRENT TIMEOUT
; COUNT IS EXTENDED SO THAT IF THE UNIT WAS BUSY IT WILL HAVE
; SUFFICIENT TIME TO SPIN BACK UP.  THE NEXT I/O REQUEST TO ANY
; UNIT WILL BE SUSPENDED FOR AT LEAST THE EXTENDED TIMEOUT UNLESS
; THE UNIT IS ALREADY READY.
;-

DBPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        TSTB    S.STS(R4)       ;IS THIS UNIT CURRENTLY BUSY?
        BEQ     51$             ;IF EQ NO
        MOVB    #4,S.STS(R4)    ;WAIT A MAXIMUM OF ONE MINUTE
50$:    MOVB    #15.,S.CTM(R4)  ;15 SECONDS AT A TIME
51$:    BISB    #US.SPU,U.STS(R5)  ;SET UNIT SPINNING UP

        .ENDC


        RETURN                  ;WAIT FOR UNIT TO RESPOND

;+
; **-$DBINT-RH11-RP04/05/06 DISK PACK CONTROLLER
;       INTERRUPT HANDLER
;-

        INTSE$  DB,PR5,R$$JP1   ;;;SAVE REGISTERS AND SET PRIORITY
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC FUNCTION EXECUTED?
        BNE     58$             ;IF NE YES

        .ENDC


        .IF DF  R$$JPO

        BIT     #40,(R2)        ;OFFSET OR RTC FUNCTION?
        BEQ     55$             ;IF EQ YES

        .ENDC


        BIT     #TRE!MCPE,(R2)  ;ANY ERRORS?
        BEQ     65$             ;IF EQ NO


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DEVICE ERROR

        .ENDC


        MOV     #IE.WLK&377,R0  ;ASSUME WRITE LOCK ERROR
        BIT     #WLE,RPER1(R2)  ;WRITE LOCK ERROR?
        BNE     70$             ;IF NE YES
        MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
        BNE     67$             ;IF NE YES
        MOV     RPER1(R2),R1    ;GET CONTENTS OF ERROR REGISTER
        BIT     #UNS!IAE!AOE!RMR!ILR!ILF,R1  ;HARD ERROR?
        BNE     70$             ;IF NE YES
        BIT     #NED!NEM,RPCS2(R2) ;HARD ERROR?
        BNE     70$             ;IF NE YES
        BIT     #DLT!WCE!UPE!PGE!MXF!MDPE,RPCS2(R2)  ;CONTROLLER ERROR?
        BNE     60$             ;IF NE YES, RETRY OPERATION
        BR      100$            ;


        .IF DF  R$$JPO

55$:    MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR
        CMP     #OFFTB+14,OFFAD(R3)  ;FINAL OFFSET TRIED?               ; RP004
        BEQ     70$             ;IF EQ YES - ALL DONE                   ;**-1
        BIT     #ERR,RPDS(R2)   ;ANY ERRORS?
        BNE     61$             ;IF NE YES                              ; RP004
                                                                        ;**-1
        .ENDC


56$:    JMP     40$             ;RETRY ORIGINAL FUNCTION


;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING REPEATED
; UNLESS THE OPERATION WAS DIAGNOSTIC.  TIMEOUTS ARE USUALLY CAUSED
; BY POWERFAILURE BUT MAY ALSO BE THE RESULT OF A HARDWARE FAILURE.
;

DBOUT:                          ;;;TIMEOUT ENTRY POINT


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;;;IS DRIVE SPINNING UP?
        BEQ     57$             ;;;IF EQ NO
        DECB    S.STS(R4)       ;;;HAVE WE WAITED ENOUGH YET?
        BEQ     57$             ;;;IF EQ YES
        MTPS    #0              ;;;ALLOW INTERRUPTS
        BR      56$             ;RETRY OPERATION
57$:    INCB    S.STS(R4)       ;;;LEAVE CONTROLLER BUSY
        BICB    #US.SPU,U.STS(R5)  ;;;RESET DRIVE SPINNING UP

        .ENDC


        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT


        .IF DF  D$$IAG

        BCC     60$             ;IF CC TIMEOUT DURING NORMAL FUNCTION
58$:    CALL    $CRPAS          ;PASS CONTROLLER REGISTERS TO TASK
        BR      70$             ;DIAGNOSTIC PROCESSING COMPLETE

        .ENDC


60$:    MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
        BNE     67$             ;IF NE YES
                                                                        ;**-1

        .IF DF  R$$JPO

        BITB    #OFA,U.CW2+1(R5)  ;TEST OFFSET ACTIVE?                  ; RP004
        BEQ     61$             ;IF EQ NO                               ; RP004
        JMP     185$            ;CONTINUE OFFSET RECOVERY               ; RP004
61$:    DECB    RTTBL(R3)       ;RETRY FUNCTION?                        ; RP004
        BGT     95$             ;IF GT YES

        .IFF

        DECB    RTTBL(R3)       ;RETRY FUNCTION?                        ; RP004
        BGT     56$             ;IF GT YES

        .ENDC


        .IF DF  D$$WCK

        BR      67$             ;FINISH UP

        .IFTF

65$:                            ;REF LABEL

        .IFT

        BITB    #IO.WLC&377,I.FCN(R1)  ;WRITE FOLLOWED BY WRITE CHECK?
        BNE     66$             ;IF NE YES
        BITB    #US.WCK,U.STS(R5)  ;WRITE CHECK ENABLED BY MCR?
        BEQ     70$             ;IF EQ NO
66$:    CMPB    #171,U.BUF(R5)  ;WAS LAST FUNCTION A READ?
        BEQ     70$             ;IF EQ YES
        CMPB    #161,U.BUF(R5)  ;WAS LAST FUNCTION A WRITE?
        BNE     70$             ;IF NE NO
        MOVB    #151,U.BUF(R5)  ;SET WRITE CHECK FUNCTION
        MOV     #RETRY,RTTBL(R3);REINITIALIZE RETRY COUNT
        BR      56$             ;START WRITE CHECK OPERATION

        .IFTF

67$:                            ;REF LABEL

        .IFT

        BIT     #WCE,RPCS2(R2)  ;WRITE CHECK ERROR?
        BEQ     70$             ;IF EQ NO
        MOV     #IE.WCK&377,R0  ;SET WRITE CHECK ERROR

        .ENDC


70$:    MOV     S.PKT(R4),R3    ;GET I/O PACKET ADDRESS
        MOV     RPWC(R2),R1     ;GET WORDS REMAINING TO TRANSFER
        ASL     R1              ;CONVERT TO BYTES LEFT TO TRANSFER
        ADD     I.PRM+4(R3),R1  ;CALCULATE BYTES ACTUALLY TRANSFERED
        MOV     #40011,(R2)     ;CLEAR CONTROLLER AND DRIVE
80$:                            ;REF LABEL


        .IF DF  E$$DVC

        MOVB    S.CON(R4),R3    ;RETRIEVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ;GET FINAL ERROR RETRY COUNT
        BIS     #RETRY*256.,R2  ;MERGE STARTING RETRY COUNT

        .ENDC


        .IF DF  M$$IXD

        CALL    $RLCH           ;RELEASE CHANNEL

        .ENDC


        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DBINI           ;PROCESS NEXT REQUEST


        .IF DF  R$$JPO

95$:    CMPB    #171,U.BUF(R5)  ;IS THIS A READ OPERATION?
        BNE     56$             ;IF NE NO
        BISB    #OFA,U.CW2+1(R5)  ;SET OFFSET ACTIVE                    ; RP004
        JMP     170$            ;RESET OFFSET TO ZERO

        .IFTF

100$:                           ;REF LABEL

        .IFT

        BIT     #DTE!HCRC,R1    ;DRIVE TIMING OR HEADER CRC ERROR?      ; RP010
        BNE     105$            ;IF NE YES                              ;**-1
        BIT     #HCE,R1         ;HEADER COMPARE ERROR?                  ; RP010
        BEQ     102$            ;IF EQ NO                               ; RP010
        JMP     230$            ;GO ISSUE RECALIBRATE TO RECOVER        ; RP010
102$:                   ;REF LABEL                                      ; RP010

        .IFTF

        TST     R1              ;DATA CHECK ERROR?
        BPL     60$             ;IF PL NO

        .IFF

        BIT     #ECH,R1         ;ECC HARD ERROR?
        BNE     60$             ;IF NE YES

        .ENDC

;
; START ECC CORRECTION PROCEDURE
;
; FIRST CALCULATE THE BYTE OFFSET TO THE START OF BLOCK TRANSFERED
;

105$:   CMPB    #171,U.BUF(R5)  ;IS THIS A READ OPERATION?
        BNE     60$             ;IF NE NO
        MOV     R1,R3           ;COPY ERROR REGISTER 1                  ; RP010
        BIS     RPER2(R2),R3    ;OR ERROR REGISTER 2                    ; RP010
        BISB    RPCS2+1(R2),R3  ;OR HIGH BYTE OF STATUS REGISTER 2      ; RP010
        CMP     #DCK,R3         ;IS IT ONLY A DATA CHECK ERROR?         ; RP010
        BNE     60$             ;IF NE NO, SOME OTHER ERROR             ; RP010


        .IF DF  S$$ECC

        MOV     R2,R3           ;COPY CSR ADDRESS
        ADD     #RPEC1,R3       ;POINT TO ECC POSITION REGISTER
        CALL    $ECCOR          ;CALL SHARED ECC ROUTINE


        .IF DF  R$$JPO

        BCS     155$            ;OFFSET RECOVERY REQUIRED

        .ENDC


        .IFF

        MOV     RPWC(R2),R0     ;GET NEGATIVE NUMBER OF WORDS REMAINING
        ASL     R0              ;CONVERT TO NEGATIVE BYTES REMAINING
        ADD     U.CNT(R5),R0    ;CALCULATE NUMBER OF BYTES TRANSFERED


        .IF DF  R$$JPO

        MOV     R0,-(SP)        ;SAVE NUMBER OF BYTES TRANSFERED
        BEQ     150$            ;IF EQ NO BYTES TRANSFERED
        BIT     #HCRC,R1        ;HEADER CRC ERROR?                      ; RP010
        BNE     107$            ;IF NE YES                              ;**-1

        .IFTF

        DEC     R0              ;CALCULATE OFFSET TO START OF BLOCK
107$:   BIC     #777,R0         ;CLEAR RESIDUE

        .IFT

        BIT     #DTE!ECH!HCRC,R1  ;ECC HARD ERROR?                      ; RP010
        BNE     150$            ;IF NE YES                              ;**-1

        .ENDC


;
; SECOND CALCULATE BYTE OFFSET IN BLOCK AND POSITION PATTERN SHIFT COUNT
;

        MOV     RPEC1(R2),R1    ;GET STARTING BIT NUMBER
        DEC     R1              ;CONVERT TO RELATIVE BIT NUMBER
        MOV     R1,-(SP)        ;SAVE STARTING RELATIVE BIT NUMBER
        BIC     #^C<17>,R1      ;ISOLATE SHIFT COUNT
        BIC     R1,(SP)         ;CLEAR SHIFT COUNT IN RELATIVE BIT NUMBER
        CLC                     ;CALCULATE OFFSET TO FIRST BYTE IN BLOCK
        ROR     (SP)            ;
        ASR     (SP)            ;
        ASR     (SP)            ;
        ADD     (SP),R0         ;CALCULATE OFFSET TO FIRST BYTE IN TRANSFER

;
; THIRD SHIFT CORRECTION PATTERN INTO PLACE
;

        MOV     RPEC2(R2),R3    ;GET CORRECTION PATTERN WORD
        CLR     (SP)            ;CLEAR SECOND WORD
110$:   DEC     R1              ;ANY MORE SHIFTS TO PERFORM?
        BLT     120$            ;IF LT NO
        ASL     R3              ;DOUBLE LEFT SHIFT
        ROL     (SP)            ;
        BR      110$            ;

;
; FOURTH APPLY FIRST CORRECTION
;

120$:   CALL    130$            ;APPLY ECC CORRECTION

;
; FIFTH APPLY SECOND CORRECTION
;

        MOV     (SP)+,R3        ;RETRIEVE SECOND PATTERN WORD
        ADD     #2,R0           ;UPDATE OFFSET TO TRANSFER
        CALL    130$            ;APPLY ECC CORRECTION

;
; SIXTH FINISH OR CONTINUE PREVIOUS FUNCTION
;

        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        MOVB    #11,(R2)        ;CLEAR DRIVE ERRORS


        .IF DF  R$$JPO

        MOV     (SP)+,R1        ;GET BYTES ACTUALLY TRANSFERED

        .ENDC


        .ENDC


        .IF DF  R$$JPO

        MOVB    S.CON(R4),R3    ;PICK-UP CONTROLLER INDEX
        CALL    210$            ;RESET RECOVERY PARAMETERS
        SUB     R1,U.CNT(R5)    ;ANY MORE WORDS TO TRANSFER?

        .IFF

        TST     RPWC(R2)        ;ANY MORE WORDS TO TRANSFER?

        .IFTF

        BEQ     70$             ;IF EQ NO

        .IFT


        .IF DF  M$$MGE


        .IF DF  M$$EXT

        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUS DEVICE?            ; RP007
        BEQ     125$            ;IF EQ NO -- DOES USE UMR'S             ; RP007
        MOVB    RPBAE(R2),U.BUF+1(R5)  ;SAVE MEMORY EXTENSION BITS      ; RP007
        BR      126$            ;                                       ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
125$:   MOVB    1(R2),U.BUF(R5) ;SAVE MEMORY EXTENSION BITS             ; RP007
        BICB    #^C<3>,U.BUF+1(R5)  ;CLEAR EXCESS BITS                  ; RP007
126$:                           ;REF LABEL                              ; RP007
                                                                        ;**-8

        .ENDC


        MOV     RPBA(R2),U.BUF+2(R5) ;SAVE BUFFER ADDRESS
        MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        MOV     RPDC(R2),I.PRM+10(R1) ;SAVE CYLINDER ADDRESS
        MOV     RPDA(R2),I.PRM+12(R1) ;SAVE TRACK/SECTOR ADDRESS

        .ENDC


        MOVB    U.BUF(R5),(R2)  ;RESTART PREVIOUS OPERATION
        RETURN                  ;

;
; ECC CORRECTION ROUTINE
;


        .IF NDF S$$ECC

130$:   CMP     R0,U.CNT(R5)    ;BYTE OFFSET WITHIN RANGE?
        BHIS    140$            ;IF HIS NO


        .IF DF  D$$IAG

        CALL    $RELOP          ;RELOCATE PHYSICAL ADDRESS

        .IFF


        .IF DF  M$$MGE

        MOV     U.BUF(R5),-(SP) ;RETRIEVE ORIGINAL MEMORY EXTENSION BITS
        CLRB    (SP)            ;CLEAR FUNCTION BYTE

        .IFTF

        MOV     U.BUF+2(R5),R1  ;RETRIEVE STARTING BUFFER ADDRESS
        ADD     R0,R1           ;CALCULATE ADDRESS OF WORD TO BE CORRECTED

        .IFT

        ADCB    1(SP)           ;PROPAGATE ADDRESS CARRY
        SWAB    R1              ;SWAP STARTING BUFFER ADDRESS
        BISB    R1,(SP)         ;MERGE 8 BITS OF UPPER ADDRESS BIAS
        ASL     R1              ;COLLECT REMAINING TWO BITS
        ROL     (SP)            ;
        ASL     R1              ;
        ROL     (SP)            ;
                                                                        ; RP007
                                                                        ; RP007
        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUS DEVICE?            ; RP007
        BNE     135$            ;IF NE YES -- DOES NOT USE UMR'S        ; RP007
        ADD     #170000,(SP)    ;FORCE ADDRESS TO BE CALCULATED THROUGH ; RP007
                                ;UNIBUS MAP                             ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
135$:   MOV     (SP)+,KISAR6    ;SET BUFFER RELOCATION BIAS             ; RP007
        CLRB    R1              ;CLEAR LOW BYTE OF STARTING ADDRESS     ;**-1
        SWAB    R1              ;SWAP ADDRESS BACK
        ASR     R1              ;SETUP APR6 ADDRESS
        ASR     R1              ;
        BIS     #140000,R1      ;

        .ENDC


        .ENDC


        MOV     (R1),-(SP)      ;COPY CURRENT DATA WORD
        BIC     R3,(R1)         ;.NOT.PATTERN.AND.DATA WORD
        BIC     (SP)+,R3        ;.NOT.DATA WORD.AND.PATTERN
        BIS     R3,(R1)         ;PATTERN.OR.DATA WORD
140$:   RETURN                  ;

        .ENDC


;
; OFFSET RECOVERY
;


        .IF DF  R$$JPO

150$:   TST     (SP)+           ;REMOVE COUNT FROM STACK
155$:   TST     R0              ;ANY GOOD SECTORS TRANSFERED?
        BEQ     180$            ;IF EQ NO

;
; THE TRANSFER ENDED IN AN ECC HARD ERROR BUT THERE WERE SECTORS
; TRANSFERED THAT CONTAINED GOOD DATA. SINCE THE ECC HARD ERROR COULD
; HAVE BEEN CAUSED BY A CYLINDER CROSSING, THE GOOD DATA IS SAVED
; AND THE TRANSFER IS RETRIED FROM THE POINT OF ERROR.
;

        ADD     R0,U.BUF+2(R5)  ;UPDATE STARTING BUFFER ADDRESS
        ADCB    U.BUF+1(R5)     ;PROPAGATE CARRY INTO EXTENSION BITS
        SUB     R0,U.CNT(R5)    ;REDUCE BYTES REMAINING TO TRANSFER
        SWAB    R0              ;CALCULATE NUMBER OF SECTORS TRANSFERED
        ASR     R0              ;
        MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        ADD     I.PRM+12(R1),R0 ;UPDATE TRACK/SECTOR ADDRESS
160$:   CMPB    #22.,R0         ;SECTOR OVERFLOW?
        BHI     165$            ;IF HI NO
        SUB     #22.,R0         ;SUBTRACT OUT A SECTOR
        ADD     #1*256.,R0      ;ADD IN A TRACK
        CMP     #19.*256.,R0    ;TRACK OVERFLOW?
        BHI     160$            ;IF HI NO
        SUB     #19.*256.,R0    ;NORMALIZE TRACK ADDRESS
        INC     I.PRM+10(R1)    ;UPDATE CYLINDER ADDRESS
        BR      160$            ;
165$:   MOV     R0,I.PRM+12(R1) ;SET UPDATED TRACK/SECTOR ADDRESS
170$:   CALL    220$            ;RESET OFFSET TABLE ADDRESS
175$:   MOV     #117,R1         ;SET RTC FUNCTION
        MOVB    #16.,RTTBL+1(R3) ;TRY 16. TIMES AT CENTERLINE
        MOV     #FMT22,R0       ;RESET OFFSET VALUE TO ZERO
        BR      190$            ;

;
; NO GOOD DATA WAS TRANSFERED - CHECK IF OFFSET SHOULD BE CHANGED
;

180$:   BIT     #DCK!DTE!ECH,R1 ;DATA CHECK OR DRIVE TIMING ERROR?
        BNE     185$            ;IF NE YES
        BISB    #IHC,U.CW2+1(R5)  ;SET HEADER COMPARE INHIBIT FLAG      ; RP004
185$:   DECB    RTTBL+1(R3)     ;CHANGE OFFSET?                         ;**-1
        BGT     200$            ;IF GT NO
        ADD     #2,OFFAD(R3)    ;UPDATE OFFSET POINTER
        MOV     @OFFAD(R3),R0   ;GET NEXT OFFSET VALUE
        BEQ     175$            ;IF EQ RETURN TO CENTERLINE
        MOV     #115,R1         ;SET OFFSET FUNCTION
        MOVB    #2,RTTBL+1(R3)  ;SET RECOVERY RETRY COUNT
        BIT     #2,RPDT(R2)     ;IS THIS DRIVE AN RP04?
        BEQ     190$            ;IF EQ YES
        ASRB    R0              ;NO, IT'S AN RP06 SO ADJUST OFFSET ...
        BIC     #100,R0         ;... VALUE AND SIGN ACCORDINGLY
190$:   MOV     #TRE!11,(R2)    ;CLEAR CONTROLLER AND DRIVE
        MOV     R0,RPOF(R2)     ;LOAD NEXT OFFSET VALUE
        BICB    #IHC,U.CW2+1(R5)  ;CLEAR HEADER COMPARE INHIBIT FLAG    ; RP004
        MOVB    S.ITM(R4),S.CTM(R4) ;RESET TIMEOUT COUNT                ;**-1
        MOVB    R1,(R2)         ;INITIATE OFFSET FUNCTION
        RETURN                  ;
200$:   JMP     40$             ;RETRY FUNCTION

;
; SET OFFSET RECOVERY PARAMETERS
;

210$:   MOVB    #1,RTTBL+1(R3)  ;SET RECOVERY COUNT TO ONE
220$:   MOV     #OFFTB-2,OFFAD(R3) ;SET OFFSET TABLE POINTER
        RETURN                  ;
                                                                        ; RP010
;                                                                       ; RP010
; SET RECOVERY RECALIBRATION FOR 'HCE' ERROR                            ; RP010
;                                                                       ; RP010
                                                                        ; RP010
230$:   MOV     #TRE!11,(R2)    ;CLEAR CONTROLLER AND DRIVE             ; RP010
        MOVB    S.ITM(R4),S.CTM(R4)  ;RESET TIMEOUT COUNT               ; RP010
        MOV     #107,(R2)       ;LOAD THE RECALIBRATE COMMAND           ; RP010
        RETURN                  ;                                       ; RP010

        .ENDC


        .DSABL  LSB

        .END
        .TITLE  DDDRV
        .IDENT  /01/

;
; COPYRIGHT (C) 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE, OR
; ANY OTHER COPIES THEROF, MAY NOT BE PROVIDED OR OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE TERMS. TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT COPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; VERSION 01
;
; M. B. GROSSMAN 9/15/78

; 
; TU58 TAPE CARTRIDGE DRIVER
;
; THIS DRIVER INTERFACES WITH THE TU58 VIA A DL-11 AT 9600 BAUD.
; COMMANDS,DATA AND DEVICE STATUS ARE FORMATED INTO
; STRUCTURED PACKETS OF BYTES IN ACCORDANCE WITH RADIAL SERIAL
; PROTOCOL.
;
; MACRO LIBRARY CALLS
;
        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
;
; EQUATED SYMBOLS
;
RTRY=   1                       ;NUMBER OF DRIVER RETRYS
;
; TU-58 RADIAL SERIAL PROTOCOL SYMBOLS
;
;       INSTRUCTION SET
READ=   2                       ;READ INSTRUCTION
WRITE=  3                       ;WRITE INSTRUCTION
POSIT=  5                       ;POSITION INSTRUCTION -USER MODE DIAG.
DIAG=   7                       ;DIAGONOSE INSTRUCTION -USER MODE DIAG.
;       FLAG BYTES
DATA=   1                       ;DATA FLAG
CNTL=   2                       ;CONTROL FLAG
INIT=   4                       ;INITIALIZE FLAG
CONT=   20                      ;CONTINUE FLAG
;
;
; THE TU-58 NORMALLY INTERFACES VIA A DL-11. AN EXCEPTION TO THIS IS
; THE PDT 130. IN THE CASE OF THE PDT (R$$PDT DEFINED) THE NUMBER AND
; LOCATION OF THE DEVICE REGISTERS ARE DIFFERENT FROM THOSE OF THE
; DL-11.
;***NOTE: AT THIS TIME THE PDT 130 TU-58 CODE IS UNTESTED!

        .IF DF  R$$PDT

DDRCS=  0                       ;RECEIVE CONTROL STATUS REGISTER
DDRBF=  2                       ;BUFFER REGISTER FOR BOTH RECEIVE
DDXBF=  2                       ;       AND TRANSMIT
DDXCS=  4                       ;TRANSMITTER CONTROL STATUS REGISTER

        .IFF

; DL-11 INTERFACE OFFSET SYMBOLS

DDRCS=  0                       ;RECEIVE CONTROL STATUS REGISTER
DDRBF=  2                       ;RECEIVE BUFFER REGISTER
DDXCS=  4                       ;TRANSMITTER CONTROL STATUS REGISTER
DDXBF=  6                       ;TRANSMITTER BUFFER REGISTER


        .ENDC

;
; DL-11 BIT ASSIGNMENTS
;
RDONE=  200                     ;RECEIVER DONE
RIE=    100                     ;RECEIVER INTERRUPT ENABLE
ERR=    100000                  ;RECEIVER DATA ERROR
TRDY=   200                     ;TRANSMITTER READY
TIE=    100                     ;TRANSMITTER INTERRUPT ENABLE
BRK=    1                       ;TRANSMIT BREAK
;
; LOCAL DATA
CNTBL:  .BLKW   T$$U58          ;ADDRESS OF UCB

        .IF GT  T$$U58-1

TEMP:   .BLKW   1               ;TEMP STORAGE FOR CONTROLLER NUMBER

        .ENDC

;
;DRIVER DISPATCH TABLE
;
$DDTBL::  .WORD DDINI
        .WORD   DDCAN
        .WORD   DDOUT
        .WORD   DDPWF
;+
; PROGRAM SEQUENCE CONTROL-
;       PROGRAM FLOW IS CONTROLLED BY A POINTER TO A TABLE
; OF ADDRESSES. THIS SEQUENCE CREATES AND DECODES THE RADIAL
; SERIAL PACKET INFORMATION. THE ACTUAL USER DATA IS
; TRANSFERRED WITHIN THE INTERRUPT SERVICE ROUTINE.
; THIS METHOD PERMITS US TO WAIT FOR INTERRUPTS WITHOUT
; HAVING TO PRESERVE ANY PROCESSOR REGISTERS (INCLUDING THE STACK).
; REPETITIVE SECTIONS OF CODE CAN BE EXECUTED A NUMBER OF TIMES
; WITHOUT LOOP COUNTERS THAT WOULD HAVE TO BE PRESERVED LOCALLY
; WHILE WAITING FOR INTERRUPTS. THIS METHOD ALSO DECREASES PROGRAM
; SIZE BY ALLOWING US TO BRANCH TO ROUTINES INSTEAD OF 
; CALLING THEM WITH A JSB INSTRUCTION.
;       THE POINTER (LOCATION RADD) IS INCREMENTED VIA THE CODE
; IN RTBK (RETURN BACK). RTBK THEN SHIFTS CONTROL TO THE 
; ADDRESS POINTED TO BY RADD. RTBK IS CALLED BY RMSG/SMSG OR
; THE INTERRUPT SERVICE ROUTINE WHENEVER THE DL-11 IS READY
; TO PERFORM THE NEXT NON-DATA TRANSFER OPERATION.
;-

; CTAB-COMMAND PACKET SEQUENCE.
;               CONE IS THE ADDRESS RETURNED TO
;       WHEN THE DL-11 IS READY TO SEND THE FIRST BYTE OF THE 
;       14. BYTE COMMAND PACKET. CTWO IS THE ADDRESS RETURNED TO
;       WHEN READY FOR THE SECOND BYTE, ETC. ETC. CFIF IS EXECUTED
;       AFTER ALL THE BYTES IN THE COMMAND PACKET ARE SENT.
;
CTAB:   .WORD   CONE,CTWO,CTHR,CFOUA,CFOUB,CFIV,CSIX,CSEV
        .WORD   CEIG,CNIN,CTEN,CELE,CTWE,CTHI,CFOR,CFIF
;
; ITAB- INITIALIZATION SEQUENCE
;
ITAB:   .WORD   IONE,ITWOA,ITWOB,ITWOC,ITWOD,ITWOE,ITHR,IFOU,IFIV,ISIX ;INIT. SEQ.
;
; TTAB- TRANSMIT DATA SEQUENCE
;
TTAB:   .WORD   TONE,TTWO,TTHR,TFOU,TFIV,TSIX ;OUTGOING (WRITE)DATA PACKET ADDRESSES
;
; RTAB- RECEIVE DATA SEQUENCE
;
RTAB:   .WORD   RONE,RTWO,RTHR,RFOU ;INCOMING (READ) DATA PACKET ADDRESSES
;
; ETAB- END PACKET DECODE SEQUENCE
;
ETAB:   .WORD   EONE,ETWO,ETHR,EFOU,EFIV,ESIX,ESEV ;READ END PACKET
        .WORD   EEIG,ENIN,ETEN,EELE,ETWE,ETHI      ;FROM TU-58
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;
RDAT:   .BLKW   T$$U58          ;RECEIVED DATA
RADD:   .BLKW   T$$U58          ;RETURN ADDRESS POINTER
DBUF:   .BLKW   T$$U58          ;DL-11 BUFFER ADDRESS
CKSM1:  .BLKW   T$$U58          ;CHECKSUM STORAGE-1ST WORD
                                ; ALSO TEMPORARY DRIVER STORAGE
CKSM2:  .BLKW   T$$U58          ;CHECKSUM STORAGE-2ND WORD
                                ; ALSO TEMPRORARY DRVIER STORAGE
FLAG:   .BLKW   T$$U58          ;LOW BYTE-BYTE COUNT
                                ;HIGH BYTE-SEND/REC. FLAG
WCNT:   .BLKW   T$$U58          ;BYTES LEFT TO BE WRITTEN
                                ;ALSO USED FOR RETURN ADDRESS
                                ;DURING IOPKT SUBROUTINE
                                ;ALSO USED FOR INITIALIZATION RETRY CONT

;+
; **-DDINI- TU58 TAPE CARTRIDGE INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN
; AN I/O REQUEST IS QUEUED AND AT THE END OF A PREVIOUS 
; I/O OPERATION TO PROPAGATE THE EXECUTION OF THE DRIVER.
; IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN
; ATTEMPT IS MADE TO DEQUEUE THE NEXT I/O REQUEST
; IF THE CONTROLLER IS BUSY A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN
; THE NEXT I/O OPERATION IS INITIATED. 
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O
;       REQUEST IS WAITING TO BE PROCESSED,
;       THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INTITIATED,
;-
        .ENABL LSB
DDINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCC     10$
        RETURN                  ;IF CS CONTROLLER BUSY OR NO REQUEST
;

; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; TU58 TAPE CARTRIDGE DRIVE I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO 2ND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF 1ST LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB, IO.WLB, IO.DGN, IO.BLS)
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER
;       WD. 14 -- NUMBER OF BYTES TO TRANSFER
;       WD. 15 -- NOT USED
;       WD. 16 -- LOW BYTE MUST BE ZERO, HIGH BYTE NOT USED
;       WD. 17 -- LOGICAL OR PHYSICAL BLOCK NUMBER
;       WD. 20 -- NOT USED
;
; DRIVE USUAGE OF UCB
;       U.CW2+1 --- STORES DRIVER'S RETRY COUNT
;
;+
; THE TU58 UTILIZES RADIAL SERIAL PROTOCOL. ALL I/O
; COMMANDS ARE INITIATED BY SENDING A COMMAND MESSAGE
; PACKET CONSISTING OF 14. BYTES OF INFORMATION. DATA
; IS THEN TRANSFERRED TO THE UNIT (WRITE) OR TO THE
; USER'S BUFFER (READ) IN MESSAGE PACKETS OF UP TO 128
; BYTES EACH. TERMINATION OF AN OPERATION BY THE TU58
; IS SIGNALED BY THE UNIT'S SENDING AN END MESSAGE
; PACKET WHICH CONTAINS INFORMATION CONCERNING THE 
; SUCCESS OF THE TRANSFER.
;-
;
10$:    MOV     R5,CNTBL(R3)    ;STORE UCB ADDRESS
        MOVB    #RTRY,U.CW2+1(R5) ;STORE RETRY COUNT
        MOV     S.CSR(R4),-(SP) ;SAVE DL-11 BUFFER ADDRESS
        MOV     R3,R4           ;STORE CONTROLLER NUMBER IN R4
        MOV     (SP)+,DBUF(R4)  ;DBUF=BUFFER ADDRESS
        CALL    $BLKCK          ;CHECK PARAMETERS
        ADD     #DDXBF,DBUF(R4) ;SAVE DL-11 XMITTER BUFFER
;
; ENTRY POINT FOR FUNCTION RETRY.
;
RINI:   MOV     #CTAB-2,RADD(R4) ;POINT TO WORD PRIOR TO COMMAND TABLE
        CLR     FLAG(R4)        ;SET FLAG FOR TRANSMIT INTERRUPTS
        BR      145$            ;PREPARE TO SEND BYTE
;
; SEND COMMAND PACKET
;
CONE:   MOVB    #CNTL,@DBUF(R4) ;SEND COMMAND FLAG BYTE
        BR      145$            ;PREPARE TO SEND BYTE
CTWO:   MOV     #10.,@DBUF(R4)  ;SEND BYTE COUNT
        MOVB    #10.,CKSM1+1(R4) ;CREATE CHECKSUM WORD FROM
        MOVB    #CNTL,CKSM1(R4) ; FIRST TWO BYTES
        BR      145$
CTHR:   CALL    IOPKT           ;STORE I/O PKT ADDRESS IN R1
;
; POSITION AND DIAGNOSE FUNCTIONS ARE USER MODE DIAGNOSTIC FUNCTIONS
;

        .IF DF  D$$IAG

        CMP     #IO.DGN!IQ.UMD,I.FCN(R1) ;TU-58 INTERNAL DIAGNOSIS?
        BNE     40$             ;IF NE NO
        MOV     #DIAG,CKSM2(R4) ;CREATE NEXT CHECKSUM WORD
        MOVB    #DIAG,@DBUF(R4) ;SEND DIAGNOSTIC OP CODE
        BR      140$            ;CONTINUE OPERATION
40$:    CMP     #IO.BLS!IQ.UMD,I.FCN(R1) ;POSITION FUNCTION?
        BNE     60$             ;IF NE NO
        MOV     #POSIT,CKSM2(R4) ;CREATE NEXT CHECKSUM WORD
        MOVB    #POSIT,@DBUF(R4) ;SEND OP CODE
        BR      140$            ;CONTINUE

        .ENDC

60$:    CMPB    #IO.RLB/256.,I.FCN+1(R1) ;READ LOGICAL BLOCK?
        BNE     70$             ;IF NE NO
        MOV     #READ,CKSM2(R4) ;CREATE NEXT CHECKSUM WORD
        MOVB    #READ,@DBUF(R4) ;SEND READ OPCODE
        BR      110$            ;CONTINUE
70$:    CMPB    #IO.WLB/256.,I.FCN+1(R1) ;WRITE LOGICAL BLOCK?
        BEQ     100$            ;IF EQ YES
        MOV     (SP)+,R1        ;RESTORE R1
        CALL    $FORK           ;ENSURE PRIORITY=0 AND REGISTERS SAVED
        MOV     #IE.IFC&377,R0  ;ILLEGAL FUNCTION CODE
        CLR     CKSM2(R4)       ;CLEAR BYTES TRANSFERRED
        JMP     IOCMP           ;EXIT
100$:   MOV     #WRITE,CKSM2(R4) ;CREATE NEXT CHECKSUM WORD
        MOVB    #WRITE,@DBUF(R4) ;SEND WRITE OPCODE
110$:   BITB    #US.WCK,U.STS(R5) ;WRITE CHECK SET?
        BNE     141$
        CMPB    #20,I.FCN(R1)   ;IS WLC OR RLC REQUESTED?
        BNE     140$            ;IF NE NO
        BR      141$
;
; THIS CODE SENDS A MODIFIER BYTE OF ONE FOR WRITECHECK AND READCHECKS
;
CFOUA:  MOVB    #1,CKSM2+1(R4)  ;ALTER CHECKSUM 
        MOVB    #1,@DBUF(R4)    ;SEND MODIFIER
        ADD     #2,RADD(R4)     ;SKIP OVER NEXT RETURN ADDRESS
        BR      160$            ;CONTINUE
140$:   ADD     #2,RADD(R4)     ;SKIP OVER NEXT RETURN ADDRESS
141$:   MOV     (SP)+,R1        ;RESTORE R1
145$:   JMP     SMSG
;
; THIS CODE SENDS A ZERO MODIFIER BYTE FOR READS AND WRITES
;
CFOUB:  CLRB    @DBUF(R4)       ;SEND MODIFIER
160$:   CALL    CHKPT           ;CHECKSUM CALCULATION
        BR      145$
CFIV:   MOVB    U.UNIT(R5),@DBUF ;SEND UNIT #
        MOVB    U.UNIT(R5),CKSM2(R4)
        BR      145$
CSIX:   CLRB    @DBUF(R4)       ;SEND 0
        CLRB    CKSM2+1(R4)
        BR      160$
CSEV:
CEIG:   CLRB    @DBUF(R4)       ;SEND TWO ZERO BYTES
        BR      145$
CNIN:   CALL    IOPKT   ;STORE I/O PKT ADDRESS IN R1
        MOVB    I.PRM+4(R1),@DBUF(R4) ;SEND LOW BYTE COUNT
        MOV     I.PRM+4(R1),CKSM2(R4) ;CREATE CHECKSUM
        BR      141$
;
; NOTE: THE DRIVER REQUIRES THAT THE NUMBER OF BYTES TO BE
;       TRANSFERRED BE EVEN AND THAT THE STARTING ADDRESS OF
;       THE DATA TRANSFER BE ON A WORD BOUNDARY.
;
CTWE:                           ;SEND HIGH BLOCK NO.
CTEN:   MOVB    CKSM2+1(R4),@DBUF(R4) ;SEND HIGH BYTE COUNT
        BR      160$
CELE:   CALL    IOPKT           ;STORE I/O PKT ADDRESS IN R1
        MOVB    I.PRM+12(R1),@DBUF(R4)  ;SEND LOW BLOCK NO.
        MOV     I.PRM+12(R1),CKSM2(R4)
        BR      141$
CTHI:   MOVB    CKSM1(R4),@DBUF(R4) ;SEND LOW CHECKSUM
        BR      145$
CFOR:   MOVB    CKSM1+1(R4),@DBUF(R4) ;SEND HIGH CHECKSUM
        .DSABL  LSB
;+
; AFTER THE COMMAND PACKET IS SENT THE TU58 RESPONDS.
; ITS RESPONSE DEPENDS ON THE OPERATION REQUESTED.
; A CONTINUE IS SENT IN RESPONSE TO A WRITE, THE FIRST
; DATA PACKET IS SENT IN RESPONSE TO A READ, AND AN
; END PACKET IS SENT IN RESPONSE TO A DIAGNOSTIC OR
; POSITION COMMAND. ALSO AN END PACKET MAY BE RECEIVED
; ON A FAILURE TO READ THE FIRST RECORD PROPERLY.
;-
        .ENABL LSB
;
; THE FOLLOWING CODE DETERMINES THE APPROPRIATE INITIAL RESPONSE
; FROM THE TU-58 AND RECEIVES THE FIRST BYTE FROM THE UNIT.
;
        INCB    FLAG+1(R4)      ;SET FLAG FOR RECEIVE
        SUB     #DDXBF-DDRBF,DBUF(R4) ;SET RECEIVE BUFFER
        BR      25$             ;READ THE RESPONSE BYTE FROM TU-58
CFIF:   CALL    IOPKT           ;STORE I/O PKT ADDRESS IN R1

        .IF DF  D$$IAG

        CMPB    #IO.DGN/256.,I.FCN+1(R1) ;DIAGNOSTIC?
        BEQ     10$             ;IF EQ YES

        .ENDC

        JMP     DPACK           ;ELSE RECEIVE DATA PACKET OR CONTINUE
10$:    MOV     (SP)+,R1        ;RESTORE R1
;+
; THE FOLLOWING CODE RECEIVES AND MANIPULATES THE 
; INFORMATION SENT IN THE TU-58'S END PACKET.
;-
ENDP:   MOV     #ETAB-2,RADD(R4) ;POINT TO END PACKET SEQUENCE
        CMPB    RDAT(R4),#CNTL  ;COMMAND/END PACKET?
        BR      24$
;
; AT EONE WE SHOULD HAVE RECEIVED THE BYTE COUNT OF AN END PACKET
; WHICH IS ALWAYS EQUAL TO 10.
;
EONE:   CMPB    RDAT(R4),#10.   ;BYTE COUNT=10.?
24$:    BNE     NTRY            ;IF NE NO
25$:    JMP     RMSG            ;READ A BYTE
ETWO:   CMPB    RDAT(R4),#100   ;OP CODE=END PACKET?
        BR      24$
ETHR:   MOVB    RDAT(R4),CKSM1(R4) ;STORE SUCCESS CODE
EFOU:                           ;DUMP BYTES
EFIV:
ESIX:
ESEV:   BR      25$
EEIG:   MOVB    RDAT(R4),CKSM2(R4) ;STORE BYTE TRANSFERRED COUNT -LOW
        BR      25$
ENIN:   MOVB    RDAT(R4),CKSM2+1(R4) ;STORE BYTE TRANSFERRED COUNT -HIGH
ETEN:
EELE:
ETWE:   BR      25$             ;DUMP BYTES
ETHI:   CALL    $FORK           ;ENSURE PRIORITY=0 AND REGISTERS SAVED
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESS
        TSTB    CKSM1(R4)       ;SUCCESSFUL?
        BGT     ERRPT           ;IF GT YES, BUT HAD RETRIES
        BEQ     ENDOP           ;IF EQ COMPLETE SUCCESS
        MOV     #IE.DNR&377,R0  ;ASSUME DEVICE NOT READY
        CMPB    CKSM1(R4),#-9.  ;CARTRIDGE NOT IN PLACE?
        BEQ     ENDOP           ;IF EQ YES
        MOV     #IE.WLK&377,R0  ;ASSUME WRITE-LOCKED
        CMPB    CKSM1(R4),#-11. ;WRITE-LOCKED?
        BEQ     ENDOP           ;IF EQ YES
        MOV     #IE.FHE,R0      ;ASSUME FATAL HARDWARE ERROR
        CMPB    CKSM1(R4),#-33. ;MOTOR STOPPED?
        BEQ     ERRPT           ;IF EQ YES
        MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR
ERRPT:
        .IF DF  E$$DVC

; DDDVER ERROR LOGGING ROUTINE FOR NON-TIMEOUT ERRORS
;  THIS ROUTINE IS CALLED WHEN A NON-TIMEOUT DEVICE ERROR OCCURS.
; A CORE BLOCK OF FOUR WORDS (THE APPROPRIATE CSR AND BUFFER, 
; THE SUCCESS CODE & THE BYTES TRANSFERRED COUNT)
; IS ALLOCATED. ERROR LOGGING
; IS THEN CALLED ($DVERR) AND FINALLY, THE CORE BLOCK
; IS DEALLOCATED
; 
; IF FOR ANY REASON THE CORE BLOCK CANNOT BE ALLOCATED THEN
; THE EXECUTIVE ERROR LOGGING ROUTINE WILL NOT BE CALLED
; AND THE ERROR SEQUENCE NUMBER WILL BE UPDATED TO INDICATE
; THAT A MISSED ERROR CONDITION OCCURRED.
; 
DDDVER: MOV     #4*2,R1         ;NUMBER OF BYTES TO ALLOCATE
        MOV     R0,-(SP)        ;SAVE STATUS CODE
        CALL    $ALOCB          ;ALLOCATE A CORE BLOCK
        BCC     80$             ;IF CC BLOCK WAS ALLOCATED
        INC     $ERRSQ          ;INDICATE A MISSED ERROR CONDITION
        BR      90$             ;END I/O ROUTINE
80$:    MOV     R0,R1           ;COPY CORE BUFFER POINTER
        MOV     DBUF(R4),R3     ;STORE BUFFER ADDRESS
        MOV     (R3),(R1)+      ;MOVE DL-11 BUFF INTO CORE BUFF.
        MOV     -(R3),(R1)+     ;MOVE DL-11 CSR INTO CORE BUFF.
        MOVB    CKSM1(R4),(R1)+ ;COPY TU-58 STATUS INFO. INTO CORE 
        CLRB    (R1)+           ;CLEAR HIGH BYTE
        MOV     CKSM2(R4),(R1)  ;STORE BYTE COUNT TRANSFERRED
        MOV     R4,-(SP)        ;STORE CONTROLLER NUMBER
        MOV     U.SCB(R5),R4    ;GET SCB ADDRESS
        MOV     R0,R2           ;
        CALL    $DVERR          ;CALL ERROR LOGGING ROUTINE
        MOV     (SP)+,R4        ;RECOVER CONTROLLER NUMBER
        MOV     #4*2,R1         ;GET NUMBER OF BYTES TO DEALLOCATE
        CALL    $DEACB          ;DEALLOCATE CORE BLOCK
90$:    MOV     (SP)+,R0        ;RESTORE I/O STATUS CODE

        .ENDC

ENDOP:

        .IF DF  D$$IAG

        CALL    IOPKT
        CMPB    #IO.DGN/256.,I.FCN+1(R1) ;DIAGNOSTIC?
        BNE     100$            ;IF NE NO

        .IF DF  M$$MGE

        MOV     I.PRM+14(R1),KISAR6 ;SET BUFFER RELOCATION BIAS

        .ENDC

        MOV     I.PRM+16(R1),R0 ;GET REGISTER BUFFER ADDRESS
        MOV     DBUF(R4),R3     ;GET DL-11 REC. BUFF ADDRESS
        TST     -(R3)           ;POINT TO REC. CSR ADDRESS
        MOV     (R3)+,(R0)+     ;MOV REC. CSR CONTENTS TO USER BUFF.
        MOV     (R3)+,(R0)+     ;MOV REC. BUFF CONTENTS
        MOV     (R3)+,(R0)+     ;MOV TRANS. CSR CONTENTS
        MOV     (R3)+,(R0)+     ;MOV TRANS. BUFF CONTENTS
        MOV     CKSM1(R4),(R0)  ;MOV TU-58 END PACKET INFO.
        MOV     #IS.SUC&377,R0  ;STORE I/O COMPLETION STATUS
100$:   TST     (SP)+           ;RESTORE STACK

        .ENDC

;
; COMMON EXIT CODE- ALL OPERATIONS COMPLETE HERE
;       CKSM2(R4)=BYTES TRANSFERRED
;       U.CW2+1(R5)=FINAL RETRY COUNT
;       R4=CONTROLLER NUMBER
;       R5=UCB ADDRESS
;
IOCMP:  MOV     CKSM2(R4),R1    ;PICKUP BYTES TRANSFERRED COUNT

        .IF DF  E$$DVC

        MOVB    U.CW2+1(R5),R2  ;STORE FINAL RETRY COUNT
        BIS     #RTRY*^D<256>,R2 ;MERGE INITIAL RETRY COUNT

        .ENDC

        CALL    $IODON
        JMP     DDINI           ;NEXT I/O PACKET
        .DSABL LSB
;
;+
; THE FOLLOWING CODE IS ENTERED WHEN AN UNEXPECTED 
; AND UNDESIRED BYTE IS RECEIVED. THE TU-58 IS REINITIALIZED
; AND IF THE RETRY COUNT IS GREATER THAN OR EQUAL TO 0
; THE I/O FUNCTION IS STARTED OVER. OTHERWISE
; AN ERROR IS LOGGED AND THE OPERATION ABORTED.
;-
        .ENABL LSB
NTRY:   DECB    U.CW2+1(R5)     ;DECREMENT RETRY COUNT
        ADD     #DDXBF-DDRBF,DBUF(R4)  ;POINT TO TRANS. BUFFER
;
; TINIT TRIES TO REINITIALIZE THE TU-58. IT WILL
; ATTEMPT THE INITIALIZATION ROUTINE OF
; SENDING BREAK, CLEARING BREAK, SENDING INIT., SENDING INIT. AND
; RECEIVING A CONTINUE.
;
TINIT:  CLR     FLAG(R4)        ;SET FOR TRANSMIT WITH NO USER DATA TRANSFER
        MOV     #ITAB-2,RADD(R4) ;POINT TO INITIALIZE TABLE
        BR      50$             ;WAIT 
;
; NULL TIMING CHARACTERS ARE SENT AT IONE AND ITWO TO ALLOW
; ENOUGH TIME FOR THE BREAK BIT TO CAUSE A FRAMING ERROR. THIS
; SIGNALS THE TU-58 TO STOP TRANSMITTING AND LISTEN.
;
IONE:   MOV     DBUF(R4),CKSM1(R4) ;TEMP. STORE BUFFER
        SUB     #DDXBF-DDXCS,CKSM1(R4)  ;POINT TO XCSR
        BIS     #BRK,@CKSM1(R4) ;SEND BREAK TO TU-58
ITWOA:                          ;SEND TIMING NULLS
ITWOB:
ITWOC:
ITWOD:
ITWOE:  CLRB    @DBUF(R4)       ;
50$:    JMP     SMSG            ;WAIT
;
; ITHR AND IFOU WILL CLEAR THE BREAK CONDITION AND ISSUE
; TWO INITIALIZE COMMANDS TO THE TU-58. (THE FIRST IS IGNORED
; BY THE CONTROLLER).
;
ITHR:   BIC     #BRK,@CKSM1(R4) ;CLEAR BREAK
        SUB     #DDXCS-DDRBF,CKSM1(R4)  ;TEMP. STORE REC. BUFFER
        TSTB    @CKSM1(R4)              ;DUMP REC. BUFFER
IFOU:   MOVB    #INIT,@DBUF(R4) ;SEND ANOTHER INIT.
        BR      50$             ;WAIT 
;
; A CHARACTER IS RECEIVED AT ISIX.
; IF IT IS A CONTINUE WE HAVE SUCCESSFULLY
; INITIALIZED THE DEVICE.
;
IFIV:   SUB     #DDXBF-DDRBF,DBUF(R4) ;POINT TO REC. BUFF.
        INCB    FLAG+1(R4)      ;SET FLAG FOR RECEIVE
        JMP     RMSG            ;WAIT
ISIX:   ADD     #DDXBF-DDRBF,DBUF(R4) ;POINT TO XBUF
        
        TSTB    U.CW2+1(R5)     ;RETRY?
        BGE     60$             ;IF GE YES
        CALL    $FORK           ;ENSURE PRIORITY=0 AND REGISTERS SAVED
        MOV     #IE.FHE&377,R0  ;FATAL ERROR
        CLR     CKSM2(R4)       ;CLEAR BYTE TRANSFER COUNT

        .IF DF  E$$DVC

        MOV     #200,CKSM1(R4)  ;SET ERROR CODE

        .ENDC

        BR      ERRPT           ;ERROR LOG AND EXIT
60$:    JMP     RINI            ;RETRY
;+
; THE FOLLOWING CODE READS DATA PACKETS SENT BY
; THE TU-58. THE NUMBER OF DATA BYTES IN THE PACKET IS
; RECEIVED AT RONE. IT IS STORED IN LOCATION FLAG
; AND THE CHECKSUM IS INITIALIZED. THE DATA IS TRANSFERRED
; WITHIN THE INTERRUPT SERVICE ROUTINE WHERE THE CHECKSUM
; IS ALSO VERIFIED. THE FIRST BYTE OF THE NEXT PACKET IS
; RECEIVED AT RFOU AND IF IT IS
; A DATA FLAG THIS CODE IS ENTERED AGAIN.
;-

DPACK:  CMPB    #IO.RLB/256.,I.FCN+1(R1) ;READ?
        BNE     102$            ;IF NE NO -IT'S A WRITE
        MOV     (SP)+,R1        ;RESTORE R1
RFOU:   CMPB    RDAT(R4),#DATA  ;DATA PACKET?
        BEQ     96$             ;IF EQ YES
94$:    JMP     ENDP
96$:    MOVB    #DATA,CKSM1(R4) ;START CHECKSUM
        MOV     #RTAB-2,RADD(R4) ;POINT TO READ TABLE
        BR      100$            ;READ A BYTE
RONE:   MOVB    RDAT(R4),FLAG(R4) ;STORE BYTE COUNT
        MOVB    RDAT(R4),CKSM1+1(R4)    ;STORE HIGH BYTE OF FIRST CHECKSUM
100$:   JMP     RMSG
;+
; THE FOLLOWING CODE SENDS A DATA PACKET TO BE
; SENT TO THE TU-58.
; THE DATA FLAG BYTE IS SENT AT TONE. THE NUMBER OF DATA
; BYTES IN THIS PACKET IS SENT AT TTWO. DATA IS THEN
; TRANSFERRED ALONG WITH THE CHECKSUM WITHIN THE INTERRUPT
; SERVICE ROUTINE. RETURN TO THIS SEGMENT IS MADE AT TFIV
; AND THE FIRST BYTE OF THE NEXT PACKET IS RECEIVED AT
; TSIX, IF IT IS A CONTINUE ANOTHER PACKET IS SENT.
; WHEN THE TU-58 HAS RECEIVED ALL THE DATA IT SENDS AN
; END PACKET FLAG INSTEAD OF A CONTINUE (THIS ALSO OCCURS
; IF THE TU-58 ENCOUNTERS AN ERROR WRITING THE DATA).
;-

102$:   MOV     I.PRM+4(R1),WCNT(R4) ;DUPLICATE BYTE COUNT
        MOV     (SP)+,R1        ;RESTORE R1
TSIX:   CMPB    RDAT(R4),#CONT  ;CONTINUE FLAG?
        BNE     94$             ;IF NE NO
        MOV     #TTAB-2,RADD(R4) ;POINT TO TRANSMIT(WRITE) TABLE
        CLRB    FLAG+1(R4)      ;SET TRANSMIT FLAG
        ADD     #DDXBF-DDRBF,DBUF(R4) ;SET TRANSMIT BUFFER
        BR      130$            ;PREPARE TO SEND FIRST BYTE
TONE:   MOVB    #DATA,@DBUF(R4) ;SEND FLAG BYTE
        MOVB    #DATA,CKSM1(R4) ;START CHECKSUM
        CMP     #128.,WCNT(R4) ;MORE THAN 1 PACKET LEFT?
        BLO     120$            ;IF L0 YES
125$:   MOVB    WCNT(R4),CKSM1+1(R4) ;CREATE HIGH BYTE OF CHECKSUM
        CLRB    WCNT(R4)        ;ZERO REMAINING BYTE COUNT
        BR      130$
120$:   MOVB    #128.,CKSM1+1(R4) ;CREATE HIGH BYTE OF CHECKSUM
        SUB     #128.,WCNT(R4)  ;ADJUST REMAINING COUNT
130$:   JMP     SMSG
TTWO:   MOVB    CKSM1+1(R4),@DBUF(R4) ;SEND BYTE COUNT
        MOVB    CKSM1+1(R4),FLAG(R4) ;SET UP FLAG BYTE COUNT
        BR      130$
TFIV:   INCB    FLAG+1(R4)      ;SET RECEIVE BYTE
        SUB     #DDXBF-DDRBF,DBUF(R4) ;SET RECEIVE BUFFER
        BR      100$            ;READ A BYTE
        .DSABL LSB

;
;       LOCAL ROUTINES


;+
; IOPKT PUTS I/O PACKET ADDRESS IN R1
;       INPUT: STACK CONTAINS THE RETURN ADDRESS
;       OUTPUTS: R1 = I/O PACKET ADDRESS
;               STACK CONTAINS THE FROMER CONTENTS OF R1
;                       TO BE RESTORED BY THE CALLER
;-
IOPKT:  MOV     (SP)+,WCNT(R4)  ;SAVE RETURN ADDRESS
        MOV     R1,-(SP)        ;PRESERVE R1
        MOV     R4,-(SP)        ;PRESERVE R4
        MOV     U.SCB(R5),R4    ;GET SCB ADDRESS
        MOV     S.PKT(R4),R1    ;GET I/O PKT ADDRESS
        MOV     (SP)+,R4        ;RESTORE R4
        JMP     @WCNT(R4)       ;NOTE R1 WILL BE RESTORED BY PROGRAM
;+
; RTBK (RETURN BACK) INCREMENTS THE RETURN ADDRESS POINTER AND
; RETURNS CONTROL TO THE PROGRAM ADDRESS THAT
; IT THEN POINTS TO.
;       INPUTS: R4=CONTROLLER NUMBER
;-
RTBK:   ADD     #2,RADD(R4)     ;POINT TO NEXT LOCATION
        MOV     @RADD(R4),-(SP) ;MOVE RETURN ADDRESS LOCATION ONTO STACK
        JMP     @(SP)+          ;RETURN TO ADDRESS IN TABLE
;+
; SMSG-SEND MESSAGE BYTE
;
; THIS ROUTINE IS JUMPED TO INORDER TO SEND INFORMATION.
; IT CHECKS TO SEE IF THE DL-11 IS
; READY, IF IT IS, THE MAIN PROGRAM IS RESUMED UNLESS WRITE
; DATA IS TO BE TRANSFERRED (DATA COUNT FLAG= NON ZERO)
; VIA THE INTERRUPT SERVICE ROUTINE CODE (SPT:). IF IT IS 
; NOT READY THE INTERRUPT ENABLE IS SET
; AND A RETURN IS EXECUTED.
;       INPUTS: R4=CONTROLLER NUMBER
;-
        .ENABL  LSB
SMSG:   SUB     #DDXBF-DDXCS,DBUF(R4) ;POINT TO CSR
        BIT     #TRDY,@DBUF(R4) ;IS TRANSMITTER READY
        BEQ     20$
SREC:   ADD     #DDXBF-DDXCS,DBUF(R4) ;POINT TO BUFFER
        TSTB    FLAG(R4)        ;BYTE COUNT 0
        BEQ     RTBK            ;IF EQ YES
        JMP     SPT             ;GO TO SEND DATA ROUTINE
20$:

        .IF DF  E$$DVC

        BIS     S.BMSK(R4),$IOABM ;SET BITMASK

        .ENDC

        BIS     #TIE,@DBUF(R4)  ;SET TRANS. INTER. ENABLE
        MOV     U.SCB(R5),R4    ;STORE SCB ADDRESS
        MOVB    S.ITM(R4),S.CTM(R4) ;SET TIMEOUT
        RETURN
        .DSABL  LSB
;+
; RMSG - RECEIVE MESSAGE BYTE
; THIS ROUTINE IS JUMPED INTO INORDER TO RECEIVE
; INFORMATION VIA THE DL-11.
; IF RECEIVER DONE IS SET THEN A RETURN TO THE MAIN PROGRAM
; IS INITIATED VIA THE INTERRUPT SERVICE ROUTINE (RPT:)
; THERE IS NO INFO. IN THE DL-11 (DONE BIT CLEAR)
; THEN A RETURN IS EXECUTED AND
; THE INTERRUPT SERVICE ROUTINE WILL
; RETURN CONTROL TO THE PROGRAM WHEN THE DONE BIT 
; IS SET AND WHEN ALL READ DATA, IF ANY,
; HAS BEEN TRANSFERRED TO THE USER'S BUFFER.
;       INPUTS: R4=CONTROLLER NUMBER
;-
        .ENABL  LSB
RMSG:   SUB     #DDRBF-DDRCS,DBUF(R4) ;POINT TO CSR
        BIT     #RDONE,@DBUF(R4) ; READY?
        BEQ     20$             ;IF EQ NO
RREC:   JMP     RPT             ;IF YES ENTER READ ROUTINE
20$:

        .IF DF  E$$DVC

        BIS     S.BMSK(R4),$IOABM ;SET BITMASK

        .ENDC

        BIS     #RIE,@DBUF(R4)  ;SET REC. INTERRUPT ENABLE
        MOV     U.SCB(R5),R4    ;RESTORE SCB ADDRESS
        MOVB    #40.,S.CTM(R4)  ;SET TIMEOUT
        RETURN
        .DSABL LSB
;+
; CHKPT CREATES A CHECKSUM BY ADDING TWO WORDS
; WITH END AROUND CARRY.
;       INPUTS: CKSM2(R4)=WORD TO BE ADDED TO CHECKSUM
;               CKSM1(R4)=OLD CHECKSUM
;       OUTPUTS:CKSM1(R4)=NEW CHECKSUM
;-
CHKPT:  ADD     CKSM2(R4),CKSM1(R4) ;ADD TWO WORDS
        ADC     CKSM1(R4)       ;ADD CARRY
                                ;FALL THROUGH AND RETURN

;       END LOCAL ROUTINES

;+
; DDCAN-CANCEL I/O ENTRY POINT
;       CANCEL I/O IS A NOP FOR FILE STRUCTURED DEVICES
;-
DDCAN:

;+
; POWERFAIL REQUIRES NO OPERATION. REINITIALIZATION
; OF THE TU-58 WILL OCCUR DURING NORMAL OPERATION IF REQUIRED.
;-
DDPWF:  RETURN

;+
; **-$DDINT TU-58 INTERRUPTS
; INTERRUPTS ARE ISSUED WHEN EITHER THE
; RECEIVE OR TRANSMIT CSR'S INTERRUPT
; ENABLE IS SET BY SUBROUTINES RMSG OR
; SMSG. THEY INDICATE THAT THE DL-11
; HAS RECEIVED A BYTE OF INFORMATION
; OR CAN ACCEPT A BYTE OF INFORMATION
; FOR TRANSMITTING.
;-
        .ENABL LSB
$DDOUT::                        ;;;OUTPUT AS WELL AS INPUT ($DDINT)
                                ;;;INTERRUPT ENTRY POINT
        INTSE$  DD,PR4,T$$U58   ;;;SAVE REGISTERS & SET PRIORITY
        .IF EQ  T$$U58-1
        CLR     R4
        .ENDC
        BIC     #<RIE!TIE>,@DBUF(R4)    ;;;CLEAR INTERRUPTS
        MOV     R1,-(SP)        ;;;SAVE R1
        MOV     U.SCB(R5),R1    ;;;GET SCB ADDRESS
        CLRB    S.CTM(R1)       ;;;CLEAR TIMEOUT
        MOV     (SP)+,R1        ;;;RESTORE R1
;
; FLAG+1 IS SET TO INDICATE A TRANSMIT OPERATION AND CLEARED
; TO INDICATE A RECEIVE OPERATION.
; FLAG IS CHECKED TO DETERMINE IF WE HAVE DATA TO TRANSFER OR
; IF WE ARE TO RETURN TO THE MAIN PROGRAM.
;
        TSTB    FLAG+1(R4)      ;;;RECEIVE INTERRUPT?
        BNE     RPT             ;;;IF NE YES
        ADD     #DDXBF-DDXCS,DBUF(R4)   ;;;POINT TO BUFFER
        TSTB    FLAG(R4)        ;;;TRANSMIT DATA PACKET?
        BNE     SPT             ;;;IF NE YES
5$:     JMP     RTBK            ;;;ELSE RETURN
;
; SPT IS THE CODE USED TO SEND USER DATA TO THE TU-58
; A RUNNING CHECKSUM IS KEPT AND IS SENT AS THE LAST TWO
; CHARACTERS OF A DATA PACKET (TTHR,TFOU). AFTER ALL DATA
; HAS BEEN SENT CONTROL IS PASSED TO THE MAIN 
; PROGRAM.
;
SPT:    CALL    $GTBYT          ;;;PUT USER'S DATA BYTE ON STACK
        BITB    #1,FLAG(R4)     ;;;CHECK FOR EVEN OR ODD BYTE NO.
        BNE     20$             ;;;IF NE ODD,THEREFORE HIGH ORDER
                                ;;;BYTE IN CHECKSUM
        MOVB    (SP)+,CKSM2(R4) ;;;SAVE LOW ORDER CHECKSUM BYTE
        MOVB    CKSM2(R4),@DBUF(R4) ;;;TRANSMIT BYTE
        BR      30$
20$:    MOVB    (SP)+,CKSM2+1(R4) ;;;SAVE HIGH ORDER CHECKSUM BYTE
        MOVB    CKSM2+1(R4),@DBUF(R4) ;;;TRANSMIT BYTE
        CALL    CHKPT           ;;;GENERATE CHECKSUM
30$:    DECB    FLAG(R4)        ;;;DECREMENT DATA COUNT
35$:    JMP     SMSG
TTHR:   MOVB    CKSM1(R4),@DBUF(R4) ;;;SEND LOW ORDER CHECKSUM BYTE
        BR      35$
TFOU:   MOVB    CKSM1+1(R4),@DBUF(R4) ;;;SEND HIGH ORDER BYTE
        BR      35$
;
; RPT CHECKS FOR AN ERROR CONDITION IN THE DL-11'S RECEIVE
; BUFFER. IF DATA IS TO BE RECEIVED THIS ROUTINE
; TRANSFERS THE CHARACTER IN THE USER'S BUFFER AND KEEPS
; A RUNNING CHECKSUM. AFTER ALL DATA IS RECEIVED THE FINAL
; TWO BYTES OF THE PACKET ARE PRESENT AT RTWO AND RTHR AND 
; IF THEY EQUAL THE CHECKSUM THEN CONTROL IS RETURNED TO 
; THE MAIN PROGRAM.
;
RPT:    ADD     #DDRBF-DDRCS,DBUF(R4)  ;;;POINT TO RECEIVE BUFFER
        MOV     @DBUF(R4),RDAT(R4) ;;;STORE RECEIVED INFO.
        BPL     80$             ;;;IF PL NO ERROR
40$:    JMP     NTRY            ;;;ATTEMPT RETRY
80$:    TSTB    FLAG(R4)        ;;;DATA TO RECEIVE
        BEQ     5$              ;;;IF EQ NO
        MOVB    RDAT(R4),-(SP)  ;;;PUT DATA ON STACK
        CALL    $PTBYT          ;;;PUT DATA INTO USER'S BUFFER
        BITB    #1,FLAG(R4)     ;;;ODD OR EVEN BYTE (FOR CHECKSUM)
        BNE     90$             ;;;IF NE ODD (HIGH ORDER CHECKSUM BYTE)
        MOVB    RDAT(R4),CKSM2(R4) ;;;LOW ORDER CHECKSUM BYTE
        BR      100$
90$:    MOVB    RDAT(R4),CKSM2+1(R4) ;;;HIGH ORDER CHECKSUM BYTE
        CALL    CHKPT
100$:   DECB    FLAG(R4)        ;;;DECREMENT DATA COUNT
        BR      160$
RTWO:   MOVB    RDAT(R4),CKSM2(R4) ;;;RECEIVE LOW ORDER CHECKSUM
        BR      160$
RTHR:   MOVB    RDAT(R4),CKSM2+1(R4) ;;;RECEIVE HIGH ORDER 
        CMP     CKSM1(R4),CKSM2(R4) ;;;ARE CHECKSUMS CORRECT?
        BNE     40$             ;;;IF NE NO
160$:   JMP     RMSG            ;;;READ FIRST BYTE OF NEXT PACKET
        .DSABL  LSB
        
;+
; TIMEOUT IS ENTERED WHEN THE DL-11 DOES NOT RESPOND WITHIN
; A CERTAIN PRESET TIME TO THE  SUBROUTINES SMSG AND RMSG
; SETTING INTERRUPT ENABLE AND ISSUING A RETURN. THIS
; INDICATES A HARDWARE FAILURE OF THE DL-11 OR HARDWARE
; FAILURE OF THE TU-58.
;-
DDOUT:
        BIC     #<RIE!TIE>,@DBUF(R3)    ;;;CLEAR INTERRUPTS
        CALL    $DTOER          ;;;ERROR LOG
        MOV     R3,R4           ;MOVE CONTROLLER NO.
        TSTB    FLAG+1(R4)      ;RECEIVE TIME OUT?
        BNE     2$              ;IF NE YES
        ADD     #DDXBF-DDXCS,DBUF(R4)  ;POINT TO TRANSMIT BUFFER
        BR      4$              ;
2$:     ADD     #DDXBF-DDRCS,DBUF(R4)  ;POINT TO TRANSMIT BUFFER
4$:     DECB    U.CW2+1(R5)     ;DECREMENT RETRY COUNT
        BLT     10$             ;IF LT NO RETRIES LEFT
        JMP     TINIT           ;RE-INIT AND RETRY
10$:    CLR     CKSM2(R3)       ;CLEAR BYTE TRANSFERRED COUNT
        MOV     #IE.TMO&377,R0  ;TIMEOUT ERROR
        JMP     ENDOP

        .END
        .TITLE  DFDRV
        .IDENT  /09/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 09
;
; D. N. CUTLER 19-OCT-73
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;       D. N. CUTLER
;       C. A. D'ELIA
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 30-NOV-76
;
;               PB009 -- CORRECT OUT OF RANGE BRANCHES WHEN A
;                       MULTI-CONTROLLER DRIVER IS GENERATED.
;
;       P. J. BEZEREDI 07-FEB-77
;
;               PB013 -- ADDITION OF EXPANDED WRITE CHECK CAPABILITY.
;
;       P. J. BEZEREDI 14-FEB-77
;
;               PB014 -- LOAD SECOND STATUS WORD WITH BYTES ACTUALLY
;                       TRANSFERED BEFORE CALLING $IODON.

;       P. J. BEZEREDI 16-MAY-77
;
;               PB030 -- POWERFAIL RECOVERY SUPPORT.
;
; RF11 FIXED HEAD DISK DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        
        
        .IF DF  D$$IAG
        
        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS
        
        .ENDC
        
 
;
; EQUATED SYMBOLS
;
 
RETRY=8.                        ;ERROR RETRY COUNT
 
;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLER NUMBER)
;
 
CNTBL:  .BLKW   R$$F11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   R$$F11          ;RETRY COUNT FOR CURRENT OPERATION
 
 
        .IF GT  R$$F11-1
 
TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER
 
        .ENDC
 
;
; DRIVER DISPATCH TABLE
;
 
$DFTBL::.WORD   DFINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DFCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DFOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   DFPWF           ;POWERFAIL ENTRY POINT
 
;+
; **-DFINI-RF11 FIXED HEAD DISK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-
 
        .ENABL  LSB
DFINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     DFCAN           ;IF CS CONTROLLER BUSY OR NO REQUEST
 
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; RF11 FIXED HEAD DISK I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB OR IO.WLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- MEMORY EXTENSION BITS (BITS 4 AND 5) OF I/O TRANSFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- LOW BYTE MUST BE ZERO AND HIGH BYTE NOT USED.
;       WD. 17 -- LOGICAL BLOCK NUMBER OF I/O REQUEST.
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. ADRS ELSE NOT USED
;       WD. 21 -- DIAGNOSTIC REG. BLK ADRS (REAL OR DISPL.+140000)
;
 
        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB
        
        
        .IF DF  M$$EXT&M$$MGE
        
        CALL    $STMAP          ;SET UP UNIBUS MAPPING ADDRESS
        
        .ENDC
        
        
        .IF DF  D$$IAG
        
        CMP     #IO.WCK!IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC WRITE CHECK?
        BNE     5$              ;IF NE NO
        BIS     #107,U.BUF(R5)  ;YES, SET WRITE CHECK FUNCTION
        BR      10$             ;
        
        .ENDC
        
        
5$:     MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        BIS     #105,U.BUF(R5)  ;ASSUME READ LOGICAL FUNCTION
        CMPB    #IO.RLB/256.,I.FCN+1(R1) ;READ LOGICAL FUNCTION?
        BHIS    7$              ;IF HIS FUNCTION IS LEGAL
6$:     JMP     70$             ;FUNCTION IS ILLEGAL
7$:     BEQ     10$             ;IF EQ FUNCTION IS READ
        SUB     #2,U.BUF(R5)    ;CONVERT TO WRITE LOGICAL FUNCTION
10$:    MOV     #RETRY,RTTBL(R3) ;SET RETRY COUNT
        MOV     #IE.BLK&377,R0  ;ASSUME ILLEGAL BLOCK NUMBER
        MOVB    I.PRM+10(R1),R2 ;GET HIGH BYTE OF LOGICAL BLOCK NUMBER
        BNE     6$              ;IF NE ILLEGAL BLOCK NUMBER
        MOV     I.PRM+12(R1),R3 ;GET LOW PART OF LOGICAL BLOCK NUMBER
        SWAB    R3              ;MULTIPLY LOW BYTE BY 256.
        BISB    R3,R2           ;SET HIGH BITS OF DISK ADDRESS
        CLRB    R3              ;CLEAR EXCESS BITS FROM LOW PART
        BIT     #177740,R2      ;HIGH PART OF ADDRESS TOO BIG?
        BNE     6$              ;IF NE YES
        MOV     R2,I.PRM+10(R1) ;SAVE HIGH PART OF DISK ADDRESS
        MOV     R3,I.PRM+12(R1) ;SAVE LOW PART OF DISK ADDRESS
 
;
; INITIATE I/O OPERATION
;
 
20$:                            ;REF LABEL
        
        
        .IF DF  M$$EXT&M$$MGE
        
        CALL    $MPUBM          ;MAP UNIBUS TO TRANSFER
        
        .ENDC
        
        
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        MOV     #401,(R2)       ;CLEAR RF11 CONTROLLER
        MOVB    S.ITM(R4),S.CTM(R4)  ;SET CURRENT TIMEOUT COUNT
        ADD     #10,R2          ;POINT TO DISK ADDRESS EXT. REGISTER
        MOV     I.PRM+10(R1),(R2)  ;INSERT HIGH PART OF DISK ADDRESS
        MOV     I.PRM+12(R1),-(R2)  ;INSERT LOW PART OF DISK ADDRESS
        MOV     U.BUF+2(R5),-(R2)  ;INSERT BUFFER ADDRESS
        MOV     U.CNT(R5),-(R2) ;INSERT NUMBER OF BYTES TO TRANSFER
        ROR     (R2)            ;CONVERT TO WORD COUNT
        NEG     (R2)            ;CONVERT TO NEGATIVE WORD COUNT
        MOV     #IE.DNR&377,R0  ;ASSUME DRIVE NOT READY
        BIT     #200,-(R2)      ;DISK READY TO ACCEPT COMMAND?
        BNE     21$             ;IF NE YES


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;IS DRIVE SPINNING UP?
        BNE     23$             ;IF NE YES

        .IFTF


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC OPERATION?
        BNE     45$             ;IF NE YES

        .ENDC


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DRIVE NOT READY ERROR

        .ENDC


        JMP     60$             ;FINISH I/O
21$:                            ;REF LABEL

        .IFT

        BICB    #US.SPU,U.STS(R5)  ;RESET DRIVE SPINNING UP

        .ENDC
        
        
        .IF DF  E$$DVC
        
        CALL    $BMSET          ;SET I/O ACTIVE BIT IN MAP
        
        .ENDC

        
        MOV     U.BUF(R5),(R2)  ;LOAD FUNCTION AND GO
        
;
; CANCEL I/O OPERATION IS A NOP FOR FILE STRUCTURED DEVICES.
;
 
DFCAN:  RETURN                  ;;;NOP FOR RF11

;+
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND
; CAUSES NO IMMEDIATE ACTION ON THE UNIT.  THE CURRENT TIMEOUT
; COUNT IS EXTENDED SO THAT IF THE UNIT WAS BUSY IT WILL HAVE
; SUFFICIENT TIME TO SPIN BACK UP.  THE NEXT I/O REQUEST TO ANY
; UNIT WILL BE SUSPENDED FOR AT LEAST THE EXTENDED TIMEOUT UNLESS
; THE UNIT IS ALREADY READY.
;-

DFPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        TSTB    S.STS(R4)       ;IS THE DRIVE CURRENTLY BUSY?
        BEQ     23$             ;IF EQ NO
        MOVB    #2,S.STS(R4)    ;WAIT A MAXIMUM OF 30 SECONDS
22$:    MOVB    #15.,S.CTM(R4)  ;15 SECONDS AT A TIME
23$:    BISB    #US.SPU,U.STS(R5)  ;SET UNIT SPINNING UP

        .ENDC


        RETURN                  ;WAIT FOR UNIT TO RESPOND
 
;+
; **-$DFINT-RF11 DISK CONTROLLER INTERRUPTS
;-
 
        INTSE$  DF,PR5,R$$F11   ;;;SAVE REGISTERS AND SET PRIORITY
        CALL    $FORK           ;;;CREATES A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF STATUS CONTROL BLOCK
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        
        
        .IF DF  D$$IAG
        
        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC FUNCTION EXECUTED?
        BNE     45$             ;IF NE YES
        
        .ENDC
        
        
        TST     (R2)            ;ANY ERRORS?
        BPL     50$             ;IF PL NO
        

        .IF DF  E$$DVC
        
        CALL    $DVERR          ;LOG DEVICE ERROR
        
        .ENDC

        
        MOV     (R2),R1         ;GET CONTENTS OF CSR
        MOV     #IE.WLK&377,R0  ;ASSUME WRITE LOCK
        BIT     #2000,R1        ;WRITE LOCK?
        BNE     60$             ;IF NE YES
        MOV     #IE.BLK&377,R0  ;ASSUME NONEXISTENT DISK
        BIT     #4000,R1        ;NONEXISTENT DISK?
        BNE     60$             ;IF NE YES
        MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR
        BIT     #40000,R1       ;UNRECOVERBLE ERROR?
        BNE     60$             ;IF NE YES
        BR      46$             ;FINISH IN COMMON CODE
 
        
;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING REPEATED
; UNLESS THE REQUEST WAS DIAGNOSTIC.  TIMEOUTS ARE USUALLY CAUSED
; BY POWERFAILURE BUT MAY ALSO BE THE RESULT OF A HARDWARE FAILURE.
;
 
DFOUT:                          ;;;TIMEOUT ENTRY POINT


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;;;IS DRIVE SPINNING UP?
        BEQ     40$             ;;;IF EQ NO
        DECB    S.STS(R4)       ;;;HAVE WE WAITED ENOUGH YET?
        BEQ     40$             ;;;IF EQ YES
        MTPS    #0              ;;;ALLOW INTERRUPTS
        JMP     20$             ;RETRY ENTIRE OPERATION
40$:    INCB    S.STS(R4)       ;;;LEAVE CONTROLLER BUSY
        BICB    #US.SPU,U.STS(R5)  ;;;RESET DRIVE SPINNING UP

        .ENDC


        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT
        
        
        .IF DF  D$$IAG
        
        BCC     46$             ;IF CC TIMEOUT DURING NORMAL FUNCTION
45$:    CALL    $CRPAS          ;PASS CONTROLLER REGISTERS TO TASK
        BR      60$             ;DIAGNOSTIC PROCESSING COMPLETE
        
        .ENDC
        
        
46$:    MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
        BNE     52$             ;IF NE YES
        DECB    RTTBL(R3)       ;RETRY FUNCTION?
        BLE     52$             ;IF LE NO
47$:    JMP     20$             ;RETRY OPERATION

50$:                            ;REF LABEL


        .IF DF  D$$WCK

        BITB    #IO.WLC&377,I.FCN(R1)  ;WRITE FOLLOWED BY WRITE CHECK?
        BNE     51$             ;IF NE YES
        BITB    #US.WCK,U.STS(R5)  ;WRITE CHECK ENABLED BY MCR?
        BEQ     60$             ;IF EQ NO
51$:    MOVB    U.BUF(R5),R1    ;GET LAST FUNCTION
        BIT     #1*2,R1         ;WRITE OR WRITE CHECK FUNCTION?
        BEQ     60$             ;IF EQ NO
        BIS     #2*2,U.BUF(R5)  ;SET WRITE CHECK FUNCTION
        BIT     #2*2,R1         ;WAS LAST FUNCTION A WRITE CHECK?
        BNE     60$             ;IF NE YES
        MOV     #RETRY,RTTBL(R3);REINITIALIZE RETRY COUNT
        BR      47$             ;START WRITE CHECK OPERATION

        .IFTF

52$:                            ;REF LABEL

        .IFT

        BIT     #20000,(R2)     ;WRITE CHECK ERROR?
        BEQ     60$             ;IF EQ NO
        MOV     #IE.WCK&377,R0  ;SET WRITE CHECK ERROR

        .ENDC


60$:    MOV     2(R2),R1        ;GET WORDS REMAINING TO TRANSFER
        ASL     R1              ;CONVERT TO BYTES LEFT TO TRANSFER
        ADD     U.CNT(R5),R1    ;CALCULATE BYTES ACTUALLY TRANSFERED
        MOV     #401,(R2)       ;CLEAR RF11 CONTROLLER
70$:                            ;REF LABEL
        

        .IF DF  E$$DVC
        
        MOVB    S.CON(R4),R3    ;RETRIEVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ;GET FINAL ERROR RETRY COUNT
        BIS     #RETRY*256.,R2  ;MERGE STARTING ERROR RETRY COUNT
        
        .ENDC
        
        
        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DFINI           ;PROCESS NEXT REQUEST
        .DSABL  LSB
 
        .END
        .TITLE  DKDRV
        .IDENT  /08/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 08
;
; D. N. CUTLER 19-OCT-73
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;       D. N. CUTLER
;       C. A. D'ELIA
;
; MODIFIED BY:  
;
;       P. J. BEZEREDI 30-NOV-76
;
;               PB009 -- CORRECT OUT OF RANGE BRANCHES WHEN A
;                       MULTI-CONTROLLER DRIVER IS GENERATED.
;
;       P. J. BEZEREDI 07-FEB-77
;
;               PB013 -- EXPAND WRITE CHECK CAPABILITY.
;
;       P. J. BEZEREDI 14-FEB-77
;
;               PB014 -- LOAD SECOND STATUS WORD WITH BYTES ACTUALLY
;                       TRANSFERED BEFORE CALLING $IODON.
;
;       P. J. BEZEREDI 16-MAY-77
;
;               PB030 -- POWERFAIL RECOVERY SUPPORT.
;
; RK11 CARTRIDGE DISK DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
 
;
; EQUATED SYMBOLS
;
 
RETRY=8.                        ;ERROR RETRY COUNT
 
;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;
 
CNTBL:  .BLKW   R$$K11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   R$$K11          ;ERROR RETRY COUNT AND DRIVE RESET FLAG
 
 
        .IF GT  R$$K11-1
 
TEMP:   .BLKW   1               ;TEMPORY STORAGE FOR CONTROLLER NUMBER
 
        .ENDC
 
        
        .IF DF  D$$IAG
        
        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS
        
;
; DIAGNOSTIC FUNCTION TABLE
;
FUNTBL: .WORD   IO.HMS!IQ.UMD, 0515
        .WORD   IO.BLS!IQ.UMD, 0511
FUNTB0: .WORD   IO.RDH!IQ.UMD, 2505
        .WORD   IO.WDH!IQ.UMD, 2503
        .WORD   IO.WCK!IQ.UMD, 0507
FUNTBE:
        
        .ENDC
        
        
;
; DRIVER DISPATCH TABLE
;
 
$DKTBL::.WORD   DKINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DKCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DKOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   DKPWF           ;POWERFAIL ENTRY POINT
 
;+
; **-DKINI-RK11 CARTRIDGE DISK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-
 
        .ENABL  LSB
1$:     RETURN                  ;CONTROLLER BUSY OR NO REQUEST
DKINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     1$              ;IF CS NO PACKET
 
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; RK11 CARTRIDGE DISK I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB OR IO.WLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- MEMORY EXTENSION BITS (BITS 4 AND 5) OF I/O TRANSFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- LOW BYTE MUST BE ZERO AND HIGH BYTE NOT USED.
;       WD. 17 -- LOGICAL BLOCK NUMBER OF I/O REQUEST.
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. ADRS ELSE NOT USED
;       WD. 21 -- DIAGNOSTIC REG. BLK ADRS (REAL OR DISPL.+140000)
;
 
        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB
        
        
        .IF DF  M$$EXT&M$$MGE
        
        CALL    $STMAP          ;SET UP UNIBUS MAPPING ADDRESS
        
        .ENDC
        
        
        MOV     #RETRY&377,RTTBL(R3)  ;CLEAR POSITIONING & SET RETRIES
        
        
        .IF DF  D$$IAG
        
        CMPB    #IO.HMS/^D<256>,I.FCN+1(R1)  ;DIAGNOSTIC FUNCTION?
        BNE     5$              ;IF NE NO
        MOV     #FUNTBL,R0      ;GET ADDRESS OF FUNCTION TABLE
2$:     CMP     (R0)+,I.FCN(R1) ;FUNCTION CODE MATCH?
        BEQ     3$              ;IF EQ YES
        TST     (R0)+           ;BYPASS CONTROLLER CODE
        CMP     #FUNTBE,R0      ;END OF FUNCTION TABLE?
        BEQ     5$              ;IF EQ YES
        BR      2$              ;TRY AGAIN
3$:     CMP     R0,#FUNTB0      ;POSITIONING FUNCTION?
        BHI     4$              ;IF HI NO
        INCB    RTTBL+1(R3)     ;YES, INDICATE POSITIONING OPERATION
4$:     BIS     (R0),U.BUF(R5)  ;SET CONTROLLER FUNCTION BITS
        BR      10$             ;GO CHECK BLOCK NUMBER
        
        .ENDC
        
        
5$:     MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        BIS     #505,U.BUF(R5)  ;ASSUME READ LOGICAL FUNCTION
        CMPB    #IO.RLB/256.,I.FCN+1(R1) ;READ LOGICAL FUNCTION?
        BHIS    6$              ;IF HIS FUNCTION IS LEGAL
        JMP     120$            ;FUNCTION IS ILLEGAL
6$:     BEQ     10$             ;IF EQ FUNCTION IS READ
        SUB     #2,U.BUF(R5)    ;CONVERT TO WRITE LOGICAL FUNCTION
10$:    CALL    $BLKCK          ;CHECK LOGICAL BLOCK NUMBER
        MOV     #12.,R1         ;SET DIVISOR
        CALL    $DIV            ;CALCULATE SECTOR NUMBER
        ASR     R0              ;WHICH SURFACE?
        BCC     20$             ;IF CC SURFACE 0
        BIS     #20,R1          ;SET SURFACE 1 BIT
20$:    SWAB    R0              ;SWAP CYLINDER TO HIGH BYTE
        MOVB    U.UNIT(R5),R2   ;RETRIEVE DRIVE NUMBER
        ASR     R2              ;COLLECT DRIVE NUMBER AND CYLINDER
        ROR     R0              ;
        ASR     R2              ;
        ROR     R0              ;
        ASR     R2              ;
        ROR     R0              ;
        BIS     R1,R0           ;MERGE SURFACE AND SECTOR
        MOV     R0,I.PRM+10(R3) ;SAVE DISK ADDRESS
 
;
; INITIATE I/O OPERATION
;
 
30$:                            ;REF LABEL
        
        
        .IF DF  M$$EXT&M$$MGE
        
        CALL    $MPUBM          ;MAP UNIBUS TO TRANSFER
        
        .ENDC
        
        
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     S.PKT(R4),R1    ;RETRIEVE ADDRESS OF I/O REQUEST PACKET
        MOVB    S.ITM(R4),S.CTM(R4) ;SET CURRENT DEVICE TIMEOUT COUNT
        ADD     #6,R2           ;POINT TO DISK ADDRESS REGISTER
        MOV     I.PRM+10(R1),(R2)  ;INSERT DISK ADDRESS
        MOV     U.BUF+2(R5),-(R2)  ;INSERT BUFFER ADDRESS
        MOV     U.CNT(R5),-(R2) ;INSERT NUMBER OF BYTES TO TRANSFER
        ROR     (R2)            ;CONVERT TO WORD COUNT
        NEG     (R2)            ;MAKE NEGATIVE WORD COUNT
        TST     -(R2)           ;POINT BACK TO CSR
        MOV     #IE.DNR&377,R0  ;ASSUME DRIVE NOT READY
        TSTB    -4(R2)          ;IS DRIVE READY?
        BMI     31$             ;IF MI YES


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;IS DRIVE SPINNING UP?
        BNE     35$             ;IF NE YES

        .IFTF


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC OPERATION?
        BNE     51$             ;IF NE YES

        .ENDC


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DRIVE NOT READY ERROR

        .ENDC


        JMP     110$            ;FINISH UP
31$:                            ;REF LABEL

        .IFT

        BICB    #US.SPU,U.STS(R5)  ;RESET DRIVE SPINNING UP

        .ENDC
        
        
        .IF DF  E$$DVC
        
        CALL    $BMSET          ;SET I/O ACTIVE BIT IN MAP
        
        .ENDC

        
        MOV     U.BUF(R5),(R2)  ;SET FUNCTION AND GO
        
;
; CANCEL I/O OPERATION IS A NOP FOR FILE STRUCTURED DEVICES.
;
 
DKCAN:  RETURN                  ;;;NOP FOR RK11

;+
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND
; CAUSES NO IMMEDIATE ACTION ON THE UNIT.  THE CURRENT TIMEOUT
; COUNT IS EXTENDED SO THAT IF THE UNIT WAS BUSY IT WILL HAVE
; SUFFICIENT TIME TO SPIN BACK UP.  THE NEXT I/O REQUEST TO ANY
; UNIT WILL BE SUSPENDED FOR AT LEAST THE EXTENDED TIMEOUT UNLESS
; THE UNIT IS ALREADY READY.
;-

DKPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        TSTB    S.STS(R4)       ;IS THE DRIVE CURRENTLY BUSY?
        BEQ     36$             ;IF EQ NO
        MOVB    #3,S.STS(R4)    ;WAIT A MAXIMUM OF 45 SECONDS
35$:    MOVB    #15.,S.CTM(R4)  ;15 SECONDS AT A TIME
36$:    BISB    #US.SPU,U.STS(R5)  ;SET UNIT SPINNING UP

        .ENDC


        RETURN                  ;WAIT FOR UNIT TO RESPOND
        
;+
; **-$DKINT-RK11 DISK CONTROLLER INTERUPTS
;-
 
        INTSE$  DK,PR5,R$$K11   ;;;SAVE REGISTERS AND SET PRIORITY
        TSTB    RTTBL+1(R4)     ;;;DRIVE RESET IN PROGRESS?
        BEQ     50$             ;;;IF EQ NO
        MOV     R4,-(SP)        ;;;SAVE CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOV     @S.CSR(R4),R4   ;;;GET CONTENTS OF CSR
        BMI     40$             ;;;IF MI DRIVE RESET ERROR
        BIT     #20000,R4       ;;;DRIVE RESET COMPLETE?
        BNE     40$             ;;;IF NE YES
        TST     (SP)+           ;;;CLEAN STACK
        RETURN                  ;;;
40$:    MOV     (SP)+,R4        ;;;RESTORE CONTROLLER INDEX
50$:    CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        
        
        .IF DF  D$$IAG
        
        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC FUNCTION EXECUTED?
51$:    BNE     130$            ;IF NE YES
        
        .ENDC
        
        
        TST     (R2)            ;ANY ERRORS?
        BPL     65$             ;IF PL NO
        

        .IF DF  E$$DVC
        
        CALL    $DVERR          ;LOG DEVICE ERROR
        
        .ENDC

        
        MOV     -2(R2),R1       ;SAVE ERROR STATUS REGISTER
53$:    MOV     S.PKT(R4),R0    ;GET I/O PACKET ADDRESS
        BITB    #IQ.X,I.FCN(R0) ;INHIBIT RETRIES
        BNE     80$             ;IF NE YES
        DECB    RTTBL(R3)       ;ANY MORE RETRIES?
        BLE     80$             ;IF LE NO
        MOV     #1,(R2)         ;CLEAR CONTROLLER
        CLRB    RTTBL+1(R3)     ;CLEAR POSSIBLE DRIVE RESET IN PROGRESS
55$:    BIT     #110000,R1      ;DRIVE RESET REQUIRED?
        BEQ     70$             ;IF EQ NO
60$:    MOVB    #1,RTTBL+1(R3)  ;SET DRIVE RESET IN PROGRESS
        MOVB    S.ITM(R4),S.CTM(R4) ;RESET TIMEOUT COUNT
        MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        MOV     I.PRM+10(R1),6(R2) ;SET PROPER DRIVE NUMBER
        MOV     #515,(R2)       ;RESET DRIVE
        RETURN                  ;
65$:    ASRB    RTTBL+1(R3)     ;DRIVE RESET IN PROGRESS?
        BCC     75$             ;IF CC NO
70$:    JMP     30$             ;RETRY FUNCTION
75$:                            ;REF LABEL
        

        .IF DF  D$$WCK

        BITB    #IO.WLC&377,I.FCN(R1)  ;WRITE WITH WRITE CHECK?
        BNE     76$             ;IF NE YES
        BITB    #US.WCK,U.STS(R5) ;WRITE CHECK ENABLED?
        BEQ     110$            ;IF EQ NO
76$:    MOV     U.BUF(R5),R1    ;GET CURRENT FUNCTION CODE
        BIT     #1*2,R1         ;WRITE OR WRITE CHECK FUNCTION?
        BEQ     110$            ;IF EQ NO
        BIS     #2*2,U.BUF(R5)  ;SET WRITE CHECK FUNCTION
        BIT     #2*2,R1         ;WAS FUNCTION A WRITE CHECK?
        BNE     110$            ;IF NE YES
        MOV     #RETRY&377,RTTBL(R3)  ;REINITIALIZE RETRY COUNT
        BR      70$             ;START WRITE CHECK OPERATION

        .IFF

        BR      110$            ;FINISH OPERATION

        .ENDC


80$:    MOV     #IE.WLK&377,R0  ;ASSUME WRITE LOCK ERROR
        BIT     #20000,R1       ;WRITE LOCK ERROR?
        BNE     110$            ;IF NE YES


        .IF DF  D$$WCK

        MOV     #IE.WCK&377,R0  ;ASSUME WRITE CHECK ERROR
        ASR     R1              ;GOOD ASSUMPTION?
        BCS     110$            ;IF CS WRITE CHECK ERROR

        .ENDC


        MOV     #IE.VER&377,R0  ;SET UNRECOVERABLE ERROR
110$:   MOV     2(R2),R1        ;GET WORDS LEFT TO TRANSFER
        ASL     R1              ;CONVERT TO BYTES LEFT TO TRANSFER
        ADD     U.CNT(R5),R1    ;CALCULATE BYTES ACTUALLY TRANSFERED
        MOV     #1,(R2)         ;CLEAR CONTROLLER
120$:                           ;REF LABEL
        

        .IF DF  E$$DVC
        
        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ;GET FINAL ERROR RETRY COUNT
        BIS     #RETRY*256.,R2  ;MERGE STARTING RETRY COUNT
        
        .ENDC
        
        
        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DKINI           ;PROCESS NEXT REQUEST
 
;
; DEVICE TIMEOUT RESULTS IN A CONTROL AND DRIVE RESET FOLLOWED BY THE
; I/O OPERATION BEING REPEATED UNLESS THE OPERATION WAS DIAGNOSTIC.
; TIMEOUTS ARE USUALLY CAUSED BY POWERFAILURE BUT MAY ALSO BE THE
; RESULT OF A HARDWARE FAILURE.
;
 
DKOUT:                          ;;;TIMEOUT ENTRY POINT


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;;;IS DRIVE SPINNING UP?
        BEQ     125$            ;;;IF EQ NO
        DECB    S.STS(R4)       ;;;HAVE WE WAITED ENOUGH YET?
        BEQ     125$            ;;;IF EQ YES
        MTPS    #0              ;;;ALLOW INTERRUPTS
        JMP     30$             ;RETRY OPERATION
125$:   INCB    S.STS(R4)       ;;;LEAVE CONTROLLER BUSY
        BICB    #US.SPU,U.STS(R5)  ;;;RESET DRIVE SPINNING UP

        .ENDC


        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT
        
        
        .IF DF  D$$IAG
        
        BCC     140$            ;IF CC TIMEOUT DURING NORMAL FUNCTION
130$:   CALL    $CRPAS          ;PASS CONTROLLER REGISTERS TO TASK
        BR      110$            ;DIAGNOSTIC PROCESSING COMPLETE
140$:                           ;REF LABEL
        
        .ENDC
        
        
        MOV     #110000,R1      ;SET FOR DRIVE RESET
        BR      53$             ;
        .DSABL  LSB
 
        .END
        .TITLE  DLDRV
        .IDENT  /01.04/
;
;
; COPYRIGHT (C) 1977, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION
; OF  THE  ABOVE COPYRIGHT  NOTICE.  THIS SOFTWARE, OR  ANY  OTHER
; COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE  MADE AVAILABLE
; TO  ANY  OTHER PERSON  EXCEPT  FOR USE ON SUCH SYSTEM AND TO ONE
; WHO AGREES TO THESE LICENSE TERMS.  TITLE  TO  AND  OWNERSHIP OF
; THE SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE  INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A  COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO  RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;
;
; VERSION 01.04
;
; P. J. BEZEREDI   07-OCT-77
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 22-MAR-78
;
;               PB064 -- OPTIMIZE MID-TRANSFER SEEKING.
;
;       P. J. BEZEREDI 09-MAY-78
;
;               PB074 -- ADDITION OF RL02 SUPPORT.
;
;       P. J. BEZEREDI 01-FEB-79
;
;               PB090 -- ADDITION OF WRITE CHECK SUPPORT.
;
;       P. J. BEZEREDI 22-MAY-79
;
;               PB105 -- CORRECTLY HANDLE SETTLE DOWN IN PROGRESS.
;
;
; RL11/RL01 DISK DRIVER
;
;
.MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
;
;****************
;
; EQUATED SYMBOLS
;
RETRY=  ^D<8>                   ;CONTROLLER ERROR RETRY COUNT
RLCNT=  ^D<5>                   ;NUMBER OF REGISTERS TO LOG ON ERROR
RLBPT=  ^D<512*20>              ;BYTES PER RL01 SURFACE


        .IF DF  D$$IAG


                                ;NO DIAGNOSTIC FUNCTIONS YET

        .ENDC


;
;****************
;
; RL11 DEVICE REGISTER OFFSETS
;
RLCS=   0                       ;CONTROL STATUS REGISTER
RLBA=   2                       ;BUS ADDRESS REGISTER
RLDA=   4                       ;DISK ADDRESS REGISTER
RLMP=   6                       ;MULTI-PURPOSE REGISTER
;
;****************
;
; RLCS BIT ASSIGNMENTS
;
ERR=    100000                  ;COMPOSITE ERROR
DE=     040000                  ;DRIVE ERROR
NXM=    020000                  ;NON-EXISTANT MEMORY
DLT=    010000                  ;DATA LATE
HNF=    010000                  ;HEADER NOT FOUND
DCK=    004000                  ;DATA CHECK ERROR
HCRC=   004000                  ;HEADER CRC ERROR
OPI=    002000                  ;OPERATION INCOMPLETE
DRDY=   1                       ;DRIVE READY
WCHK=   2                       ;WRITE CHECK FUNCTION
WRITE=  2                       ;WRITE OFFSET
GSTS=   4                       ;GET DRIVE STATUS FUNCTION
SEEK=   6                       ;SEEK FUNCTION
RDH=    10                      ;READ HEADERS FUNCTION
READ=   14                      ;READ DATA FUNCTION
IE=     100                     ;INTERRUPT ENABLE
CRDY=   200                     ;CONTROLLER READY
;
;****************
;
; RLDA STATUS CODES
;
MRK=    1                       ;MARKER BIT
STS=    2                       ;GET STATUS BIT
SN=     4                       ;SIGN BIT FOR SEEK
RST=    10                      ;DRIVE RESET BIT
HS=     20                      ;HEAD SELECT BIT FOR DIFFERENCE
REV=    200!MRK                 ;REVERSE SEEK DIFFERENCE WORD
;
;****************
;
; RLMP GET STATUS BIT ASSIGNMENTS
;
WDE=    100000                  ;WRITE DATA ERROR
CHE=    040000                  ;CURRENT HEAD ERROR
WLS=    020000                  ;WRITE LOCK STATUS
SKTO=   010000                  ;SEEK TIMEOUT ERROR
SPD=    004000                  ;SPEED ERROR
WGE=    002000                  ;WRITE GATE ERROR
VC=     001000                  ;VOLUME CHECK
DSE=    000400                  ;DRIVE SELECT ERROR
DT=     000200                  ;DRIVE TYPE                             ; PB074
HSS=    000100                  ;HEAD SELECT STATUS
CO=     000040                  ;COVER OPEN
HH=     000020                  ;HEADS HOME
BH=     000010                  ;BRUSHES HOME
SLM=    000005                  ;DRIVE IN SEEK-LINEAR MODE STATE
;
;****************
;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES
; THESE ARE INDEXED BY THE CONTROLLER NUMBER
;
CNTBL:  .BLKW   R$$L11          ;ADRS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   R$$L11          ;RETRY COUNT FOR CURRENT OPERATION
PRMSV:  .BLKW   R$$L11*5        ;PARAMETER SAVE AREA FOR WRITE CHECK    ; PB090


        .IF GT  R$$L11-1

TEMP:   .BLKW   1               ;TEMP STORAGE FOR CONTROLLER NUMBER

        .ENDC


;
;****************
;
;DRIVER DISPATCH TABLE
;
$DLTBL::.WORD   DLINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DLCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DLOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   DLPWF           ;POWERFAIL ENTRY POINT
;
;****************
;
;+
; **-DLINI-RL11/RL01 DISK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O
; REQUEST IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO
; PROPAGATE THE EXECUTION OF THE DRIVER.  IF THE SPECIFIED CONTROLLER
; IS NOT BUSY, THEN AN ATTEMPT IS MADE TO DEQUEUE THE NEXT I/O REQUEST.
; ELSE A RETURN TO THE CALLER IS EXECUTED.  IF THE DEQUEUE ATTEMPT
; IS SUCCESSFUL, THEN THE NEXT I/O OPERATION IS INITIATED.  A RETURN
; TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;       R5= ADRS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS
;       WAITING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE
;       DRIVER INITIATES THE REQUESTED I/O FUNCTION
;-
        .ENABL  LSB
DLINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCC     1$              ;IF CC PROCESS REQUEST
        RETURN                  ;RETURN IF BUSY OR NO REQUEST
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1= ADRS OF THE I/O REQUEST PACKET
;       R2= PHYSICAL UNIT NUMBER OF THE REQUESTED DRIVE
;       R3= CONTROLLER INDEX
;       R4= ADRS OF THE STATUS CONTROL BLOCK (SCB)
;       R5= ADRS OF THE UCB OF THE DRIVE TO BE INITIATED
;
; RL11/RL01 DISK CONTROLLER I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER
;       WD. 02 -- ADRS OF THE TCB OF THE REQUESTOR TASK
;       WD. 03 -- POINTER TO 2ND LUN WORD IN REQUESTOR TASK HEADER
;       WD. 04 -- CONTENTS OF FIRST LUN WORD (UCB ADRS)
;       WD. 05 -- I/O FUNCTION CODE
;       WD. 06 -- VIRTUAL ADRS OF I/O STATUS BLOCK
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK
;       WD. 10 -- I/O STATUS BLOCK ADRS (REAL OR DISPL.+140000)
;       WD. 11 -- VIRTUAL ADRS OF AST SERVICE ROUTINE
;       WD. 12 -- MEMORY EXTENSION BITS OF I/O TRANSFER
;       WD. 13 -- BUFFER ADRS OF I/O TRANSFER
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED
;       WD. 15 -- NOT USED.
;       WD. 16 -- LOW BYTE MUST BE ZERO AND HIGH BYTE IS NOT USED
;       WD. 17 -- LOW PART OF LOGICAL BLK NUMBER OF I/O REQUEST
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. BLK. ELSE NOT USED
;       WD. 21 -- DIAGNOSTIC REG BLK ADR (REAL OR DSPL+140000) ELSE NOT USED
;
; DRIVER USAGE OF WORDS IN I/O PACKET:
;       I.PRM+6  (WD. 15) - SEEK DIFFERENCE WORD FOR ERROR LOGGING
;       I.PRM+10 (WD. 16) - STARTING DISK ADDRESS FOR THIS TRANSFER
;       I.PRM+12 (WD. 17) - BYTE COUNT FOR THIS TRANSFER
;
;****************
;
; THIS SECTION CALCULATES THE ACTUAL DISK ADDRESS FROM THE
; LOGIGAL BLOCK INFORMATION SUPPLIED IN THE I/O PACKET.  IT ALSO
; DETERMINES THE FUNCTION TO PERFORM (DIAGNOSTIC OR READ/WRITE).
;
1$:     MOV     R5,CNTBL(R3)    ;SAVE ADRS OF REQUEST UCB


        .IF DF  M$$EXT&M$$MGE

        CALL    $STMAP          ;SET UP 11/70 UNIBUS MAPPING ADRS

        .ENDC


        MOVB    R2,U.BUF+1(R5)  ;SET CURRENT UNIT NUMBER
        MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        BIS     #READ!IE,U.BUF(R5)  ;ASSUME READ LOGICAL FUNCTION
        CMPB    #IO.RLB/^D<256>,I.FCN+1(R1)  ;REALLY?
        BHIS    5$              ;IF HIS FUNCTION IS LEGAL
        JMP     90$             ;FUNCTION IS ILLEGAL
5$:     BEQ     10$             ;IF EQ YES
        SUB     #WRITE,U.BUF(R5)  ;CONVERT TO WRITE LOGICAL FUNCTION
10$:    MOV     #RETRY,RTTBL(R3)  ;SET INITIAL RETRY COUNT
        MOV     I.PRM+12(R1),R0 ;RETREIVE BLOCK NUMBER
        CLR     R2              ;CLEAR HIGH ORDER BLOCK NUMBER
        BITB    #IO.WPB&377,I.FCN(R1)  ;PHYSICAL BLOCK FUNCTION?
        BNE     12$             ;IF NE YES
        CALL    $BLKCK          ;CHECK LOGICAL BLOCK NUMBER
        CMPB    #IO.WLB/^D<256>,I.FCN+1(R3)  ;WRITE FUNCTION?
        BNE     11$             ;IF NE NO
        BITB    #IO.WLT&377,I.FCN(R3)  ;OK TO WRITE ON LAST TRACK?
        BNE     11$             ;IF NE YES
        MOV     R0,I.PRM+6(R3)  ;YES, SAVE STARTING BLOCK NUMBER
        ADD     #^D<20>,I.PRM+12(R3)  ;ADD 1 TRACK'S WORTH OF BLOCKS
        CALL    $BLKC1          ;CHECK IF WRITE ON LAST TRACK OF DISK
        MOV     I.PRM+6(R3),R0  ;RESTORE ORIGINAL STARTING BLOCK NUMBER
11$:    ASL     R0              ;CONVERT BLOCKS TO SECTORS
12$:    MOV     S.PKT(R4),R3    ;RESET I/O PACKET ADDRESS
        MOV     #^D<40>,R1      ;DIVIDE BY SECTORS/SURFACE
        CALL    $DIV            ;CALCULATE CYLINDER NUMBER
        .REPT   6.
        ASL     R0              ;POSITION CYLINDER AND SURFACE
        .ENDR
        BIS     R1,R0           ;MERGE SECTOR WITH CYLINDER AND SURFACE
        MOV     R0,I.PRM+10(R3) ;SAVE STARTING DISK ADDRESS
        MOV     U.CNT(R5),I.PRM+12(R3)  ;ASSUME ONLY ONE XFER NEEDED
        MOV     #^D<40>,R0      ;SET SECTORS/SURFACE
        SUB     R1,R0           ;CALCULATE SECTORS LEFT ON SURFACE
        SWAB    R0              ;GET BYTES LEFT ON SURFACE
        CMP     U.CNT(R5),R0    ;ARE ADDITIONAL TRANSFERS REQUIRED?
        BLOS    13$             ;IF LOS NO                              ; PB090
        MOV     R0,I.PRM+12(R3) ;SET BYTE COUNT FOR FIRST TRANSFER      ;**-1
13$:    MOVB    S.CON(R4),R0    ;RETREIVE CONTROLLER INDEX              ; PB090
        MOV     #R$$L11*10.,R1  ;SET UP REGISTER R1                     ; PB090
        CALL    $MUL            ;FORM INDEX INTO PARAMETER SAVE AREA    ; PB090
        ADD     #PRMSV,R1       ;POINT TO THIS ENTRY                    ; PB090
        MOV     U.BUF(R5),(R1)+ ;SAVE INITIAL PARAMETERS                ; PB090
        MOV     U.BUF+2(R5),(R1)+  ;...                                 ; PB090
        MOV     U.CNT(R5),(R1)+ ;...                                    ; PB090
        MOV     I.PRM+10(R3),(R1)+  ;...                                ; PB090
        MOV     I.PRM+12(R3),(R1)+  ;...                                ; PB090

;+
; THIS SECTION WILL INITIATE THE OPERATION
;-

DLINIO:                         ;REF LABEL


        .IF DF  M$$EXT&M$$MGE

        CALL    $MPUBM          ;MAP 11/70 UNIBUS TO TRANSFER

        .ENDC


        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     S.PKT(R4),R3    ;GET ADDRESS OF I/O PACKET


        .IF DF  E$$DVC

        CLRB    U.CW2+1(R5)     ;RESET DRIVE SETTLE DOWN FLAG
        CLR     I.PRM+6(R3)     ;RESET ERROR DIFFERENCE WORD

        .ENDC


        MOVB    S.ITM(R4),S.CTM(R4)  ;SET DEVICE TIMEOUT COUNTER
        CALL    DLRST           ;RESET DRIVE AND GET STATUS
        MOV     RLMP(R2),R1     ;GET THE STATUS INFO
        MOV     #IE.DNR&377,R0  ;ASSUME DRIVE NOT READY
        BIC     #WLS!DT!HSS,R1  ;REMOVE IRRELEVANT BITS                 ; PB074
        BIT     #DRDY,(R2)      ;IS THE DRIVE READY?                    ;**-1
        BEQ     15$             ;IF EQ NO
        CMP     #HH!BH!SLM,R1   ;HEADS, BRUSHES AND STATE OK?
        BEQ     20$             ;IF EQ YES
15$:                            ;REF LABEL


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;IS DRIVE SPINNING UP?
        BNE     30$             ;IF NE YES

        .IFTF


        .IF DF  E$$DVC

        CALL    DLDVER          ;LOG THE DEVICE NOT READY               ; PB105
                                                                        ; PB105
        .ENDC                                                           ; PB105
                                                                        ; PB105
                                                                        ; PB105
        JMP     90$             ;EXIT AS FATAL                          ; PB105
                                                                        ;**-8
20$:                            ;REF LABEL

        .IFT

        BICB    #US.SPU,U.STS(R5)  ;RESET DRIVE SPINNING UP

        .ENDC


        MOV     I.PRM+10(R3),R0 ;RETREIVE STARTING DISK ADDRESS
        CALL    DLDIFF          ;CALCULATE DIFFERENCE WORD
21$:    BEQ     22$             ;IF EQ NO SEEK IS NECESSARY             ; PB064
        MOV     #SEEK,R1        ;GET CODE FOR SEEK FUNCTION             ;**-1
        CALL    DLXCT           ;EXECUTE THE SEEK
        BMI     40$             ;IF MI ERROR DURING SEEK FUNCTION
22$:    ADD     #RLMP,R2        ;POINT TO RLMP                          ; PB064
        MOV     I.PRM+12(R3),R1 ;GET BYTE COUNT                         ;**-1
        ROR     R1              ;MAKE IT A WORD COUNT
        NEG     R1              ;ALSO NEGATIVE
        MOV     R1,(R2)         ;LOAD WORD COUNT
        MOV     I.PRM+10(R3),-(R2)  ;LOAD STARTING DISK ADDRESS
        MOV     U.BUF+2(R5),-(R2)   ;LOAD BUS ADDRESS


        .IF DF  E$$DVC

        CALL    $BMSET          ;SET I/O ACTIVE BIT IN MAP

        .ENDC


        MOV     U.BUF(R5),-(R2) ;LOAD FUNCTION AND GO

;+
;+
; CANCEL I/O OPERATION IS A NOP FOR FILE STRUCTURED DEVICES.
;-

DLCAN:  RETURN                  ;;;NOP FOR RL11

;+
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND
; CAUSES NO IMMEDIATE ACTION ON THE UNIT.  THE CURRENT TIMEOUT
; COUNT IS EXTENDED SO THAT IF THE UNIT WAS BUSY IT WILL HAVE
; SUFFICIENT TIME TO SPIN BACK UP.  THE NEXT I/O REQUEST TO ANY
; UNIT WILL BE SUSPENDED FOR AT LEAST THE EXTENDED TIMEOUT UNLESS
; THE UNIT IS ALREADY READY.
;-

DLPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        TSTB    S.STS(R4)       ;IS DRIVE CURRENTLY BUSY?
        BEQ     31$             ;IF EQ NO
        MOVB    #4,S.STS(R4)    ;WAIT A MAXIMUM OF ONE MINUTE
30$:    MOVB    #15.,S.CTM(R4)  ;15 SECONDS AT A TIME
31$:    BISB    #US.SPU,U.STS(R5)  ;SET UNIT SPINNING UP

        .ENDC


        RETURN                  ;WAIT FOR UNIT TO RESPOND

;+
; **-$DLINT-RL11/RL01 DISK CONTROLLER
;       INTERRUPT AND ERROR SERVICE ROUTINES
;-
        INTSE$  DL,PR5,R$$L11   ;;;SAVE REGISTERS AND SET PRIORITY
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        ASRB    RTTBL+1(R3)     ;HOME SEEK IN PROGRESS?
        BCS     DLINIO          ;IF CS YES
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL OPERATION
        MOV     (R2),R1         ;GET CONTENTS OF RLCS
        BMI     40$             ;IF MI AN ERROR OCCURRED
        MOV     S.PKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        SUB     I.PRM+12(R3),U.CNT(R5)  ;CALCULATE BYTES LEFT TO XFER
        BEQ     75$             ;IF EQ NONE LEFT- COMPLETE WRITE-CHECK  ; PB090
        MOV     U.CNT(R5),I.PRM+12(R3)  ;ASSUME LAST XFER COMING        ;**-1
        CMP     U.CNT(R5),#RLBPT  ;IS THIS THE LAST TRANSFER?
        BLOS    35$             ;IF LOS YES
        MOV     #RLBPT,I.PRM+12(R3)  ;TRANSFER A WHOLE TRACKS WORTH
35$:    BIC     #CRDY,R1        ;CLEAR CRDY TO START FUNCTION
        MOV     R1,U.BUF(R5)    ;SAVE CURRENT FUNCTION AND ADDRESS BITS
        MOV     RLBA(R2),U.BUF+2(R5)  ;SAVE CURRENT BUS ADDRESS
        MOV     I.PRM+10(R3),R0 ;GET INITIAL DISK ADDRESS
        MOV     R0,R1           ;COPY DISK ADDRESS                      ; PB064
        BIC     #77,R0          ;ISOLATE CYLINDER AND SURFACE
        ADD     #100,R0         ;UPDATE SURFACE/CYLINDER ADDRESS
        MOV     R0,I.PRM+10(R3) ;SAVE NEW DISK ADDRESS
        CALL    DLDIF0          ;CALCULATE MID-TRANSFER DIFFERENCE      ; PB064
        JMP     21$             ;GO DO THE OPERATION                    ; PB064
                                                                        ;**-1
40$:    BIT     #DRDY,R1        ;IS THE DRIVE READY?                    ; PB105
        BNE     50$             ;IF NE YES                              ;**-10
45$:    MOVB    #3,S.CTM(R4)    ;SET 3 SECOND TIMEOUT FOR DRIVE
        INCB    U.CW2+1(R5)     ;FLAG DRIVE IS SETTLING DOWN
        RETURN                  ;

50$:    MOV     (R2),R1         ;RETREIVE RLCS CONTENTS                 ; PB105
                                                                        ; PB105
                                                                        ; PB105
        .IF DF  E$$DVC                                                  ; PB105
                                                                        ; PB105
        MOV     R1,-(SP)        ;SAVE CONTENTS OF RLCS                  ; PB105
        CALL    DLDVER          ;LOG DEVICE ERROR                       ;**-1
        MOV     (SP)+,R1        ;RESTORE RLCS CONTENTS

        .ENDC


        MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR             ; PB090
        BIT     #NXM,R1         ;NON-EXISTANT MEMORY?
        BNE     85$             ;IF NE YES
        BIT     #DE,R1          ;DRIVE PROBLEMS?
        BEQ     55$             ;IF EQ NO                               ; PB090
        CALL    DLGST           ;EXECUTE GET DRIVE STATUS FUNCTION      ;**-1
        BIT     #WGE,RLMP(R2)   ;WRITE GATE ERROR?                      ;**-1
        BEQ     85$             ;IF EQ NO
        BIT     #WLS,RLMP(R2)   ;IS DRIVE WRITE LOCKED?
        BEQ     60$             ;IF EQ NO                               ; PB090
        MOV     #IE.WLK&377,R0  ;SET WRITE LOCK ERROR CODE              ; PB090
        BR      90$             ;                                       ; PB090
55$:    BIT     #10,U.BUF(R5)   ;WRITE CHECK FUNCTION?                  ; PB090
        BNE     60$             ;IF NE NO                               ; PB090
        BIT     #OPI,R1         ;OPERATION INCOMPLETE?                  ; PB090
        BNE     60$             ;IF NE YES                              ; PB090
        BIT     #DCK,R1         ;WRITE CHECK ERROR?                     ; PB090
        BEQ     60$             ;IF EQ NO                               ; PB090
        MOV     #IE.WCK&377,R0  ;YES, SET WRITE CHECK ERROR CODE        ; PB090
60$:    MOV     S.PKT(R4),R1    ;RETREIVE I/O PACKET ADDRESS            ;**-1
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
        BNE     90$             ;IF NE YES                              ; PB090
        DECB    RTTBL(R3)       ;ANY MORE RETRIES LEFT?                 ;**-1
        BLE     90$             ;IF LE NO                               ; PB090
65$:    JMP     DLINIO          ;RETRY ENTIRE OPERATION                 ;**-1
75$:    BITB    #IO.WLC&377,I.FCN(R3)  ;WRITE WITH WRITE CHECK?         ; PB090
        BNE     76$             ;IF NE YES                              ; PB090
        BITB    #US.WCK,U.STS(R5)  ;WRITE CHECK ENABLED?                ; PB090
        BEQ     90$             ;IF EQ NO                               ; PB090
76$:    MOV     U.BUF(R5),R1    ;GET CURRENT FUNCTION CODE              ; PB090
        BIT     #WCHK,R1        ;WRITE OR WRITE CHECK FUNCTION?         ; PB090
        BEQ     90$             ;IF EQ NO                               ; PB090
        BIT     #10,R1          ;WAS FUNCTION WRITE CHECK?              ; PB090
        BEQ     90$             ;IF EQ YES                              ; PB090
        MOVB    S.CON(R4),R1    ;RETREIVE CONTROLLER INDEX              ; PB090
        MOV     #RETRY,RTTBL(R1);RESET RETRY COUNT                      ; PB090
        MOV     #R$$L11*10.,R0  ;SET UP R0                              ; PB090
        CALL    $MUL            ;FORM INDEX INTO PARAMETER SAVE AREA    ; PB090
        ADD     #PRMSV,R1       ;...                                    ; PB090
        MOV     (R1)+,U.BUF(R5) ;RESTORE STARTING PARAMETERS            ; PB090
        MOV     (R1)+,U.BUF+2(R5)  ;...                                 ; PB090
        MOV     (R1)+,U.CNT(R5)  ;...                                   ; PB090
        MOV     (R1)+,I.PRM+10(R3) ;...                                 ; PB090
        MOV     (R1)+,I.PRM+12(R3) ;...                                 ; PB090
        BIC     #10,U.BUF(R5)   ;CONVERT TO WRITE CHECK FUNCTION        ; PB090
        BR      65$             ;START THE WRITE CHECK OPERATION        ; PB090
85$:    MOV     #IE.VER&377,R0  ;SET UNSUCCESSFUL OPERATION
90$:    MOV     S.PKT(R4),R2    ;GET ADDRESS OF I/O PACKET
        MOV     I.PRM+4(R2),R1  ;GET TOTAL TRANSFER SIZE
        SUB     U.CNT(R5),R1    ;CALCULATE BYTES TRANSFERED


        .IF DF  E$$DVC

        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ;GET FINAL RETRY COUNT
        BIS     #RETRY*^D<256>,R2  ;MERGE STARTING RETRY COUNT

        .ENDC


        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DLINI           ;PROCESS NEXT REQUEST

;+
; **-DLOUT-RL11/RL01 DISK CONTROLLER
;       DEVICE TIMEOUT ROUTINE
;
; DEVICE TIMEOUT RESULTS IN THE OPERATION BEING REPEATED.
; TIMEOUTS ARE USUALLY CAUSED BY A POWER FAILURE BUT MAY ALSO
; BE THE RESULT OF A HARDWARE MALFUNCTION.
;-

DLOUT:                          ;;;TIMEOUT ENTRY POINT


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;;;IS DRIVE SPINNING UP?
        BEQ     95$             ;;;IF EQ NO
        DECB    S.STS(R4)       ;;;HAVE WE WAITED ENOUGH YET?
        BNE     94$             ;;;IF NE NO
        INCB    S.STS(R4)       ;;;LEAVE CONTROLLER BUSY
        BICB    #US.SPU,U.STS(R5)  ;;;RESET DRIVE SPINNING UP
        BR      96$             ;;;
94$:    MTPS    #0              ;;;ALLOW INTERRUPTS
        BR      65$             ;RETRY ENTIRE OPERATION
                                                                        ;**-1
        .ENDC


95$:    TSTB    U.CW2+1(R5)     ;;;IS DRIVE SETTLING DOWN?              ; PB105
        BEQ     96$             ;;;IF EQ NO                             ;**-3
        MTPS    #0              ;;;YES, ALLOW INTERRUPTS
        JMP     50$             ;PROCESS THE ERROR                      ; PB105
96$:                            ;;;REF LABEL                            ; PB105
                                                                        ; PB105
                                                                        ; PB105
        .IF DF  E$$DVC                                                  ; PB105
                                                                        ;**-8
        CALL    DLDTER          ;;;LOG DEVICE TIMEOUT

        .IFF

        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT

        .ENDC


        CALL    DLRST           ;RESET DRIVE
        BR      60$             ;REPEAT THE OPERATION

;+
; **-DLXCT,DLGST,DLRST-RL11/RL01 DISK CONTROLLER
;       FUNCTION EXECUTION ROUTINES
;
; THIS ROUTINE WILL EXECUTE A GET DRIVE STATUS OR ANY
; NON-INTERRUPTABLE FUNCTION AND WAIT FOR ITS COMPLETION.
;
; INPUTS:
;       R1 = FUNCTION CODE
;       R2 = CSR ADDRESS
;       R5 = UCB ADDRESS
;
; OUTPUTS:
;       R1 = CONTENTS OF RLCS (TESTED)
;       FUNCTION EXECUTED
;-

DLRST:  MOV     #RST!STS!MRK,RLDA(R2)  ;SET MESSAGE CODES IN RLDA
        CALL    100$            ;DO THE DRIVE RESET FIRST
DLGST:  MOV     #STS!MRK,RLDA(R2)  ;SET MESSAGE CODES IN RLDA
100$:   MOV     #GSTS,R1        ;SET GET STATUS FUNCTION
DLXCT:  MOV     R1,-(SP)        ;SAVE FUNCTION CODE
        MOVB    U.UNIT(R5),1(SP);MERGE CURRENT DRIVE BITS
        MOV     (SP)+,(R2)      ;LOAD RLCS
101$:   TSTB    (R2)            ;WAIT FOR THE FUNCTION TO COMPLETE
        BPL     101$            ;
        MOV     (R2),R1         ;SAVE RLCS AND TEST FOR ERRORS
        RETURN                  ;

;+
; **-DLDIFF-RL11/RL01 DISK CONTROLLER
;       CYLINDER ADDRESS DIFFERENCE CALCULATOR
;
; THIS SUBROUTINE CALCULATES THE DIFFERENCE WORD USED IN THE
; SEEK OPERATION.  IF A HEADER CANNOT BE READ AFTER 16. RETRIES,
; AN ERROR WILL BE LOGGEN AND A ONE CYLINDER REVERSE SEEK WILL
; BE ISSUED.  THE SEEK IS FOLLOWED BY A READ HEADERS TO CAUSE AN
; INTERRUPT.
;
; INPUTS:
;       R0 = DESIRED DISK ADDRESS
;       R3 = I/O PACKET ADDRESS
;
; OUTPUTS:
;       R1 = DIFFERENCE WORD
;       RLDA = LOADED WITH DIFFERENCE WORD
;       I.PRM+6 = LOADED WITH DIFFERENCE WORD (ERROR LOGGING ONLY)
;       IF EQ NO SEEK IS NECESSARY
;-

DLDIFF: MOV     #RETRY*2,-(SP)  ;SET READ HEADER RETRY COUNT
110$:   MOV     #RDH,R1         ;SET CODE FOR READ HEADERS FUNCTION
        CALL    DLXCT           ;EXECUTE THE FUNCTION
        BPL     115$            ;IF PL FUNCTION EXECUTED OK
        DEC     (SP)            ;ANY RETRIES LEFT?
        BGT     110$            ;IF GT YES
        CMP     (SP)+,(SP)+     ;REMOVE RETRY COUNT AND CALLERS ADDRESS


        .IF DF  E$$DVC

        CALL    DLDVER          ;LOG HEADER ERROR

        .IFF

        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX

        .IFTF

        CALL    DLRST           ;RESET DRIVE
        MOV     #REV,RLDA(R2)   ;LOAD REVERSE SEEK DIFFERENCE WORD
        MOV     #SEEK,R1        ;GET CODE FOR SEEK FUNCTION
        CALL    DLXCT           ;EXECUTE THE SEEK
        BMI     85$             ;IF MI WE FAILED
        BIC     #377,R1         ;CLEAR OUT FUNCTION BITS
        BIS     #IE!RDH,R1      ;LOAD CODES FOR READ HEADER
        MOVB    #1,RTTBL+1(R3)  ;INDICATE REVERSE SEEK IN PROGRESS
        MOVB    S.ITM(R4),S.CTM(R4)  ;SET DEVICE TIMEOUT COUNTER
        MOV     R1,(R2)         ;LOAD FUNCTION AND GO
        RETURN                  ;WAIT FOR THE INTERRUPT
115$:   TST     (SP)+           ;REMOVE RETRY COUNT
        MOV     RLMP(R2),R1     ;RETREIVE HEADER WORD
DLDIF0:                         ;REF LABEL                              ; PB064

        .IFT

        CLR     I.PRM+6(R3)     ;RESET DIFFERENCE WORD

        .IFTF

        BIC     #77,R0          ;MASK OUT SECTOR BITS
        BIC     #77,R1          ;...
        CMP     R0,R1           ;DO WE NEED TO DO A SEEK?
        BEQ     117$            ;IF EQ NO
        MOV     R0,-(SP)        ;SAVE DESIRED DISK ADDRESS
        BIC     #^C<100>,(SP)   ;ISOLATE SURFACE BIT
        ASR     (SP)            ;PUT INTO THE PROPER POSITION
        ASR     (SP)            ;...
        BIC     #100,R0         ;REMOVE SURFACE BIT
        BIC     #100,R1         ;...
        SUB     R0,R1           ;SUBTRACT DESIRED FROM ACTUAL
;       BEQ     116$            ;IF EQ ONLY CHANGE SURFACE
        BCC     116$            ;IF CC ACTUAL >= DESIRED
        NEG     R1              ;ACTUAL < DESIRED, MAKE POSITIVE DIFFERENCE
        BIS     #SN,R1          ;SET SIGN FOR MOVE TO CENTER OF DISK
116$:   INC     R1              ;SET MARKER BIT
        BIS     (SP)+,R1        ;MERGE IN SURFACE BIT
        MOV     R1,RLDA(R2)     ;LOAD DIFFERENCE WORD

        .IFT

        MOV     R1,I.PRM+6(R3)  ;SAVE DIFFERENCE WORD

        .ENDC


117$:   RETURN                  ;


        .IF DF  E$$DVC

;+
; **-DLDXXX-RL11/RL01 DISK CONTROLLER
;       ERROR LOGGING ROUTINES
;
; THIS ROUTINE IS CALLED WHENEVER A DEVICE ERROR OR DEVICE TIMEOUT
; OCCURS.  A CORE BLOCK THE SIZE OF THE REGISTER BUFFER IS ALLOCATED
; AND THE UNIBUS REGISTERS ALONG WITH THE DRIVE STATUS INFORMATION
; ARE TRANSFERED INTO THE CORE BLOCK.  THEN THE CSR ADDRESS IN THE
; SCB IS SET TO THE CORE BLOCK ADDRESS AND THE APPROPRIATE EXECUTIVE
; ERROR LOGGING ROUTINE IS CALLED.  THE CORE BLOCK IS THEN
; DEALLOCATED AND THE CSR ADRESS IN THE SCB RESTORED.
;
; IF FOR ANY REASON THE CORE BLOCK CANNOT BE ALLOCATED THEN THE
; EXECUTIVE ERROR LOGGING ROUTINE WILL NOT BE CALLED AND THE ERROR
; SEQUENCE NUMBER WILL BE UPDATED TO INDICATE THAT A MISSED ERROR
; CONDITION OCCURRED.
;
; INPUTS:
;       R2 = CSR ADDRESS
;       R4 = SCB ADDRESS
;
; OUTPUTS:
;       R1 = DESTROYED
;       R3 = CONTROLLER INDEX
;-

DLDVER: MOV     #$DVERR,R1      ;GET ADRS OF DEVICE ERROR ROUTINE
        BR      150$            ;
DLDTER: MOV     #$DTOER,R1      ;;;GET ADRS OF DEVICE TIMEOUT ROUTINE
150$:   MOV     R0,-(SP)        ;SAVE I/O STATUS CODE
        MOV     R1,-(SP)        ;SET CO-ROUTINE ADDRESS
        MOV     #RLCNT*2,R1     ;GET NUMBER OF BYTES TO ALLOCATE
        CALL    $ALOCB          ;ALLOCATE A CORE BLOCK
        BCC     151$            ;IF CC BLOCK WAS ALLOCATED
        INC     $ERRSQ          ;INDICATE A MISSED ERROR CONDITION
        CMP     (SP)+,#$DTOER   ;ALLOCATION FAILURE, TIMEOUT IN PROGRESS?
        BNE     152$            ;IF NE NO
        BIC     #IE,@S.CSR(R4)  ;;;CLEAR INTERRUPT ENABLE
        MTPS    #0              ;;;ALLOW INTERRUPTS
        BR      152$            ;DON'T LOG ERROR IF ALLOCATION FAILURE
151$:   MOV     R0,R1           ;SET POINTER TO CORE BLOCK
        MOV     S.CSR(R4),R2    ;GET REAL CSR ADDRESS
        MOV     (R2),(R1)+      ;TRANSFER RLCS
        MOV     RLBA(R2),(R1)+  ;TRANSFER RLBA
        MOV     RLDA(R2),(R1)+  ;TRANSFER RLDA
        MOV     RLMP(R2),(R1)+  ;TRANSFER RLMP
        CALL    DLGST           ;EXECUTE GET DRIVE STATUS FUNCTION
        MOV     RLMP(R2),<RLCNT-1*2>(R0)  ;SAVE DRIVE STATUS
        MOV     R0,S.CSR(R4)    ;REPLACE CSR WITH CORE BLOCK ADDRESS
        CALL    @(SP)+          ;CALL EXEC ERROR LOGGING ROUTINE
        MOV     R2,S.CSR(R4)    ;RESTORE CSR ADDRESS
        MOV     #RLCNT*2,R1     ;GET NUMBER OF BYTES TO DEALLOCATE
        CALL    $DEACB          ;DEALLOCATE THE CORE BLOCK
152$:   MOV     S.CSR(R4),R2    ;RESTORE CSR ADDRESS
        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX
        MOV     (SP)+,R0        ;RESTORE I/O STATUS CODE
        RETURN

        .ENDC


        .DSABL  LSB

        .END

        .TITLE  DMDRV
        .IDENT  /04.02/
 
;
; COPYRIGHT (C) 1976, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 04.02
;
; P. J. BEZEREDI   23-SEP-76
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 25-JAN-78
;
;               PB056 -- CORRECTLY RELOCATE UNIBUS PHYSICAL ADDRESSES
;                       ON 22-BIT PROCESSORS.
;
;       P. J. BEZEREDI 03-APR-79
;
;               PB100 -- IMPROVE HARD ERROR DETECTION AND HANDLING.
;
; RK611-RK06/RK07 DISK CARTRIDGE DRIVER
;
;
.MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
;
;****************
;
; EQUATED SYMBOLS
;
RETRY=  ^D<8>                   ;CONTROLLER ERROR RETRY COUNT
OFFTRY= ^D<2>                   ;OFFSET POSITION RETRY COUNT
RMCNT=  ^D<22>                  ;NUMBER OF REGISTERS TO LOG ON ERROR
;
;****************
;
; RK611 DEVICE REGISTER OFFSETS
;
RMCS1=  0                       ;CONTROL STATUS REGISTER 1
RMWC=   2                       ;WORD COUNT
RMBA=   4                       ;BUS ADDRESS
RMDA=   6                       ;DISK ADDRESS
RMCS2=  10                      ;CONTROL STATUS REGISTER 2
RMDS=   12                      ;DRIVE STATUS
RMER=   14                      ;ERROR REGISTER
RMOF=   16                      ;OFFSET/ATTENTION REGISTER
RMDC=   20                      ;DESIRED CYLINDER
RMDB=   24                      ;DATA BUFFER
RMMR1=  26                      ;MAINTENANCE REGISTER 1
RMECPS= 30                      ;ECC POSITION
RMECPT= 32                      ;ECC PATTERN
RMMR2=  34                      ;MAINTENANCE REGISTER 2
RMMR3=  36                      ;MAINTENANCE REGISTER 3
;
;****************
;
; RMCS1 BIT ASSIGNMENTS
;
SD=     1                       ;SELECT DRIVE & GET STATUS
WRT=    2                       ;WRITE OFFSET
ACK=    3                       ;PACK ACKNOWLEDGE
DC=     5                       ;DRIVE CLEAR
IE=     100                     ;INTERRUPT ENABLE
RDY=    200                     ;CONTROLLER READY
HMS=    113                     ;IE + RECALIBRATE + GO
OFF=    115                     ;IE + OFFSET + GO
BLS=    117                     ;IE + SEEK + GO
READ=   121                     ;IE + READ + GO
RDH=    125                     ;IE + READ HEADER + GO
WDH=    127                     ;IE + WRITE HEADER + GO
WCK=    131                     ;IE + WRITE CHECK + GO
CERR=   100000                  ;CONTROLLER ERROR/CONTROLLER CLEAR
DI=     040000                  ;DRIVE INTERRUPT
DCPAR=  020000                  ;DRIVE TO CONTROLLER PARITY ERROR
CTO=    004000                  ;CONTROLLER TIMEOUT
CDT=    002000                  ;CONTROLLER DRIVE TYPE
;
;****************
;
; RMCS2 BIT ASSIGNMENTS
;
DLT=    100000                  ;DATA LATE
WCE=    040000                  ;WRITE CHECK ERROR
UPE=    020000                  ;UNIBUS PARITY
NED=    010000                  ;NON EXISTANT DISK
NEM=    004000                  ;NON EXISTANT MEMORY
PGE=    002000                  ;PROGRAMMING ERROR
MDS=    001000                  ;MULTIPLE DRIVE SELECT
UFE=    000400                  ;UNIT FIELD ERROR
SCLR=   000040                  ;RESET CONTROLLER AND ALL DRIVES
;
;****************
;
; RMDS BIT ASSIGNMENTS
;
SVAL=   100000                  ;STATUS VALID
DDT=    000400                  ;DISK DRIVE TYPE
DRDY=   000200                  ;DRIVE READY
VV=     000100                  ;VOLUME VALID
DRA=    000001                  ;DRIVE AVAILABLE
;
;****************
;
; RMER BIT ASSIGNMENTS
;
DCK=    100000                  ;DATA CHECK ERROR
UNS=    040000                  ;DRIVE UNSAFE
OPI=    020000                  ;OPERATION INCOMPLETE
DTE=    010000                  ;DRIVE TIMING ERROR
WLE=    004000                  ;WRITE LOCK ERROR
IDAE=   002000                  ;INVALID DISK ADDRESS
COE=    001000                  ;CYLINDER OVERFLOW
HVRC=   000400                  ;HEADER VRC ERROR
BSE=    000200                  ;BAD SECTOR ERROR
ECH=    000100                  ;ERROR CORRECTION HARD
FMTE=   000020                  ;FORMAT ERROR
CDPAR=  000010                  ;CONTROLLER TO DRIVE PARITY ERROR
NXF=    000004                  ;NON-EXECUTABLE FUNCTION
SKI=    000002                  ;SEEK INCOMPLETE
ILF=    000001                  ;ILLEGAL FUNCTION
;
;****************
;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES
; THESE ARE INDEXED BY THE CONTROLLER NUMBER
;
CNTBL:  .BLKW   R$$611          ;ADRS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   R$$611          ;RETRY COUNT FOR CURRENT OPERATION


        .IF GT  R$$611-1

TEMP:   .BLKW   1               ;TEMP STORAGE FOR CONTROLLER NUMBER

        .ENDC


        .IF DF  D$$IAG

        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS

;
; DIAGNOSTIC FUNCTION TABLE
;
FUNTBL: .BYTE   HMS, IO.HMS!IQ.UMD&377
        .BYTE   BLS, IO.BLS!IQ.UMD&377
        .BYTE   OFF, IO.OFF!IQ.UMD&377
        .BYTE   RDH, IO.RDH!IQ.UMD&377
        .BYTE   WDH, IO.WDH!IQ.UMD&377
        .BYTE   WCK, IO.WCK!IQ.UMD&377
FUNTBE:

        .ENDC


        .IF DF  R$$6OF

;
; OFFSET POSITIONING DATA
;
OFFTB:                          ;POSITIONING VALUE TABLE
        .BYTE   000             ;RETURN TO CENTERLINE
        .BYTE   020             ; +400
        .BYTE   220             ; -400
        .BYTE   040             ; +800
        .BYTE   240             ; -800
        .BYTE   060             ; +1200
        .BYTE   260             ; -1200
OFFTBE: .BYTE   000             ;RETURN TO CENTERLINE
                                ;
OFFAD:  .BLKW   R$$611          ;ADRS OF CURRENT OFFSET VALUE

        .ENDC


;
;****************
;
;DRIVER DISPATCH TABLE
;
$DMTBL::.WORD   DMINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DMCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DMOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   DMPWF           ;POWERFAIL ENTRY POINT
;
;****************
;
;+
; **-DMINI-RK611-RK06/RK07 DISK CARTRIDGE CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O
; REQUEST IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO
; PROPAGATE THE EXECUTION OF THE DRIVER.  IF THE SPECIFIED CONTROLLER
; IS NOT BUSY, THEN AN ATTEMPT IS MADE TO DEQUEUE THE NEXT I/O REQUEST.
; ELSE A RETURN TO THE CALLER IS EXECUTED.  IF THE DEQUEUE ATTEMPT
; IS SUCCESSFUL, THEN THE NEXT I/O OPERATION IS INITIATED.  A RETURN
; TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;       R5= ADRS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS
;       WAITING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE
;       DRIVER INITIATES THE REQUESTED I/O FUNCTION
;-
        .ENABL  LSB
1$:     RETURN                  ;RETURN TO CALLER
DMINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     1$              ;IF CS CONTROLLER IS BUSY OR NO REQUEST
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1= ADRS OF THE I/O REQUEST PACKET
;       R2= PHYSICAL UNIT NUMBER OF THE REQUESTED DRIVE
;       R3= CONTROLLER INDEX
;       R4= ADRS OF THE STATUS CONTROL BLOCK (SCB)
;       R5= ADRS OF THE UCB OF THE DRIVE TO BE INITIATED
;
; RK611-RK06/RK07 DISK CARTRIDGE CONTROLLER I/O REQUEST PACKET FORMAT
;
;       WD. 00 -- I/O QUEUE THREAD WORD
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER
;       WD. 02 -- ADRS OF THE TCB OF THE REQUESTOR TASK
;       WD. 03 -- POINTER TO 2ND LUN WORD IN REQUESTOR TASK HEADER
;       WD. 04 -- CONTENTS OF FIRST LUN WORD (UCB ADRS)
;       WD. 05 -- I/O FUNCTION CODE
;       WD. 06 -- VIRTUAL ADRS OF I/O STATUS BLOCK
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK
;       WD. 10 -- I/O STATUS BLOCK ADRS (REAL OR DISPL.+140000)
;       WD. 11 -- VIRTUAL ADRS OF AST SERVICE ROUTINE
;       WD. 12 -- MEMORY EXTENSION BITS OF I/O TRANSFER
;       WD. 13 -- BUFFER ADRS OF I/O TRANSFER
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED
;       WD. 15 -- DIAGNOSTIC SUPPLIMENTAL PARAMETER OR TEMP. STORAGE
;       WD. 16 -- LOW BYTE MUST BE ZERO AND HIGH BYTE IS NOT USED
;       WD. 17 -- LOW PART OF LOGICAL BLK NUMBER OF I/O REQUEST
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. BLK ADRS
;       WD. 21 -- DIAGNOSTIC REG. BLK ADRS (REAL OR DISPL.+140000)
;
;****************
;
; THIS SECTION CALCULATES THE ACTUAL DISK ADDRESS FROM THE
; LOGIGAL BLOCK INFORMATION SUPPLIED IN THE I/O PACKET.  IT ALSO
; DETERMINES THE FUNCTION TO PERFORM (DIAGNOSTIC OR READ/WRITE).
;
        MOV     R5,CNTBL(R3)    ;SAVE ADRS OF REQUEST UCB


        .IF DF  M$$EXT&M$$MGE
                                                                        ;**-8

        CALL    $STMAP          ;SET UP 11/70 UNIBUS MAPPING ADRS

        .ENDC


        .IF DF  M$$MGE

        ASL     U.BUF(R5)       ;POSITION EXTENDED MEMORY BITS
        ASL     U.BUF(R5)
        ASL     U.BUF(R5)
        ASL     U.BUF(R5)

        .ENDC


        .IF DF  D$$IAG

3$:     CMPB    #<IO.HMS/^D<256>>,I.FCN+1(R1)  ;DIAGNOSTIC FUNCTION?
        BNE     5$              ;IF NE NO
        MOV     #FUNTBL,R0      ;GET ADDRESS OF FUNCTION TABLE
4$:     MOVB    (R0)+,U.BUF(R5) ;LOAD CONTROLLER FUNCTION CODE
        CMPB    (R0)+,I.FCN(R1) ;IS IT THE CORRECT CODE?
        BEQ     7$              ;IF EQ YES
        CMP     #FUNTBE,R0      ;END OF FUNCTION TABLE?
        BNE     4$              ;IF NE NO

        .ENDC


5$:     MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        MOVB    #READ,U.BUF(R5) ;ASSUME READ LOGICAL FUNCTION
        CMPB    #<IO.RLB/^D<256>>,I.FCN+1(R1)  ;REALLY?
        BHIS    6$              ;IF HIS FUNCTION IS LEGAL
        JMP     34$             ;FUNCTION IS ILLEGAL
6$:     BEQ     7$              ;IF EQ FUNCTION WAS READ
        ADD     #WRT,U.BUF(R5)  ;CONVERT TO WRITE LOGICAL FUNCTION
7$:     MOV     #RETRY,RTTBL(R3);SET INITIAL RETRY COUNT


        .IF DF  R$$6OF

        CALL    110$            ;RESET OFFSET RECOVERY VALUES

        .ENDC


        CALL    $BLKCK          ;CHECK LOGICAL BLOCK NUMBER
        CMPB    #IO.WLB/^D<256>,I.FCN+1(R3)  ;WRITE FUNCTION?
        BNE     8$              ;IF NE NO
        BITB    #IO.WLT&377,I.FCN(R3)  ;OK TO WRITE ON LAST TRACK?
        BNE     8$              ;IF NE YES
        MOV     R0,I.PRM+6(R3)  ;YES, SAVE STARTING BLOCK NUMBER
        ADD     #^D<22>,I.PRM+12(R3)  ;ADD 1 TRACK'S WORTH OF BLOCKS
        CALL    $BLKC1          ;CHECK IF WRITE ON LAST TRACK OF DISK
        MOV     I.PRM+6(R3),R0  ;RESTORE ORIGINAL STARTING BLOCK NUMBER
8$:     MOV     #^D<22>*3,R1    ;SET DIVISOR=BLOCKS PER CYLINDER
        CALL    $DIV            ;FIND CYLINDER ADDRESS (R0=LBN)
        MOV     R0,I.PRM+10(R3) ;SAVE DESIRED CYLINDER ADRS
        MOV     R1,R0           ;SET DIVIDEND=TRACK/SECTOR (REMAINDER)
        MOV     #^D<22>,R1      ;SET DIVISOR=BLOCKS PER TRACK
        CALL    $DIV            ;FIND TRACK AND SECTOR ADDRESS
        SWAB    R0              ;SWAP TRACK TO HIGH BYTE
        BIS     R1,R0           ;MERGE SECTOR WITH TRACK
        MOV     R0,I.PRM+12(R3) ;SAVE TRACK AND SECTOR ADRS
;
; THIS NEXT SECTION WILL INITIATE THE I/O OPERATION
;
DMINIO:                         ;REF LABEL


        .IF DF  M$$EXT&M$$MGE

        CALL    $MPUBM          ;MAP 11/70 UNIBUS TO TRANSFER

        .ENDC


        CLRB    U.CW2+1(R5)     ;RESET POSITIONING IN PROGRESS FLAG
        MOV     S.CSR(R4),R2    ;GET CSR ADRS
        MOV     S.PKT(R4),R3    ;GET ADRS OF I/O PACKET
        MOVB    S.ITM(R4),S.CTM(R4)  ;SET TIMEOUT COUNT
        ADD     #RMCS2,R2       ;POINT TO RMCS2
        MOV     #SCLR,(R2)      ;CLEAR CONTROLLER AND INIT ALL DRIVES
        MOVB    U.UNIT(R5),R0   ;FETCH DRIVE UNIT NUMBER
        MOV     R0,(R2)         ;SELECT THE DRIVE
        MOV     I.PRM+12(R3),-(R2)  ;SET TRACK AND SECTOR ADRS
        MOV     U.BUF+2(R5),-(R2)   ;SET USER BUFFER ADRS
        MOV     U.CNT(R5),-(R2) ;SET BYTES TO TRANSFER
        ROR     (R2)            ;MAKE THAT WORDS TO TRANSFER
        NEG     (R2)            ;MAKE IT A NEGATIVE WORD COUNT
        TST     -(R2)           ;POINT TO CSR
        MOV     #ACK,R0         ;GET PACK ACKNOWLEDGE FUNCTION
        CALL    155$            ;EXECUTE PACK ACK TO SET VV
11$:    TSTB    (R2)            ;WAIT FOR THE SERIAL MESSAGE ...
        BPL     11$             ;... TO RETURN
        MOV     #IE.DNR&377,R0  ;ASSUME SELECTED UNIT NOT READY
        MOV     I.PRM+10(R3),RMDC(R2)  ;SET CYLINDER ADDRESS
        MOV     RMDS(R2),R1     ;GET CURRENT DRIVE STATUS
        COM     R1              ;COMPLEMENT STATUS
        BIT     #SVAL!DRDY!VV!DRA,R1  ;DRIVE READY?
        BNE     12$             ;IF NE NO
        BIT     #UNS,RMER(R2)   ;DRIVE UNSAFE?
        BEQ     14$             ;IF EQ NO
12$:                            ;REF LABEL


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;IS DRIVE SPINNING UP?
        BNE     17$             ;IF NE YES

        .IFTF


        .IF DF  D$$IAG

        CALL    DMDINT          ;TEST FOR DIAGNOSTIC DRIVE NOT READY
        BCS     13$             ;IF CS DIAGNOSTIC                       ; PB100
                                                                        ;**-3
        .ENDC


        .IF DF  E$$DVC

        CALL    DMDVER          ;LOG DRIVE NOT READY ERROR

        .ENDC


13$:    JMP     32$             ;FINISH I/O                             ; PB100
14$:                            ;REF LABEL                              ;**-1

        .IFT

        BICB    #US.SPU,U.STS(R5)  ;RESET DRIVE SPINNING UP

        .ENDC


        .IF DF  D$$IAG

        CMPB    U.BUF(R5),#BLS  ;IS THIS A POSITIONING FUNCTION?
        BHI     15$             ;IF HI NO
        INCB    U.CW2+1(R5)     ;YES, INDICATE POSITIONING OPERATION
        CMP     #IO.OFF!IQ.UMD,I.FCN(R3)  ;OFFSET FUNCTION?
        BNE     15$             ;IF NE NO
        MOV     I.PRM+6(R3),RMOF(R2)  ;YES, SET OFFSET VALUE
15$:                            ;REF LABEL

        .ENDC


        .IF DF  E$$DVC

        CALL    $BMSET          ;SET I/O ACTIVE BIT IN MAP

        .ENDC


16$:    MOV     U.BUF(R5),R0    ;;;GET FUNCTION AND MEMORY BITS
        CALLR   155$            ;;;SET CDT, LOAD FUNCTION AND GO

;+
; CANCEL I/O OPERATION IS A NOP FOR FILE STRUCTURED DEVICES.
;-

DMCAN:  RETURN                  ;;;NOP FOR THE RK611

;+
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND
; CAUSES NO IMMEDIATE ACTION ON THE UNIT.  THE CURRENT TIMEOUT
; COUNT IS EXTENDED SO THAT IF THE UNIT WAS BUSY IT WILL HAVE
; SUFFICIENT TIME TO SPIN BACK UP.  THE NEXT I/O REQUEST TO ANY
; UNIT WILL BE SUSPENDED FOR AT LEAST THE EXTENDED TIMEOUT UNLESS
; THE UNIT IS ALREADY READY.
;-

DMPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        TSTB    S.STS(R4)       ;IS DRIVE CURRENTLY BUSY?
        BEQ     18$             ;IF EQ NO
        MOVB    #4,S.STS(R4)    ;WAIT A MAXIMUM OF ONE MINUTE
17$:    MOVB    #15.,S.CTM(R4)  ;15 SECONDS AT A TIME
18$:    BISB    #US.SPU,U.STS(R5)  ;SET UNIT SPINNING UP

        .ENDC


        RETURN                  ;WAIT FOR UNIT TO RESPOND

;+
; **-$DMINT-RK611-RK06/RK07 DISK CARTRIDGE CONTROLLER
;       INTERRUPT AND ERROR SERVICE ROUTINES
;
; HARD ERRORS ---> $IODON
; SOFT ERRORS ---> RETRY LAST FUNCTION
; DATA ERRORS ---> RETRY FUNCTION AND CORRECT IF POSSIBLE
;-
        INTSE$  DM,PR5,R$$611   ;;;SAVE REGISTERS AND SET PRIORITY
        MOV     R3,-(SP)        ;;;SAVE REGISTER 3
        MOV     U.SCB(R5),R3    ;;;GET ADDRESS OF SCB
        MOV     S.CSR(R3),R3    ;;;GET ADDRESS OF CSR
        TSTB    U.CW2+1(R5)     ;;;POSITIONING IN PROGRESS?
        BEQ     20$             ;;;IF EQ NO
        BIT     #CERR!DI,(R3)   ;;;POSITIONING COMPLETE OR ERROR?
        BNE     20$             ;;;IF NE YES
        MOV     (SP)+,R3        ;;;RESTORE R3
        RETURN                  ;;;WAIT FOR POSITIONING TO COMPLETE

20$:    BIC     #CERR!IE,(R3)   ;;;KILL IE WITHOUT HURTING CERR
        MOV     (SP)+,R3        ;;;RESTORE R3
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;GET ADRS OF SCB
        MOV     S.CSR(R4),R2    ;GET CSR ADDRESS
        TST     (R2)            ;ERRORS ALREADY PRESENT?
        BMI     21$             ;IF MI YES, FORGET STATUS UPDATE
        TST     RMDS(R2)        ;IS THE CURRENT STATUS VALID?
        BMI     21$             ;IF MI YES
        CALL    151$            ;NO, SELECT DRIVE TO GET FRESH STATUS
21$:    MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER


        .IF DF  D$$IAG

        CALL    DMDINT          ;PROCESS DIAGNOSTIC INTERRUPT
        BCS     29$             ;IF CS INTERRUPT PROCESSING COMPLETE

        .ENDC


        TSTB    U.CW2+1(R5)     ;POSITIONING FUNCTION?
        BNE     24$             ;IF NE YES
        TST     (R2)            ;ANY ERRORS?
        BPL     27$             ;IF PL NO


        .IF DF  E$$DVC

        CALL    DMDVER          ;YES, LOG THE DEVICE ERROR

        .ENDC


        MOV     RMER(R2),R1     ;COPY ERROR REGISTER BITS               ; PB100
        MOV     #IE.WLK&377,R0  ;ASSUME WRITE LOCK ERROR                ; PB100
        BIT     #WLE,R1         ;WRITE LOCK ERROR?                      ; PB100
        BNE     23$             ;IF NE YES                              ; PB100
        MOV     #IE.BBE&377,R0  ;ASSUME BAD BLOCK ERROR                 ; PB100
        BIT     #BSE,R1         ;BAD BLOCK ERROR?                       ; PB100
        BNE     23$             ;IF NE YES                              ; PB100
        MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR             ; PB100
        BIT     #UNS!DTE!IDAE!COE!FMTE!NXF!ILF,R1  ;HARD ERROR?         ; PB100
        BNE     23$             ;IF NE YES                              ; PB100
        BIT     #UPE!NED!NEM!PGE!MDS!UFE,RMCS2(R2)  ;HARD ERROR?        ; PB100
        BNE     23$             ;IF NE YES                              ; PB100
        MOV     S.PKT(R4),R3    ;RETREIVE I/O PACKET ADDRESS            ; PB100
        BITB    #IQ.X,I.FCN(R3) ;INHIBIT RETRIES?                       ; PB100
        BEQ     35$             ;IF EQ NO, TRY FOR SOFT/DATA ERRORS     ;**-11
23$:    BR      32$             ;YES, FINISH UP
24$:    MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR


        .IF DF  R$$6OF

        ASRB    U.CW2+1(R5)     ;RECALIBRATE FUNCTION?
        BNE     25$             ;IF NE NO

        .IFTF

        TST     (R2)            ;ERRORS DURING RECALIBRATE?
        BPL     31$             ;IF PL NO
        BR      32$             ;YES, FINISH UP

        .IFT

25$:    CMP     #OFFTBE,OFFAD(R3)  ;FINAL OFFSET TRIED?
        BEQ     32$             ;IF EQ YES, ALL DONE
        TST     (R2)            ;ERRORS ATTEMPTING TO OFFSET HEADS?
        BMI     31$             ;IF MI YES

        .ENDC


26$:                            ;REF LABEL


        .IF DF  E$$DVC

        CALL    190$            ;DEALLOCATE REGISTER CORE BLOCK

        .ENDC


        JMP     DMINIO          ;RETRY ORIGINAL FUNCTION
27$:                            ;REF LABEL


        .IF DF  D$$WCK

        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        BITB    IO.WLC&377,I.FCN(R1)  ;WRITE FOLLOWED BY WRITE CHECK?
        BNE     28$             ;IF NE YES
        BITB    #US.WCK,U.STS(R5)  ;WRITE CHECK ENABLED BY MCR?
        BEQ     29$             ;IF EQ NO
28$:    CMPB    #READ,U.BUF(R5) ;WAS LAST FUNCTION A READ?
        BEQ     29$             ;IF EQ YES
        CMPB    #READ+WRT,U.BUF(R5)  ;WAS LAST FUNCTION A WRITE?
        BNE     29$             ;IF NE NO
        MOVB    #WCK,U.BUF(R5)  ;SET WRITE CHECK FUNCTION
        MOV     #RETRY,RTTBL(R3);REINITIALIZE RETRY COUNT
        BR      26$             ;START WRITE CHECK OPERATION

        .ENDC


29$:    CLR     U.CNT(R5)       ;NO ERRORS, SET ALL BYTES TRANSFERED
        BR      39$             ;FINISH I/O

;+
; **-DMOUT-RK611-RK06/RK07 DISK CARTRIDGE CONTROLLER
;       DEVICE TIMEOUT ROUTINE
;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING REPEATED
; UNLESS THE OPERATION WAS DIAGNOSTIC.  TIMEOUTS ARE USUALLY CAUSED
; BY POWER FAILURE BUT MAY ALSO BE THE RESULT OF NO RESPONSE
; FROM THE HARDWARE.
;-

DMOUT:                          ;;;TIMEOUT ENTRY POINT


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;;;IS DRIVE SPINNING UP?
        BEQ     30$             ;;;IF EQ NO
        DECB    S.STS(R4)       ;;;HAVE WE WAITED ENOUGH YET?
        BEQ     30$             ;;;IF EQ YES
        MTPS    #0              ;;;ALLOW INTERRUPTS
        JMP     DMINIO          ;RETRY ENTIRE OPERATION
30$:    INCB    S.STS(R4)       ;;;LEAVE CONTROLLER BUSY
        BICB    #US.SPU,U.STS(R5)  ;;;RESET DRIVE SPINNING UP

        .ENDC


        .IF DF  D$$IAG

        CALL    DMDINT          ;;;TEST FOR DIAGNOSTIC TIMEOUT
        BCS     32$             ;IF CS IT WAS

        .ENDC


        .IF DF  E$$DVC

        CALL    DMDVTO          ;;;LOG DEVICE TIMEOUT

        .IFF

        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT

        .ENDC


        TSTB    U.CW2+1(R5)     ;TIMOUT DURING POSITIONING FUNCTION?
        BNE     32$             ;IF NE YES
31$:    MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
        BNE     32$             ;IF NE YES
        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX              ; PB100
        DECB    RTTBL(R3)       ;RETRY FUNCTION?
        BGT     26$             ;IF GT YES
;
;****************
;
; AT THIS POINT ALL I/O IS FINISHED. WE WILL CALCULATE THE
; BYTES ACTUALLY TRANSFERED AND SET THE ERROR LOGGING RETRY COUNTS.
; THEN $IODON IS CALLED TO TERMINATE THE I/O OPERATION.
;
32$:                            ;REF LABEL


        .IF DF  D$$WCK

        BIT     #WCE,RMCS2(R2)  ;WRITE CHECK ERROR?
        BEQ     33$             ;IF EQ NO
        MOV     #IE.WCK&377,R0  ;SET WRITE CHECK ERROR

        .ENDC


33$:    MOV     RMWC(R2),R1     ;GET RESIDUAL WORD COUNT
        ASL     R1              ;CONVERT TO BYTE COUNT
        NEG     R1              ;CONVERT TO POSITIVE BYTES REMAINING
        MOV     R1,U.CNT(R5)    ;SAVE BYTES REMAINING TO TRANSFER
39$:                            ;REF LABEL


        .IF DF  E$$DVC

        CALL    190$            ;DEALLOCATE REGISTER CORE BLOCK
        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ;GET FINAL ERROR RETRY COUNT
        BIS     #<RETRY*^D<256>>,R2  ;MERGE STARTING RETRY COUNT

        .ENDC


34$:    MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        MOV     I.PRM+4(R1),R1  ;GET ACTUAL BYTES TO TRANSFER
        SUB     U.CNT(R5),R1    ;CALCULATE BYTES ACTUALLY TRANSFERED
        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DMINI           ;PROCESS NEXT REQUEST
;
;****************
;
35$:    BIT     #DLT!WCE,RMCS2(R2)  ;DATA LATE OR WRITE CHECK ERROR?
        BNE     31$             ;IF NE YES
        BIT     #DCPAR!CTO,(R2) ;CONTROLLER TIMEOUT OR PARITY ERROR?
        BNE     31$             ;IF NE YES
        BIT     #CDPAR,R1       ;CONTROLLER TO DRIVE PARITY ERROR?
        BNE     31$             ;IF NE YES
        BIT     #OPI!SKI,R1     ;DRIVE POSITIONING ERROR?
        BEQ     37$             ;IF EQ NO


        .IF DF  E$$DVC

        CALL    190$            ;DEALLOCATE REGISTER CORE BLOCK

        .ENDC


        CALL    154$            ;CLEAR CONTROLLER
        CALL    150$            ;ISSUE DRIVE CLEAR FUNCTION
        MOV     #HMS,R0         ;SET RECALIBRATE FUNCTION
36$:    MOVB    S.ITM(R4),S.CTM(R4)  ;RESET TIMEOUT COUNT
        INCB    U.CW2+1(R5)     ;INDICATE POSITIONING OPERATION
        CALLR   155$            ;ISSUE FUNCTION
37$:                            ;REF LABEL


        .IF DF  R$$6OF

        BIT     #HVRC,R1        ;HEADER VRC ERROR?
        BNE     DMECC           ;YES, DO ECC

        .IFTF

        TST     R1              ;DATA CHECK ERROR?
        BPL     31$             ;IF PL NO, MUST BE SOFT ERROR

        .IFF

        BIT     #ECH,R1         ;ECC HARD ERROR?
        BNE     31$             ;YES, RETRY IT

        .ENDC


;
;****************
;
; ERROR CORRECTION IS ACCOMPLISHED IN SIX STEPS:
;
;       1) CALCULATE THE BYTE OFFSET TO THE START OF THE BLOCK
;          TRANSFERED.
;       2) CALCULATE OFFSET TO THE FIRST BAD BYTE IN THE BLOCK.
;       3) CONVERT CORRECTION PATTERN INTO TWO PATTERN WORDS.
;       4) APPLY ECC CORRECTION USING FIRST PATTERN WORD.
;       5) APPLY ECC CORRECTION USING SECOND PATTERN WORD.
;       6) FINISH OR CONTINUE PREVIOUS FUNCTION.
;
DMECC:  CMPB    #READ,U.BUF(R5) ;IS THIS A READ OPERATION?
        BNE     31$             ;IF NE NO


        .IF DF  S$$ECC

        MOV     R2,R3           ;COPY CSR ADDRESS
        ADD     #RMECPS,R3      ;POINT TO ECC POSITION REGISTER
        CALL    $ECCOR          ;CALL SHARED ECC ROUTINE


        .IF DF  R$$6OF

        BCS     60$             ;OFFSET RECOVERY NECESSARY

        .ENDC


        .IFF

        MOV     RMWC(R2),R0     ;GET NEGATIVE WORDS REMAINING
        ASL     R0              ;CONVERT TO BYTES
        ADD     U.CNT(R5),R0    ;CALCULATE BYTES ACTUALLY TRANSFERED
        MOV     R0,-(SP)        ;SAVE IT


        .IF DF  R$$6OF

        BEQ     DMOFST          ;BRANCH IF NO BYTES TRANSFERED
        BIT     #HVRC,R1        ;HEADER VRC ERROR?
        BNE     40$             ;YES

        .IFTF

        DEC     R0              ;CALCULATE OFFSET TO START OF BLOCK
40$:    BIC     #777,R0         ;CLEAR RESIDUE

        .IFT

        BIT     #ECH!HVRC,R1    ;ECC HARD ERROR?
        BNE     DMOFST          ;YES

        .ENDC


        MOV     RMECPS(R2),R1   ;GET STARTING BIT NUMBER
        DEC     R1              ;CONVERT TO RELATIVE BIT NUMBER
        MOV     R1,-(SP)        ;SAVE STARTING RELATIVE BIT NUMBER
        BIC     #^C<17>,R1      ;ISOLATE SHIFT COUNT
        BIC     R1,(SP)         ;CLEAR SHIFT COUNT IN RELATIVE BIT #
        CLC                     ;CALCULATE OFFSET TO FIRST BAD ...
        ROR     (SP)            ;... BYTE IN THE BLOCK
        ASR     (SP)
        ASR     (SP)
        ADD     (SP),R0         ;SET OFFSET TO FIRST BYTE IN TRANSFER
        MOV     RMECPT(R2),R3   ;GET CORRECTION PATTERN WORD
        CLR     (SP)            ;CLEAR SECOND PATTERN WORD
41$:    DEC     R1              ;ANY MORE SHIFTS TO PERFORM?
        BLT     42$             ;IF LT NO
        ASL     R3              ;THIS IS IN CASE THE ERROR BURST ...
        ROL     (SP)            ;... CROSSED A 16 BIT WORD BOUNDRY
        BR      41$             ;CONTINUE SHIFTING
42$:    CALL    DMECOR          ;APPLY ECC CORRECTION
        MOV     (SP)+,R3        ;RETREIVE SECOND PATTERN WORD
        ADD     #2,R0           ;UPDATE OFFSET TO NEXT BAD(?) WORD
        CALL    DMECOR          ;APPLY ECC CORRECTION
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX
        MOV     (SP)+,R1        ;RETREIVE BYTES ACTUALLY TRANSFERED

        .ENDC


        .IF DF  R$$6OF

        CALL    110$            ;RESET OFFSET RECOVERY PARAMETERS

        .ENDC


        SUB     R1,U.CNT(R5)    ;ANY MORE BYTES TO TRANSFER?
        BEQ     32$             ;NO


        .IF DF  M$$MGE

        MOV     (R2),R1         ;RETREIVE RMCS1 CONTENTS
        SWAB    R1              ;REPOSITION BYTES
        BICB    #^C<3>,R1       ;ISOLATE MEMORY EXTENSION BITS          ; PB056
        MOVB    R1,U.BUF+1(R5)  ;SAVE FOR NEXT FUNCTION                 ;**-1

        .ENDC


        MOV     RMBA(R2),U.BUF+2(R5)  ;SAVE BUFFER ADRS
        MOV     S.PKT(R4),R1    ;GET ADRS OF I/O PACKET
        MOV     RMDC(R2),I.PRM+10(R1)  ;SAVE CYLINDER ADRS
        MOV     RMDA(R2),I.PRM+12(R1)  ;SAVE TRACK/SECTOR ADRS


        .IF DF  E$$DVC

        CALL    190$            ;DEALLOCATE REGISTER CORE BLOCK

        .IFTF

        CALL    154$            ;CLEAR CONTROLLER
        CALL    150$            ;ISSUE DRIVE CLEAR FUNCTION
        MOV     U.BUF+2(R5),RMBA(R2)  ;SET PREVIOUS BUFFER ADDRESS

        .IFT

        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS

        .ENDC


        MOV     I.PRM+10(R1),RMDC(R2)  ;SET PREVIOUS CYLINDER ADDRESS
        MOV     I.PRM+12(R1),RMDA(R2)  ;SET PREVIOUS DISK ADDRESS
        JMP     16$             ;RESTART FROM WHERE WE LEFT OFF


        .IF NDF S$$ECC

;
; ECC CORRECTION ALGORITHM
;
; THIS ROUTINE CALCULATES THE MEMORY ADDRESS OF THE DATA WORD TO
; BE CORRECTED AND THEN USING THE SUPPLIED PATTERN WORD PREFORMS
; AN XOR OF THE PATTERN AND DATA WORDS.
;
DMECOR: CMP     R0,U.CNT(R5)    ;BYTE OFFSET WITHIN RANGE?
        BHIS    50$             ;NO


        .IF DF  D$$IAG

        CALL    $RELOP          ;RELOCATE PHYSICAL ADDRESS

        .IFF


        .IF DF  M$$MGE

        MOV     U.BUF(R5),-(SP) ;GET ORIGINAL MEMORY EXTENSION BITS
        CLRB    (SP)            ;CLEAR FUNCTION BYTE

        .IFTF

        MOV     U.BUF+2(R5),R1  ;RETREIVE STARTING BUFFER ADRS
        ADD     R0,R1           ;CALCULATE ADDRESS OF WORD TO BE CORRECTED

        .IFT

        ADCB    1(SP)           ;PROPAGATE ADRS CARRY
        SWAB    R1              ;SWAP STARTING BUFFER ADRS
        BISB    R1,(SP)         ;MERGE 8 BITS OF UPPER ADRS BIAS
        ASL     R1              ;COLLECT REMAINING TWO BITS
        ROL     (SP)
        ASL     R1
        ROL     (SP)
                                                                        ; PB056
                                                                        ; PB056
        .IF DF  M$$EXT                                                  ; PB056
                                                                        ; PB056
        ADD     #170000,(SP)    ;FORCE UNIBUS MAP TO ACCESS MAIN MEMORY ; PB056
                                                                        ; PB056
        .ENDC                                                           ; PB056
                                                                        ; PB056
                                                                        ; PB056
        MOV     (SP)+,KISAR6    ;SET BUFFER RELOCATION BIAS
        CLRB    R1              ;CLEAR LOW BYTE OF STARTING ADRS
        SWAB    R1              ;SWAP ADRS BACK
        ASR     R1              ;SETUP APR6 ADRS
        ASR     R1
        BIS     #140000,R1

        .ENDC


        .ENDC


        MOV     (R1),-(SP)      ;COPY CURRENT DATA WORD
        BIC     R3,(R1)         ;.NOT.PATTERN.AND.DATA WORD
        BIC     (SP)+,R3        ;.NOT.DATA WORD.AND.PATTERN
        BIS     R3,(R1)         ;PATTERN.OR.DATA WORD
50$:    RETURN

        .ENDC


        .IF DF  R$$6OF

;+
; OFFSET POSITIONING READ RECOVERY
;
; THE TRANSFER ENDED IN AN ECC HARD ERROR BUT THERE WERE SECTORS
; TRANSFERED THAT CONTAINED GOOD DATA.  SINCE THE ECC HARD ERROR
; COULD HAVE BEEN CAUSED BY A CYLINDER CROSSING, THE GOOD DATA IS
; SAVED AND THE TRANSFER IS RETRIED FROM THE POINT OF ERROR.
;-
DMOFST: TST     (SP)+           ;REMOVE STACKED COUNT
60$:    TST     R0              ;ANY GOOD SECTORS TRANSFERED?
        BEQ     80$             ;NOPE
        ADD     R0,U.BUF+2(R5)  ;UPDATE STARTING BUFFER ADRS
        ADCB    U.BUF+1(R5)     ;PROPAGATE CARRY INTO EXTENSION BITS
        SUB     R0,U.CNT(R5)    ;REDUCE BYTES REMAINING TO TRANSFER
        SWAB    R0              ;CALCULATE THE NUMBER OF...
        ASR     R0              ;...SECTORS TRANSFERED
        MOV     S.PKT(R4),R1    ;GET ADRS OF I/O PACKET
        ADD     I.PRM+12(R1),R0 ;UPDATE TRACK/SECTOR ADRS
61$:    CMPB    #^D<22>,R0      ;SECTOR OVERFLOW?
        BHI     65$             ;NO
        SUB     #^D<22>,R0      ;SUBTRACT OUT A SECTOR
        ADD     #<1*^D<256>>,R0 ;ADD IN A TRACK
        CMP     #<3*^D<256>>,R0 ;TRACK OVERFLOW?
        BHI     61$             ;NO
        SUB     #<3*^D<256>>,R0 ;NORMALIZE TRACK ADRS
        INC     I.PRM+10(R1)    ;UPDATE CYLINDER ADRS
        BR      61$
65$:    MOV     R0,I.PRM+12(R1) ;SET UPDATED TRACK/SECTOR ADRS
70$:    CALL    120$            ;RESET OFFSET TABLE ADRS
        BR      85$
;
; NO GOOD DATA WAS TRANSFERED SO CHECK TO SEE IF THE OFFSET
; FROM TRACK CENTERLINE SHOULD BE CHANGED.
;
80$:    DECB    RTTBL+1(R3)     ;CHANGE OFFSET?
        BGT     100$            ;NO
        MOVB    #OFFTRY,RTTBL+1(R3)  ;SET RECOVERY RETRY COUNT
85$:    INC     OFFAD(R3)       ;UPDATE OFFSET POINTER


        .IF DF  E$$DVC

        CALL    190$            ;DEALLOCATE REGISTER CORE BLOCK

        .ENDC


        MOVB    @OFFAD(R3),R0   ;GET NEXT OFFSET VALUE
        BNE     90$             ;IF NE NOT RETURNING TO CENTERLINE
        MOVB    #RETRY*2,RTTBL+1(R3)  ;TRY 16 TIMES AT CENTERLINE
90$:    CALL    154$            ;CLEAR CONTROLLER
        CALL    150$            ;ISSUE DRIVE CLEAR FUNCTION
        MOV     R0,RMOF(R2)     ;LOAD NEXT OFFSET VALUE
        MOV     #OFF,R0         ;SET OFFSET FUNCTION
        JMP     36$
100$:   JMP     26$             ;RETRY FUNCTION
;
;****************
;
; RESET THE OFFSET RECOVERY PARAMETERS
;
110$:   MOVB    #1,RTTBL+1(R3)  ;SET RECOVERY COUNT TO ONE
120$:   MOV     #OFFTB-1,OFFAD(R3)  ;SET OFFSET TABLE POINTER
        RETURN

        .ENDC


;+
; INITIATE A CONTROLLER/DRIVE CLEAR OR SELECT DRIVE FUNCTION
; AND WAIT FOR THE SERIAL MESSAGE.
;
; NOTE: THE TIMING LOOP AT 153$ IS TO ALLOW TIME FOR THE
;       SERIAL MESSAGE TO BE SENT TO THE DRIVE AND THE STATUS
;       TO BE RECEIVED BY THE RK611.  AVERAGE TIME = 15US.
;-
150$:   MOV     R0,-(SP)        ;SAVE REGISTER
        MOV     #DC,R0          ;ISSUE DRIVE CLEAR FUNCTION
        BR      152$            ;
151$:   MOV     R0,-(SP)        ;
        MOV     #SD,R0          ;ISSUE SELECT DRIVE FUNCTION
152$:   CALL    155$            ;LOAD RMCS1
153$:   TSTB    (R2)            ;WAIT FOR THE SERIAL MESSAGE ...
        BPL     153$            ;... TO DO ITS THING
        MOV     (SP)+,R0        ;RESTORE REGISTER
        RETURN                  ;
154$:   MOV     #CERR,(R2)      ;CLEAR CONTROLLER
        MOVB    U.UNIT(R5),-(SP)  ;GET CURRENT UNIT NUMBER
        MOV     (SP)+,RMCS2(R2) ;RE-SELECT THE UNIT
        RETURN
155$:   TST     U.CW3(R5)       ;RK07 BLOCK NUMBER?
        BPL     156$            ;IF PL NO, IT'S AN RK06
        BIS     #CDT,R0         ;SET CDT FOR RK07
156$:   MOV     R0,(R2)         ;EXECUTE THE FUNCTION
        RETURN                  ;


        .IF DF  E$$DVC

;+
; **-DMDVXX-RK611-RK06/RK07 DISK CARTRIDGE CONTROLLER
;       ERROR LOGGING ROUTINES
;
; THIS ROUTINE IS CALLED WHENEVER A DEVICE ERROR OR DEVICE TIMEOUT
; OCCURS.  A CORE BLOCK THE SIZE OF THE REGISTER BUFFER IS
; ALLOCATED AND THE REGISTERS (INCLUDING THE SIX EXTRA MAINTENANCE
; REGISTERS) ARE TRANSFERED INTO THE CORE BLOCK.  THEN THE CSR
; ADDRESS IN THE SCB IS SET TO THE CORE BLOCK ADDRESS AND THE
; APPROPRIATE EXECUTIVE ERROR LOGGING ROUTINE IS CALLED.  THE CORE
; BLOCK ADDRESS IS THEN USED AS A PSEUDO REGISTER BASE ADDRESS BY
; THE ERROR HANDLING ROUTINES.  BEFORE THE NEXT FUNCTION IS ISSUED,
; THE DEALLOCATION ROUTINE AT 190$ MUST BE CALLED TO DEALLOCATE THE
; CORE BLOCK AND RESTORE THE REAL CSR BASE ADDRESS.
;
; IF FOR ANY REASON THE CORE BLOCK CANNOT BE ALLOCATED THEN
; THE EXECUTIVE ERROR LOGGING ROUTINE WILL NOT BE CALLED AND
; THE ERROR SEQUENCE NUMBER WILL BE UPDATED TO INDICATE THAT
; A MISSED ERROR CONDITION OCCURRED.
;
; NOTE: IF ENTRY IS THE RESULT OF A DEVICE TIMEOUT THEN THIS
;       ROUTINE IS EXECUTED AT THE RK611 DEVICE PRIORITY LEVEL (PR5)
;       UNTIL THE EXEC ERROR LOGGING ROUTINE IS CALLED.
;
; INPUTS:
;        R2 = CSR ADDRESS
;        R4 = SCB ADDRESS
;
; OUTPUTS:
;        R2 = ADDRESS OF REGISTER CORE BLOCK IF ONE WAS ALLOCATED
;             OR CSR ADDRESS IF ONE WAS NOT.
;        R4 = SCB ADDRESS
;
;        R0,R3 ARE PRESERVED ACROSS CALL
;-
DMDVER: MOV     #$DVERR,R1      ;GET ADRS OF DEVICE ERROR ROUTINE
        BR      180$
DMDVTO: MOV     #$DTOER,R1      ;;;GET ADRS OF DEVICE TIMEOUT ROUTINE
180$:   MOV     R3,-(SP)        ;PRESERVE CONTROLLER INDEX
        MOV     R0,-(SP)        ;SAVE I/O STATUS CODE
        MOV     R2,-(SP)        ;SAVE CSR ADDRESS
        MOV     R1,-(SP)        ;SET CO-ROUTINE ADDRESS
        MOV     #RMCNT*2,R1     ;GET NUMBER OF BYTES TO ALLOCATE
        CALL    $ALOCB          ;ALLOCATE A CORE BLOCK
        BCC     182$            ;IF CC BLOCK WAS ALLOCATED
        INC     $ERRSQ          ;INDICATE A MISSED ERROR CONDITION
        CMP     (SP)+,#$DTOER   ;ALLOCATION FAILURE, TIMEOUT IN PROGRESS?
        BNE     183$            ;IF NE DON'T LOG ERROR
        BIC     #CERR!IE,@S.CSR(R4)  ;;;CLEAR IE WITHOUT DOING A CCLR
        MTPS    #0              ;;;ALLOW INTERRUPTS
        BR      183$            ;DON'T LOG ERROR IF ALLOCATION FAILURE
182$:   MOV     R0,S.CSR(R4)    ;REPLACE CSR WITH ADDRESS OF CORE BLOCK
        MOV     2(SP),R2        ;GET REAL CSR ADDRESS
        CALL    DMRPAS          ;XFER THE REGISTERS
        CALL    @(SP)+          ;CALL THE EXEC ERROR LOGGING ROUTINE
        MOV     S.CSR(R4),R0    ;GET ADDRESS OF CORE BLOCK
        MOV     (SP),S.CSR(R4)  ;RESTORE CSR ADDRESS
        MOV     R0,(SP)         ;PUT CORE BLOCK ADRS IN SAVED CSR ADRS
183$:   MOV     (SP)+,R2        ;SET CSR ADDRESS
184$:   MOV     (SP)+,R0        ;RESTORE I/O STATUS CODE
        MOV     (SP)+,R3        ;RESTORE CONTROLLER INDEX
185$:   RETURN

190$:   CMP     R2,S.CSR(R4)    ;SHOULD WE DEALLOCATE?
        BEQ     185$            ;IF EQ NO
        MOV     R3,-(SP)        ;SAVE CONTROLLER INDEX
        MOV     R0,-(SP)        ;SAVE POSSIBLE I/O STATUS CODE
        MOV     #RMCNT*2,R1     ;GET NUMBER OF BYTES TO DEALLOCATE
        MOV     R2,R0           ;SET ADDRESS OF CORE BLOCK IN R0
        CALL    $DEACB          ;DEALLOCATE THE BLOCK
        MOV     S.CSR(R4),R2    ;RESET REAL CSR ADDRESS
        BR      184$            ;

        .ENDC


        .IF DF  E$$DVC!D$$IAG

;+
; **-DMRPAS-RK611-RK06/RK07 DISK CARTRIDGE CONTROLLER
;       CONTROLLER REGISTER PASS ROUTINE
;
; THIS ROUTINE WILL TRANSFER THE CONTENTS OF THE CONTROLLER
; REGISTERS (INCLUDING THE SIX EXTRA MAINTENANCE REGISTERS)
; INTO A PREVIOUSLY ALLOCATED BUFFER.
;
; INPUTS:
;        R0 = BUFFER ADDRESS
;        R2 = CSR ADDRESS
;        R5 = UCB ADDRESS
; OUTPUTS:
;        R2 = CSR ADDRESS
;        R3 = DESTROYED
;-
DMRPAS: MOV     #^D<14>,R3      ;LOOP COUNT FOR MAJOR REGISTERS
        MOV     R2,-(SP)        ;SAVE CSR ADDRESS
195$:   MOV     (R2)+,(R0)+     ;TRANSFER THE REGISTER
        DEC     R3
        BNE     195$
        MOV     (SP)+,R2        ;RESTORE CSR ADDRESS
196$:   CALL    154$            ;CLEAR CONTROLLER
        MOV     R3,RMMR1(R2)    ;SELECT DRIVE SERIAL MESSAGE
        CALL    151$            ;SELECT DRIVE TO GET PROPER MESSAGE
        MOV     RMMR2(R2),(R0)+ ;SAVE CONTENTS OF MR2
        MOV     RMMR3(R2),(R0)+ ;SAVE CONTENTS OF MR3
        INC     R3              ;INCREMENT DRIVE SERIAL MESSAGE COUNT
        CMP     R3,#4           ;DONE FOUR MESSAGES YET?
        BNE     196$            ;NO, LOOP
        CALL    154$            ;CLEAR CONTROLLER
        CALLR   150$            ;FINISH-UP BY CLEARING THE DRIVE

        .ENDC


        .IF DF  D$$IAG

;+
; **-DMDINT-RK611-RK06/RK07 DISK CARTRIDGE CONTROLLER
;       DIAGNOSTIC INTERRUPT HANDLER
;
; THIS SUBROUTINE HANDLES INTERUPTS FROM DIAGNOSTIC OPERATIONS.
; IF THE FUNCTION WAS DIAGNOSTIC THEN THE DEVICE REGISTERS
; ARE PASSED BACK TO THE DIAGNOSTIC TASK, THE CONTROLLER (VIA DMRPAS)
; AND THE DRIVE ARE CLEARED AND THE I/O STATUS IS RETURNED.
;
; INPUTS:
;       R2 = ADRS OF CSR
;       R4 = ADRS OF SCB
;       R5 = ADRS OF UCB
;
; OUTPUTS:
;       R1 = I/O PACKET ADDRESS (IF DIAGNOSTIC FUNCTION)
;       R2 = ADDRESS OF CSR
;       R4 = ADDRESS OF SCB
;       C = 1 IF INTERRUPT WAS FROM DIAGNOSTIC FUNCTION
;
;       R0,R3 ARE PRESERVED ACROSS CALL
;-
DMDINT: MOV     R3,-(SP)        ;PRESERVE CONTROLLER INDEX
        MOV     S.PKT(R4),R3    ;GET ADRS OF I/O PACKET
        CLC                     ;ASSUME NOT DIAGNOSTIC INTERRUPT
        BITB    #IQ.UMD,I.FCN(R3)  ;DIAGNOSTIC FUNCTION?
        BEQ     252$            ;IF EQ NO, EXIT
        MOV     R0,-(SP)        ;SAVE CURRENT I/O STATUS CODE
        TSTB    R0              ;WAS THIS A SUCCESSFUL INTERRUPT?
        BPL     250$            ;IF PL YES
        CALL    $DTOER          ;;;TIMEOUT, CLEAN-UP AFTER IT
        BR      251$            ;JUST PASS THE REGISTERS
250$:   CMP     #IO.RDH!IQ.UMD,I.FCN(R3)  ;READ HEADERS?
        BNE     251$            ;NO, PROCESS NORMAL
        CLR     R0              ;CLEAR BYTE OFFSET INTO BUFFER
        CALL    $RELOP          ;RELOCATE PHYSICAL ADDRESS
        MOV     RMDB(R2),(R1)+  ;TRANSFER FIRST HEADER WORD
        MOV     RMDB(R2),(R1)+  ;TRANSFER SECOND HEADER WORD
        MOV     RMDB(R2),(R1)+  ;TRANSFER THIRD HEADER WORD
251$:   MOV     R3,R1           ;SAVE I/O PACKET ADDRESS


        .IF DF  M$$MGE

        MOV     I.PRM+14(R3),KISAR6  ;SET BUFFER RELOCATION BIAS

        .ENDC


        MOV     I.PRM+16(R3),R0 ;GET REGISTER BUFFER ADDRESS
        CALL    DMRPAS          ;PASS THE CONTROLLER REGISTERS
        SEC                     ;SET DIAGNOSTIC INTERRUPT RETURN
        MOV     (SP)+,R0        ;RESTORE I/O STATUS CODE
252$:   MOV     (SP)+,R3        ;RESTORE CONTROLLER INDEX
        RETURN

        .ENDC


        .DSABL  LSB
        .END

        .TITLE  DPDRV
        .IDENT  /07/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 07
;
; D. N. CUTLER 9-FEB-74
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
; 
;       P. J. BEZEREDI 07-FEB-77
;
;               PB013 -- ADDITION OF EXPANDED WRITE CHECK SUPPORT.
;
;       P. J. BEZEREDI 14-FEB-77
;
;               PB014 -- LOAD SECOND STATUS WORD WITH BYTES ACTUALLY
;                       TRANSFERED BEFORE CALLING $IODON.
;
;       P. J. BEZEREDI 30-MAR-77
;
;               PB022 -- ADD DELAY AFTER ABORTING THE CONTROLLER TO
;                       ACCOMODATE FAST PROCESSORS.
;
;       P. J. BEZEREDI 26-APR-77
;
;               PB025 -- CORRECT HOME SEEK IN PROGRESS LOGIC.
;
;       P. J. BEZEREDI 16-MAY-77
;
;               PB030 -- POWERFAIL RECOVERY SUPPORT.
;
;       P. J. BEZEREDI 01-FEB-79
;
;               PB097 -- ISSUE RECALIBRATE IF HEADER NOT FOUND.
;
;
; RP11-C/E DISK PACK CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS

;
; EQUATED SYMBOLS
;

RETRY=8.                        ;ERROR RETRY COUNT

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   R$$P11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   R$$P11          ;ERROR RETRY COUNT AND POSITIONING FLAG


        .IF GT  R$$P11-1

TEMP:   .BLKW   1               ;TEMPORY STORAGE FOR CONTROLLER NUMBER

        .ENDC


        .IF DF  D$$IAG

        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS

;
; DIAGNOSTIC FUNCTION CODE TABLE
;
FUNTBL: .WORD   IO.HMS!IQ.UMD, 20015
        .WORD   IO.BLS!IQ.UMD, 20011
        .WORD   IO.RDH!IQ.UMD, 14105
        .WORD   IO.WDH!IQ.UMD, 14103
        .WORD   IO.WCK!IQ.UMD, 00107
FUNTBE:

        .ENDC


;
; DRIVER DISPATCH TABLE
;

$DPTBL::.WORD   DPINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DPCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DPOUT           ;DEVICE TIMEOUT
        .WORD   DPPWF           ;POWERFAIL ENTRY POINT

;+
; **-DPINI-RP11-C/E DISK PACK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
1$:     RETURN                  ;CONTROLLER BUSY OR NO REQUEST
DPINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     1$              ;IF CS NO PACKET

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R3=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; RP11-C/E DISK PACK CONTROLLER I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB OR IO.WLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- MEMORY EXTENSION BITS (BITS 4 AND 5) OF I/O TRANSFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- LOW BYTE MUST BE ZERO AND HIGH BYTE NOT USED.
;       WD. 17 -- LOGICAL BLOCK NUMBER OF I/O REQUEST.
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. ADRS ELSE NOT USED
;       WD. 21 -- DIAGNOSTIC REG. BLK ADRS (REAL OR DISPL.+140000)
;

        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB


        .IF DF  M$$EXT&M$$MGE

        CALL    $STMAP          ;SET UP UNIBUS MAPPING ADDRESS

        .ENDC


        MOVB    R2,U.BUF+1(R5)  ;INSERT DRIVE NUMBER


        .IF DF  D$$IAG

        CMPB    #IO.HMS/^D<256>,I.FCN+1(R1)  ;DIAGNOSTIC FUNCTION?
        BNE     5$              ;IF NE NO
        MOV     #FUNTBL,R0      ;GET ADDRESS OF FUNCTION TABLE
3$:     CMP     (R0)+,I.FCN(R1) ;FUNCTION CODE MATCH?
        BEQ     4$              ;IF EQ YES
        TST     (R0)+           ;BYPASS CONTROLLER CODE
        CMP     #FUNTBE,R0      ;END OF FUNCTION TABLE?
        BEQ     5$              ;IF EQ YES
        BR      3$              ;TRY AGAIN
4$:     BIS     (R0),U.BUF(R5)  ;SET CONTROLLER FUNCTION BITS
        BR      10$             ;GO CHECK LOGICAL BLOCK NUMBER

        .ENDC


5$:     MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        BIS     #105,U.BUF(R5)  ;ASSUME READ LOGICAL FUNCTION
        CMPB    #IO.RLB/256.,I.FCN+1(R1) ;READ LOGICAL FUNCTION?
        BHIS    6$              ;IF HIS FUNCTION IS LEGAL
        JMP     100$            ;FUNCTION IS ILLEGAL
6$:     BEQ     10$             ;IF EQ FUNCTION WAS READ
        SUB     #2,U.BUF(R5)    ;CONVERT TO WRITE LOGICAL FUNCTION
10$:    MOV     #RETRY&377,RTTBL(R3) ;CLEAR HOME SEEK FLAG AND SET RETRY COUNT
        CALL    $BLKCK          ;CHECK LOGICAL BLOCK NUMBER
        ASR     R2              ;DIVIDE LOGICAL BLOCK NUMBER BY 2
        ROR     R0              ;
        ROL     R2              ;SAVE 1 BIT REMAINDER
        MOV     #100.,R1        ;SET CYLINDER DIVISOR
        CALL    $DIV            ;CALCULATE CYLINDER NUMBER
        MOV     R0,I.PRM+10(R3) ;SAVE CYLINDER NUMBER
        ASL     R1              ;MULTIPLY REMAINDER BY 2
        BIS     R2,R1           ;MERGE PREVIOUS 1 BIT REMAINDER
        MOV     R1,R0           ;SET DIVIDEND
        MOV     #10.,R1         ;SET TRACK DIVISOR
        CALL    $DIV            ;CALCULATE TRACK AND SECTOR
        SWAB    R0              ;SWAP TRACK NUMBER TO LEFT BYTE
        BIS     R1,R0           ;MERGE SECTOR NUMBER
        MOV     R0,I.PRM+12(R3) ;SAVE TRACK AND SECTOR ADDRESS

;
; INITIATE I/O OPERATION
;

30$:                            ;REF LABEL


        .IF DF  M$$EXT&M$$MGE

        CALL    $MPUBM          ;MAP UNIBUS TO TRANSFER

        .ENDC


        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     S.PKT(R4),R1    ;RETRIEVE ADDRESS OF I/O REQUEST PACKET
        MOVB    S.ITM(R4),S.CTM(R4) ;SET CURRENT DEVICE TIMEOUT COUNT
        CALL    200$            ;ABORT CONTROLLER AND SELECT UNIT
        ADD     #10,R2          ;POINT TO DISK ADDRESS REGISTER
        MOV     I.PRM+12(R1),(R2)  ;INSERT TRACK AND SECTOR ADDRESS
        MOV     I.PRM+10(R1),-(R2)  ;INSERT CYLINDER ADDRESS
        MOV     U.BUF+2(R5),-(R2)  ;INSERT BUFFER ADDRESS
        MOV     U.CNT(R5),-(R2) ;INSERT NUMBER OF BYTES TO TRANSFER
        ROR     (R2)            ;CONVERT TO WORD COUNT
        NEG     (R2)            ;MAKE NEGATIVE WORD COUNT
        TST     -(R2)           ;POINT BACK TO CSR
        MOV     #IE.DNR&377,R0  ;ASSUME DRIVE NOT READY
        MOV     -4(R2),-(SP)    ;GET CONTENTS OF DRIVE STATUS REGISTER
        COM     (SP)            ;COMPLEMENT STATUS
        BIT     #140000,(SP)+   ;DRIVE READY AND ON-LINE?
        BEQ     31$             ;IF EQ YES


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;IS DRIVE SPINNING UP?
        BNE     35$             ;IF NE YES

        .IFTF


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC OPERATION?
        BNE     39$             ;IF NE YES

        .ENDC


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DRIVE NOT READY ERROR

        .ENDC


        JMP     90$             ;FINISH I/O
31$:                            ;REF LABEL

        .IFT

        BICB    #US.SPU,U.STS(R5)  ;RESET DRIVE SPINNING UP

        .ENDC


        .IF DF  D$$IAG

        CMPB    #IO.RDH!IQ.UMD&377,I.FCN(R1)  ;READ HEADER FUNCTION?
        BEQ     33$             ;IF EQ YES
        CMPB    #IO.WDH!IQ.UMD&377,I.FCN(R1)  ;WRITE HEADER FUNCTION?
        BNE     34$             ;IF NE NO
33$:    BIT     #360,10(R2)     ;SYNCHRONIZE THE SECTOR COUNTER ...
        BNE     33$             ;... ON THE NEXT INDEX PULSE IN CASE ...
        BIT     #360,10(R2)     ;... A UNIT OTHER THAN 0 WAS ...
        BNE     33$             ;... SELECTED FOR HEADER OPERATIONS.
34$:                            ;REF LABEL

        .ENDC


        .IF DF  E$$DVC

        CALL    $BMSET          ;SET I/O ACTIVE BIT IN MAP

        .ENDC


        MOVB    U.BUF(R5),(R2)  ;LOAD FUNCTION AND GO

;
; CANCEL I/O OPERATION IS A NOP FOR FILE STRUCTURED DEVICES.
;

DPCAN:  RETURN                  ;;;NOP FOR RP11

;+
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND
; CAUSES NO IMMEDIATE ACTION ON THE UNIT.  THE CURRENT TIMEOUT
; COUNT IS EXTENDED SO THAT IF THE UNIT WAS BUSY IT WILL HAVE
; SUFFICIENT TIME TO SPIN BACK UP.  THE NEXT I/O REQUEST TO ANY
; UNIT WILL BE SUSPENDED FOR AT LEAST THE EXTENDED TIMEOUT UNLESS
; THE UNIT IS ALREADY READY.
;-

DPPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        TSTB    S.STS(R4)       ;IS DRIVE CURRENTLY BUSY?
        BEQ     36$             ;IF EQ NO
        MOVB    #5,S.STS(R4)    ;WAIT A MAXIMUM OF 75 SECONDS
35$:    MOVB    #15.,S.CTM(R4)  ;15 SECONDS AT A TIME
36$:    BISB    #US.SPU,U.STS(R5)  ;SET UNIT SPINNING UP

        .ENDC


        RETURN                  ;WAIT FOR UNIT TO RESPOND

;+
; **-$DPINT-RP11-C/E DISK PACK CONTROLLER INTERRUPTS
;-

        INTSE$  DP,PR5,R$$P11   ;;;SAVE REGISTERS AND SET PRIORITY
        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOV     S.CSR(R4),R4    ;;;GET ADDRESS OF CSR
        BIC     #20100,(R4)     ;;;CLEAR INTERRUPT ENABLE
        MOVB    #377,-4(R4)     ;;;CLEAR ATTENTION SUMMARY BITS ON
        CLRB    -4(R4)          ;;;BOTH OLD AND ECO'D CONTROLLERS
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R2           ;COPY ADDRESS OF CSR
        MOV     U.SCB(R5),R4    ;RETRIEVE ADDRESS OF SCB
        MOVB    S.CON(R4),R3    ;RETRIEVE CONTROLLER INDEX
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC FUNCTION EXECUTED?
39$:    BNE     105$            ;IF NE YES

        .ENDC


        ASRB    RTTBL+1(R3)     ;HOME SEEK IN PROGRESS?
        BCS     59$             ;IF CS YES
        TST     (R2)            ;ANY ERRORS?
        BPL     50$             ;IF PL NO


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DEVICE ERROR

        .ENDC


40$:    BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
        BNE     60$             ;IF NE YES
        DECB    RTTBL(R3)       ;ANY MORE RETRIES?
        BLE     60$             ;IF LE NO
        BIT     #1371,-2(R2)    ;RECOVERABLE ERROR?
        BEQ     60$             ;IF EQ NO
        BIT     #14000,-4(R2)   ;SKI OR HNF ERRORS?                     ; PB097
        BEQ     46$             ;IF EQ NO                               ;**-1
45$:    MOVB    #1,RTTBL+1(R3)  ;SET HOME SEEK IN PROGRESS FLAG
        MOVB    S.ITM(R4),S.CTM(R4) ;RESET DEVICE TIMEOUT COUNT
        CALL    200$            ;ABORT CONTROLLER AND SELECT UNIT
        BIS     #20015,(R2)     ;INITIATE HOME SEEK FUNCTION
        RETURN                  ;
46$:    JMP     30$             ;RETRY ENTIRE OPERATION
50$:                            ;REF LABEL


        .IF DF  D$$WCK

        BITB    #IO.WLC&377,I.FCN(R1)  ;WRITE FOLLOWED BY WRITE CHECK?
        BNE     51$             ;IF NE YES
        BITB    #US.WCK,U.STS(R5)  ;WRITE CHECK ENABLED BY MCR?
        BEQ     90$             ;IF EQ NO
51$:    MOVB    U.BUF(R5),R1    ;GET LAST FUNCTION
        BIT     #1*2,R1         ;WRITE OR WRITE CHECK FUNCTION?
        BEQ     90$             ;IF EQ NO
        BIS     #2*2,U.BUF(R5)  ;SET WRITE CHECK FUNCTION
        BIT     #2*2,R1         ;WAS LAST FUNCTION A WRITE CHECK?
        BNE     90$             ;IF NE YES
        MOV     #RETRY,RTTBL(R3);REINITIALIZE RETRY COUNT
        BR      46$             ;START WRITE CHECK OPERATION

        .IFF

        BR      90$             ;FINISH OPERATION

        .ENDC


59$:    TST     (R2)            ;HOME SEEK SUCCESSFUL?
        BPL     46$             ;IF PL YES
60$:    MOV     #IE.WLK&377,R0  ;ASSUME DRIVE WRITE LOCKED
        MOV     -2(R2),R1       ;GET CONTENTS OF ERROR REGISTER
        BMI     90$             ;IF MI WRITE LOCK ERROR


        .IF DF  D$$WCK

        MOV     #IE.WCK&377,R0  ;ASSUME WRITE CHECK ERROR
        BIT     #10,R1          ;WRITE CHECK ERROR?
        BNE     90$             ;IF NE YES

        .ENDC


        MOV     #IE.VER&377,R0  ;UNRECOVERABLE ERROR
90$:    MOV     2(R2),R1        ;GET WORDS REMAINING TO TRANSFER
        ASL     R1              ;CONVERT TO BYTES LEFT TO TRANSFER
        ADD     U.CNT(R5),R1    ;CALCULATE BYTES ACTUALLY TRANSFERED
        CALL    200$            ;ABORT THE CONTROLLER
100$:                           ;REF LABEL


        .IF DF  E$$DVC

        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ;GET FINAL ERROR RETRY COUNT
        BIS     #RETRY*256.,R2  ;MERGE STARTING RETRY COUNT

        .ENDC


        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DPINI           ;PROCESS NEXT REQUEST

;
; DEVICE TIMEOUT RESULTS IN A HOME SEEK FOLLOWED BY THE I/O OPERATION
; BEING REPEATED UNLESS THE OPERATION WAS DIAGNOSTIC.  TIMEOUTS ARE
; USUALLY CAUSED BY POWERFAILURE BUT MAY ALSO BE THE RESULT OF A
; HARDWARE FAILURE.
;

DPOUT:                          ;;;TIMEOUT ENTRY POINT


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;;;IS DRIVE SPINNING UP?
        BEQ     104$            ;;;IF EQ NO
        DECB    S.STS(R4)       ;;;HAVE WE WAITED ENOUGH YET?
        BEQ     104$            ;;;IF EQ YES
        MTPS    #0              ;;;ALLOW INTERRUPTS
        BR      46$             ;RETRY ENTIRE OPERATION
104$:   INCB    S.STS(R4)       ;;;LEAVE CONTROLLER BUSY
        BICB    #US.SPU,U.STS(R5)  ;;;RESET DRIVE SPINNING UP

        .ENDC


        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT


        .IF DF  D$$IAG

        BCC     110$            ;IF CC TIMEOUT DURING NORMAL FUNCTION
105$:   CALL    $CRPAS          ;PASS CONTROLLER REGISTERS TO TASK
        BR      90$             ;DIAGNOSTIC PROCESSING COMPLETE
110$:                           ;REF LABEL

        .ENDC


        MOVB    U.UNIT(R5),1(R2) ;SET CURRENT UNIT NUMBER
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
        BNE     90$             ;IF NE YES
        DECB    RTTBL(R3)       ;ANY RETRIES LEFT?
        BLE     90$             ;IF LE NO
        BR      45$             ;

;+
; THIS ROUTINE WILL ABORT THE CONTROLLER AND SELECT THE CURRENT
; UNIT.  A DELAY IS INITIATED BETWEEN EACH CONTROLLER ABORT TO
; ALLOW THE HARDWARE TIME TO SETTLE DOWN ON FAST PROCESSORS.
;-

200$:   MOV     #1,(R2)         ;ABORT THE CONTROLLER
        BICB    -(SP),(SP)+     ;DELAY TO ALLOW THE HARDWARE ...
        BICB    -(SP),(SP)+     ;... TIME TO SETTLE DOWN
        MOV     #1,(R2)         ;CLEAR ANY ERRORS CAUSED BY THE ABORT
        BICB    -(SP),(SP)+     ;DELAY TO ALLOW THE HARDWARE ...
        BICB    -(SP),(SP)+     ;... TIME TO SETTLE DOWN
        MOVB    U.BUF+1(R5),1(R2)  ;SELECT THE UNIT
        RETURN                  ;

        .DSABL  LSB

        .END
        .TITLE  DRABO
        .IDENT  /03/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; D. N. CUTLER 11-SEP-73
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  ABODF$
        ABODF$                  ;DEFINE TASK ABORT CODES
 
;+
; **-$DRABO-ABORT TASK
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO TERMINATE THE EXECUTION OF A
; SPECIFIED TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(83.),DPB SIZE(3.).
;       WD. 01 -- FIRST HALF OF TASK NAME.
;       WD. 02 -- SECOND HALF OF TASK NAME.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TASK TO TERMINATE.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TASK TO TERMINATE.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS7' IS RETURNED IF THE SPECIFIED
;                       TASK IS NOT ACTIVE.
;-
 
$DRABO::TST     (R1)+           ;SPECIFIED TASK ACTIVE?
        BMI     10$             ;IF MI NO
        TSTB    (R1)            ;TASK ALREADY BEING TERMINATED?
        BMI     10$             ;IF MI YES
        MOV     R0,R1           ;SET TCB ADDRESS OF TASK TO ABORT
        MOV     #S.CABO,R0      ;SET REASON FOR ABORT
        CALLR   $ABTSK          ;ABORT TASK
10$:    DRSTS   D.RS7           ;SET DIRECTIVE STATUS
 
        .END
        .TITLE  DRASG
        .IDENT  /05.01/
 
;
; COPYRIGHT (C) 1974, 1976, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 05.01
;
; D. N. CUTLER 18-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
; 
;       M. S. HARVEY    5-APR-79
;               MSH007 -- ALLOW REASSIGN IF ANOTHER LUN IS ASSIGNED
;                         TO THE SAME ATTACHED DEVICE
;
; MACRO LIBRARY CALLS
;

        .MCALL  TCBDF$
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$DRASG-ASSIGN LUN
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO ASSIGN A DEVICE UNIT TO A
; LOGICAL UNIT NUMBER (LUN).
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(7.),DPB SIZE(4.).
;       WD. 01 -- LUN TO BE ASSIGNED.
;       WD. 02 -- NAME OF DEVICE TO BE ASSIGNED.
;       WD. 03 -- UNIT NUMBER OF DEVICE TO BE ASSIGNED.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LUN IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS90' IS RETURNED IF A FILE
;                       IS OPEN OR UNIT ATTACHED ON THE SPECIFIED LUN.
;               DIRECTIVE STATUS OF 'D.RS92' IS RETURNED IF DEVICE
;                       AND/OR UNIT IS INVALID.
;-

$DRASG::CALL    $MPLUN          ;MAP LUN TO DEVICE UCB
        TST     (R1)            ;FILE ACCESSED ON LUN?
        BNE     40$             ;IF NE YES
        MOV     R0,-(SP)        ;SAVE ADDRESS OF UCB
        MOV     R1,R4           ;SAVE ADDRESS OF SECOND LUN WORD
        MOV     (R3)+,R2        ;GET NAME OF DEVICE
        MOVB    (R3),R0         ;GET UNIT NUMBER


        .IF DF  L$$ASG


        .IF DF  M$$MUP

        BIT     #T3.SLV,T.ST3(R5) ;SLAVE TASK?
        BNE     17$             ;IF NE YES, BYPASS LOGICAL DEVICE TABLE

        .ENDC


        MOV     #$LOGHD,R3      ;POINT TO LOGICAL ASSIGNMENT LIST
13$:    MOV     (R3),R3         ;GET ADDRESS OF NEXT ENTRY
        BEQ     17$             ;IF EQ END OF LIST
        TSTB    L.TYPE(R3)      ;SYSTEM WIDE ASSIGNMENT?
        BEQ     15$             ;IF EQ YES
        CMP     L.UCB(R3),T.UCB(R5) ;TI UCB ADDRESS MATCH?
        BNE     13$             ;IF NE NO
15$:    CMP     R2,L.NAM(R3)    ;DEVICE NAME MATCH?
        BNE     13$             ;IF NE NO
        CMPB    R0,L.UNIT(R3)   ;UNIT NUMBER MATCH?
        BNE     13$             ;IF NE NO
        MOV     L.ASG(R3),R1    ;GET ASSIGNMENT UCB ADDRESS
        BR      25$             ;FINISH IN COMMON CODE

        .ENDC


17$:    MOV     #$DEVHD,R3      ;POINT TO PHYSICAL DEVICE TABLES
20$:    MOV     (R3),R3         ;GET ADDRESS OF NEXT DCB
        BEQ     50$             ;IF EQ END OF TABLES
        CMP     R2,D.NAM(R3)    ;DEVICE NAME MATCH?
        BNE     20$             ;IF NE NO
        CMPB    R0,D.UNIT(R3)   ;UNIT GREATER THAN OR EQUAL TO LOW BOUNDRY?
        BLO     20$             ;IF LO NO
        CMPB    R0,D.UNIT+1(R3) ;UNIT LESS THAN OR EQUAL TO HIGH BOUNDRY?
        BHI     20$             ;IF HI NO
        SUB     D.UNIT(R3),R0   ;CALCULATE RELATIVE UNIT NUMBER
        BIC     #177400,R0      ;CLEAR EXCESS BITS
        MOV     D.UCBL(R3),R1   ;GET LENGTH OF UCB IN BYTES
        CALL    $MUL            ;CALCULATE NUMBER OF BYTES
        ADD     D.UCB(R3),R1    ;CALCULATE ADDRESS OF UCB
25$:    MOV     (SP)+,R3        ;WAS LUN PREVIOUSLY ASSIGNED?
        BEQ     30$             ;IF EQ NO
        CMP     R5,U.ATT(R3)    ;UNIT ATTACHED TO CURRENT TASK?
        BNE     27$             ;IF NE NO
        MOV     R1,-(SP)        ;SAVE NEW ASSIGNMENT UCB ADDRESS
        MOV     R1,R0           ;COPY UCB ADDRESS
        CALL    $MPLND          ;MAP TO REAL UCB ADDRESS
        MOV     (SP)+,R1        ;RETRIEVE NEW ASSIGNMENT UCB ADDRESS
        CMP     R0,R3           ;NEW ASSIGNMENT TO SAME FINAL UCB?
        BNE     35$             ;IF EQ NO                               ;MSH007
27$:    MOV     R3,R5           ;COPY OLD ASSIGNMENT UCB ADDRESS        ;**-1
        MOV     #$IOKIL,-(SP)   ;SET TO KILL I/O ON PREVIOUS ASSIGNMENT
30$:    MOV     R1,-(R4)        ;ASSIGN LUN TO NEW UNIT
        RETURN                  ;
35$:    MOV     R1,-(SP)        ;SAVE NEW UCB POINTER                   ;MSH007
        MOV     $HEADR,R1       ;GET TASK HEADER                        ;MSH007
        ADD     #H.NLUN,R1      ;POINT TO THE NUMBER OF LUNS            ;MSH007
        MOV     (R1),-(SP)      ;PICK UP COUNT                          ;MSH007
37$:    CMP     (R1)+,(R1)+     ;ADVANCE TO NEXT UCB POINTER + 2        ;MSH007
        CMP     R1,R4           ;SAME LUN AS BEING REASSIGNED?          ;MSH007
        BEQ     39$             ;IF EQ YES                              ;MSH007
        MOV     -2(R1),R0       ;GET THIS LUN ASSIGNMENT                ;MSH007
        CALL    $MPLND          ;FOLLOW ANY REDIRECT; HANDLE TI:        ;MSH007
        CMP     R0,R3           ;LUN ASSIGNED TO SAME DEV AS REASS LUN? ;MSH007
        BNE     39$             ;NO, BRANCH                             ;MSH007
        TST     (SP)+           ;REMOVE COUNT                           ;MSH007
        MOV     (SP)+,R1        ;GET NEW LUN ASSIGNMENT                 ;MSH007
        BR      27$             ;ATTACH CAN BE IGNORED                  ;MSH007
39$:    DEC     (SP)            ;POINT TO NEXT LUN                      ;MSH007
        BGT     37$             ;TRY AGAIN                              ;MSH007
        CMP     (SP)+,(SP)+     ;CLEAN STACK                            ;MSH007
40$:    DRSTS   D.RS90          ;SET DIRECTIVE STATUS
50$:    DRSTS   D.RS92          ;SET DIRECTIVE STATUS

        .END
        .TITLE  DRATX
        .IDENT  /06/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 06
;
; D. N. CUTLER 31-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  ABODF$,HDRDF$,HWDDF$,TCBDF$
        ABODF$                  ;DEFINE TASK ABORT CODES
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
 
;+
; **-$DRATX-AST SERVICE EXIT
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO TERMINATE THE EXECUTION OF AN
; ASYNCHRONOUS SYSTEM TRAP SERVICE ROUTINE. IF ANOTHER AST IS QUEUED AND
; AST'S ARE NOT DISABLED, THEN THE NEXT AST IS EFFECTED IMMEDIATELY.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(115.),DPB SIZE(1.).
;
;       AT ISSUANCE THE TASK STACK CONTAINS:
;
;       14(SP)=EVENT FLAG MASK WORD FOR FLAGS 1.-16.
;       12(SP)=EVENT FLAG MASK WORD FOR FLAGS 17.-32.
;       10(SP)=EVENT FLAG MASK WORD FOR FLAGS 33.-48.
;       06(SP)=EVENT FLAG MASK WORD FOR FLAGS 49.-64.
;       04(SP)=PRE AST TASK PS.
;       02(SP)=PRE AST TASK PC.
;       00(SP)=PRE AST TASK DIRECTIVE STATUS WORD.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS WORD RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF PRE AST STATE IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF THE DIRECTIVE
;                       WAS NOT EXECUTED FROM AN AST SERVICE ROUTINE.
;
;       NOTE: IF AN ADDRESS CHECK FAILURE OCCURS WHILE REMOVING ARGU-
;               MENTS FROM THE TASK STACK, THEN THE ISSUING TASK IS
;               ABORTED.
;-
 
 
        .IF DF  A$$TRP
 
$DRATX::MOV     (R2),-(SP)      ;DIRECTIVE EXECUTED FROM AST?
        BPL     10$             ;IF PL NO
        ASR     (SP)            ;SHIFT AST SUSPEND AND WAITFOR BITS INTO
        BIC     #^C<T2.AST!T2.STP!T2.SPN!T2.WFR>,(SP) ;CLEAR EXTRA BITS
        BIC     (SP),(R2)       ;CLEAR AST IN PROGRESS FLAG
        BISB    (SP)+,(R2)      ;RESTORE PRE AST STATE
 
 
        .IF DF  C$$CKP&D$$ISK
 
        BIT     #T2.STP,(R2)    ;WAS TASK STOPPED?
        BEQ     5$              ;IF EQ NO
        MOV     T.PCB(R5),R0    ;POINT TO TASK PCB
        CALL    $NXTSK          ;REALLOCATE TASK PARTITION
 
        .ENDC
 
 
5$:     MOV     @$HEADR,R3      ;GET SAVED STACK POINTER
        
 
        .IF DF  M$$MGE
 
        MFPI    SP              ;GET USER STACK POINTER
        MOV     (SP),R0         ;COPY STACK POINTER
        ADD     #2,R0           ;STEP OVER DPB WORD
        ADD     #16,(SP)        ;ADJUST TO NEW TOP OF STACK
        MTPI    SP              ;RESTORE USER STACK POINTER
 
        .IFF
 
        MOV     R3,R0           ;COPY SAVED STACK POINTER
        ADD     #4*2+2,R0       ;POINT TO FIRST USER STACK WORD
 
        .IFTF
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     #7*2,R1         ;SET NUMBER OF BYTES TO CHECK
        CALL    $ACHCK          ;ADDRESS CHECK TASK STACK WORDS
        BCS     20$             ;IF CS ADDRESS CHECK FAILURE
 
        .ENDC
 
 
        .IFT
 
        CALL    $RELOM          ;RELOCATE AND MAP STACK ADDRESS
 
        .IFTF
 
        MOV     (R0)+,2(SP)     ;SET DIRECTIVE STATUS TO RETURN
        CMP     (R3)+,(R3)+     ;POINT TO SAVED PC
        MOV     (R0)+,(R3)+     ;RESTORE PRE AST PC
        MOV     (R0)+,(R3)+     ;RESTORE PRE AST PS
 
        .IFT
 
        BIS     #CMODE!PMODE,-(R3) ;MAKE SURE CURRENT AND PREVIOUS IS USER
        BIC     #PR7,(R3)+      ;MAKE SURE PRIORITY IS ZERO
 
        .IFTF
 
        MOV     (R0)+,H.EFLM(R4) ;RESTORE WAITFOR MASK WORD
        MOV     H.EFSV(R4),H.EFLM+2(R4) ;RESTORE WAITFOR MASK ADDRESS
        
        .IFF
 
        TST     (R0)+           ;ADJUST TO PROPER LOCATION
        MOV     -(R3),(R0)      ;MOVE TASK PS WORD
        MOV     -(R3),-(R0)     ;MOVE TASK PC WORD
        MOV     -(R3),-(R0)     ;MOVE SAVED R5
        MOV     -(R3),-(R0)     ;MOVE SAVED R4
        MOV     R0,@$HEADR      ;SET ADDRESS OF NEW TASK STACK POINTER
 
        .ENDC
 
 
        CALLR   $SETRT          ;FORCE A REDISPATCHING OF PROCESSOR
10$:    DRSTS   D.RS80          ;SET DIRECTIVE STATUS
 
 
        .IF DF  A$$CHK!M$$MGE
 
20$:    MOV     #S.CAST,R0      ;SET AST ABORT
        CALLR   $ABCTK          ;ABORT CURRENT TASK
 
        .ENDC
 
 
        .ENDC
 
 
        .END
        .TITLE  DRCIN
        .IDENT  /01.06/
 
;
; COPYRIGHT (C) 1977, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; VERSION 01.06
;
; P. WANNHEDEN 24-MAY-77
;
; MODIFIED BY:
;
;       CHUCK SPITZ     5-MAR-79
;               CS036 -- ALLOW CONNECT TO VECTORS POINTING TO $NONSI ON
;                       SYSTEMS WITH LOGGING OF UNDEFINED INTERRUPTS
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,TCBDF$,PCBDF$,ITBDF$
        HWDDF$                  ; DEFINE HARDWARE REGISTERS
        TCBDF$                  ; DEFINE TCB OFFSETS
        PCBDF$                  ; DEFINE PCB OFFSETS
        ITBDF$                  ; DEFINE ITB OFFSETS

;+
; **-$DRCIN-CONNECT TO INTERRUPT.
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CONNECT A SPECIFIED INTERRUPT
; VECTOR TO AN INTERRUPT SERVICE ROUTINE (ISR) IN THE TASK'S OWN SPACE,
; OR TO DISCONNECT A PREVIOUSLY CONNECTED INTERRUPT VECTOR.
;
; IF THE FUNCTION "CONNECT" IS REQUESTED, THE OPERATION IS AS FOLLOWS:
; A BLOCK OF DYNAMIC MEMORY IS ALLOCATED AND SET UP AS AN INTERRUPT
; TRANSFER BLOCK (ITB). THE ITB IS LINKED TO THE ITB LIST OF THE
; TASK WITH LISTHEAD (SINGLE WORD!!) IN T.CPCB OF THE TCB.
; CHECKPOINTING AND SHUFFLING IS DISABLED FOR THE TASK.
; THE VECTOR IS SET UP TO POINT TO THE OFFSET X.JSR IN THE ITB,
; WHICH CONTAINS A SUBROUTINE CALL TO THE SPECIAL INTERRUPT SAVE
; ROUTINE $INTSC.
;
; IF THE FUNCTION "DISCONNECT" IS REQUESTED, THE OPERATION IS
; ESSENTIALLY THE REVERSE OF WHAT IS DESCRIBED FOR "CONNECT".
;
;       *************************************************
;       *   NOTE - THE DISCONNECT FUNCTION, WHEN        *
;       *   DISCONNECTING THE LAST VECTOR (OR           *
;       *   ONLY), CLEARS THE CHECKPOINT-DISABLE        *
;       *   BIT (T2.CKD) AND NO-SHUFFLE BIT (PS.NSF)    *
;       *   REGARDLESS OF WHAT THE STATE WAS BEFORE     *
;       *   VECTORS WERE CONNECTED OR ANY CHANGE IN     *
;       *   STATE WHILE VECTORS WERE CONNECTED.         *
;       *   (EXCEPTION - IF THE TASK IS MARKED FOR      *
;       *   ABORT BECAUSE OF MEMORY PARITY ERROR,       *
;       *   IT IS NOT MADE SHUFFLABLE).                 *
;       *************************************************
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(129.),DPB SIZE(7.).
;       WD. 01 -- INTERRUPT VECTOR ADDRESS.
;       WD. 02 -- BASE ADDRESS FOR MAPPING OF ISR AND
;                 ENABLE/DISABLE-INTERRUPT ROUTINES.
;                 IGNORED IN AN UNMAPPED SYSTEM.
;       WD. 03 -- ADDRESS OF INTERRUPT SERVICE ROUTINE. IF ZERO, DIRECTIVE
;                 IS "DISCONNECT FROM INTERRUPTS" AND REMAINING ARGUMENTS
;                 ARE IGNORED.
;       WD. 04 -- ADDRESS OF ENABLE/DISABLE-INTERRUPT ROUTINE.
;       WD. 05 -- (LOW BYTE) LOW BYTE OF PSW TO BE SET
;                 BEFORE CALLING ISR.
;       WD. 06 -- ADDRESS OF AST ROUTINE.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=POINTER TO WD. 01 IN DPB
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK).
;
;       IF SUCCESSFUL COMPLETION:
;       CC-C    0
;       DIRECTIVE STATUS:
;               +1
;       BEFORE RETURN, THE ENABLE/DISABLE-INTERRUPTS ROUTINE
;       (IF SPECIFIED) IS CALLED IN KERNEL MODE WITH CC-C CLEAR.
;
;       IF DIRECTIVE IS REJECTED:
;       CC-C    1
;       DIRECTIVE STATUS:
;               D.RS1   AN ITB COULD NOT BE ALLOCATED (NO POOL SPACE).
;               D.RS8   THE FUNCTION REQUESTED IS "DISCONNECT"
;                       AND THE TASK IS NOT OWNER OF THE VECTOR.
;               D.RS16  ISSUING TASK IS NOT PRIVILEGED.
;               D.RS17  THE SPECIFIED VECTOR IS ALREADY IN USE.
;               D.RS19  THE SPECIFIED VECTOR IS ILLEGAL (LOWER THAN 60
;                       OR HIGHER THAN HIGHEST VECTOR SPECIFIED AT SYSGEN,
;                       OR NOT A MULTIPLE OF 4).
;               D.RS81  ISR OR ENABLE/DISABLE-INTERRUPT ROUTINE IS NOT
;                       WITHIN 4K WORDS FROM (BASE ADDRESS & 177700).
;-

        .IF DF  C$$INT

        .ENABL  LSB

$DRCIN::

        .IF DF  M$$MGE

        BIT     #T3.PRV,T.ST3(R5) ; IS TASK PRIVILEGED?
        BEQ     95$             ; N - ILLEGAL, JUMP

        .ENDC


        MOV     (R3)+,R4        ; GET VECTOR ADDRESS
        BIT     #3,R4           ; MULTIPLE OF 4?
        BNE     60$             ; N - ILLEGAL VECTOR, JUMP
        CMP     R4,#60          ; VECTOR IN RANGE?
        BLO     60$             ; N - JUMP
        CMP     R4,#V$$CTR
        BHIS    60$             ; N - JUMP
        MOV     (R3)+,R0        ; GET BASE ADDRESS
        MOV     (R3)+,-(SP)     ; GET ISR ADDRESS
        BEQ     40$             ; ZERO - DISCONNECT, JUMP
;
; DIRECTIVE IS "CONNECT"
;

        .IF NDF E$$NSI

        CMP     @R4,#$NONSI     ; VECTOR IN USE?
        BNE     70$             ; Y - ILLEGAL, JUMP

        .IFF

        CMP     @R4,#$NONSI     ;VECTOR IN USE?                         ; CS036
        BEQ     10$             ;IF EQ NO, CONTINUE PROCESSING          ; CS036
        CMP     @R4,#$NS0       ; VECTOR IN USE?
        BLO     70$             ; Y - ILLEGAL, JUMP
        CMP     @R4,#$NS7
        BHI     70$             ; Y - ILLEGAL, JUMP

        .ENDC

10$:    BIT     #T2.CKD,@R2     ; CHECKPOINTING DISABLED?
        BNE     15$             ; Y - JUMP
        BIS     #T2.CKD,@R2     ; N - DO IT
        CLR     T.CPCB(R5)      ; INITIALIZE LIST OF ITB'S
15$:

        .IF DF  D$$YNM & D$$SHF

        MOV     T.PCB(R5),R1    ; GET PCB
        BIT     #PS.SYS,P.STAT(R1) ; SYSTEM CONTROLLED?
        BEQ     20$             ; N - JUMP
        BIS     #PS.NSF,P.STAT(R1) ; SET NON-SHUFFLABLE
20$:

        .ENDC


        .IF DF  M$$MGE

        BIC     #77,R0          ; CLEAR LOWER 6 BITS IN BASE ADDRESS
        CALL    $RELOC          ; RELOCATE TO APR 6 ADDRESS
        SUB     #20000,R2       ; RELOCATE TO APR 5 ADDRESS
        BCS     90$             ; OUT OF RANGE - JUMP
        SUB     R0,@SP          ; GET DISPLACEMENT FROM "BASE" TO "ISR"
        CMP     @SP,#20000      ; .GT. 4K WORDS?
        BHIS    90$             ; Y - ILLEGAL, JUMP

        .IFTF

        MOV     (R3)+,-(SP)     ; GET ENB./DIS.INT. ROUTINE ADDRESS

        .IFT

        BEQ     30$             ; NO SUCH ROUTINE - JUMP
        SUB     R0,@SP          ; GET DISPLACEMENT FROM BASE
        BCS     90$             ; OUT OF RANGE - JUMP
        CMP     @SP,#20000      ; .GT. 4K WORDS?
        BHIS    90$             ; Y - ILLEGAL, JUMP
        ADD     R2,@SP          ; MAKE APR 5 ADDRESSES
30$:    ADD     R2,2(SP)
        MOV     R1,-(SP)        ; SAVE APR 5 VALUE

        .IFTF

        MOV     #X.LEN,R1       ; GET SIZE OF ITB IN BYTES
        CALL    $ALOCB          ; ALLOCATE AN ITB
        BCS     80$             ; FAILURE - JUMP
        MOV     T.CPCB(R5),@R0  ; LINK ITB TO ITB LIST IN TCB (X.LNK)
        MOV     R0,T.CPCB(R5)
        TST     (R0)+           ; STEP PAST LINK WORD IN ITB
        MOV     R0,R1           ; SAVE INTERRUPT ENTRY POINT
        MOV     #4537,(R0)+     ; "JSR R5,@#$INTSC" (X.JSR)
        MOV     #$INTSC,(R0)+   ; (X.JSR+2)
        MOV     (R3)+,@R0       ; PSW AND UNUSED BYTE (X.PSW)

        .IFT

        ADD     #X.REL-X.PSW,R0 ; POINT TO X.REL IN ITB
        MOV     (SP)+,(R0)+     ; STORE APR 5 VALUE (X.REL)

        .IFF

        ADD     #X.DSI-X.PSW,R0 ; POINT TO X.DSI IN ITB

        .IFTF

        MOV     (SP)+,(R0)+     ; STORE ENB./DIS.INT. ROUTINE ADDRESS (X.DSI)
        MOV     R5,(R0)+        ; STORE TCB ADDRESS (X.TCB)
        MOV     (SP)+,X.ISR-<X.TCB+2>(R0) ; STORE ISR ADDRESS (X.ISR)
        CLR     X.FORK+2-<X.TCB+2>(R0) ; CLEAR FORK PC WORD (X.FORK+2)

        .IF DF  A$$TRP

        MOV     #$DQAC,(R0)+    ; STORE ADDRESS OF ROUTINE TO DEQUEUE
                                ; AST BLOCK QUEUED BY $QASTC
        TST     (R0)+           ; STEP PAST AST QUEUE THREAD WORD
        MOV     PC,(R0)+        ; SET NON-ZERO TO INDICATE
                                ; AST BLOCK FREE (A.CBL)
        MOV     #7*2+2,(R0)+    ; NUMBER OF WORDS TO ALLOCATE ON AST STACK
                                ; (A.BYT)
        MOV     @R3,(R0)+       ; AST ADDRESS (A.AST)
        MOV     #1,(R0)+        ; NUMBER OF AST PARAMETERS = 1 (A.NPR)

        .ENDC

        MOV     R4,(R0)+        ; AST PARAMETER = VECTOR ADDRESS (X.VEC)
        MOV     @R4,@R0         ; SAVE VECTOR PC (X.VPC)
        MOV     R1,@R4          ; SET VECTOR TO POINT TO ITB
        TST     -(R1)           ; BACK UP TO START OF ITB AND CLEAR CC-C
35$:    MOV     X.DSI(R1),R2    ; GET ADDRESS OF USER ROUTINE TO
                                ; ENABLE/DISABLE INTERRUPTS
        BEQ     130$            ; NONE - EXIT

        .IFT

        MOV     X.REL(R1),KISAR5 ; MAP ROUTINE IN KERNEL APR 5

        .ENDC

        CALLR   @R2             ; CALL ROUTINE AND RETURN
                                ; R1 = POINTER TO ITB
                                ; CC-C = 0 TO ENABLE INTERRUPTS,
                                ;      = 1 TO DISABLE INTERRUPTS
;
;
; DIRECTIVE IS "DISCONNECT"
;
40$:    MOV     @R4,R1          ; GET PC FROM VECTOR
        SUB     #X.JSR,R1       ; GET START OF ITB (X.LNK)
        BIT     #T2.CKD,@R2     ; CHECKPOINTING DISABLED?
        BEQ     100$            ; N - TASK HAS NO ITB'S, JUMP
        CALL    $DISIN          ; DISABLE INTERRUPTS, DEALLOCATE THE
                                ; ITB ETCETERA
        BCS     100$            ; ERROR (TASK IS NOT OWNER OF VECTOR) - JUMP
        DRSTS   +1              ; EXIT WITH SUCCESS

60$:    DRSTS   D.RS19          ; ILLEGAL VECTOR
70$:    DRSTS   D.RS17          ; VECTOR ALREADY IN USE
80$:    DRSTS   D.RS1           ; NO POOL SPACE

        .IF DF  M$$MGE

90$:    DRSTS   D.RS81          ; ISR OR ENB./DIS.INT. ROUTINE ADDRESS NOT
                                ; WITHIN RANGE (BASE&177700, BASE&177700+4K)
95$:    DRSTS   D.RS16          ; PRIVILEGE VIOLATION

        .ENDC

100$:   DRSTS   D.RS8           ; DISCONNECT - TASK IS NOT OWNER OF VECTOR
;
;
;+
; **-$DISIN-DISCONNECT INTERRUPT VECTOR.
;
; INPUT:
;       R1      POINTER TO ITB
;       R5      POINTER TO TASK TCB
;
; OUTPUT:
;       IF SUCCESS:
;       CC-C    0
;       THE FOLLOWING OPERATIONS ARE PERFORMED:
;       1. THE ITB IS REMOVED FROM THE ITB LIST STARTING
;          IN T.CPCB OF THE TASK'S TCB.
;       2. IF A USER ROUTINE TO DISABLE INTERRUPTS WAS SUPPLIED
;          WHEN THE VECTOR WAS CONNECTED TO, THAT ROUTINE IS CALLED
;          IN KERNEL MODE WITH CC-C SET.
;       3. VECTOR PC IS RESTORED TO POINT TO THE NONSENSE INTERRUPT ROUTINE.
;       4. IF THE FORK BLOCK OF THE ITB IS IN THE FORK QUEUE, IT
;          IS REMOVED.
;       5. IF THE AST BLOCK OF THE ITB IS IN THE AST QUEUE FOR THE TASK,
;          IT IS REMOVED.
;       6. IF THIS WAS THE ONLY VECTOR CONNECTED TO THE TASK,
;          CHECKPOINTING IS ENABLED FOR THE TASK. IF THE TASK RUNS IN
;          A SYSTEM CONTROLLED PARTITION, THE TASK IS MADE SHUFFLABLE.
;       7. FINALLY, THE ITB IS DEALLOCATED.
;
;       IF ERROR (TASK IS NOT OWNER OF VECTOR):
;       CC-C    1
;
; REGISTERS ALTERED: R0,R1,R2,R3
;-
;
;
$DISIN::MOV     R5,R0           ; GET TCB
        ADD     #T.CPCB,R0      ; POINT TO ITB LISTHEAD
        MOV     2(R0),-(SP)     ; SAVE WORD FOLLOWING LISTHEAD
        CALL    $QRMVT          ; REMOVE FROM ITB LIST
        MOV     (SP)+,2(R0)     ; RESTORE WORD FOLLOWING LISTHEAD
        BCS     130$            ; ITB NOT IN LIST - EXIT WITH ERROR
        SEC
        CALL    35$             ; CALL USER ROUTINE TO DISABLE INTERRUPTS
                                ; WITH CC-C SET
        MOV     X.VPC(R1),@X.VEC(R1) ; RESTORE VECTOR PC
        ADD     #X.FORK,R1      ; POINT AT FORK BLOCK IN ITB
        MOV     #$FRKHD,R0      ; GET FORK LISTHEAD
        MTPS    #PR7            ; DISABLE INTERRUPTS
        CALL    $QRMVT          ;;; REMOVE FROM FORK LIST IF IT IS THERE
        MTPS    #0              ;;; ENABLE INTERRUPTS

        .IF DF  A$$TRP

        ADD     #X.AST-X.FORK,R1 ; POINT AT AST BLOCK IN ITB
        MOV     R5,R0
        ADD     #T.ASTL,R0      ; GET AST LIST LISTHEAD
        CALL    $QRMVT          ; REMOVE FROM AST LIST IF IT IS THERE
        SUB     #X.AST,R1       ; RESTORE ITB POINTER

        .IFF

        SUB     #X.FORK,R1      ; RESTORE ITB POINTER

        .ENDC

        MOV     R1,R0           ; GET ITB POINTER IN R0
        TST     T.CPCB(R5)      ; ITB LIST NOW EMPTY?
        BNE     120$            ; N - JUMP
        BIC     #T2.CKD,T.ST2(R5) ; Y - ENABLE CHECKPOINTING

        .IF DF  D$$YNM & D$$SHF

        MOV     T.PCB(R5),R1    ; GET PCB
        BIT     #PS.SYS,P.STAT(R1) ; SYSTEM CONTROLLED PARTITION?
        BEQ     120$            ; N - JUMP
        BIT     #T2.ABO,T.ST2(R5) ; TASK MARKED FOR ABORT?
        BEQ     110$            ; N - JUMP
        CMP     T.EFLG(R5),#S.PRTY ; Y - IS REASON MEMORY PARITY ERROR?
        BEQ     120$            ; Y - DON'T MAKE SHUFFLABLE
110$:   BIC     #PS.NSF,P.STAT(R1) ; MAKE SHUFFLABLE

        .ENDC

120$:   MOV     #X.LEN,R1       ; GET LENGTH OF ITB
        CALL    $DEACB          ; DEALLOCATE ITB
        CLC                     ; SUCCESS
130$:   RETURN

        .DSABL  LSB

        .ENDC


        .END
        .TITLE  DRCMT
        .IDENT  /05/
 
;
; COPYRIGHT (C) 1974, 1976, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 05
;
; D. N. CUTLER 31-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;
; MODIFIED BY:
;
;       CHUCK SPITZ 22-FEB-79
;               CS034 -- ADD SELECTIVE CANCEL OF MARKTIMES
;
; CANCEL MARK TIME AND SCHEDULE REQUESTS DIRECTIVES
;
; MACRO LIBRARY CALLS
;

        .MCALL  CLKDF$
        CLKDF$                  ;DEFINE CLOCK QUEUE CONTROL BLOCK OFFSETS

;+
; **-$DRCMT-CANCEL MARK TIME REQUESTS
; **-$DRCMS-CANCEL SELECTIVE MARK TIME REQUESTS                         ; CS034
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CANCEL ALL MARK TIME REQUESTS
; (DPB SIZE=1) OR ALL REQUESTS WITH MATCHING EVENT FLAG OR AST ADDRESS  ; CS034
; (DPB SIZE=3).                                                         ; CS034
;                                                                       ;**-1
; DPB FORMAT.
;
;       WD. 00 -- DIC(27.), DPB SIZE(1. OR 3.)                          ; CS034
;       WD. 01 -- EFN NUMBER                                            ; CS034
;       WD. 02 -- AST ADDRESS                                           ; CS034
;                                                                       ;**-1
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF WD. 00 + 2.                                       ; CS034
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.                   ;**-1
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       NOTE: $DRCMT IS ALSO CALLED FROM THE EXIT DIRECTIVE AND         ; CS034
;               ONLY REQUIRES R5 TO BE LOADED ON ENTRANCE.              ;**-1
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF +1.
;-

        .ENABL  LSB
                                                                        ; CS034
        .IF DF C$$SMT                                                   ; CS034
                                                                        ; CS034
$DRCMS::CMPB    -(R3),#1        ;DPB SIZE = 1?                          ; CS034
        BEQ     $DRCMT          ;IF EQ YES, CANCEL ALL MARK TIMES       ; CS034
        CMPB    (R3)+,#3        ;DPB SIZE = 3?                          ; CS034
        BNE     5$              ;IF NE NO, INVALID DPB SIZE             ; CS034
        MOV     (R3)+,R1        ;PICK UP SPECIFIED EFN                  ; CS034
        MOV     (R3),R2         ;PICK UP SPECIFIED AST ADDRESS          ; CS034
        CLR     R4              ;SET MARK TIME CODE                     ; CS034
        CALLR   $CLRSM          ;CANCEL SELECTED MARK TIME ENTRIES      ; CS034
                                                                        ; CS034
        .IFTF   ;C$$SMT                                                 ; CS034
                                                                        ; CS034
$DRCMT::CLR     R4              ;SET TYPE OF REQUEST TO REMOVE
        BR      10$             ;REMOVE ALL MARK TIME ENTRIES.

                                                                        ; CS034
        .IFT    ;C$$SMT                                                 ; CS034
                                                                        ; CS034
5$:     DRSTS   D.RS99          ;INVALID DPB SIZE                       ; CS034
                                                                        ; CS034
        .ENDC   ;C$$SMT                                                 ; CS034
                                                                        ; CS034
;+
; **-$DRCSR-CANCEL SCHEDULE REQUESTS
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CANCEL ALL SCHEDULE REQUESTS FOR A
; SPECIFIED TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(25.),DPB SIZE(3.).
;       WD. 01 -- FIRST HALF OF TASK NAME.
;       WD. 02 -- SECOND HALF OF TASK NAME.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB TO CANCEL SCHEDULE REQUESTS FOR.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TASK TO CANCEL SCHEDULE REQUES
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF +1.
;-

$DRCSR::MOV     R0,R5           ;SET TCB ADDRESS
        CLR     R4              ;SET INITIAL ENTRY TYPE MINUS 2
        CALL    (PC)            ;REMOVE PERIODIC/SINGLE SHOT REQUESTS
        TST     (R4)+           ;ADVANCE TO NEXT ENTRY TYPE
10$:    CALLR   $CLRMV          ;REMOVE ALL REMAINING ENTRIES
        .DSABL  LSB

        .END
        .TITLE  DRDAR
        .IDENT  /03/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; D. N. CUTLER 30-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       T. J. MILLER
;
; MODIFIED BY:
;
; DISABLE/ENABLE AST RECOGNITION DIRECTIVES
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  TCBDF$
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
 
;+
; **-$DRDAR-DISABLE AST RECOGNITION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO DISABLE RECOGNITION OF ASYNCHRONOUS
; SYSTEM TRAPS FOR THE ISSUING TASK. FURTHER AST'S ARE QUEUED AS THEY OCCUR
; AND WILL BE EFFECTED WHEN AST RECOGNITION IS ENABLED.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(99.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF AST RECOG-
;                       NITION IS ALREADY DISABLED.
;-
 
 
        .IF DF  A$$TRP
 
        .ENABL  LSB
$DRDAR::BIT     #T2.DST,(R2)    ;AST RECOGNITION ALREADY DISABLED?
        BNE     10$             ;IF NE YES
        BIS     #T2.DST,(R2)    ;DISABLE AST RECOGNITION
        RETURN                  ;RETURN DIRECTIVE STATUS OF +1
 
;+
; **-$DREAR-ENABLE AST RECOGNITION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO RECOGNIZE ASYNCHORONOUS SYSTEM
; TRAPS FOR THE ISSUING TASK. AST'S THAT HAVE BEEN QUEUED WHILE AST RECOG-
; NITION WAS DISABLED ARE EFFECTED IMMEDIATELY.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(101.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF AST RECOG-
;                       NITION IS NOT DISABLED.
;-
 
$DREAR::BIT     #T2.DST,(R2)    ;AST RECOGNITION DISABLED?
        BEQ     10$             ;IF EQ NO
        BIC     #T2.DST,(R2)    ;ENABLE AST RECOGNITION
        CALLR   $SETRT          ;FORCE A REDISPATCHING OF PROCESSOR
10$:    DRSTS   D.RS8           ;SET DIRECTIVE STATUS
        .DSABL  LSB
 
        .ENDC
 
 
        .END
        .TITLE  DRDCP
        .IDENT  /4.2/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 4.2
;
; D. N. CUTLER 5-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 6-JUN-77
;
;               TM088 -- CLEAR CHECKPOINT PCB WORD ON DISABLE CHECK-
;                       POINTING.
;
;       H. D. COFFMAN   6-NOV-78
;
;               HDC021 -- CHECK CHECKPOINTABILITY OF TASKS BEFORE
;                         ENABLING CHECKPOINTING. ENSURE TASKS 
;                         CONNECTED TO INTERRUPTS CANNOT BE CHECKPOINTED.
;
;       CHUCK SPITZ     6-MAR-79
;               CS037 -- ALWAYS DEFINE $DRECP AND $DRDCP FOR MCR
;
; DISABLE/ENABLE CHECKPOINTING DIRECTIVES
;
; MACRO LIBRARY CALLS
;

        .MCALL  TCBDF$
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$DRDCP-DISABLE CHECKPOINTING
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO DISABLE THE CHECKPOINTABILITY
; OF THE ISSUING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(95.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK).
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF CHECKPOINTING
;                       IS ALREADY DISABLED FOR ISSUING TASK.
;               DIRECTIVE STATUS OF 'D.RS10' IS RETURNED IF THE ISSUING
;                       TASK IS NOT CHECKPOINTABLE.
;-


        .IF DF  C$$CKP&D$$ISK

        .ENABL  LSB
$DRDCP::BIT     #T2.CHK,(R2)    ;TASK CHECKPOINTABLE?
        BNE     20$             ;IF NE NO
        BIT     #T2.CKD,(R2)    ;CHECKPOINTING ALREADY DISABLED?
        BNE     30$             ;IF NE YES
        BIS     #T2.CKD,(R2)    ;DISABLE CHECKPOINTING


        .IF DF  C$$INT

        CLR     T.CPCB(R5)      ;CLEAR CHECKPOINT PCB PTR (ICB LISTHEAD)

        .ENDC


10$:    RETURN                  ;RETURN DIRECTIVE STATUS OF +1
20$:    DRSTS   D.RS10          ;SET DIRECTIVE STATUS

;+
; **-$DRECP-ENABLE CHECKPOINTING
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO ENABLE THE CHECKPOINTABILITY
; OF THE ISSUING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(97.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF CHECKPOINTING
;                IS ALREADY DISABLED FOR THE ISSUING TASK  OR           ; HDC021
;                 THE ISSUING TASK IS CONNECTED TO INTERRUPTS           ; HDC021
;               DIRECTIVE STATUS OF 'D.RS10' IS RETURNED IF THE         ; HDC021
;                 ISSUING TASK IS NOT CHECKPOINTABLE.                   ; HDC021
;                                                                       ; HDC021
;-                                                                      ; HDC021
$DRECP::BIT     #T2.CHK,(R2)    ;IS TASK CHECKPOINTABLE?                ; HDC021
        BNE     20$             ;IF NE NO                               ; HDC021
        BIT     #T2.CKD,(R2)    ;CHECKPOINTING DISABLED?                ; HDC021
        BEQ     30$             ;IF EQ YES                              ; HDC021
                                                                        ; HDC021
        .IF DF  C$$INT                                                  ; HDC021
                                                                        ; HDC021
        MOV     T.CPCB(R5),R0   ;TASK CONNECTED TO INTERRUPTS?          ; HDC021
        BNE     30$             ;IF NE YES, CANNOT ENABLE CHECKPOINTING ; HDC021
                                                                        ; HDC021
        .ENDC   ;C$$INT                                                 ; HDC021
                                                                        ; HDC021
        BIC     #T2.CKD,(R2)    ;ENABLE CHECKPOINTING                   ;**-5
        MOV     T.PCB(R5),R0    ;GET ADDRESS OF TASK PARTITION PCB
        CALLR   $NXTSK          ;REASSIGN PARTITION IF NECESSARY
30$:    DRSTS   D.RS8           ;SET DIRECTIVE STATUS
        .DSABL  LSB

        .IFF    ;C$$CKP&D$$ISK                                          ; CS037
                                                                        ; CS037
        .IF DF M$$CRX                                                   ; CS037
                                                                        ; CS037
$DRECP::                                                                ; CS037
$DRDCP::RETURN          ;IF NO CHECKPOINTING, JUST RETURN FOR MCR       ; CS037
                                                                        ; CS037
        .ENDC   ;M$$CRX                                                 ; CS037
                                                                        ; CS037
        .ENDC   ;C$$CKP&D$$ISK                                          ; CS037
                                                                        ; CS037
                                                                        ;**-1

        .END
        .TITLE  DRDRV
        .IDENT  /01.06/
;
;
; COPYRIGHT (C) 1977, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION
; OF  THE  ABOVE COPYRIGHT  NOTICE.  THIS SOFTWARE, OR  ANY  OTHER
; COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE  MADE AVAILABLE
; TO  ANY  OTHER PERSON  EXCEPT  FOR USE ON SUCH SYSTEM AND TO ONE
; WHO AGREES TO THESE LICENSE TERMS.  TITLE  TO  AND  OWNERSHIP OF
; THE SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE  INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A  COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO  RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;
;
; VERSION 01.06
;
; P. J. BEZEREDI 08-SEP-77
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 16-MAR-77
;
;               PB062 -- CORRECTLY INITIALIZE OFFSET RECOVERY.
;
;       R. T. PERRON 20-JUL-78
;
;               RP001 -- ADD RP07 COMPATIBILITY FEATURES
;
;       R. T. PERRON 27-JUL-78
;
;               RP002 -- CORRECTLY CLEARED DRIVE ERROR DURING
;                       USE OF SHARED ECC ROUTINE
;
;       R. T. PERRON 07-AUG-78
;
;               RP003 -- CORRECT BRANCH OUT OF RANGE
;
;       R. T. PERRON 15-JAN-79
;
;               RP007 -- ADDITION OF RH11 SUPPORT FOR 22-BIT ADDRESSING
;
;       R. T. PERRON 10-APR-79
;
;               RP012 -- CORRECTLY REPORT ECC FAILURE TERMINATION RESULTS
;
;
; RH70/11 - RM03/RP07 DISK PACK DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS

;
; EQUATED SYMBOLS
;
; DEVICE REGISTER AND STATUS BIT DEFINITIONS
;

RMCS1=0                         ;CONTROL STATUS REGISTER 1

TRE=40000                       ;TRANSFER ERROR
MCPE=20000                      ;MASSBUS CONTROL PARITY ERROR


RMWC=2                          ;WORD COUNT REGISTER
RMBA=4                          ;BUFFER ADDRESS REGISTER
RMDA=6                          ;DESIRED TRACK/SECTOR REGISTER

RMCS2=10                        ;CONTROL STATUS REGISTER 2

DLT=100000                      ;DATA LATE ERROR
WCE=40000                       ;WRITE CHECK ERROR
UPE=20000                       ;UNIBUS PARITY ERROR
NED=10000                       ;NONEXISTENT DISK ERROR
NEM=4000                        ;NONEXISTENT MEMORY ERROR
PGE=2000                        ;PROGRAMMING ERROR
MXF=1000                        ;MISSED TRANSFER ERROR
MDPE=400                        ;MASSBUS DATA PARITY ERROR

RMDS=12                         ;DRIVE STATUS REGISTER

ERR=40000                       ;ERROR SUMMARY BIT
MOL=10000                       ;MEDIUM ONLINE
WRL=4000                        ;WRITE LOCKED DRIVE
DRY=200                         ;DRIVE READY
VV=100                          ;VOLUME VALID
OM=1                            ;OFFSET MODE ACTIVE


RMER1=14                        ;ERROR SUMMARY REGISTER

DCK=100000                      ;DATA CHECK ERROR
UNS=40000                       ;DRIVE UNSAFE
OPI=20000                       ;OPERATION INCOMPLETE
DTE=10000                       ;DRIVE TIMING ERROR
WLE=4000                        ;WRITE LOCK ERROR
IAE=2000                        ;INVALID DISK ADDRESS
AOE=1000                        ;ADDRESS OVERFLOW
HCRC=400                        ;HEADER CRC ERROR
HCE=200                         ;HEADER COMPARE ERROR
ECH=100                         ;ECC HARD ERROR
WCF=40                          ;WRITE CLOCK FAILURE
FER=20                          ;FORMAT ERROR
PAR=10                          ;MASSBUS CONTROL/DATA BUS PARITY ERROR
RMR=4                           ;REGISTER MODIFY REFUSED
ILR=2                           ;ILLEGAL REGISTER
ILF=1                           ;ILLEGAL FUNCTION


RMAS=16                         ;ATTENTION SUMMARY REGISTER
RMLA=20                         ;LOOKAHEAD REGISTER
RMDBR=22                        ;DATA BUFFER REGISTER
RMMR=24                         ;MAINTENENCE REGISTER
RMDT=26                         ;DRIVE TYPE REGISTER
RMSN=30                         ;DRIVE SERIAL NUMBER

RMOF=32                         ;DRIVE OFFSET REGISTER

CMOD=100000                     ;COMMAND MODIFIER                       ; RP001
MTD=40000                       ;MOVE TRACK DESCRIPTOR                  ; RP001
FMT16=10000                     ;FORMAT (1=16 BIT)
ECI=4000                        ;ECC INHIBIT
HCI=2000                        ;HEADER COMPARE INHIBIT


RMDC=34                         ;DESIRED CYLINDER NUMBER

RMER2=42                        ;ERROR REGISTER #2

BSE=100000                      ;BAD SECTOR ERROR
SKI=40000                       ;SEEK INCOMPLETE ERROR
IVC=10000                       ;INVALID COMMAND ERROR
LSC=4000                        ;LOSS OF SECTOR CLOCK ERROR
LBC=2000                        ;LOSS OF BIT CLOCK ERROR
DVC=200                         ;DEVICE CHECK ERROR
DPE=10                          ;MASSBUS DATA PARITY ERROR

RMEC1=44                        ;ECC POSITION REGISTER
RMEC2=46                        ;ECC PATTERN REGISTER
RMBAE=50                        ;BUS ADDRESS EXTENSION REGISTER


        .IF DF  M$$IXD

RMBAE=74                        ;MIXED MASSBUS ADDRESS EXTENSION REGISTER

        .ENDC


;
; ERROR RETRY COUNT
;

RETRY=8.                        ;CONTROLLER ERROR RETRY COUNT (NON-ECC ERRORS)

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLER NUMBER)
;

CNTBL:  .BLKW   R$$M11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   R$$M11          ;RETRY COUNT FOR CURRENT OPERATION
                                                                        ; RP001
                                                                        ; RP001
        .IF DF D$$IAG                                                   ; RP001
                                                                        ; RP001
DGTBL:  .BLKW   R$$M11          ;DIAGNOSTIC PARAMETER TABLE             ; RP001
                                                                        ; RP001
        .ENDC                                                           ; RP001
                                                                        ; RP001
                                                                        ; RP001


        .IF GT  R$$M11-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC


        .IF DF  R$$MOF

OFFAD:  .BLKW   R$$M11          ;ADDRESS OF CURRENT OFFSET VALUE

;
; OFFSET POSITIONING VALUE TABLE
;

OFFTB:  .WORD   FMT16!0         ;PLUS OFFSET
        .WORD   FMT16!200       ;MINUS OFFSET
        .WORD   0               ;TERMINATOR

        .ENDC


        .IF DF  D$$IAG

        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS

;
; DIAGNOSTIC FUNCTION TABLE
;
FUNTBL: .BYTE   107, IO.HMS!IQ.UMD&377
        .BYTE   105, IO.BLS!IQ.UMD&377
FUNTB0: .BYTE   115, IO.OFF!IQ.UMD&377                                  ; RP001
        .BYTE   135, IO.DGN!IQ.UMD&377                                  ; RP001
        .BYTE   151, IO.WCK!IQ.UMD&377                                  ; RP001
FUNTB1: .BYTE   173, IO.RDH!IQ.UMD&377                                  ; RP001
        .BYTE   163, IO.WDH!IQ.UMD&377                                  ;**-2
        .BYTE   175, IO.RTD!IQ.UMD&377                                  ; RP001
        .BYTE   165, IO.WTD!IQ.UMD&377                                  ; RP001
FUNTB2: .BYTE   165, IO.TDD!IQ.UMD&377                                  ; RP001
FUNTBE:

        .ENDC


;
; DRIVER DISPATCH TABLE
;

$DRTBL::.WORD   DRINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DRCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DROUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   DRPWF           ;POWER FAIL ENTRY POINT

;+
; **-DRINI-RH70/11 - RM03/RP07 DISK PACK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
1$:     RETURN                  ;RETURN TO CALLER
DRINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     1$              ;IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; RH70/11 - RM03/RP07 DISK PACK I/O REQUEST PACKET FORMAT
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB OR IO.WLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- MEMORY EXTENSION BITS (BITS 4 AND 5) OF I/O TRANSFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- DIAGNOSTIC SUPPLIMENTAL PARAMETER ELSE NOT USED.
;       WD. 16 -- HIGH PART OF LOGICAL BLOCK NUMBER AND HIGH BYTE NOT USED
;       WD. 17 -- LOW PART OF LOGICAL BLOCK NUMBER OF I/O REQUEST.
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. BLK ADRS.
;       WD. 21 -- DIAGNOSTIC REG. BLK ADRS (REAL OR DISPL.+140000).
;

        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB
                                                                        ; RP001
                                                                        ; RP001
        .IF DF D$$IAG                                                   ; RP001
                                                                        ; RP001
        MOV     I.PRM+6(R1),DGTBL(R3) ;SAVE DIAGNOSTIC PARAMETERS       ; RP001
                                                                        ; RP001
        .ENDC                                                           ; RP001
                                                                        ; RP001
                                                                        ; RP001
        CLR     I.PRM+6(R1)     ;INITIALIZE FLAGS                       ; RP001


        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUS DEVICE?            ; RP007
        BNE     2$              ;IF NE YES -- DOES NOT USE UMR'S        ; RP007
        CALL    $STMAP          ;MAP UNIBUS TO MEMORY                   ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
        ASL     U.BUF(R5)       ;SHIFT ADDRESS EXTENSION BITS INTO PLACE; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
2$:                             ;REF LABEL                              ; RP007
                                                                        ;**-8

        .IF DF  D$$IAG

        CMPB    #IO.HMS/256.,I.FCN+1(R1)  ;DIAGNOSTIC FUNCTION?
        BNE     5$              ;IF NE NO
        MOV     #FUNTBL,R0      ;GET ADDRESS OF FUNCTION TABLE
3$:     MOVB    (R0)+,U.BUF(R5) ;LOAD CONTROLLER FUNCTION CODE          ; RP001
        CMPB    (R0)+,I.FCN(R1) ;IS IT THE CORRECT CODE?                ; RP001
        BEQ     4$              ;IF EQ YES                              ; RP001
        CMP     #FUNTBE,R0      ;END OF TABLE?                          ; RP001
        BNE     3$              ;IF NE NO                               ; RP001
        MOV     #IE.IFC&377,R0  ;FUNCTION IS ILLEGAL                    ; RP001
        JMP     70$             ;GO REPORT IT                           ; RP001
4$:     CMPB    #10,U.CW2(R5)   ;IS IT AN RP07?                         ; RP001
        BNE     10$             ;IF NE NO                               ; RP001
        CMP     #FUNTB1,R0      ;IS IT A HEADER FUNCTION?               ; RP001
        BLO     10$             ;IF LO NO                               ; RP001
        BIS     #CMOD,I.PRM+6(R1)  ;SET COMMAND MODIFIER                ; RP001
        CMP     #FUNTB2,R0      ;IS TRACK DESCRIPTOR DISPLACED?         ; RP001
        BNE     10$             ;IF NE NO                               ; RP001
        BIS     #MTD,I.PRM+6(R1)  ;SET MOVE TRACK DESCRIPTOR BIT        ; RP001
        BR      10$             ;                                       ; RP001
                                                                        ;**-5
        .ENDC


5$:     MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        MOVB    #171,U.BUF(R5)  ;ASSUME READ LOGICAL FUNCTION
        CMPB    #IO.RLB/256.,I.FCN+1(R1) ;READ LOGICAL FUNCTION?
        BHIS    6$              ;IF HIS FUNCTION IS LEGAL
        JMP     70$             ;FUNCTION IS ILLEGAL
6$:     BEQ     10$             ;IF EQ FUNCTION IS READ
        SUB     #10,U.BUF(R5)   ;CONVERT TO WRITE LOGICAL FUNCTION
10$:    MOV     #RETRY,RTTBL(R3) ;SET RETRY COUNT
        CALL    210$            ;SET OTHER RECOVERY PARAMETERS
        CALL    $BLKCK          ;CHECK LOGICAL BLOCK NUMBER
        CMPB    #IO.WLB/256.,I.FCN+1(R3)  ;WRITE COMMAND ?
        BNE     15$             ;IF NE NO
        BITB    #IO.WLT&377,I.FCN(R3)  ;WRITE LAST TRACK FUNCTION ?
        BNE     15$             ;IF NE YES
        CMPB    #10,U.CW2(R5)   ;IS IT AN RP07?                         ; RP001
        BEQ     14$             ;IF EQ YES                              ; RP001
        ADD     #32.,I.PRM+12(R3)  ;INCREMENT BLOCK NUMBER BY 1 TRACK
        ADCB    I.PRM+10(R3)    ;ADD THE CARRY                          ; RP001
        CALL    $BLKC1          ;SEE IF WRITE IS TO BAD SECTOR FILE     ;**-1
        SUB     #32.,R0         ;CORRECT THE BLOCK NUMBER
        BR      1400$           ;BRANCH AROUND NEXT                     ; RP001
14$:    ADD     #34.,I.PRM+12(R3)  ;INCREMENT BLOCK NUMBER BY 1 TRACK   ; RP001
        ADCB    I.PRM+10(R3)    ;ADD THE CARRY                          ; RP001
        CALL    $BLKC1          ;SEE IF THE WRITE IS TO BAD SECTOR FILE ; RP001
        SUB     #34.,R0         ;CORRECT THE BLOCK NUMBER               ; RP001
1400$:  SBC     R2              ;AND HIGH BLOCK NUMBER                  ; RP001
15$:    CMPB    #10,U.CW2(R5)   ;IS IT AN RP07?                         ; RP001
        BEQ     20$             ;IF EQ YES                              ; RP001
        MOV     #5*32.,R1       ;SECTORS/CYLINDER COUNT                 ; RP001
        CALL    240$            ;SPECIAL DIVIDE ROUTINE                 ; RP001
        MOV     #32.,R1         ;SET DIVISOR TO NUMBER OF SECTORS/TRACK ;**-12
        BR      30$             ;GO AROUND NEXT                         ; RP001
20$:    MOV     #30.*34.,R1     ;SECTORS/CYLINDER COUNT                 ; RP001
        CALL    240$            ;SPECIAL DIVIDE ROUTINE                 ; RP001
        MOV     #34.,R1         ;SET DIVISOR TO NUMBER OF SECTORS/TRACK ; RP001
30$:    CALL    $DIV            ;CALCULATE TRACK AND SECTOR             ; RP001
        SWAB    R0              ;SWAP TRACK TO HIGH BYTE                ;**-1
        BIS     R1,R0           ;MERGE TRACK
        MOV     R0,I.PRM+12(R3) ;SAVE DESIRED TRACK AND SECTOR ADDRESS
                                                                        ; PB062
                                                                        ; PB062
        .IF DF  R$$MOF                                                  ; PB062
                                                                        ; PB062
        BIS     #1,I.PRM+6(R3)  ;SET OFFSET MODE INACTIVE               ; PB062
                                                                        ; PB062
        .ENDC                                                           ; PB062


        .IF DF  M$$IXD

        CALL    $RQCH           ;REQUEST CHANNEL

        .ENDC


;
; INITIATE I/O OPERATION
;

        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
40$:                            ;REF LABEL                              ; RP007
                                                                        ; RP007
                                                                        ; RP007
        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUSS DEVICE?           ; RP007
        BNE     400$            ;IF NE YES -- DOES NOT USE UMR'S        ; RP007
        CALL    $MPUBM          ;MAP UNIBUS TO MEMORY                   ; RP007
400$:                           ;REF LABEL                              ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
        MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET              ; RP007
        MOVB    S.ITM(R4),S.CTM(R4) ;SET CURRENT DEVICE TIMEOUT COUNT   ;**-18
        ADD     #10,R2          ;POINT TO SECOND CSR
        MOV     #40,(R2)        ;CLEAR RH11 CONTROLLER AND ALL DRIVES
        MOVB    U.UNIT(R5),(R2) ;SELECT PROPER DRIVE
        MOV     I.PRM+12(R1),-(R2)  ;INSERT TRACK/SECTOR ADDRESS
        MOV     U.BUF+2(R5),-(R2)  ;INSERT BUFFER ADDRESS
        MOV     U.CNT(R5),-(R2) ;INSERT NUMBER OF BYTES TO TRANSFER
        ROR     (R2)            ;CONVERT TO WORD COUNT
        NEG     (R2)            ;MAKE NEGATIVE WORD COUNT
        MOV     #23,-(R2)       ;EXECUTE PACK ACK FUNCTION TO SET VV
                                                                        ; RP001
                                                                        ; RP001
        .IF DF D$$IAG                                                   ; RP001
                                                                        ; RP001
        CMPB    #IO.DGN!IQ.UMD&377,I.FCN(R1) ;DIAGNOSE OPERATION?       ; RP001
        BNE     41$             ;IF NE NO                               ; RP001
        MOVB    S.CON(R4),R0    ;GET CONTROLLER NUMBER                  ; RP001
        MOV     DGTBL(R0),RMMR(R2) ;SET DIAGNOSE PARAMETERS             ; RP001
41$:                            ;REF LABEL                              ; RP001
                                                                        ; RP001
        .ENDC                                                           ; RP001
                                                                        ; RP001
                                                                        ; RP001
        MOV     #IE.DNR&377,R0  ;ASSUME DRIVE NOT READY
        MOV     I.PRM+10(R1),RMDC(R2)  ;SET DESIRED CYLINDER ADDRESS
        MOV     RMDS(R2),R3     ;GET CURRENT DRIVE STATUS
        COM     R3              ;COMPLEMENT STATUS
        BIT     #MOL!DRY!VV,R3  ;DRIVE READY?
        BNE     42$             ;IF NE NO
        BIT     #UNS,RMER1(R2)  ;DRIVE UNSAFE?
        BEQ     44$             ;IF EQ NO
42$:                            ;REF LABEL


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;IS DRIVE SPINNING UP?
        BNE     48$             ;IF NE YES

        .IFTF


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC OPERATION?
        BEQ     43$             ;IF EQ NO
        JMP     58$             ;PROCESS DIAGNOSTIC DRIVE NOT READY
43$:                            ;REF LABEL

        .ENDC


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DRIVE NOT READY ERROR

        .ENDC


        JMP     70$             ;FINISH I/O
44$:                            ;REF LABEL

        .IFT

        BICB    #US.SPU,U.STS(R5)  ;RESET DRIVE SPINNING UP

        .ENDC


        MOV     #FMT16,-(SP)    ;GET FORMAT BIT


        .IF DF  R$$MOF!D$$IAG

        BIT     #40,RMDT(R2)    ;IS IT AN RP07?                         ; RP001
        BNE     45$             ;IF NE YES                              ; RP001
        BITB    #1,I.PRM+6(R1)  ;WAS OFFSET ACTIVE ?
        BNE     45$             ;IF NE NO
        MOVB    #15,(R2)        ;LOAD OFFSET FUNCTION
45$:    BIS     I.PRM+6(R1),(SP)  ;SET OTHER BITS

        .ENDC


        MOV     (SP)+,RMOF(R2)  ;LOAD THE OFFSET REGISTER


        .IF DF  E$$DVC                                                  ; RP007
                                                                        ; RP007
        CALL    $BMSET          ;SET I/O ACTIVE IN BIT MAP              ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;;;IS IT A MASS BUS DEVICE?          ; RP007
        BEQ     47$             ;;;IF EQ NO -- DOES USE UMR'S           ; RP007
        MOVB    U.BUF+1(R5),RMBAE(R2)  ;;;SET ADDRESS EXTENSION BITS    ; RP007
        MOVB    U.BUF(R5),(R2)  ;;;START FUNCTION                       ; RP007
        RETURN                  ;;;;                                    ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
47$:    MOV     U.BUF(R5),(R2)  ;;;START FUNCTION                       ; RP007


;
; CANCEL I/O OPERATION IS A NOP FOR FILE STRUCTURED DEVICES.
;

DRCAN:: RETURN          ;;;NOP FOR RM03/RP07

;+
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND
; CAUSES NO IMMEDIATE ACTION ON THE UNIT.  THE CURRENT TIMEOUT
; COUNT IS EXTENDED SO THAT IF THE UNIT WAS BUSY IT WILL HAVE
; SUFFICIENT TIME TO SPIN BACK UP.  THE NEXT I/O REQUEST TO ANY
; UNIT WILL BE SUSPENDED FOR AT LEAST THE EXTENDED TIMEOUT UNLESS
; THE UNIT IS ALREADY READY.
;-

DRPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        TSTB    S.STS(R4)       ;IS DRIVE CURRENTLY BUSY?
        BEQ     49$             ;IF EQ NO
        MOVB    #4,S.STS(R4)    ;WAIT A MAXIMUM OF ONE MINUTE
48$:    MOVB    #15.,S.CTM(R4)  ;15 SECONDS AT A TIME
49$:    BISB    #US.SPU,U.STS(R5)  ;SET DRIVE SPINNING UP

        .ENDC


        RETURN                  ;WAIT FOR UNIT TO RESPOND

;+
; **-$DRINT RH70/11 - RM03/RP07 DISK PACK CONTROLLER
;       INTERRUPT HANDLER
;-

        INTSE$  DR,PR5,R$$M11   ;;;SAVE REGISTERS AND SET PRIORITY
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC FUNCTION EXECUTED?
        BNE     58$             ;IF NE YES

        .ENDC


        BIT     #70,(R2)        ;RECALIBRATE COMMAND ?
        BNE     50$             ;IF NE NO
        MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR
        BITB    #IQ.X,I.FCN(R1)  ;RETIRES INHIBITED ?
        BNE     6000$           ; IF NE YES                             ; RP003
        BIT     #ERR,RMDS(R2)   ;ERROR SET ?                            ;**-1
        BEQ     60$             ;IF EQ NO
        CLR     R1              ;SHOW NO BYTES TRANSFERED
        JMP     80$             ;FINISH UP
50$:    BIT     #TRE!MCPE,(R2)  ;ANY ERRORS DURING TRANSFER ?
        BEQ     61$             ;IF EQ NO


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DEVICE ERROR

        .ENDC


        MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETIRES ?
        BNE     53$             ;IF NE YES, SEE IF DRIVE NEEDS A RECAL
        BIT     #IVC!LSC!LBC!DVC!DPE,RMER2(R2)  ;CLOCK ERROR OR OTHER SET ?
        BNE     60$             ;IF NE YES
        BIT     #NED!NEM!PGE,RMCS2(R2)  ;HARD ERROR ?
        BNE     70$             ;IF NE YES
        BIT     #UNS!IAE!AOE!RMR!ILR!ILF,RMER1(R2)      ;HARD ERROR?
        BNE     70$             ;IF NE YES
        BIT     #DCK,RMER1(R2)  ;DATA CHECK ?
        BNE     51$             ;IF NE YES
        BIT     #DTE!HCRC,RMER1(R2)  ;TIMING OR HEADER ERROR ?
        BEQ     52$             ;IF EQ NO
51$:    CMPB    #IO.WLB/256.,I.FCN+1(R1)  ;WRITE ORDER
        BEQ     60$             ;IF EQ YES
        BR      105$            ;
52$:    BIT     #FER,RMER2(R2)  ;FORMAT ERROR ?
        BNE     70$             ;IF NE YES
53$:    BIT     #SKI,RMER2(R2)  ;SEEK INCOMPLETE ?
        BNE     54$             ;IF NE YES
        BIT     #HCE,RMER1(R2)  ;HEADER COMPARE ERROR ?
        BEQ     55$             ;IF EQ NO
54$:    JMP     230$            ;PROCESS SKI OR HCE ERRORS
55$:    BIT     #BSE,RMER2(R2)  ;BAD SECTOR ERROR ?
        BEQ     56$             ;IF EQ NO
        MOV     #IE.BBE&377,R0  ;BAD BLOCK ERROR
        BR      70$             ;HARD ERROR
56$:    BIT     #WLE,RMER1(R2)  ;WLE SET ?
        BEQ     60$             ;IF EQ NO
        MOV     #IE.WLK&377,R0  ;WRITE LOCK ERROR
        BR      80$             ;


;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING REPEATED
; UNLESS THE OPERATION WAS DIAGNOSTIC.  TIMEOUTS ARE USUALLY CAUSED
; BY POWER FAILURE BUT MAY ALSO BE THE RESULT OF A HARDWARE FAILURE.
;

DROUT:                          ;;;TIMEOUT ENTRY POINT


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;;;IS DRIVE SPINNING UP?
        BEQ     57$             ;;;IF EQ NO
        DECB    S.STS(R4)       ;;;HAVE WE WAITED ENOUGH YET?
        BEQ     57$             ;;;IF EQ YES
        MTPS    #0              ;;;ALLOW INTERRUPTS
        JMP     40$             ;RETRY ENTIRE OPERATION
57$:    INCB    S.STS(R4)       ;;;LEAVE CONTROLLER BUSY
        BICB    #US.SPU,U.STS(R5)  ;;;RESET DRIVE SPINNING UP

        .ENDC


        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT


        .IF DF  D$$IAG

        BCC     60$             ;IF CC TIMEOUT DURING NORMAL FUNCTION
58$:    CALL    $CRPAS          ;PASS CONTROLLER REGISTERS TO TASK
        BR      70$             ;DIAGNOSTIC PROCESSING COMPLETE

        .ENDC


60$:    MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
6000$:  BNE     65$             ; IF NE YES                             ; RP003
        DECB    RTTBL(R3)       ;ANY MORE RETRIES ?                     ;**-1


        .IF DF  R$$MOF

        BGT     95$             ;IF GT YES

        .IFF

        BLE     65$             ;IF LE NO
        JMP     40$             ;

        .ENDC


61$:                            ;REF LABEL

        .IF DF  D$$WCK

        BITB    #IO.WLC&377,I.FCN(R1)  ;WRITE FOLLOWED BY WRITE CHECK ?
        BNE     62$             ;IF NE YES
        BITB    #US.WCK,U.STS(R5)  ;WRITE CHECK ENABLED BY MCR ?
        BEQ     70$             ;IF EQ NO
62$:    CMPB    #171,U.BUF(R5)  ;WAS LAST FUNCTION A READ ?
        BEQ     70$             ;IF EQ YES
        CMPB    #161,U.BUF(R5)  ;WAS LAST OPERATION A WRITE ?
        BNE     70$             ;IF NE NO
        MOVB    #151,U.BUF(R5)  ;CHANGE OPERATION TO WRITE CHECK
        MOV     #RETRY,RTTBL(R3)  ;REINITIALIZE RETRY COUNT
        JMP     40$             ;START WRITE CHECK

        .IFTF

65$:                            ;REF LABEL

        .IFT

        BIT     #WCE,RMCS2(R2)  ; WRITE CHECK ERROR ?
        BEQ     70$             ;IF EQ NO
        MOV     #IE.WCK&377,R0  ;SET WRITE CHECK ERROR

        .ENDC


70$:    MOV     S.PKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        MOV     RMWC(R2),R1     ;WORDS NOT TRANSFER (2'S COMPLEMENT)
        ASL     R1              ;MAKE INTO A BYTE COUNT
        ADD     I.PRM+4(R3),R1  ;CALCULATE BYTES TRANSFERED
        MOV     #TRE!11,(R2)    ;CLEAR RH11 CONTROLLER AND DRIVE
80$:                            ;REF LABEL


        .IF DF  E$$DVC

        MOVB    S.CON(R4),R3    ;RETRIEVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ;GET FINAL ERROR RETRY COUNT
        BIS     #RETRY*256.,R2  ;MERGE STARTING RETRY COUNT

        .ENDC


        .IF DF  M$$IXD

        CALL    $RLCH           ;RELEASE CHANNEL

        .ENDC


        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DRINI           ;PROCESS NEXT REQUEST


        .IF DF  R$$MOF

95$:    JMP     175$            ;RETURN TO CENTERLINE

        .ENDC


;
; START ECC CORRECTION PROCEDURE
;
; FIRST CALCULATE THE BYTE OFFSET TO THE START OF BLOCK TRANSFERED
;

105$:                           ;REF LABEL

        .IF DF  S$$ECC

        MOV     RMER1(R2),R1    ;STORE ERROR REGISTER
        MOV     R2,R3           ;COPY CSR ADDRESS
        ADD     #RMEC1,R3       ;POINT TO ECC POSITION REGISTER
        CALL    $ECCOR          ;CALL SHARED ECC ROUTINE
        BCS     155$            ;RECOVERY REQUIRED

        .IFF

        MOV     RMWC(R2),R0     ;GET NEGATIVE NUMBER OF WORDS REMAINING
        ASL     R0              ;CONVERT TO NEGATIVE BYTES REMAINING
        ADD     U.CNT(R5),R0    ;CALCULATE NUMBER OF BYTES TRANSFERED
        MOV     R0,-(SP)        ;SAVE NUMBER OF BYTES TRANSFERED
        BEQ     150$            ;IF EQ NO BYTES TRANSFERED
        BIT     #HCRC,RMER1(R2)  ;HEADER CRC ERROR ?
        BNE     107$            ;IF NE YES
        DEC     R0              ;CALCULATE OFFSET TO START OF BLOCK
107$:   BIC     #777,R0         ;CLEAR RESIDUE
        BIT     #DTE!ECH!HCRC,RMER1(R2) ;ECC HARD ERROR?
        BNE     150$            ;IF NE YES

;
; SECOND CALCULATE BYTE OFFSET IN BLOCK AND POSITION PATTERN SHIFT COUNT
;

        MOV     RMEC1(R2),R1    ;GET STARTING BIT NUMBER
        DEC     R1              ;CONVERT TO RELATIVE BIT NUMBER
        MOV     R1,-(SP)        ;SAVE STARTING RELATIVE BIT NUMBER
        BIC     #^C<17>,R1      ;ISOLATE SHIFT COUNT
        BIC     R1,(SP)         ;CLEAR SHIFT COUNT IN RELATIVE BIT NUMBER
        CLC                     ;CALCULATE OFFSET TO FIRST BYTE IN BLOCK
        ROR     (SP)            ;
        ASR     (SP)            ;
        ASR     (SP)            ;
        ADD     (SP),R0         ;CALCULATE OFFSET TO FIRST BYTE IN TRANSFER

;
; THIRD SHIFT CORRECTION PATTERN INTO PLACE
;

        MOV     RMEC2(R2),R3    ;GET CORRECTION PATTERN WORD
        CLR     (SP)            ;CLEAR SECOND WORD
110$:   DEC     R1              ;ANY MORE SHIFTS TO PERFORM?
        BLT     120$            ;IF LT NO
        ASL     R3              ;DOUBLE LEFT SHIFT
        ROL     (SP)            ;
        BR      110$            ;

;
; FOURTH APPLY FIRST CORRECTION
;

120$:   CALL    130$            ;APPLY ECC CORRECTION

;
; FIFTH APPLY SECOND CORRECTION
;

        MOV     (SP)+,R3        ;RETRIEVE SECOND PATTERN WORD
        ADD     #2,R0           ;UPDATE OFFSET TO TRANSFER
        CALL    130$            ;APPLY ECC CORRECTION

;
; SIXTH FINISH OR CONTINUE PREVIOUS FUNCTION
;

        MOV     #IS.SUC,R0      ;ASSUME SUCCESSFUL TRANSFER
        MOV     (SP)+,R1        ;GET BYTES ACTUALLY TRANSFERED          ;**-1
        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX

        .ENDC


        MOVB    #11,(R2)        ;CLEAR DRIVE ERRORS                     ; RP002
        CALL    210$            ;RESET RECOVERY PARAMETERS
        SUB     R1,U.CNT(R5)    ;ANY MORE WORDS TO TRANSFER?
        BEQ     70$             ;IF EQ NO


        .IF DF  M$$MGE


        .IF DF  M$$EXT

        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUS DEVICE?            ; RP007
        BEQ     125$            ;IF EQ NO -- DOES USE UMR'S             ; RP007
        MOVB    RMBAE(R2),U.BUF+1(R5)  ;SAVE MEMORY EXTENSION BITS      ; RP007
        BR      126$            ;                                       ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
125$:   MOVB    1(R2),U.BUF+1(R5) ;SAVE MEMORY EXTENSION BITS           ; RP007
        BICB    #^C<3>,U.BUF+1(R5)  ;CLEAR EXCESS BITS                  ; RP007
126$:                           ;REF LABEL                              ; RP007
                                                                        ;**-8

        .ENDC


        MOV     RMBA(R2),U.BUF+2(R5) ;SAVE BUFFER ADDRESS
        MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        MOV     RMDC(R2),I.PRM+10(R1) ;SAVE CYLINDER ADDRESS
        MOV     RMDA(R2),I.PRM+12(R1) ;SAVE TRACK/SECTOR ADDRESS
        MOVB    U.BUF(R5),(R2)  ;RESTART PREVIOUS OPERATION
        RETURN                  ;

;
; ECC CORRECTION ROUTINE
;


        .IF NDF S$$ECC

130$:   CMP     R0,U.CNT(R5)    ;BYTE OFFSET WITHIN RANGE?
        BHIS    140$            ;IF HIS NO


        .IF DF  D$$IAG

        CALL    $RELOP          ;RELOCATE PHYSICAL ADDRESS

        .IFF


        .IF DF  M$$MGE

        MOV     U.BUF(R5),-(SP) ;RETRIEVE ORIGINAL MEMORY EXTENSION BITS
        CLRB    (SP)            ;CLEAR FUNCTION BYTE

        .IFTF

        MOV     U.BUF+2(R5),R1  ;RETRIEVE STARTING BUFFER ADDRESS
        ADD     R0,R1           ;CALCULATE ADDRESS OF WORD TO BE CORRECTED

        .IFT

        ADCB    1(SP)           ;PROPAGATE ADDRESS CARRY
        SWAB    R1              ;SWAP STARTING BUFFER ADDRESS
        BISB    R1,(SP)         ;MERGE 8 BITS OF UPPER ADDRESS BIAS
        ASL     R1              ;COLLECT REMAINING TWO BITS
        ROL     (SP)            ;
        ASL     R1              ;
        ROL     (SP)            ;
                                                                        ; RP007
                                                                        ; RP007
        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUS DEVICE?            ; RP007
        BNE     135$            ;IF NE YES -- DOES NOT USE UMR'S        ; RP007
        ADD     #170000,(SP)    ;FORCE ADDRESS TO BE CALCULATED THROUGH ; RP007
                                ;UNIBUS MAP                             ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
135$:   MOV     (SP)+,KISAR6    ;SET BUFFER RELOCATION BIAS             ; RP007
        CLRB    R1              ;CLEAR LOW BYTE OF STARTING ADDRESS     ;**-1
        SWAB    R1              ;SWAP ADDRESS BACK
        ASR     R1              ;SETUP APR6 ADDRESS
        ASR     R1              ;
        BIS     #140000,R1      ;

        .ENDC


        .ENDC


        MOV     (R1),-(SP)      ;COPY CURRENT DATA WORD
        BIC     R3,(R1)         ;.NOT.PATTERN.AND.DATA WORD
        BIC     (SP)+,R3        ;.NOT.DATA WORD.AND.PATTERN
        BIS     R3,(R1)         ;PATTERN.OR.DATA WORD
140$:   RETURN                  ;

        .ENDC


;
; DATA ERROR & HEADER ERROR RECOVERY
;

150$:   TST     (SP)+           ;REMOVE COUNT FROM STACK
155$:   MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        TST     R0              ;ANY GOOD SECTORS TRANSFERED ?
        BEQ     180$            ;BR IF NO

;
; THE TRANSFER ENDED IN A DATA ERROR (EG, ECH, DTE, OR HCRC) BUT THERE
; WERE SECTORS TRANSFERED THAT CONTAINED GOOD DATA; THE GOOD DATA
; IS SAVED AND THE TRANSFER IS RETRIED FROM THE POINT OF ERROR.
;

        ADD     R0,U.BUF+2(R5)  ;UPDATE STARTING BUFFER ADDRESS
        ADCB    U.BUF+1(R5)     ;PROPAGATE CARRY INTO EXTENSION BITS
        SUB     R0,U.CNT(R5)    ;REDUCE BYTES REMAINING TO TRANSFER
        SWAB    R0              ;CALCULATE NUMBER OF SECTORS TRANSFERED
        ASR     R0              ;
        ADD     I.PRM+12(R1),R0 ;UPDATE TRACK/SECTOR ADDRESS
158$:   BIT     #40,RMDT(R2)    ;IS IT AN RP07?                         ; RP001
        BNE     162$            ;IF NE YES                              ; RP001
160$:   CMPB    #32.,R0         ;SECTOR OVERFLOW?
        BHI     165$            ;IF HI NO
        SUB     #32.,R0         ;SUBTRACT OUT A SECTOR
        ADD     #1*256.,R0      ;ADD IN A TRACK
        CMP     #5.*256.,R0     ;TRACK OVERFLOW?
        BHI     160$            ;IF HI NO
        SUB     #5.*256.,R0     ;NORMALIZE TRACK ADDRESS
        BR      164$            ;BRANCH AROUND NEXT                     ; RP001
162$:   CMPB    #34.,R0         ;SECTOR OVERFLOW?                       ; RP001
        BHI     165$            ;IF HI NO                               ; RP001
        SUB     #34.,R0         ;SUBTRACT OUT A SECTOR                  ; RP001
        ADD     #1*256.,R0      ;ADD IN A TRACK                         ; RP001
        CMP     #30.*256.,R0    ;TRACK OVERVFLOW?                       ; RP001
        BHI     162$            ;IF HI NO                               ; RP001
        SUB     #30.*256.,R0    ;NORMALIZE TRACK ADDRESS                ; RP001
164$:   INC     I.PRM+10(R1)    ;UPDATE CYLINDER ADDRESS                ; RP001
        BR      158$            ;                                       ; RP001
165$:   MOV     R0,I.PRM+12(R1) ;SET UPDATED TRACK/SECTOR ADDRESS       ;**-2
175$:   BISB    #1,I.PRM+6(R1)  ;SETUP RTC FLAG
        CALL    210$            ;RESTORE OFFSET TABLE AND RETRY COUNT
        BR      200$            ;

;
; NO GOOD DATA WAS TRANSFERED - CHECK IF OFFSET SHOULD BE CHANGED
;

180$:                           ;REF LABEL


        .IF DF  R$$MOF

        BIT     #DCK!DTE!ECH,RMER1(R2)  ;DATA CHECK OR DRIVE TIMING ERROR?
        BNE     185$            ;IF NE YES
        CMP     OFFAD(R3),#OFFTB  ;AT OFFSET ALREADY ?
        BLO     185$            ;IF LO NO
        BIS     #HCI,I.PRM+6(R1)  ;SET 'HCI' BIT

        .IFTF

185$:   DECB    RTTBL+1(R3)     ;CHANGE OFFSET?
        BGT     200$            ;IF GT NO
        BIT     #40,RMDT(R2)    ;IS IT AN RP07?                         ; RP001
        BNE     186$            ;IF NE YES                              ; RP001

        .IFT

        ADD     #2,OFFAD(R3)    ;UPDATE OFFSET POINTER
        CMP     #OFFTB+4,OFFAD(R3)  ;FINISHED ?
        BNE     187$            ;IF NE NO

        .IFTF

186$:   MOV     #IE.VER&377,R0  ;UNRECOVERABLE ERROR CODE               ; RP012
        MOVB    #0,RTTBL(R3)    ;ZERO RETRY COUNT                       ; RP012
        JMP     70$             ;DONE                                   ; RP012
                                                                        ;**-1
        .IFT

187$:   MOV     @OFFAD(R3),I.PRM+6(R1)  ;GET NEXT OFFSET VALUE
        MOVB    #2,RTTBL+1(R3)  ;SET RECOVERY RETRY COUNT

        .ENDC


200$:   JMP     40$             ;RETRY FUNCTION

;
; SET RECOVERY & OFFSET PARAMETERS
;

210$:   MOVB    #16.,RTTBL+1(R3)  ;INITIALIZE THE RETRY COUNT


        .IF DF  R$$MOF

220$:   MOV     #OFFTB-2,OFFAD(R3) ;SET OFFSET TABLE POINTER

        .ENDC


        RETURN                  ;

;
;SET RECOVERY RECALIBRATION FOR 'HCE' AND 'SKI' ERRORS
;

230$:   MOV     #TRE!11,(R2)    ;CLEAR CONTROLLER AND DRIVE
        MOVB    S.ITM(R4),S.CTM(R4)  ;RESET TIMEOUT COUNT
        MOVB    #107,(R2)       ;LOAD THE RECALIBRATE COMMAND
        RETURN                  ;

;                                                                       ; RP001
;       SPECIAL 32-BIT INTEGER DIVIDE ROUTINE                           ; RP001
;                                                                       ; RP001
;       INPUTS:                                                         ; RP001
;               R0=LOW-ORDER PART OF DIVIDEND                           ; RP001
;               R1=POSITIVE DIVISOR                                     ; RP001
;               R2=HIGH-ORDER PART OF DIVIDEND                          ; RP001
;                                                                       ; RP001
;       OUTPUTS:                                                        ; RP001
;               R0=LOW-ORDER PART OF QUOTIENT                           ; RP001
;               R1=UNDEFINED, FOR POSSIBLE FUTURE USE                   ; RP001
;               R2=REMAINDER                                            ; RP001
;                                                                       ; RP001
240$:   MOV     #16.,-(SP)      ;SET DIVIDE LOOP COUNT                  ; RP001
245$:   ASL     R0              ;DOUBLE LEFT SHIFT                      ; RP001
        ROL     R2              ;THESE TWO INSTRUCTIONS                 ; RP001
        CMP     R2,R1           ;PARTIAL REMAINDER LARGER THAN DIVISOR? ; RP001
        BLO     250$            ;IF LO NO                               ; RP001
        SUB     R1,R2           ;SUBTRACT OUT DIVISOR                   ; RP001
        INC     R0              ;ACCUMULATE QUOTIENT                    ; RP001
250$:   DEC     (SP)            ;ANY MORE PARTIAL DIVIDES?              ; RP001
        BGT     245$            ;IF GT YES                              ; RP001
        TST     (SP)+           ;PRUNE THE STACK                        ; RP001
        MOV     R0,I.PRM+10(R3) ;SAVE DESIRED CYLINDER ADDRESS          ; RP001
        MOV     R2,R0           ;SET DIVIDEND TO TRACK/SECTOR REMAINDER ; RP001
        RETURN                                                          ; RP001

        .DSABL  LSB

        .END
        .TITLE  DRDSP
        .IDENT  /14/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; VERSION 14
;
; D. N. CUTLER 12-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 20-JUL-77
;
;               TM088 -- ADD CONNECT TO INTERRUPT TO DIRECTIVE DISPATCH
;                       TABLE.
;
;       CHUCK SPITZ 29-AUG-78
;
;               CS017 -- ADD STOP BIT DIRICTIVES AND PARENT OFFSPRING
;                       SUPPORT
;
;       CHUCK SPITZ 26-OCT-78
; 
;               CS018 -- ADD PARENT OFFSPRING TASKING SUPPORT
;
;       CHUCK SPITZ 17-JAN-79
;               CS026 -- NEW DISPATCH TABLE. REPLACES CS017, CS018.
; DIRECTIVE DISPATCHER
;
; MACRO LIBRARY CALLS
;

        .MCALL  HDRDF$,HWDDF$,TCBDF$,WDBDF$
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
        WDBDF$                  ;DEFINE USER WINDOW DEF BLOCK OFFSETS

; LOCAL MACROS                                                          ; CS026
                                                                        ; CS026
;                                                                       ; CS026
; MACRO TO DEFINE SUCCESSIVE DIRECTIVE MASK BITS                        ; CS026
;                                                                       ; CS026
                                                                        ; CS026
        .MACRO  DEFINE SYM                                              ; CS026
SYM=N                                                                   ; CS026
N=N/2                                                                   ; CS026
        .ENDM                                                           ; CS026
                                                                        ; CS026
; THE SIZ MACRO IS USED TO DETERMINE THE HIGHEST DIC CODE USED, AS      ; CS026
; WELL AS THE TOTAL NUMBER OF DIC'S IN USE. IT'S PARAMETERS ARE THE     ; CS026
; SAME AS THE GEN MACRO BELOW, THOUGH IT ONLY NEEDS THE DIC AND COND.   ; CS026
                                                                        ; CS026
        .MACRO  SIZ,DIC,DPBSIZ,DIRADR,MASK,COND,SECOND                  ; CS026
                                                                        ; CS026
        .IF NB <COND>                                                   ; CS026
                                                                        ; CS026
        .IF DF COND                                                     ; CS026
                                                                        ; CS026
NUMDIR=NUMDIR+1                                                         ; CS026
                                                                        ; CS026
        .IF GT DIC-HIDIR                                                ; CS026
HIDIR=DIC                                                               ; CS026
        .ENDC                                                           ; CS026
                                                                        ; CS026
        .ENDC   ;COND                                                   ; CS026
                                                                        ; CS026
        .IFF    ;NB COND                                                ; CS026
                                                                        ; CS026
NUMDIR=NUMDIR+1                                                         ; CS026
                                                                        ; CS026
        .IF GT DIC-HIDIR                                                ; CS026
HIDIR=DIC                                                               ; CS026
        .ENDC                                                           ; CS026
                                                                        ; CS026
        .ENDC   ;NB COND                                                ; CS026
        .ENDM                                                           ; CS026
                                                                        ; CS026
                                                                        ; CS026
; THE GEN MACRO IS USED TO FILL IN THE ABOVE TABLES, BASED UPON THE     ; CS026
; CONDITIONAL ASSEMBLY PARAMETERS DEFINED IN RSXMC.MAC.  RSXMC.MAC      ; CS026
; IS CREATED BY SYSGEN PART 1.  THE PARAMETERS FOR THE GEN MACRO ARE:   ; CS026
;       DIC - DIRECTIVE IDENTIFICATION CODE. (MUST BE ODD)              ; CS026
;       COND - CONDITIONAL ASSEMBLY PARAMETERS WHICH MUST BE DEFINED    ; CS026
;               IF THE DIRECTIVE IS SUPPORTED.                          ; CS026
;       DPBSIZ - SIZE OF THE DIRECTIVE PARAMETER BLOCK.                 ; CS026
;       SECOND - CONDITIONAL ASSEMBLY PARAMETERS WHICH IF DEFINED,      ; CS026
;               REQUIRE THAT THE DIRECTIVE HAVE A VARIABLE LENGTH DPB.  ; CS026
;       MASK - DIRECTIVE PROCESSING CONTROL MASK                        ; CS026
;       DIRADR - ADDRESS OF THE DIRECTIVE PROCESSING ROUTINE            ; CS026
;                                                                       ; CS026
        .MACRO  GEN,DIC,DPBSIZ,DIRADR,MASK,COND,SECOND                  ; CS026
                                                                        ; CS026
        .IF B <COND>                                                    ; CS026
                                                                        ; CS026
        GEN     <DIC>,<DPBSIZ>,<DIRADR>,<MASK>,R$$11M,<SECOND>          ; CS026
                                                                        ; CS026
        .IFF    ;B <COND>                                               ; CS026
                                                                        ; CS026
        .IF DF COND                                                     ; CS026
                                                                        ; CS026
        .IF DF BYTTAB                                                   ; CS026
.=<BTAB+<DIC/2>>                                                        ; CS026
        .BYTE   DSPPTR                                                  ; CS026
.=DSPTBL+DSPPTR                                                         ; CS026
DSPPTR=DSPPTR+4                                                         ; CS026
        .IFF    ;BYTTAB                                                 ; CS026
.=<DIC*2-2+DSPTBL>                                                      ; CS026
        .ENDC   ;BYTTAB                                                 ; CS026
                                                                        ; CS026
        .WORD   DIRADR                                                  ; CS026
                                                                        ; CS026
        .IF NB <SECOND>                                                 ; CS026
                                                                        ; CS026
        .IF DF SECOND                                                   ; CS026
                                                                        ; CS026
        .BYTE   0                                                       ; CS026
VARDPB=0                                                                ; CS026
                                                                        ; CS026
        .IFF    ;SECOND                                                 ; CS026
                                                                        ; CS026
        .BYTE   DPBSIZ*2                                                ; CS026
                                                                        ; CS026
        .ENDC   ;SECOND                                                 ; CS026
                                                                        ; CS026
        .IFF    ;NB SECOND                                              ; CS026
                                                                        ; CS026
        .BYTE   DPBSIZ*2                                                ; CS026
                                                                        ; CS026
        .ENDC   ;NB SECOND                                              ; CS026
                                                                        ; CS026
DSPMK=0                                                                 ; CS026
                                                                        ; CS026
        .IF NB  <MASK>                                                  ; CS026
        .IRP    X,<MASK>                                                ; CS026
DSPMK=DSPMK!X                                                           ; CS026
        .ENDM                                                           ; CS026
        .ENDC                                                           ; CS026
                                                                        ; CS026
        .BYTE   DSPMK                                                   ; CS026
                                                                        ; CS026
        .ENDC   ;COND                                                   ; CS026
                                                                        ; CS026
        .ENDC   ;B <COND>                                               ; CS026
                                                                        ; CS026
        .ENDM                                                           ; CS026
                                                                        ; CS026
; EACH DIRECTIVE IS REPRESENTED AS A LINE IN THE DIREC MACRO.           ; CS026
; THE ONLY PARAMETER FOR THE DIREC MACRO IS THE NAME OF THE MACRO       ; CS026
; TO BE INVOKED UPON EACH LINE.  THE FIRST CALL OF DIREC SPECIFIES      ; CS026
; THE SIZ MACRO TO DETERMINE WHETHER THE SINGLE OR DOUBLE TABLE         ; CS026
; SCHEME IS TO BE USED.  THE SECOND CALL SPECIFIES THE GEN MACRO        ; CS026
; TO ACTUALLY GENERATE THE PROPER TABLE STRUCTURE.                      ; CS026
                                                                        ; CS026
        .MACRO  DIREC,MAC                                               ; CS026
                                                                        ; CS026
        MAC     1.,12.,$DRQIO           ;QUEUE I/O                      ; CS026
        MAC     3.,12.,$DRQIO           ;QUEUE I/O AND WAIT             ; CS026
        MAC     5.,3.,$DRGLI            ;GET LUN INFORMATION            ; CS026
        MAC     7.,4.,$DRASG            ;ASSIGN LUN                     ; CS026
        MAC     9.,4.,$DRATP,<DFCTSK,SRSTCL>,A$$PRI ;ALTER PRIORITY     ; CS026
        MAC     11.,7.,$DRREQ,SRSTCL,,P$$OFF ;REQUEST, SPAWN            ; CS026
        MAC     17.,11.,$DRRUN,SRSTCL   ;RUN TASK                       ; CS026
        MAC     21.,2.,$DRRRA,,A$$TRP&P$$LAS&P$$SRF ;SETUP FOR          ; CS026
                                        ;RECEIVE BY REFERENCE AST       ; CS026
        MAC     23.,5.,$DRMKT,CEFNCL    ;MARK TIME                      ; CS026
        MAC     25.,3.,$DRCSR,<SRSTCL,MUPCHK> ;CANCEL SCHEDULE REQUESTS ; CS026
        MAC     27.,1.,$DRCMT,,,C$$SMT  ;CANCEL (SELECTIVE) MARK TIME   ; CS026
        MAC     29.,2.,$DREXS,,P$$OFF   ;EXIT WITH STATUS               ; CS026
        MAC     31.,2.,$DRCEF,<CEFNCL,CEFNMT> ;CLEAR EVENT FLAG         ; CS026
        MAC     33.,2.,$DRSEF,<CEFNCL,CEFNMT> ;SET EVENT FLAG           ; CS026
        MAC     35.,1.,$DRDSE           ;DECLARE SIGNIFICANT EVENT      ; CS026
        MAC     39.,2.,$DRRAF,,,G$$EFN  ;READ ALL/EXTENDED EVENT FLAGS  ; CS026
        MAC     41.,2.,$DRWFS,<CEFNCL,CEFNMT> ;WAIT FOR SINGLE EVENT FLA; CS026
        MAC     43.,3.,$DRWFL           ;WAIT FOR LGOICAL OR OF EVENT FL; CS026
        MAC     45.,1.,$DRSPN           ;SUSPEND EXECUTION              ; CS026
        MAC     47.,3.,$DRRES,SRSTCL    ;RESUME EXECUTION               ; CS026
        MAC     49.,1.,$DRWSE           ;WAIT FOR SIGNIFICANT EVENT     ; CS026
        MAC     51.,1.,$DREXT           ;TASK EXIT                      ; CS026
        MAC     53.,2.,$DREIF,<CEFNCL,CEFNMT> ;EXIT IF                  ; CS026
        MAC     55.,2.,$DRCRR,ACHKDB,P$$LAS ;CREATE REGION              ; CS026
        MAC     57.,2.,$DRATR,ACHKDB,P$$LAS ;ATTACH REGION              ; CS026
        MAC     59.,2.,$DRDTR,ACHKDB,P$$LAS ;DETACH REGION              ; CS026
        MAC     61.,2.,$DRGTP           ;GET TIME PARAMETERS            ; CS026
        MAC     63.,2.,$DRGTK,,G$$TTK   ;GET TASK PARAMETERS            ; CS026
        MAC     65.,4.,$DRGPP,,G$$TPP   ;GET PARTITION PARAMETERS       ; CS026
        MAC     69.,5.,$DRSRF,SRSTCL,P$$LAS&P$$SRF ;SEND BY REFERENCE   ; CS026
        MAC     71.,5.,$DRSND,SRSTCL,R$$SND ;SEND DATA TO TASK          ; CS026
        MAC     75.,4.,$DRREC,,R$$SND   ;RECEIVE DATA FROM TASK         ; CS026
        MAC     77.,4.,$DRREC,,R$$SND   ;RECEIVE DATA FROM TASK OR EXIT ; CS026
        MAC     81.,2.,$DRRRF,ACHKDB,P$$LAS&P$$SRF ;RECEIVE BY REFERENCE; CS026
        MAC     83.,3.,$DRABO,<SRSTCL,MUPCHK> ;ABORT TASK               ; CS026
        MAC     89.,3.,$DREXP,,D$$YNM&E$$XPR&M$$MGE ;EXTEND PARTITION   ; CS026
        MAC     95.,1.,$DRDCP,,C$$CKP&D$$ISK ;DISABLE CHECKPOINTING     ; CS026
        MAC     97.,1.,$DRECP,,C$$CKP&D$$ISK ;ENABLE CHECKPOINTING      ; CS026
        MAC     99.,1.,$DRDAR,,A$$TRP   ;DISABLE AST RECOGNITION        ; CS026
        MAC     101.,1.,$DREAR,,A$$TRP  ;ENABLE AST RECOGNITION         ; CS026
        MAC     103.,3.,$DRSDV          ;SPECIFY ODT SST VECTOR         ; CS026
        MAC     105.,3.,$DRSTV          ;SPECIFY TASK SST VECTOR        ; CS026
        MAC     107.,2.,$DRRCV,,A$$TRP&R$$SND ;SETUP FOR RECEIVE AST    ; CS026
        MAC     109.,2.,$DRPUT,,A$$TRP&P$$RFL ;SETUP FOR POWERFAIL AST  ; CS026
        MAC     111.,2.,$DRFEX,,A$$TRP&F$$LPP ;SETUP FOR FLOATING POINT ; CS026
        MAC     113.,2.,$DRGMX,,P$$LAS&P$$GMX ;GET MAPPING CONTEXT      ; CS026
        MAC     115.,1.,$DRATX,,A$$TRP  ;AST TRAP EXIT                  ; CS026
        MAC     117.,2.,$DRCRW,ACHKDB,P$$LAS ;CREATE ADDRESS WINDOW     ; CS026
        MAC     119.,2.,$DRELW,ACHKDB,P$$LAS ;ELIMINATE ADDRESS WINDOW  ; CS026
        MAC     121.,2.,$DRMAP,ACHKDB,P$$LAS ;MAP ADDRESS WINDOW        ; CS026
        MAC     123.,2.,$DRUNM,ACHKDB,P$$LAS ;UNMAP ADDRESS WINDOW      ; CS026
        MAC     125.,1.,$DRGSS,,G$$TSS  ;GET SENSE SWITCHES             ; CS026
        MAC     127.,41.,$DRGCL,,M$$CRX ;GET MCR COMMAND LINE           ; CS026
        MAC     129.,7.,$DRCIN,,C$$INT  ;CONNECT TO INTERRUPT           ; CS026
        MAC     131.,1.,$DRSTP,,S$$TOP  ;STOP TASK                      ; CS026
        MAC     133.,3.,$DRUNS,<DFCTSK,SRSTCL>,S$$TOP ;UNSTOP TASK      ; CS026
        MAC     135.,2.,$DRSTS,<CEFNCL,CEFNMT>,S$$TOP ;STOP FOR SINGLE  ; CS026
                                        ;EVENT FLAG                     ; CS026
        MAC     137.,3.,$DRSTL,,S$$TOP  ;STOP FOR LOGICAL OR OF EVENT   ; CS026
                                        ;FLAGS                          ; CS026
        MAC     139.,4.,$DRRCS,,S$$TOP&R$$SND ;RECEIVE DATA OR STOP     ; CS026
        MAC     143.,6.,$DRCNC,SRSTCL,P$$OFF ;CONNECT TO TASK           ; CS026
        MAC     157.,2.,$DRCRE,,G$$EFN  ;CREATE EVENT FLAG GROUP        ; CS026
        MAC     159.,2.,$DRELE,,G$$EFN  ;ELIMINATE EVENT FLAG GROUP     ; CS026
                                                                        ; CS026
;                                                                       ; CS026
; ADD NEW DIRECIVES HERE                                                ; CS026
;                                                                       ; CS026
                                                                        ; CS026
        .ENDM                                                           ; CS026
                                                                        ; CS026
                                                                        ; CS026
;                                                                       ; CS026
; THE DIRECTIVE DISPATCHER IS ASSEMBLED TO USE ONE OF THE FOLLOWING     ; CS026
; DISPATCH TABLE STRUCTURES, DEPENDING UPON WHICH REQUIRES THE LEAST    ; CS026
; AMOUNT OF MEMORY.  THE FIRST SCHEME USES A DISPATCH TABLE, DSPTBL,    ; CS026
; THAT CONTAINS 2 WORDS FOR EACH POSSIBLE DIC. THE FORMAT OF EACH ENTRY ; CS026
; IS:                                                                   ; CS026
;       .WORD   ADDRESS ;ADDRESS OF DIRECTIVE PROCESSING ROUTINE        ; CS026
;                       ; OR 0 IF DIRECTIVE IS NOT SUPPORTED.           ; CS026
;       .BYTE   DBPSIZ  ;SIZE OF DPB FOR THIS DIRECTIVE OR 0 IF         ; CS026
;                       ; THIS DIRECTIVE HAS A VAIRABLE LENGTH DPB.     ; CS026
;       .BYTE   MASK    ;CONTROL BITS USED BY THE DISPATCHER.           ; CS026
;                                                                       ; CS026
; THE MEMORY USED FOR THIS TABLE IS EQUAL TO THE HIGHEST DIC VALUE      ; CS026
; TIMES 2 MINUS 2 BYTES.                                                ; CS026
;                                                                       ; CS026
; IF THE ABOVE TABLE WOULD BE LESS THAN 3/4 FULL, WE USE THE FOLLOWING  ; CS026
; TWO TABLES FOR DIRECTIVE DISPATCHING.  THE FIRST TABLE, BTAB, CONTAINS; CS026
; BYTE FOR EACH POSSIBLE DIC.  THE BYTE CONTAINS THE OFFSET INTO THE    ; CS026
; DISPATCH TABLE DSPTBL IF THE DIRECTIVE IS SUPPORTED, OR 0 IF IT IS NOT; CS026
; THE SECOND TABLE, DSPTBL, IS THE SAME FORMAT AS ABOVE, HOWEVER, IT IS ; CS026
; ONLY REQUIRED TO HAVE ENTRIES FOR THE DIC'S IN USE.  THE FIRST ELEMENT; CS026
; DSPTBL IS 2(DSPTBL) BECAUSE WE USE 0 TO REPRESENT INVALID DIC'S.      ; CS026
;                                                                       ; CS026
; THE CONDITIONAL ASSEMBLY PARAMETER BYTTAB IS DEFINED IF THE TWO TABLE ; CS026
; SCHEME IS USED.                                                       ; CS026
;                                                                       ; CS026
                                                                        ; CS026
; LOCAL SYMBOLS                                                         ; CS026
                                                                        ; CS026
NUMDIR=0                        ;NUMBER OF DIC'S IN USE                 ; CS026
HIDIR=0                         ;HIGHEST DIC IN USE                     ; CS026
                                                                        ; CS026
; DEFINE DISPATCHER MASK OFFSETS                                        ; CS026
                                                                        ; CS026
DSPNX=2                         ;INITIAL DIRECTIVE MAPPING TABLE INDEX  ; CS026
N=200                           ;INITIAL MASK VALUE                     ; CS026
        DEFINE  ACHKDB          ;ADDRESS CHECK PLAS DEFINITION BLOCK    ; CS026
        DEFINE  CEFNCL          ;CALL $CEFN (1=YES)                     ; CS026
        DEFINE  CEFNMT          ;EFN MUST BE SPECIFIED (1=YES)          ; CS026
        DEFINE  DFCTSK          ;TASK NAME DEFAULTS TO CURRENT TASK     ; CS026
        DEFINE  MUPCHK          ;PERFORM MULTI-USER PROTECTION CHECK    ; CS026
        DEFINE  SRSTCL          ;CALL   $SRSTD (1=YES)                  ; CS026
                                                                        ; CS026
        DIREC   SIZ             ;DETERMINE HIGHEST DIC AND NUMBER OF DIC; CS026
                                ;IN USE                                 ; CS026
                                                                        ; CS026
        .IF LE NUMDIR-<HIDIR*3/8.>      ;IF WE ARE USING LESS THAN      ; CS026
                                        ;3/4 OF THE DIC'S, WE WILL      ; CS026
BYTTAB=0                                ;USE THE TWO TABLE SCHEME       ; CS026
                                                                        ; CS026
        .ENDC                                                           ; CS026
                                                                        ; CS026
;                                                                       ; CS026
; LOCAL DATA - ADJACENCY ASSUMED                                        ; CS026
;                                                                       ; CS026
USRPS:  .BLKW   1               ;POINTER TO USER PS WORD                ; CS026
BTRMV:  .BLKW   1               ;BYTES TO REMOVE ON EXIT                ; CS026
                                                                        ; CS026
                                                                        ; CS026
        .IF DF BYTTAB                                                   ; CS026
                                                                        ; CS026
BTAB:   .BLKB   HIDIR/2+1       ;BYTE INDEX TABLE                       ; CS026
        .EVEN                                                           ; CS026
.=.-2                                                                   ; CS026
DSPTBL: .BLKW   NUMDIR*2+1      ;DISPATCH TABLE                         ; CS026
DSPPTR=2                        ;POINTER INTO DISPATCH TABLE            ; CS026
                                                                        ; CS026
        .IFF    ;BYTTAB                                                 ; CS026
                                                                        ; CS026
DSPTBL: .BLKW   HIDIR+1                                                 ; CS026
                                                                        ; CS026
        .ENDC   ;BYTTAB                                                 ; CS026
                                                                        ; CS026
$$$=.                                                                   ; CS026
        DIREC   GEN             ;GENERATE DIRECTIVE DISPATCH TABLE      ; CS026
.=$$$                                                                   ; CS026
                                                                        ;**-392

;+
; **-$TRTRP-TRAP TRAP
;
; THIS ROUTINE IS TRAPPED TO WHEN A TRAP INSTRUCTION IS EXECUTED. IF THE
; STACK DEPTH IS ZERO, THEN A DIRECTIVE STATUS IS TO BE RETURNED. ELSE
; CONTROL IS TRANSFERED TO THE EMT/TRAP SST HANDLING ROUTINE.
;
; INPUTS:
;
;       2(SP)=PS WORD PUSHED BY TRAP INSTRUCTION.
;       0(SP)=PC WORD PUSHED BY TRAP INSTRUCTION.
;
; OUTPUTS:
;
;       IF THE STACK DEPTH IS ZERO, THEN A DIRECTIVE STATUS IS RETURNED.
;       ELSE CONTROL IS TRANSFERED TO THE EMT/TRAP SST HANDLING ROUTINE.
;-

        .ENABL  LSB
$TRTRP::TST     $STKDP          ;;;STACK DEPTH ZERO?
        BNE     $EMTRP          ;;;IF NE NO
        MTPS    #0              ;;;ALLOW INTERRUPTS
        MOV     (SP),R0         ;GET ADDRESS PLUS 2 OF TRAP INSTRUCTION


        .IF DF  M$$MGE

        BIS     #PMODE,PS       ;SET PREVIOUS MODE TO USER
        MOV     #$STACK-22,SP   ;RELOAD EXEC STACK POINTER

        .IFF

        MOV     #$STACK-12,SP   ;RELOAD EXEC STACK POINTER

        .ENDC


        MOVB    -2(R0),R0       ;PICKUP DIRECTIVE STATUS
        MOV     R0,-(SP)        ;SAVE DIRECTIVE STATUS
        BPL     60$             ;IF PL OKAY AS IS
        INC     @USRPS          ;SET CARRY IN USER PS WORD
        BR      60$             ;

;+
; **-$EMTRP-EMT TRAP
;
; THIS ROUTINE IS TRAPPED TO WHEN AN EMT INSTRUCTION IS EXECUTED. IF THE
; STACK DEPTH IS NOT +1, THEN THE SYSTEM IS CRASHED. ELSE A TEST IS
; MADE TO SEE IF THE EMT INSTRUCTION HAD A CODE OF 377. IF NOT, THEN
; CONTROL IS TRANSFERED TO THE EMT/TRAP SST HANDLING ROUTINE. ELSE THE
; APPROPRIATE DIRECTIVE IS EXECUTED.
;
; INPUTS:
;
;       2(SP)=PS WORD PUSHED BY EMT INSTRUCTION.
;       0(SP)=PC WORD PUSHED BY EMT INSTRUCTION.
;
; OUTPUTS:
;
;       IF THE STACK DEPTH IS NOT +1, THEN THE SYSTEM IS CRASHED. ELSE
;       CONTROL IS GIVEN TO THE EMT/TRAP SST ROUTINE OR A DIRECTIVE ROUTINE
;       DEPENDENT ON WHETHER THE EMT HAD A CODE OF 377.
;-

$EMTRP::DIRSV$                  ;;;SAVE REGISTERS AND SET PRIORITY
        TST     $STKDP          ;WERE WE AT STACK DEPTH +1?
        BNE     70$             ;IF NE NO-CRASH SYSTEM
        MOV     @$HEADR,R3      ;GET SAVED STACK POINTER
        CMP     (R3)+,(R3)+     ;POINT TO USER PC WORD
        MOV     (R3)+,R5        ;GET ADDRESS OF EMT PLUS 2


        .IF DF  M$$MGE

        MFPI    -(R5)           ;GET DIRECTIVE WORD
        CMP     #104377,(SP)    ;DIRECTIVE EMT?
        BNE     80$             ;IF NE NO
        MOV     #1,(SP)         ;SET SUCCESSFUL DIRECTIVE STATUS

        .IFF

        CMP     #104377,-(R5)   ;DIRECTIVE EMT?
        BNE     80$             ;IF NE NO
        MOV     #1,-(SP)        ;SET SUCCESSFUL DIRECTIVE STATUS

        .IFTF

        MOV     #USRPS,R5       ;POINT TO LOCAL DATA
        MOV     R3,(R5)+        ;SAVE ADDRESS OF USER PS
        BIC     (SP),(R3)+      ;CLEAR CARRY IN USER PS WORD
        CLR     (R5)            ;INDICATE NO BYTES

        .IFT

        MFPI    SP              ;GET USER STACK POINTER
        MOV     (SP)+,R3        ;
$DRLM1::MFPI    (R3)            ;GET FIRST WORD ON USER STACK
        BIT     #1,(SP)         ;DPB ON STACK?
        BNE     $DRLM2          ;IF NE YES
        MOV     #2,(R5)         ;INDICATE DPB POINTED TO BY STACK
        MOV     (SP),R3         ;SET ADDRESS OF DPB
        MFPI    @(SP)+          ;GET FIRST WORD OF DPB
$DRLM2::MOV     (SP)+,R1        ;PICK UP FIRST DPB WORD
        CLR     R0              ;EXTRACT DIC CODE                       ;**-4
        BISB    R1,R0           ;
        MOV     R1,$DICSV       ;SAVE DIC AND DPB SIZE                  ; CS018
        CLRB    R1              ;CLEAR DIC BYTE                         ;**-8
        SWAB    R1              ;SWAP DPB SIZE TO LOW BYTE

        .IFF

        BIT     (SP),(R3)       ;DPB ON STACK?
        BNE     10$             ;IF NE YES
        MOV     (R3),R3         ;GET ADDRESS OF DPB
        MOV     #2,(R5)         ;INDICATE DPB POINTED TO BY STACK


        .IF DF  A$$CHK

        CALL    $ACHK2          ;ADDRESS CHECK FIRST DPB WORD

        .ENDC

10$:    CLR     R0              ;EXTRACT DIC CODE                       ;**-3
        BISB    (R3),R0         ;
        MOV     (R3),$DICSV     ;SAVE DIC AND DPB SIZE                  ; CS018
        MOVB    1(R3),R1        ;EXTRACT DPB SIZE                       ; CS018
                                                                        ;**-10
        .ENDC


        ASL     R1              ;CONVERT TO BYTES TO REMOVE AT EXIT
        MOV     R1,R4           ;COPY SIZE
        CLR     -(SP)           ;ASSUME ILLEGAL DIC OR DPB SIZE
        ASR     R0              ;DIVIDE CODE BY 2
        BCC     35$             ;IF CC ILLEGAL DIC CODE


        CMP     R0,#HIDIR/2     ;LEGAL DIC CODE?                        ; CS026
        BHI     35$             ;IF HI NO                               ;**-3

                                                                        ;**-5
        .IF DF BYTTAB                                                   ; CS026

        CLR     R2              ;MAP TO DIRECTIVE DISPATCH TABLE
        BISB    BTAB(R0),R2     ;                                       ; CS026
        BEQ     35$             ;IF EQ ILLEGAL DIRECTIVE                ;**-1
        ADD     #DSPTBL,R2      ;POINT TO PROPER TABLE ENTRY            ; CS026
                                                                        ; CS026
        .IFF    ;BYTTAB                                                 ; CS026
                                                                        ; CS026
        MOV     #DSPTBL,R2      ;MAP TO DIRECTIVE DISPATCH TABLE        ; CS026
        ASL     R0                                                      ; CS026
        ASL     R0                                                      ; CS026
        ADD     R0,R2                                                   ; CS026
        TST     (R2)            ;VALID DIRCTIVE?                        ; CS026
        BEQ     35$             ;IF EQ, NO                              ; CS026
                                                                        ; CS026
        .ENDC   ;BYTTAB                                                 ; CS026
                                                                        ; CS026
        CMPB    R1,2(R2)        ;DPB SIZE MATCH?                        ;**-1
                                                                        ; CS026
        .IF DF VARDPB                                                   ; CS026
                                                                        ; CS026
        BEQ     20$             ;IF EQ YES                              ; CS026
        TSTB    2(R2)           ;VARIABLE LENGTH DPB?                   ; CS026
                                                                        ; CS026
        .ENDC   ;VARDPB                                                 ; CS026
                                                                        ; CS026
        BNE     35$             ;IF NE NO
20$:                            ;REF LABEL                              ; CS018
        MOV     (R2)+,(SP)      ;GET ADDRESS OF DIRECTIVE ROUTINE
        BIS     (R2),R4         ;PICK UP DIRECTIVE SIZE AND MASK BYTE   ; CS018
                                                                        ;**-1

        .IF DF  P$$LAS&M$$MGE

        BPL     35$             ;IF PL NOT A PLAS DIRECTIVE
$DPLM1::MFPI    2(R3)           ;PICK UP POINTER TO DEFINITION BLOCK
$DPLM2::MOV     (SP)+,R3        ;
        MOV     #8.*2,R1        ;PICK UP SIZE OF DEFINITION BLOCK

        .ENDC


35$:                            ;REFERENCE LABEL


        .IF DF  A$$CHK!M$$MGE

        CALL    $ACHKP          ;ADDRESS CHECK AND MAP DEFINITION BLOCK

        .ENDC


        TST     (R3)+           ;SKIP OVER FIRST DPB WORD
        TST     (R5)            ;DPB ON STACK?
        BNE     36$             ;IF NE NO
        MOVB    R4,(R5)         ;SET NUMBER OF BYTES TO REMOVE AT EXIT
36$:    CLRB    R4              ;CLEAR OUT SIZE BYTE
        TST     (SP)            ;LEGAL DIC AND DPB SIZE?
        BEQ     90$             ;IF EQ NO
        MOV     $TKTCB,R5       ;PICK UP CURRENT TASK TCB
        ASL     R4              ;CALL $CEFN OR PLAS DIRECTIVE?


        .IF DF  P$$LAS

        BCC     37$             ;IF CC NOT A PLAS DIRECTIVE
        TST     -(R3)           ;POINT BACK TO FIRST WORD OF BLOCK
        BIC     #WS.CRW!WS.UNM!WS.ELW!WS.RRF,W.NSTS(R3) ;INIT OUTPUTS
37$:                            ;REFERENCE LABEL

        .ENDC


        BPL     40$             ;IF PL NO
        CALL    $CEFN           ;CONVERT EVENT FLAG NUMBER
        BCC     50$             ;IF CC EVENT FLAG SPECIFIED
40$:    ASL     R4              ;EVENT FLAG REQUIRED?
        BEQ     50$             ;IF EQ NO
        BMI     100$            ;IF MI EVENT FLAG WAS REQUIRED


        .IF DF  A$$PRI!M$$MUP

        ASL     R4              ;TASK NAME DEFAULT TO CURRENT TASK?
        BPL     45$             ;IF PL NO
        MOV     R5,R0           ;PICK UP CURRENT TASK TCB
        TST     (R3)            ;TASK NAME SPECIFIED?
        BEQ     46$             ;IF EQ NO

        .ENDC


45$:    CALL    $SRSTD          ;SEARCH STD FOR TASK NAME
        BCS     110$            ;IF CS NAME NOT FOUND
46$:    CMP     (R3)+,(R3)+     ;ADVANCE PAST TASK NAME


        .IF DF  M$$MUP

        ASL     R4              ;PERFORM MULTI-USER PROTECTION CHECK?
        BPL     47$             ;IF PL NO
        BIT     #T3.PRV,T.ST3(R5) ;ISSUING TASK PRIVILEGED?
        BNE     47$             ;IF NE YES
        BIT     #T3.SLV,T.ST3(R0) ;TARGET TASK A SLAVE TASK?
        BNE     120$            ;IF NE YES, DON'T ALLOW
        CMP     T.UCB(R5),T.UCB(R0) ;CURRENT AND TARGET TASK UCBS MATCH?
        BNE     120$            ;IF NE NO

        .ENDC


47$:    MOV     R0,R1           ;COPY TCB ADDRESS
        ADD     #T.STAT,R1      ;POINT TO TASK STATUS WORD
50$:    MOV     R5,R2           ;SET POINTER TO SECOND TASK STATUS WORD
        ADD     #T.ST2,R2       ;
        MOV     $HEADR,R4       ;POINT TO CURRENT TASK HEADER

;
; CALL DIRECTIVE ROUTINE WITH THE FOLLOWING ARGUMENTS:
;
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R3=ADDRESS OF THE NEXT WORD IN THE DIRECTIVE DPB.
;       R2=ADDRESS OF THE SECOND TASK STATUS WORD OF THE CURRENT TASK.
;       R1=DEPENDENT ON DIRECTIVE.
;       R0=DEPENDENT ON DIRECTIVE.
;

        CALL    @(SP)+          ;CALL DIRECTIVE ROUTINE
60$:                            ;REF LABEL


        .IF DF  M$$MGE

        MTPI    @#H.DSW         ;SET DIRECTIVE STATUS WORD
        MFPI    SP              ;GET USER STACK POINTER
        ADD     BTRMV,(SP)      ;REMOVE BYTES FROM USER STACK
        MTPI    SP              ;RESTORE USER STACK POINTER

        .IFF

        MOV     (SP)+,@.DSW     ;SET DIRECTIVE STATUS WORD
        MOV     $HEADR,R0       ;GET ADDRESS OF TASK HEADER
        BEQ     65$             ;IF EQ TASK TERMINATED
        MOV     (R0),R0         ;GET TASK STACK POINTER
        ADD     #8.,R0          ;POINT TO FIRST STACK WORD
        MOV     R0,R1           ;COPY ADDRESS
        ADD     BTRMV,R1        ;POINT TO NEW TOP OF USER STACK
        MOV     -(R0),-(R1)     ;MOVE RETURN PS WORD
        MOV     -(R0),-(R1)     ;MOVE RETURN PC WORD
        MOV     -(R0),-(R1)     ;MOVE SAVED R5
        MOV     -(R0),-(R1)     ;MOVE SAVED R4
        MOV     R1,@$HEADR      ;SET NEW STACK POINTER

        .ENDC


        .IF NDF A$$PRI

$DRATP::                        ;NOP ALTER PRIORITY

        .ENDC


65$:    RETURN                  ;EXIT FROM TRAP

;
; SYSTEM CRASH - EMT/TRAP EXECUTED AT STACK DEPTH OTHER THAN +1
;

70$:    CRASH

;
; EMT/TRAP SST ROUTINE TRANSFER
;

80$:                            ;REF LABEL


        .IF DF  M$$MGE

        MOV     $HEADR,R5       ;POINT TO CURRENT TASK HEADER
        MOV     H.WND(R5),R5    ;POINT TO NUMBER OF WINDOW BLOCKS
        TST     W.BLVR+2(R5)    ;CURRENT TASK MAPPED TO EXEC?
        BEQ     85$             ;IF EQ NO
        CMP     (SP),#104376    ;IS THIS A CALL TO $SWSTK?

        .IFF

        CMP     (R5),#104376    ;IS THIS A CALL TO $SWSTK?

        .ENDC


        BNE     85$             ;IF NE NO
        JMP     $SWSTK          ;PROCESS CALL TO $SWSTK
85$:    JMP     $EMSST          ;PROCESS SST FAULT

;
; ILLEGAL DIRECTIVE
;

90$:    DRSTS   D.RS99          ;SET DIRECTIVE STATUS

;
; REQUIRED EVENT FLAG NUMBER NOT SPECIFIED
;

100$:   DRSTS   D.RS97          ;SET DIRECTIVE STATUS

;
; SPECIFIED TASK NAME NOT FOUND IN TASK DIRECTORY
;

110$:   DRSTS   D.RS2           ;SET DIRECTIVE STATUS

;
; PRIVILEGE VIOLATION
;


        .IF DF  M$$MUP

120$:   DRSTS   D.RS16          ;SET DIRECTIVE STATUS

        .ENDC


        .DSABL  LSB

        .END
        .TITLE  DREIF
        .IDENT  /15.1/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 15.1
;
; D. N. CUTLER 13-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 7-DEC-76
;
;               TM069 -- ADDITION OF CHECK FOR OUTSTANDING TERMINAL I/O.
;
;       T. J. MILLER 25-JAN-77
;
;               TM074 -- CORRECT BUG IN I/O RUNDOWN.
;
;       T. J. MILLER 21-APR-77
;
;               TM077 -- DEALLOCATE RECEIVE BY REFERENCE AST BLOCK.
;
;       T. J. MILLER 6-JUN-77
;
;               TM088 -- CLEAN UP CONNECT TO INTERRUPT ITB'S ON TASK
;                       EXIT.
;
;       T. J. MILLER 21-JUL-77
;
;               TM096 -- FIX BUG RELATING TO THE RELEASE OF MEMORY IN
;                       PLAS SYSTEMS.
;
;       T. J. MILLER 5-OCT-77
;
;               TM113 -- DEALLOCATE TASK PCB ON LOAD FAILURE IN PLAS
;                       SYSTEM.
;
;       CHUCK SPITZ 20-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES, AND HANDLE ALL
;                       ASTS FROM TCB
;
;       CHUCK SPITZ 24-OCT-78
;               CS018 -- ADD PARENT OFFSPRING TASKING
;
;       CHUCK SPITZ 7-DEC-78
;               CS020 -- ADD GROUP GLOBAL EF'S
;
;       CHUCK   SPITZ 7-DEC-78
;               CS021 -- ADD DISABLE CONTEXT SWITCHING
;
;       CHUCK SPITZ 28-MAR-79
;               CS042 -- CORRECT CONDITIONAL, PARENT-OFFSPRING RUNDOWN,
;                       AND UNSOLICITED CHAR. AST RUNDOWN
;
;       M. S. HARVEY    9-MAY-79
;               MSH021 -- DON'T RETURN EXIT STATUS FROM ACPS
;
; EXIT DIRECTIVES
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$,CLKDF$,HDRDF$,PCBDF$,PKTDF$,TCBDF$               ; CS042
        CLKDF$                  ;DEFINE CLOCK BLOCK OFFSETS             ; CS042
        ABODF$                  ;DEFINE TASK ABORT CODES                ;**-1
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;
; LOCAL SYMBOL DEFINITION
;

CLRMSK=T2.AST!T2.DST!T2.CKD!T2.HLT!T2.ABO!T2.CAF
CLRMSK=CLRMSK!<<T2.STP!T2.SPN!T2.WFR>*2>!T2.STP!T2.SPN!T2.WFR

;+
; **-$DREIF-EXIT IF
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO TERMINATE THE EXECUTION OF THE
; ISSUING TASK IF, AND ONLY IF, AN INDICATED EVENT FLAG IS CLEAR.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(53.),DPB SIZE(2.).
;       WD. 01 -- EVENT FLAG NUMBER OF EVENT FLAG THAT MUST BE CLEAR.
;
; INPUTS:
;
;       R0=EVENT FLAG MASK WORD.
;       R1=EVENT FLAG MASK ADDRESS.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF 'D.RS22' IS RETURNED IF THE SPECIFIED
;                       EVENT FLAG IS SET.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS97' IF NO OR AN INVALID EVENT
;                       FLAG NUMBER IS SPECIFIED.
;-

$DREIF::BIT     R0,(R1)         ;EVENT FLAG CLEAR?
        BEQ     $DREXT          ;IF EQ YES
        DRSTS   D.RS22          ;SET DIRECTIVE STATUS

;+
; **-$DREXT-EXIT
; **-$CEXIT-CONTINUE TASK EXIT (AFTER SETTING EXIT STATUS)              ; CS018
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO TERMINATE THE EXECUTION OF THE
; ISSUING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(51.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       NOTE: THIS DIRECTIVE IS ALSO CALLED FROM THE DISPATCHER AND
;               THEREFORE ONLY REQUIRES R5 TO BE LOADED ON ENTRANCE.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       NO STATUS IS RETURNED TO THE ISSUING TASK SINCE THIS DIRECTIVE
;       TERMINATES ITS EXECUTION.
;-

$DREXT::                        ;REFERENCE LABEL                        ; CS018
                                                                        ; CS018
        .IF DF  P$$OFF                                                  ; CS018
                                                                        ; CS018
        BIT     #T3.ACP,T.ST3(R5) ;IS TASK AN ACP?                      ;MSH021
        BNE     5$              ;IF NE YES                              ;MSH021
        MOV     #EX$SUC,T.EFLG+2(R5) ;SET SUCCESSFUL EXIT STATUS        ; CS018
5$:                             ;REF LABEL                              ;MSH021
                                                                        ; CS018
        .ENDC   ;P$$OFF                                                 ; CS018
                                                                        ; CS018
        .IF DF G$$EFN                                                   ; CS020
                                                                        ; CS020
$DREX1::BIT     #T2.AST,T.ST2(R5) ;TASK AT AST STATE?                   ; CS020
        BEQ     $CEXIT          ;IF EQ NO                               ; CS020
        BIT     #T2.WFR*2,T.ST2(R5) ;WAS TASK IN WAITFOR                ; CS020
        BEQ     $CEXIT          ;IF EQ NO                               ; CS020
        MOV     R4,R2           ;COPY HEADER ADDRESS                    ; CS020
        CALL    $DEAGF          ;DEACCESS GROUP GLOBAL EVENT FLAGS      ; CS020
                                                                        ; CS020
        .ENDC   ;G$$EFN                                                 ; CS020
                                                                        ; CS020
$CEXIT::CALL    $DRCMT          ;CANCEL MARK TIME REQUESTS              ; CS018
                                                                        ;**-1

        .IF DF  C$$INT

        BIT     #T2.CKD,T.ST2(R5) ;DOES TASK POSSIBLY HAVE ANY ITB'S?
        BEQ     2$              ;IF EQ NO
1$:     MOV     T.CPCB(R5),R1   ;PICK UP NEXT ITB POINTER
        BEQ     2$              ;IF EQ NONE LEFT
        CALL    $DISIN          ;DISCONNECT INTERRUPT VECTOR
        BR      1$              ;
2$:                             ;REF LABEL

        .ENDC


        .IF DF  M$$CRX

        CALL    $RLMCB          ;RELEASE MCR COMMAND BUFFER

        .ENDC


        CMP     R5,$LSTLK       ;TASK OWN MCR DATA BASE LOCK?
        BNE     3$              ;IF NE NO
        CLR     $LSTLK          ;CLEAR OWNER TCB ADDRESS
3$:     BIS     #T2.HLT,T.ST2(R5) ;SET TO HALT TASK

        CLRB    $CXDBL          ;MAKE SURE CONTEXT SWITCHING ENABLED    ; CS021
                                                                        ; CS021
        .IF DF F$$LPP!P$$RFL!R$$SND!P$$SRF&A$$TRP                       ; CS017
                                                                        ; CS017
        MOV     T.SAST(R5),R0   ;GET ADDRESS OF SPEC AST BLOCK          ; CS017
        BEQ     35$             ;IF EQ LIST IS EMPTY                    ; CS017
        MOV     R0,@T.ASTL+2(R5) ;LINK BLOCK TO NORMAL AST LIST         ; CS017
32$:    MOV     R0,R1           ;SAVE ADDRESS OF SPEC AST BLOCK         ; CS017
        MOV     (R0),R0         ;GET NEXT BLOCK                         ; CS017
        BNE     32$             ;IF NE MORE BLOCKS IN LIST              ; CS017
        MOV     R1,T.ASTL+2(R5) ;FIX UP LAST POINTER IN LISTHEAD        ; CS017
        CLR     T.SAST(R5)      ;NO MORE SPEC ASTS                      ; CS017
35$:                            ;REF LABEL                              ; CS017
                                                                        ; CS017
        .ENDC   ;F$$LPP!P$$FRL!R$$SND!P$$SRF&A$$TRP                     ; CS017
                                                                        ; CS017
        .IF DF  A$$TRP!T$$BUF!P$$OFF                                    ; CS042
                                                                        ;**-34
        JSR     R5,MTQUE        ;EMPTY AST QUEUE
        .WORD   T.ASTL          ;OFFSET TO AST QUEUE LISTHEAD
        .WORD   $DEACB          ;ADDRESS OF DEALLOCATION ROUTINE

        .ENDC


        .IF DF  R$$SND

        BIT     #T3.NSD!T3.ACP,T.ST3(R5) ;FLUSH RECEIVE QUEUE?
        BNE     4$              ;IF NE NO
        JSR     R5,MTQUE        ;EMPTY RECEIVE QUEUE
        .WORD   T.RCVL          ;OFFSET TO RECEIVE QUEUE LISTHEAD
        .WORD   $DEPKT          ;ADDRESS OF DEALLOCATION ROUTINE
4$:                             ;REF LABEL

        .ENDC


        .IF DF  P$$LAS&P$$SRF

        JSR     R5,MTQUE        ;EMPTY RECEIVE BY REFERENCE QUEUE
        .WORD   T.RRFL          ;OFFSET TO RECEIVE BY REF LISTHEAD
        .WORD   $DEPKT          ;ADDRESS OF DEALLOCATION ROUTINE

        .ENDC


        .IF DF  I$$RAR!I$$RDN!M$$MGE

5$:     MOV     #SCNLN,-(SP)    ;SET ADDRESS OF LUT SCANNING CO-ROUTINE
        TSTB    T.IOC(R5)       ;ANY I/O OUTSTANDING?


        .IF DF  T$$BUF

        BNE     6$              ;IF NE YES
        BIT     #T2.TIO,T.ST2(R5) ;OUTSTANDING TERMINAL I/O?

        .ENDC


        BEQ     30$             ;IF EQ NO
6$:     BIT     #T2.ABO,T.ST2(R5) ;TASK ALREADY MARKED FOR ABORT?
        BNE     10$             ;IF NE YES
        MOV     #S.IOMG,R0      ;SET REASON FOR ABORT
        CALL    $ABCTK          ;ABORT CURRENT TASK
10$:    MOV     (SP),-(SP)      ;DUPLICATE ADDRESS OF LUT SCANNING CO-ROUTINE
20$:    CALL    @(SP)+          ;GET NEXT ASSIGNED LUN
        BCS     30$             ;IF CS END OF LOGICAL UNIT TABLE
        CALL    $IOKIL          ;KILL I/O ON UNIT FOR CURRENT TASK
        BR      20$             ;GO AGAIN
30$:    CALL    @(SP)+          ;GET NEXT ASSIGNED LUN
        BCS     100$            ;IF CS END OF LOGICAL UNIT TABLE
        CMP     $TKTCB,U.ATT(R5) ;UNIT ATTACHED TO CURRENT TASK?
        BNE     40$             ;IF NE NO
        MOV     #IO.DET,R4      ;SET DETACH I/O FUNCTION
        BR      50$             ;
40$:    MOV     (R1),R2         ;FILE OPEN ON UNIT?
        BEQ     30$             ;IF EQ NO
        ASR     R2              ;ACCESS OR DEACCESS PENDING?
        BCS     30$             ;IF CS YES
        MOV     #IO.CLN,R4      ;SET CLOSE LUN I/O FUNCTION
50$:    CMP     (SP)+,(SP)+     ;CLEAN STACK
        MOV     R1,-(SP)        ;SAVE ADDRESS OF SECOND LUN WORD
        MOV     #I.LGTH,R1      ;SET LENGTH OF BLOCK NEEDED
        CALL    $ALOCB          ;ALLOCATE I/O PACKET
        MOV     (SP)+,R3        ;RETRIEVE ADDRESS OF SECOND LUN WORD
        BCS     90$             ;IF CS NO CORE AVAILABLE
        MOV     R0,R1           ;COPY ADDRESS OF I/O PACKET
        TST     (R0)+           ;POINT TO SECOND WORD
        MOV     $TKTCB,R2       ;GET ADDRESS OF TCB OF CURRENT TASK
        MOVB    T.IOC(R2),-(SP) ;SAVE CURRENT I/O COUNT
        INCB    T.IOC(R2)       ;INCREMENT OUTSTANDING I/O COUNT
        MOVB    T.PRI(R2),(R0)+ ;SET REQUEST PRIORITY
        CLRB    (R0)+           ;CLEAR EVENT FLAG NUMBER
        MOV     R2,(R0)+        ;INSERT CURRENT TASK TCB ADDRESS
        MOV     R3,(R0)+        ;INSERT ADDRESS OF SECOND LUN WORD
        MOV     R5,(R0)+        ;INSERT UCB ADDRESS
        MOV     R4,(R0)+        ;INSERT I/O FUNCTION CODE
        CMP     #IO.CLN,R4      ;CLOSE LUN I/O FUNCTION?
        BNE     60$             ;IF NE NO
        INC     @U.VCB(R5)      ;INCREMENT VOLUME TRANSACTION COUNT
        INC     (R3)            ;INTERLOCK LUN USAGE
60$:    MOV     #12.,R2         ;SET LOOP COUNT
70$:    CLR     (R0)+           ;CLEAR REMAINDER OF I/O PACKET
        DEC     R2              ;ANY MORE TO CLEAR?
        BGT     70$             ;IF GT YES
        CALL    $DRQRQ          ;QUEUE I/O REQUEST
        MOV     $TKTCB,R5       ;GET ADDRESS OF TCB OF CURRENT TASK
        CMPB    T.IOC(R5),(SP)+ ;REQUEST ALREADY FINISHED?
        BEQ     5$              ;IF EQ YES
80$:    BIS     #TS.RDN,T.STAT(R5) ;SET I/O RUNDOWN IN PROGRESS
90$:    CALLR   $TKWSE          ;WAITFOR SIGNIFICANT EVENT
100$:   TSTB    T.IOC(R5)       ;ANY I/O STILL OUTSTANDING?
        BNE     80$             ;IF NE YES


        .IF DF  T$$BUF

        BIT     #T2.TIO,T.ST2(R5) ;OUTSTANDING TERMINAL I/O?
        BNE     80$             ;IF NE YES

        .ENDC


        .ENDC

        .IF DF  P$$OFF                                                  ; CS018
                                                                        ; CS018
        MOV     $TSKHD,R0       ;POINT TO FIRST INSTALLED TASK TCB      ; CS018
92$:    TST     T.RDCT(R5)      ;ANY RUNDOWN OPERATIONS REMAINING?      ; CS018
        BEQ     98$             ;IF EQ NO                               ; CS018
        MOV     T.TCBL(R0),-(SP) ;SAVE POINTER TO NEXT INSTALLED TASK   ; CS018
        BEQ     96$             ;IF EQ CURRENT TASK IS NULL TASK        ; CS018
        ADD     #T.OCBH,R0      ;POINT TO OCB QUEUE OF TASK             ; CS018
94$:    MOV     (R0),R0         ;POINT TO NEXT ENTRY IN LIST            ; CS018
        BEQ     96$             ;IF EQ THERE IS NONE                    ; CS018
        CMP     O.PTCB(R0),R5   ;IS EXITING TASK THE PARENT?            ; CS018
        BNE     94$             ;IF NE NO                               ; CS018
        DEC     T.RDCT(R5)      ;DECREMENT RUNDOWN COUNT                ; CS018
        CLR     O.PTCB(R0)      ;INDICATE PARENT TASK HAS EXITTED       ; CS018
        BR      94$             ;TRY TO REMOVE ANY MORE                 ; CS018
96$:    MOV     (SP)+,R0        ;RESTORE TCB ADDRESS                    ; CS018
        BNE     92$             ;IF NE NO                               ; CS018
98$:                            ;REF LABEL                              ; CS018
                                                                        ; CS018
        .ENDC   ;P$$OFF                                                 ; CS018

        ADD     #T.ST2,R5       ;POINT TO SECOND TASK STATUS WORD


        .IF DF  T$$KMG

        BIT     #T2.ABO,(R5)    ;TASK MARKED FOR ABORT?
        BEQ     110$            ;IF EQ NO
        MOV     $TKNPT,R0       ;GET TERMINATION NOTIFICATION TCB ADDRESS
        BEQ     110$            ;IF EQ NOT IN SYSTEM
        CMP     $TKTCB,R0       ;TERMINATION NOTIFICATION TASK BEING TERMINATED?
        BEQ     103$            ;IF EQ YES
        BIS     #TS.MSG,-(R5)   ;SET ABORT MESSAGE IN PROGRESS
        CALL    $EXRQN          ;REQUEST TERMINATION NOTIFICATION TASK
        CALLR   $TKWSE          ;WAITFOR SIGNIFICANT EVENT
103$:   MOV     $ACTHD,R0       ;GET ADDRESS OF FIRST TCB
107$:   BIC     #TS.MSG,T.STAT(R0) ;CLEAR WAITING FOR MESSAGE
        BIC     #T2.ABO,T.ST2(R0) ;CLEAR MARKED FOR ABORT
        MOV     T.ACTL(R0),R0   ;GET ADDRESS OF NEXT TCB
        TST     T.ACTL(R0)      ;NULL TASK?
        BNE     107$            ;IF NE MORE TO GO
110$:                           ;REF LABEL

        .ENDC


        .IF DF  I$$RAR

        BIT     #T3.REM,2(R5)   ;REMOVE TASK AT EXIT?
        BEQ     120$            ;IF EQ NO
        MOV     #M$$CRB,R1      ;SET LENGTH OF BLOCK NEEDED
        CALL    $ALOCB          ;ALLOCATE CORE BLOCK
        BCS     90$             ;IF CS WAITFOR SIGNIFICANT EVENT
        MOV     R0,-(SP)        ;SAVE ADDRESS OF CORE BLOCK
        TST     (R0)+           ;POINT TO SECOND WORD IN BLOCK
        MOV     T.UCB-T.ST2(R5),(R0)+ ;INSERT TI UCB ADDRESS
        MOV     (PC)+,(R0)+     ;INSERT REMOVE COMMAND
        .ASCII  /RE/            ;
        MOV     (PC)+,(R0)+     ;
        .ASCII  /M /            ;
        MOV     T.NAM-T.ST2(R5),R1 ;GET FIRST HALF OF TASK NAME
        CALL    $C5TA           ;CONVERT TO ASCII
        MOV     T.NAM+2-T.ST2(R5),R1 ;GET SECOND HALF OF TASK NAME
        CALL    $C5TA           ;CONVERT TO ASCII
        MOVB    #33,(R0)        ;INSERT ALTMODE AS TERMINAL BYTE
        MOV     (SP)+,R1        ;RETRIEVE ADDRESS OF CORE BLOCK
        CALL    $QMCRL          ;QUEUE MCR COMMAND LINE

        .ENDC


120$:   BIS     #TS.EXE,-(R5)   ;DEACTIVATE TASK
        BIC     #TS.CKR!TS.MSG,(R5)+ ;CLEAR STATUS BITS
        BIC     #CLRMSK,(R5)    ;


        .IF DF  A$$PRI

        MOVB    T.DPRI-T.ST2(R5),T.PRI-T.ST2(R5) ;RESTORE TASK PRIORITY

        .ENDC


        .IF DF  D$$ISK

        BIT     #T2.FXD,(R5)+   ;TASK FIXED IN MEMORY?
        BNE     130$            ;IF NE YES
        BIS     #TS.OUT,-4(R5)  ;SET TASK OUT OF MEMORY


        .IF DF  P$$LAS

        MOV     T.PCB-T.ST3(R5),R0 ;POINT TO TASK PCB
        MOV     R0,-(SP)        ;SAVE CURRENT PCB POINTER
        BIT     #PS.SYS,P.STAT(R0) ;IS IT A SYSTEM CONTROLLED PARTITION?
        BEQ     124$            ;IF EQ NO
        MOV     P.MAIN(R0),(SP) ;POINT BACK TO MAIN PCB
124$:   MOV     R5,-(SP)        ;SAVE ADDRESS OF THIRD STATUS WORD
        TST     T.ATT-T.ST3(R5) ;ATTACH QUEUE EMPTY (IF EQ LOAD FAILURE)
        BNE     125$            ;IF NE NO
        MOV     R5,R0           ;COPY TCB POINTER
        SUB     #T.ST3,R0       ;POINT TO START OF TCB
        CALL    $RLPAR          ;RELEASE TASK PARTITION
        MOV     T.PCB-T.ST3(R5),R0 ;PICK UP TASK PCB ADDRESS
        BIT     #PS.SYS,P.STAT(R0) ;SYSTEM CONTROLLED PARTITION?
        BEQ     125$            ;IF EQ NO
        MOV     #P.LGTH,R1      ;SET SIZE TO RELEASE
        CALL    $DEACB          ;DEALLOCATE TASK PCB
125$:   MOV     (SP),R5         ;PICK UP ADDRESS OF THIRD STATUS WORD
        MOV     T.ATT-T.ST3(R5),R5 ;POINT TO NEXT ATTACHMENT DESCRIPTOR
        BEQ     126$            ;IF EQ THERE IS NONE
        SUB     #A.TCBL,R5      ;POINT TO START OF ATTACHMENT DESCRIPTOR
        CALL    $DETRG          ;DETACH THE REGION
        BR      125$            ;
126$:   MOV     (SP)+,R5        ;RESTORE ADDRESS OF THIRD STATUS WORD
        MOV     (SP)+,T.PCB-T.ST3(R5) ;RESET TASK PCB ADDRESS

        .ENDC


        .IF DF  M$$MGE

        MOV     R4,R0           ;SET ADDRESS OF TASK HEADER
        MOV     H.HDLN(R0),R1   ;GET LENGTH OF HEADER IN BYTES
        CALL    $DEACB          ;DEALLOCATE HEADER

        .ENDC


        MOV     $TKTCB,R0       ;SET ADDRESS OF TASK TCB


        .IF NDF P$$LAS


        .IF DF  D$$YNM&M$$MGE

        MOV     T.PCB(R0),R4    ;SAVE ADDRESS OF TASK PCB

        .IFTF
        CALL    $RLPAR          ;RELEASE TASK PARTITION

        .IFT

        BIT     #PS.SYS,P.STAT(R4) ;SYSTEM CONTROLLED PARTITION?
        BEQ     130$            ;IF EQ NO
        MOV     $TKTCB,R0       ;RETRIEVE ADDRESS OF TCB
        MOV     P.MAIN(R4),T.PCB(R0) ;RESET TASK PCB POINTER
        MOV     R4,R0           ;SET ADDRESS OF BLOCK TO RELEASE
        MOV     #P.LGTH,R1      ;SET LENGTH OF BLOCK TO RELEASE
        CALL    $DEACB          ;DEALLOCATE PARTITION CONTROL BLOCK

        .ENDC


        .ENDC


130$:                           ;REFERENCE LABEL

        .ENDC

                                                                        ; CS018
        .IF DF P$$OFF                                                   ; CS018
                                                                        ; CS018
132$:   MOV     R5,R0           ;COPY POINTER TO THIRD STATUS WORD      ; CS018
                                                                        ; CS018
        .IF DF D$$ISK                                                   ; CS018
                                                                        ; CS018
        ADD     #T.OCBH-T.ST3,R0 ;POINT TO OCB QUEUE LISTHEAD           ; CS018
                                                                        ; CS018
        .IFF    ;D$$ISK                                                 ; CS018
                                                                        ; CS018
        ADD     #T.OCBH-T.ST2,R0 ;POINT TO OCB QUEUE LISTHEAD           ; CS018
                                                                        ; CS018
        .IFTF   ;D$$ISK                                                 ; CS018
                                                                        ; CS018
        CALL    $QRMVF          ;REMOVE NEXT OCB                        ; CS018
        BCS     134$            ;IF CS, THERE IS NONE                   ; CS018
                                                                        ; CS018
        .IFT    ;D$$ISK                                                 ; CS018
                                                                        ; CS018
        MOV     T.EFLG+2-T.ST3(R5),R0 ;PICK UP SAVED EXIT STATUS        ; CS018
                                                                        ; CS018
        .IFF    ;D$$ISK                                                 ; CS018
                                                                        ; CS018
        MOV     T.EFLG+2-T.ST2(R5),R0 ;PICK UP SAVED EXIT STATUS        ; CS018
                                                                        ; CS018
        .ENDC   ;D$$ISK                                                 ; CS018
                                                                        ; CS018
        CALL    $QUEXT          ;QUEUE EXIT STATUS TO PARENT            ; CS018
        BR      132$            ;GO AGAIN                               ; CS018
134$:                           ;REF LABEL                              ; CS018
                                                                        ; CS018
        .ENDC   ;P$$OFF                                                 ; CS018
                                                                        ; CS018

        CLR     $HEADR          ;DO NOT SAVE CONTEXT OF CURRENT TASK
        MOV     $TKTCB,R0       ;GET ADDRESS OF CURRENT TCB
        CALL    $ACTRM          ;REMOVE TCB FROM THE ATL QUEUE


        .IF DF  M$$CRX

        BIT     #T3.MCR,(R5)    ;MCR EXTERNAL FUNCTION TASK?
        BEQ     140$            ;IF EQ NO
        BIC     #T3.MCR,(R5)    ;CLEAR MCR FUNCTION FLAG
        MOV     #4,R1           ;SET SIZE OF BLOCK REQUIRED
        CALL    $ALOCB          ;ALLOCATE CORE BLOCK
        BCS     140$            ;IF CS ALLOCATION FAILURE
        MOV     R0,R1           ;COPY ADDRESS OF BLOCK
        TST     (R0)+           ;POINT TO SECOND WORD OF BLOCK
        MOV     T.UCB-T.ST3(R5),(R0) ;INSERT TI UCB ADDRESS
        INC     (R0)            ;SET FLAG TO SIGNIFY MCR PROMPT
        CALL    $QMCRL          ;QUEUE MCR COMMAND LINE

        .ENDC


140$:   CALLR   $DRDSE          ;DECLARE SIGNIFICANT EVENT

;
; SUBROUTINE TO EMPTY QUEUE
;


        .IF DF  A$$TRP!R$$SND!T$$BUF!P$$OFF!P$$SRF                      ; CS042
                                                                        ;**-1
MTQUE:  MOV     (R5)+,R4        ;GET OFFSET TO QUEUE LISTHEAD
        ADD     (SP),R4         ;CALCULATE ADDRESS OF QUEUE LISTHEAD
10$:    TST     (R5)+           ;ADVANCE TO RETURN ADDRESS
13$:    MOV     R4,R0           ;SET ADDRESS OF LISTHEAD
        CALL    $QRMVF          ;REMOVE AN ENTRY FROM QUEUE
        BCS     40$             ;IF CS NO ENTRIES LEFT
        MOV     R1,R0           ;SET ADDRESS OF BLOCK TO DEALLOCATE
                                                                        ; CS042
        .IF DF C$$CKP&T$$BUF!A$$TRP!P$$OFF                              ; CS042
                                                                        ; CS042
        CMP     #T.ASTL,-4(R5)  ;PROCESSING AST QUEUE?                  ; CS042
        BNE     20$             ;IF NE, NO, JUST DEALLOCATE PACKET      ; CS042
        MOVB    2(R0),R1        ;SET LENGTH OF BLOCK (FOR AST'S ONLY)
        BGT     20$             ;IF GT LENGTH SPECIFIED (AST'S ONLY)
        BMI     30$             ;IF MI, ITS BUFFERED I/O OR AN OCB      ; CS042
                                                                        ; CS042
        .IF DF A$$TRP                                                   ; CS042
                                                                        ; CS042
        TST     2(R0)           ;IS IT UNSOL CHAR AST?                  ; CS042
        BNE     18$             ;IF NE, NO, ITS A SPECIFIED AST         ; CS042
        MOV     R4,-(SP)        ;SAVE R4                                ; CS042
        MOV     R5,-(SP)        ;SAVE R5                                ; CS042
                                                                        ; CS042
        .IF DF M$$MGE                                                   ; CS042
                                                                        ; CS042
        CMP     -(R0),-(R0)     ;POINT TO KISAR5 VALUE OF DEALL SUBR    ; CS042
        MOV     (R0)+,KISAR5    ;MAP THE SUBROUTINE                     ; CS042
        CALL    @(R0)+          ;DEALLOCATE THE BLOCK                   ; CS042
                                                                        ; CS042
        .IFF    ;M$$MGE                                                 ; CS042
                                                                        ; CS042
        CALL    @-2(R0)         ;CALL THE DEALLOCATION ROUTINE          ; CS042
                                                                        ; CS042
        .ENDC   ;M$$MGE                                                 ; CS042
                                                                        ; CS042
        MOV     (SP)+,R5        ;RESTORE REGS                           ; CS042
        MOV     (SP)+,R4        ;                                       ; CS042
        BR      13$             ;GO AGAIN                               ; CS042
18$:    MOV     #C.LGTH,R1      ;SET SIZE OF SPECIFIED AST BLOCK        ; CS042
                                                                        ; CS042
        .ENDC   ;A$$TRP                                                 ; CS042
                                                                        ; CS042
        .ENDC   ;C$$CKP&T$$BUF!A$$TRP!P$$OFF                            ; CS042
                                                                        ; CS042
20$:    CALL    @-(R5)          ;DEALLOCATE CORE BLOCK                  ;**-11
        BR      10$             ;GO AGAIN
30$:                            ;REF LABEL                              ; CS042
                                                                        ; CS042
        .IF DF P$$OFF                                                   ; CS042
                                                                        ; CS042
        .IF DF C$$CKP&T$$BUF                                            ; CS042
                                                                        ; CS042
        ASLB    R1              ;BUFFERED I/O?                          ; CS042
        BPL     35$             ;IF PL, YES                             ; CS042
                                                                        ; CS042
        .ENDC   ;C$$CKP&T$$BUF                                          ; CS042
                                                                        ; CS042
        MOV     #O.LGTH,R1      ;PICK UP LENGTH OF OCB                  ; CS042
        BR      20$             ;DEALLOCATE IT                          ; CS042
                                                                        ; CS042
        .ENDC   ;P$$OFF                                                 ; CS042
                                                                        ; CS042
        .IF DF C$$CKP&T$$BUF                                            ; CS042
                                                                        ; CS042
35$:    CALL    $FINBF          ;FINISH BUFFERED I/O                    ; CS042
        BR      13$             ;                                       ;**-4

        .ENDC


40$:    RTS     R5              ;

        .ENDC


;
; CO-ROUTINE TO SCAN LOGICAL UNIT TABLE
;


        .IF DF  I$$RAR!I$$RDN!M$$MGE

SCNLN:  MOV     (SP),R3         ;SAVE RETURN ADDRESS
        CLR     (SP)            ;START AT LUN ZERO
10$:    MOV     $TKTCB,R5       ;GET ADDRESS OF CURRENT TASK TCB
        MOV     $HEADR,R4       ;GET ADDRESS OF HEADER OF CURRENT TASK
20$:    MOV     (SP),R1         ;GET NEXT LUN NUMBER
        INC     (SP)            ;INCREMENT LUN NUMBER
        CMP     H.NLUN(R4),(SP) ;END OF LUT?
        BLO     30$             ;IF LO YES
        CALL    $MPLNE          ;MAP LUN NUMBER TO UCB ADDRESS
        BCS     20$             ;IF CS NO DEVICE ASSIGNED TO LUN
        MOV     R0,R5           ;COPY UCB ADDRESS
        CALL    (R3)            ;CALL THE CALLER BACK
        MOV     (SP)+,R3        ;RETRIEVE RETURN ADDRESS
        BR      10$             ;GO AGAIN
30$:    MOV     R3,(SP)         ;SET RETURN ADDRESS
        RETURN                  ;

        .ENDC


        .END
        .TITLE  DREXP
        .IDENT  /02/
 
;
; COPYRIGHT (C) 1976, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 02
;
; T. J. MILLER 8-JUL-76
;
; MODIFIED BY:
;
;       T. J. MILLER 7-DEC-76
;
;               TM069 -- ADD CHECK FOR OUTSTANDING TERMINAL I/O.
;
;       T. J. MILLER 10-JAN-77
;
;               TM072 -- DISALLOW DECREASE IN SIZE FOR TASK'S WITH
;                       RESIDENT OVERLAYS.
;
;       T. J. MILLER 2-NOV-77
;
;               TM115 -- DISALLOW DECREASE IN SIZE BELOW OTHER
;                       WINDOWS MAPPED IN TASK PARTITION (REMOVING
;                       TM072 CHECK).
;
;       CHUCK SPITZ 5-SEP-78
;               CS017 -- REPLACE T2.BFX WITH T2.FXD&TS.OUT
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,HDRDF$,PCBDF$,TCBDF$
        HWDDF$                  ;DEFINE HARDWARE OFFSETS
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$DREXP-EXTEND PARTITION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO EXTEND THE PARTITION OF THE
; ISSUING TASK BY A POSITIVE OR NEGATIVE INCREMENT.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(89.),DPB SIZE(3.).
;       WD. 01 -- EXTEND INCREMENT.
;       WD. 02 -- RESERVED.
;
; INPUTS:
;
;       R2=ADDRESS OF THE SECOND TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE EXTEND INCREMENT IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF '+1' IS RETURNED.
;
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IF TASK NOT IN SYSTEM CON-
;                       TROLLED PARTITION, TASK IS NOT CHECKPOINTABLE
;                       AND SPECIFIED POSITIVE INCREMENT, OR TASK HAS
;                       PREALLOCATED CHECKPOINT SPACE AND IS EXTENDING
;                       GREATER THAN INSTALLED SIZE.
;               DIRECTIVE STATUS OF 'D.RS88' IF SPECIFIED INCREMENT IS
;                       INVALID.
;-


        .IF DF  D$$YNM&E$$XPR&M$$MGE

$DREXP::TSTB    T.IOC(R5)       ;TASK HAVE OUTSTANDING I/O?
        BNE     15$             ;IF NE YES


        .IF DF  A$$TRP&C$$CKP&T$$BUF

        BIT     #T2.TIO,(R2)    ;TASK HAVE OUTSTANDING TERMINAL I/O?
        BNE     15$             ;IF NE YES

        .ENDC


        MOV     T.PCB(R5),R0    ;POINT TO TASK PCB
        BIT     #PS.SYS,P.STAT(R0) ;IS IT A SYSTEM CONTROLLED PARTITION?
        BEQ     67$             ;IF EQ NO
        MOV     T.MXSZ(R5),R1   ;ASSUME RETURNING TO INSTALLED SIZE
        MOV     (R3),R3         ;PICK UP SPECIFIED INCREMENT
        BEQ     10$             ;IF EQ DEFAULT TO INSTALLED SIZE
        ADD     P.SWSZ(R0),R3   ;CALCULATE NEW SIZE
        MOV     R3,R1           ;COPY NEW SIZE
10$:    CMP     R1,P.SWSZ(R0)   ;TASK INCREASING SIZE?
        BLOS    30$             ;IF LOS NO
        CMP     R1,$MXEXT       ;INCREASING PAST CURRENT MAXIMUM?
        BHI     45$             ;IF HI YES
        BIT     #T2.CHK!T2.CKD!T2.FXD,(R2) ;TASK CHECKPOINTABLE?        ; CS017
15$:    BNE     67$             ;IF NE NO                               ;**-1
20$:                            ;REF LABEL


        .IF DF  D$$YNC

        BIT     #T3.CAL,2(R2)   ;TASK HAVE CHECKPOINT SPACE ALLOCATED?
        BEQ     30$             ;IF EQ NO

        .ENDC


        CMP     R1,T.MXSZ(R5)   ;EXTENDING TO LARGER THAN INSTALLED SIZE?
        BHI     67$             ;IF HI YES
30$:    MOV     R1,-(SP)        ;COPY NEW SIZE
        SWAB    (SP)            ;CONVERT SIZE TO BYTES
        RORB    (SP)            ;
        ROR     (SP)            ;
        ROR     (SP)            ;


        .IF DF  P$$LAS

        CMP     R1,#200         ;NEW SIZE GREATER THAN 4K?
        BHI     35$             ;IF HI YES

        .IFTF

        CMP     (SP),H.HDLN(R4) ;NEW TASK SIZE SMALLER THAN HEADER?
        BLO     90$             ;IF LO YES

        .IFT

35$:    BIT     #T3.ROV,2(R2)   ;TASK HAVE RESIDENT OVERLAYS?
        BNE     50$             ;IF NE YES, IGNORE VIRTUAL ADDRESS CHKS

        .ENDC


        MOV     H.WND(R4),R4    ;POINT TO NUMBER OF WINDOW BLOCKS
        MOV     (R4)+,R2        ;PICK UP NUMBER OF WINDOW BLOCKS
        TST     (R4)+           ;POINT TO TASK LOW VIRTUAL ADDRESS
        MOV     (R4),R3         ;PICK UP TASK LOW VIRTUAL ADDRESS
        ASL     R3              ;CONVERT TO 32W BLOCKS
        ROL     R3              ;
        ROLB    R3              ;
        SWAB    R3              ;
        ADD     R1,R3           ;CALC HIGH VIRTUAL ADDRESS IN 32W BLOCKS
        CMP     R3,#2000        ;LEGAL SIZE?
        BHIS    90$             ;IF HIS NO
        ADD     (R4),(SP)       ;CALCULATE NEW TOP VIRTUAL ADDRESS
40$:    DEC     R2              ;MORE WINDOW BLOCKS TO GO?
        BLE     50$             ;IF LE NO
        ADD     #W.BLGH,R4      ;POINT TO LOW VIRTUAL ADDRESS OF NEXT
        TST     W.BSIZ-W.BLVR(R4) ;ESTABLISHED WINDOW?
        BEQ     40$             ;IF EQ NO


        .IF DF  P$$LAS

        CMP     -2(R4),R0       ;WINDOW MAPPED TO TASK REGION? (W.BPCB)
        BNE     44$             ;IF NE NO
        MOV     2(R4),R3        ;PICK UP HIGH VIRTUAL ADDRESS (W.BHVR)
        SUB     (R4),R3         ;CALCULATE LENGTH OF MAP - 1 (W.BLVR)
        INC     R3              ;CALCULATE LENGTH OF MAP
        ASL     R3              ;CONVERT TO 32W BLOCKS
        ROL     R3              ;
        ROLB    R3              ;
        SWAB    R3              ;
        ADD     W.BOFF-W.BLVR(R4),R3 ;CALCULATE LAST 32W BLOCK MAPPED
        CMP     R1,R3           ;REDUCING SIZE CONFLICT WITH WINDOW?
        BLO     90$             ;IF LO YES

        .ENDC


44$:    CMP     (SP),(R4)       ;VIRTUAL ADDRESS OVERLAP?
        BLOS    40$             ;IF LOS NO
45$:    BR      90$             ;ILLEGAL SIZE
50$:    TST     (SP)+           ;CLEAN STACK
        MOV     P.MAIN(R0),R2   ;POINT TO MAIN PARTITION PCB
        CMP     R1,P.SIZE(R2)   ;MAIN PARTITION LARGE ENOUGH?
        BHI     90$             ;IF HI NO
        MOV     R1,P.SWSZ(R0)   ;SET SWAP SIZE FOR TASK PARTITION
        CLR     R4              ;INITIALIZE END OF HOLE CALCULATION
        MOV     P.SUB(R0),R3    ;POINT TO NEXT SUBPAR AFTER TASK PAR
        BNE     60$             ;IF NE THERE IS ONE
        MOV     R2,R3           ;ELSE POINT TO MAIN PARTITION
        ADD     P.SIZE(R3),R4   ;CALCULATE END OF HOLE
60$:    ADD     P.REL(R3),R4    ;
        MOV     P.REL(R0),R3    ;CALCULATE END OF DESIRED SPACE
        ADD     R1,R3           ;
        CMP     R3,R4           ;WILL EXTEND WORK IN PLACE?
        BLOS    70$             ;IF LOS YES
        CALL    $SETRT          ;FORCE RESCHEDULING
        MOV     R5,R1           ;COPY TASK TCB ADDRESS


        .IF DF  D$$YNC

        CALL    $CHKPT          ;ATTEMPT TO CHECKPOINT TASK
        BIT     #TS.CKP,T.STAT(R5) ;WAS THE CHECKPOINT INITIATED?
        BEQ     65$             ;IF EQ NO
        RETURN                  ;
65$:    MOV     T.PCB(R5),R4    ;PICK UP TASK PCB ADDRESS
        MOV     P.SIZE(R4),P.SWSZ(R4) ;RESET SWAP SIZE
        DRSTS   D.RS1           ;POOL OR CHECKPOINT FILE ALLOC FAILURE

        .IFF

        CALLR   $CHKPT          ;INITIATE CHECKPOINT OF TASK

        .ENDC


67$:    DRSTS   D.RS8           ;DIRECTIVE INCONSISTENT WITH TASK STATE
70$:    CMP     R1,P.SIZE(R0)   ;DECREASING TASK SIZE?
        BHIS    71$             ;IF HIS NO
        MOV     #$NXTSK,-(SP)   ;INSURE PARTITION WILL BE REALLOCATED
71$:    MOV     R1,P.SIZE(R0)   ;EXTEND TASK IN PLACE


        .IF DF  P$$LAS

        BIT     #T3.ROV,T.ST3(R5) ;TASK HAVE RESIDENT OVERLAYS?
        BNE     80$             ;IF NE YES, DO NOT CHANGE MAPPING

        .ENDC


        MOV     P.HDR(R0),R1    ;POINT TO TASK'S HEADER
        MOV     H.WND(R1),R1    ;POINT TO NUMBER OF WINDOW BLOCKS
        MOVB    W.BFPD+2(R1),R3 ;PICK UP FIRST PDR ADDRESS
74$:    CLR     (R3)+           ;UNMAP NEXT PDR
        DECB    W.BNPD+2(R1)    ;MORE TO GO?
        BNE     74$             ;IF NE YES
        CALL    $MAPTK          ;MAP TASK ADDRESS WINDOW
        MOV     P.REL(R0),R3    ;CALCULATE FIRST APR OFFSET


        .IF DF  P$$LAS

        ADD     W.BOFF-W.BLPD(R1),R3 ;

        .ENDC


        MOV     (R1),R2         ;PICK UP LAST PDR IMAGE
        MOVB    -(R1),R4        ;PICK UP NUMBER OF PDR'S
        MOVB    -(R1),R1        ;PICK UP FIRST PDR ADDRESS
75$:    MOV     R3,UISAR0-UISDR0(R1) ;LOAD NEXT APR
        MOVB    R2,(R1)+        ;SET ACCESS NEXT PDR
        MOVB    #177,(R1)+      ;SET SIZE NEXT PDR
        ADD     #200,R3         ;ADVANCE APR BASE
        DEC     R4              ;MORE TO GO?
        BNE     75$             ;IF NE YES
        MOV     R2,-(R1)        ;SET LAST PDR
80$:    RETURN                  ;
90$:    DRSTS   D.RS84          ;INVALID INCREMENT SPECIFIED

        .ENDC


        .END
        .TITLE  DRGCL
        .IDENT  /03/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; D. N. CUTLER 20-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;
; MODIFIED BY:
;
;+
; **-$DRGCL-GET MCR COMMAND LINE
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO TRANSFER A 1 TO 80. BYTE COMMAND LINE
; TO THE LAST MCR FUNCTION TASK REQUESTED BY THE MCR DISPATCHER.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(127.),DPB SIZE(41.).
;       WD. 01 -- FIRST WORD OF 80. BYTE BUFFER.
;           .
;           .
;           .
;       WD. 50 -- LAST WORD OF 80. BYTE BUFFER.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE 80. BYTE BUFFER IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS EQUAL TO THE LENGTH OF THE COMMAND LINE
;                       IN BYTES IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF THE ISSUING
;                       TASK IS NOT THE LAST TASK THAT WAS REQUESTED
;                       BY THE MCR DISPATCHER.
;-
        
        
        .IF DF  M$$CRX
 
        .ENABL  LSB
$DRGCL::CALL    30$             ;SEARCH FOR TASK COMMAND BUFFER
        BCC     10$             ;IF CC ONE FOUND
        DRSTS   D.RS80          ;SET DIRECTIVE STATUS
10$:    CMP     (R0)+,(R0)+     ;POINT TO COMMAND TEXT
20$:    INC     2(SP)           ;INCREMENT BYTE COUNT
        MOVB    (R0),(R3)       ;INSERT BYTE INTO USER BUFFER
        CMPB    #33,(R0)+       ;ALTMODE TERMINATOR?
        BEQ     25$             ;IF EQ YES
        CMPB    #15,(R3)+       ;CARRIAGE RETURN?
        BNE     20$             ;IF NE NO
25$:    SUB     #2,2(SP)        ;ADJUST TO PROPER BYTE COUNT
 
;+
; **-$RLMCB-RELEASE MCR COMMAND BUFFER
;
; INPUTS:
;
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS:
;
;       IF THE COMMAND LINE CURRENTLY IN THE MCR COMMAND BUFFER IS
;       FOR THE CURRENT TASK, THEN THE BUFFER IS RELEASED AND $MCRTN
;       IS CLEARED.
;-
 
$RLMCB::CALL    30$             ;SEARCH FOR TASK COMMAND BUFFER
        BCS     50$             ;IF CS NONE FOUND
        MOV     (R0),(R1)       ;REMOVE BUFFER FROM LIST
        MOV     #84.,R1         ;SET LENGTH OF BUFFER TO RELEASE
        CALLR   $DEACB          ;DEALLOCATE BUFFER
        
;
; SUBROUTINE TO SEARCH FOR COMMAND BUFFER FOR CURRENT TASK
;
        
30$:    MOV     #$MCRCB,R0      ;POINT TO COMMAND BUFFER LISTHEAD
40$:    MOV     R0,R1           ;SAVE ADDRESS OF PREVIOUS BUFFER
        MOV     (R1),R0         ;GET ADDRESS OF NEXT BUFFER
        SEC                     ;ASSUME END OF LIST
        BEQ     50$             ;IF EQ YES
        CMP     R5,2(R0)        ;TCB ADDRESS MATCH?
        BNE     40$             ;IF NE NO
50$:    RETURN                  ;
        .DSABL  LSB
 
        .ENDC
        
        
        .END
        .TITLE  DRGEF
        .IDENT  /01/
 
;
; COPYRIGHT (C) 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 01
;
; J. E. PROVINO 21-SEP-78
;
; FOR RSX-11M:  CHUCK SPITZ 8-DEC-78
;
; MODIFIED BY:
;
; GROUP GLOBAL EVENT FLAG ROUTINES
;
; MACRO LIBRARY CALLS
;
        .MCALL  PKTDF$,TCBDF$,HDRDF$,PCBDF$
        PKTDF$                  ;DEFINE GROUP GLOBAL OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
 
 
;+
; **-$DRCRE-CREATE GROUP GLOBAL EVENT FLAGS
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CREATE GROUP GLOBAL EVENT 
; FLAGS FOR A SPECIFIED GROUP.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(157.),DPB SIZE(2.).
;       WD. 01 -- GROUP NUMBER
;
; INPUTS:
;
;       R2=ADDRESS OF SECOND STATUS WORD OF CURRENT TASK
;       R3=POINTER TO WD. 1 IN THE DPB
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IF ALLOCATION FAILURE.
;               DIRECTIVE STATUS OF 'D.RS16' IF NON-PRIVILEGED TASK
;                       ATTEMPTS TO CREATE EVENT FLAGS FOR ANOTHER GROUP.
;               DIRECTIVE STATUS OF 'D.RS17' IS RETURNED IF GROUP GLOBAL
;                       EVENT FLAGS ALREADY EXIST.
;               DIRECTIVE STATUS OF 'D.RS91' IS RETURNED IF GROUP IS
;                       INVALID.
;-

        .IF DF G$$EFN
 
        .ENABL  LSB
$DRCRE::MOV     (R3)+,R0        ;GET GROUP NUMBER
        BNE     10$             ;IF NE USE IT IT
        MOVB    H.CUIC+1(R4),R4 ;DEFAULT TO CURRENT GROUP
        BR      25$             ;
10$:    BIT     #T3.PRV,T.ST3(R5) ;TASK PRIVILEGED?
        BNE     20$             ;IF NE YES
        CMPB    R0,H.CUIC+1(R4) ;CREATING FLAGS FOR OWN GROUP?
        BNE     90$             ;IF NE PRIV VIOLATION
20$:    CMP     R0,#377         ;LEGAL?
        BHI     80$             ;IF HI NO
        MOV     R0,R4           ;COPY GROUP NUMBER
25$:    CALL    $SRGEF          ;SEARCH FOR GROUP GLOBAL EVENT FLAGS
        BCC     40$             ;IF CC FOUND
        MOV     R0,-(SP)        ;SAVE R0
        MOV     #10.,R1         ;SET UP TO ALLOCATE 10. BYTES
        CALL    $ALOCB          ;ALLOCATE A BLOCK FOR GROUP GLOBAL FLAGS
        BCS     70$             ;IF CS ALLOCATION FAILURE
        MOV     R0,R1           ;COPY ADDRESS OF ALLOCATED BLOCK
        MOV     (SP)+,R0        ;RESTORE R0
        MOV     (R0),(R1)       ;LINK NEW BLOCK IN THE LIST
        MOV     R1,(R0)         ;
        MOVB    R4,G.GRP(R1)    ;SAVE GROUP NUMBER IN THE BLOCK
        CLRB    G.STAT(R1)      ;CLEAR STATUS BYTE
        CLR     G.CNT(R1)       ;INITIALIZE ACCESS COUNT
        CLR     G.EFLG(R1)      ;CLEAR FIRST EVENT FLAG WORD
        CLR     G.EFLG+2(R1)    ;CLEAR SECOND EVENT FLAG WORD
30$:    RETURN                  ;
40$:    BICB    #GS.DEL,G.STAT(R1) ;CLEAR MARKED FOR DELETE
        BR      110$            ;INDICATE FLAGS ALREADY EXIST
 
;+
; **-DRELE-ELIMINATE GROUP GLOBAL EVENT FLAGS
;
; THIS DIRECTIVE ELIMINATES GROUP GLOBAL EVENT FLAGS FOR A SPECIFIED GROUP.
;
; DPB FORMAT:
;
;       WD. 0 -- DIC. (159.),DBP SIZE(2.)
;       WD. 1 -- GROUP NUMBER
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK
;       R3=ADDRESS OF THE DBP + 2
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED
;               DIRECTIVE STATUS OF 'D.RS16' IS RETURNED IF NON-PRIVILEGED
;                       TASK ATTEMPTS TO ELIMINATE FLAGS FOR ANOTHER GROUP.
;               DIRECTIVE STATUS OF 'D.RS17' IS RETURNED IF EVENT FLAG
;                       BLOCK IS ALREADY MARKED FOR DELETE.
;               DIRECTIVE STATUS OF 'D.RS91' IS RETURNED IF THE SPECIFIED 
;                       EVENT FLAG GROUP IS GREATER THAN 377.
;               DIRECTIVE STATUS OF 'D.RS97' IS RETURNED IF THE SPECIFIED
;                       EVENT FLAG GROUP DOES NOT EXIST.
;-
 
$DRELE::MOV     (R3)+,R0        ;GET GROUP NUMBER
        BNE     50$             ;IF NE USE IT
        MOVB    H.CUIC+1(R4),R4 ;DEFAULT TO CURRENT GROUP
        BR      65$             ;
50$:    BIT     #T3.PRV,T.ST3(R5) ;TASK PRIVILEGED?
        BNE     60$             ;IF NE YES
        CMPB    R0,H.CUIC+1(R4) ;ELIMINATING OTHER GROUP?
        BNE     90$             ;IF NE PRIV VIOLATION
60$:    CMP     R0,#377         ;LEGAL?
        BHI     80$             ;IF HI NO
        MOV     R0,R4           ;COPY GROUP NUMBER
65$:    CALL    $SRGEF          ;SEARCH FOR GROUP GLOBAL EVENT FLAG BLOCK
        BCS     100$            ;IF CS NOT FOUND
        BITB    #GS.DEL,G.STAT(R1) ;ALREADY MARKED FOR DELETE?
        BNE     110$            ;IF NE YES
        BISB    #GS.DEL,G.STAT(R1) ;MARK IT FOR DELETE
        TST     G.CNT(R1)       ;STILL BEING USED?
        BNE     30$             ;IF NE YES, SYSXT WILL ELIMINATE IT LATER
        CALLR   $ELGEF          ;ELIMINATE IT NOW
70$:    DRSTS   D.RS1           ;ALLOCATION FAILURE
80$:    DRSTS   D.RS91          ;INVALID GROUP
90$:    DRSTS   D.RS16          ;PRIVILEGE VIOLATION
100$:   DRSTS   D.RS97          ;GROUP NOT FOUND
110$:   DRSTS   D.RS17          ;FLAGS ALREADY EXIST OR MARKED FOR DELETE
        .DSABL  LSB
        
;+
; **-$ELGEF-SUBROUTINE TO ELIMINATE A GROUP GLOBAL EVENT FLAG BLOCK
;
; THIS SUBROUTINE UNCONDITIONALLY UNLINKS A GROUP GLOBAL EVENT FLAG BLOCK
; AND DEALLOCATES IT.
;
; INPUTS:
;
;       R0=ADDRESS OF BLOCK POINTING TO BLOCK TO BE DEALLOCATED
;       R1=ADDRESS OF BLOCK TO BE ELIMINATED
;
; OUTPUTS:
;
;       NONE.
;-
 
$ELGEF::MOV     (R1),(R0)       ;UNLINK THE BLOCK
        MOV     R1,R0           ;SET UP TO DEALLOCATE THE BLOCK
        MOV     #10.,R1         ;
        CALLR   $DEACB          ;DEALLOCATE THE BLOCK
 
;+
; **-$DEAGF-DEACCESS GROUP GLOBAL EVENT FLAGS
;
; THIS ROUTINE DETERMINES IF THE SPECIFIED TASK IS WAITING FOR A 
; GROUP GLOBAL EVENT FLAG.  IF IT IS, THE ACCESS COUNT IN THE GROUP
; GLOBAL EVENT FLAG BLOCK IS DECREMENTED AND THE BLOCK IS DEALLOCATED 
; IF IT IS MARKED FOR DELETE.
;
; INPUTS:
;
;       R2=TASK HEADER ADDRESS.
;       R5=TASK TCB ADDRESS.
;
; OUTPUTS:
;
;       NONE.
;
;       R5 IS THE ONLY REGISTER PRESERVED.
;-
 
$DEAGF::MOVB    H.CUIC+1(R2),R4 ;GET GROUP NUMBER
        CALL    $SRGEF          ;SEARCH FOR GROUP GLOBAL EVENT FLAGS
        BCS     10$             ;IF CS NOT FOUND
        MOV     H.EFLM+2(R2),R3 ;GET ADDRESS OF EVENT FLAG MASK
        CMP     R3,R1           ;GROUP GLOBAL EVENT FLAG?
        BLO     10$             ;IF LO NO
        SUB     #10.,R3         ;POINT TO LINK WORD
        CMP     R3,R1           ;GROUP GLOBAL EVENT FLAG?
        BHIS    10$             ;IF HIS NO
        DEC     G.CNT(R1)       ;DECREMENT ACCESS COUNT
        BNE     10$             ;IF NE, CAN'T ELIMINATE FLAGS YET
        BITB    #GS.DEL,G.STAT(R1) ;MARKED FOR DELETE?
        BNE     $ELGEF          ;ELIMINATE GROUP GLOBAL EVENT FLAG GROUP
10$:    RETURN                  ;
 
;+
; **-$GTGEF-GET ADDRESS OF GROUP GLOBAL EVENT FLAGS
;
; THIS ROUTINE SEARCHES FOR THE GROUP GLOBAL EVENT FLAGS ASSOCIATED WITH
; A TASK.  IF THE EVENT FLAGS ARE NOT FOUND, DIRECTIVE STATUS IS RETURNED.
; IF THE FLAGS EXIST THE ADDRESS OF THE EVENT FLAG WORD IS RETURNED IN R1.
;
; INPUTS:
;
;       R5=TCB ADDRESS OF TASK.
;
; OUTPUTS:
;
;       C=0 IF GROUP GLOBAL EVENT FLAGS WERE FOUND 
;               R1=ADDRESS OF GROUP GLOBAL EVENT FLAGS
;
;       C=1 IF  EVENT FLAGS WERE NOT FOUND
;               DRSTS D.RS91 RETURNED
;
;       NOTE: THE SPECIFIED TASK MUST NOT BE CHECKPOINTED.
;
;-
 
$GTGEF::MOV     R0,-(SP)        ;SAVE REGISTERS
        MOV     R4,-(SP)        ;
        MOV     T.PCB(R5),R4    ;GET TASK REGION PCB ADDRESS
        BIT     #TS.OUT,T.STAT(R5) ;TASK CHECKPOINTED?
        BEQ     10$             ;IF EQ NO
        BPT                     ;
10$:
        MOV     P.HDR(R4),R4    ;GET TASK HEADER ADDRESS
        MOVB    H.CUIC+1(R4),R4 ;GET GROUP NUMBER
        CALL    $SRGEF          ;SEARCH FOR GROUP GLOBAL EVENT FLAGS
        BCS     90$             ;IF CS NOT FOUND
        ADD     #6,R1           ;POINT TO FIRST EVENT FLAG WORD
        MOV     (SP)+,R4        ;RESTORE REGISTERS
        MOV     (SP)+,R0        ;
        RETURN
90$:    DRSTS   D.RS91          ;SET DIRECTIVE STATUS
 
;+
; **-$SRGEF-SEARCH FOR GROUP GLOBAL EVENT FLAGS
; 
; THIS ROUTINE IS CALLED TO SEARCH FOR GROUP GLOBAL EVENT FLAGS
;
; INPUTS:
;
;       R4=GROUP NUMBER
;
; OUTPUTS:
;
;       C=1 IF SPECIFIED GROUP GLOBAL EVENT FLAGS NOT FOUND
;       C=0 IF SPECIFIED GROUP GLOBAL EVENT FLAGS ARE FOUND
;               R0=ADDRESS OF WORD POINTING TO BLOCK
;               R1=ADDRESS OF THE BLOCK
;
;-
 
$SRGEF::MOV     #$GGEF,R1       ;GET ADDRESS OF GROUP GLOBAL EF HEAD
10$:    MOV     R1,R0           ;SAVE POINTER TO CURRENT BLOCK
        MOV     (R1),R1         ;GET ADDRESS OF NEXT BLOCK
        BEQ     20$             ;IF EQ END OF LIST
        CMPB    G.GRP(R1),R4    ;IS THIS THE CORRECT BLOCK?
        BEQ     30$             ;IF EQ YES
        BLO     10$             ;IF LO KEEP SEARCHING
20$:    SEC                     ;SET CARRY TO INDICATE NOT FOUND
30$:    RETURN                  ;
 
        .ENDC   ;G$$EFN
 
        .END
        .TITLE  DRGLI
        .IDENT  /06/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 06
;
; D. N. CUTLER 18-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
 
;+
; **-$DRGLI-GET LUN INFORMATION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO FILL A SIX WORD BUFFER WITH
; INFORMATION ABOUT A DEVICE THAT IS ASSIGNED TO A SPECIFIED LUN. IF RE-
; QUESTS TO THE DEVICE HAVE BEEN RE-DIRECTED, THEN THE INFORMATION RETURN-
; ED PERTAINS TO THE RE-DIRECT DEVICE.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(5.),DPB SIZE(3.).
;       WD. 01 -- LUN TO RETURN INFORMATION FOR.
;       WD. 02 -- ADDRESS OF A SIX WORD BUFFER.
;
;       BUFFER FORMAT:
;
;       WD. 00 -- NAME OF ASSIGNED DEVICE.
;       WD. 01 -- UNIT NUMBER OF ASSIGNED DEVICE AND FLAGS BYTE.
;       WD. 02 -- FIRST DEVICE CHARACTERISTICS WORD.
;       WD. 03 -- SECOND DEVICE CHARACTERISTICS WORD.
;       WD. 04 -- THIRD DEVICE CHARACTERISTICS WORD.
;       WD. 05 -- FOURTH DEVICE CHARACTERISTICS WORD.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LUN IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS5' IS RETURNED IF NO DEVICE
;                       IS ASSIGNED TO THE SPECIFIED LUN.
;-
 
$DRGLI::CALL    $MPLUN          ;MAP LUN TO UCB ADDRESS
        BCS     10$             ;IF CS NO DEVICE ASSIGNED
        MOV     R0,R4           ;SAVE ADDRESS OF DEVICE UCB
        MOV     (R3),R3         ;GET ADDRESS OF BUFFER
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     #6*2,R1         ;SET LENGTH OF BUFFER
        CALL    $ACHKP          ;ADDRESS CHECK BUFFER
 
        .ENDC
 
 
        MOV     (R4),R2         ;GET ADDRESS OF DEVICE DCB
        TST     (R2)+           ;POINT TO ADDRESS OF FIRST UCB
        MOV     R4,R0           ;COPY ADDRESS OF UCB
        SUB     (R2)+,R0        ;CALCULATE RELATIVE ADDRESS OF UCB
        MOV     (R2)+,(R3)+     ;INSERT GENERIC DEVICE NAME
        MOV     (R2)+,(R3)      ;PICK UP LOW UNIT NUMBER FOR DCB
        MOV     (R2)+,R1        ;PICK UP UCB LENGTH
        CALL    $DIV            ;CALCULATE RELATIVE UNIT NUMBER
        ADD     R0,(R3)+        ;CALCULATE LOGICAL UNIT NUMBER
        MOVB    #200,-(R3)      ;ASSUME RESIDENT DRIVER
 
 
        .IF DF  L$$DRV
 
        TST     (R2)            ;DRIVER RESIDENT?
        BNE     5$              ;IF NE YES
        CLRB    (R3)            ;ELSE INDICATE DRIVER IS NONRESIDENT
 
        .ENDC
 
 
5$:     INC     R3              ;ADVANCE POINTER
        ADD     #U.CW1,R4       ;POINT TO FIRST CHARACTERISTICS WORD
        MOV     (R4)+,(R3)+     ;INSERT DEVICE CHARACTERISTICS WORDS
        MOV     (R4)+,(R3)+     ;
        MOV     (R4)+,(R3)+     ;
        MOV     (R4),(R3)       ;
        RETURN                  ;RETURN DIRECTIVE STATUS OF +1
10$:    DRSTS   D.RS5           ;SET DIRECTIVE STATUS
 
        .END
        .TITLE  DRGPP
        .IDENT  /05/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 05
;
; D. N. CUTLER 3-JAN-74
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  PCBDF$,TCBDF$
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
 
;+
; **-$DRGPP-GET PARTITION PARAMETERS
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO FILL A THREE WORD BUFFER WITH
; PARTITION PARAMETERS.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(65.),DPB SIZE(4.).
;       WD. 01 -- FIRST HALF OF OPTIONAL PARTITION NAME.
;       WD. 02 -- SECOND HALF OF OPTIONAL PARTITION NAME.
;       WD. 03 -- ADDRESS OF A THREE WORD BUFFER.
;
;       BUFFER FORMAT:
;
;       WD. 00 -- BASE ADDRESS OF PARTITION IN 32W BLOCKS.
;       WD. 01 -- SIZE OF PARTITION IN 32W BLOCKS.
;       WD. 02 -- PARTITION FLAGS WORD.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE PARTITION NAME IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS EQUAL TO THE STARTING VIRTUAL ADDRESS
;                       OF THE SPECIFIED PARTITION IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS2' IS RETURNED IF SPECIFIED
;                       PARTITION IS NOT IN SYSTEM.
;-
        
        
        .IF DF  G$$TPP
 
 
        .IF DF  P$$LAS
 
$DRGPP::TST     (R3)+           ;PARTITION NAME SPECIFIED?
        BNE     10$             ;IF NE YES
        CALL    $SRATT          ;SEARCH FOR REGION ID
        MOV     A.PCB(R5),R2    ;PICK UP PCB ADDRESS
        BR      30$             ;
10$:    TST     -(R3)           ;POINT TO FIRST WORD OF PARTITION NAME
        CALL    $SRNAM          ;SEARCH FOR NAMED PARTITION
        BCC     20$             ;IF CC NAMED PARTITION FOUND
        DRSTS   D.RS2           ;INVALID PARTITION NAME
20$:    TST     (R3)+           ;ADVANCE POINTER
30$:    MOV     R2,R4           ;COPY PCB POINTER
 
        .IFF
 
$DRGPP::MOV     (R3)+,R0        ;PARTITION SPECIFIED?
        BEQ     30$             ;IF EQ NO
        MOV     $PARHD,R4       ;GET ADDRESS OF FIRST PARTITION PCB
10$:    CMP     R0,P.NAM(R4)    ;FIRST HALF OF NAME MATCH?
        BNE     20$             ;IF NE NO
        CMP     (R3),P.NAM+2(R4) ;SECOND HALF OF NAME MATCH?
        BEQ     40$             ;IF EQ YES
20$:    MOV     (R4),R4         ;GET ADDRESS OF NEXT PCB
        BNE     10$             ;IF NE MORE TO SCAN
        DRSTS   D.RS2           ;SET DIRECTIVE STATUS
30$:    MOV     T.PCB(R5),R4    ;GET PCB ADDRESS OF CURRENT TASK
 
        .ENDC
 
 
40$:    MOV     2(R3),R3        ;GET ADDRESS OF 3 WORD BUFFER
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     #3*2,R1         ;SET LENGTH OF BUFFER
        CALL    $ACHKP          ;ADDRESS CHECK BUFFER
 
        .ENDC
 
 
        .IF DF  M$$MGE
 
        MOV     P.REL(R4),(R3)+ ;INSERT PHYSICAL ADDRESS OF PARTITION
        CLR     2(SP)           ;SET DIRECTIVE STATUS WORD
 
        .IFF
 
        MOV     P.REL(R4),R1    ;GET STARTING VIRTUAL ADDRESS OF PARTITION
        MOV     R1,(R3)+        ;INSERT PHYSICAL ADDRESS OF PARTITION
        MOV     R1,2(SP)        ;SET DIRECTIVE STATUS WORD
        
        .IFTF
 
        MOV     P.SIZE(R4),(R3)+ ;INSERT SIZE OF PARTITION
        CLR     (R3)            ;ASSUME SYSTEM CONTROLLED PARTITION
        
        
        .IF DF  D$$YNM&M$$MGE
        
        BIT     #PS.SYS,P.STAT(R4) ;SYSTEM CONTROLLED PARTITION?
        BNE     60$             ;IF NE YES
        
        .ENDC
        
 
        INC     (R3)            ;SET USER CONTROLLED PARTITION
 
        .IFF
 
        CALL    (PC)            ;CONVERT LENGTH TO 32W BLOCKS
        SWAB    -(R3)           ;CONVERT TO 32W BLOCKS
        ASLB    1(R3)           ;
        ROL     (R3)            ;
        ROL     (R3)            ;
 
        .ENDC
 
 
60$:    RETURN
 
        .ENDC
        
        
        .END
        .TITLE  DRGSS
        .IDENT  /03/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; D. N. CUTLER 31-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;
; MODIFIED BY:
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
 
;+
; **-$DRGSS-GET SENSE SWITCHES
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO STORE THE CONTENTS OF THE CONSOLE
; SWITCH REGISTER IN THE ISSUING TASK'S DIRECTIVE STATUS WORD.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(125.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS EQUAL TO THE CONTENTS OF THE
;               CONSOLE SWITCH REGISTER.
;-
        
        
        .IF DF  G$$TSS
 
$DRGSS::MOV     SWR,2(SP)       ;SET CONTENTS OF CONSOLE SWITCH REGISTER
        RETURN                  ;RETURN DIRECTIVE STATUS
 
        .ENDC
        
        
        .END
        .TITLE  DRGTK
        .IDENT  /05/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 05
;
; D. N. CUTLER 27-MAR-74
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 2-NOV-77
;
;               TM110 -- RETURN PROTECTION UIC WORD.
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HDRDF$,PCBDF$,TCBDF$
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
 
;+
; **-$DRGTK-GET TASK PARAMETERS
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO FILL A SIXTEEN WORD BUFFER WITH
; TASK PARAMETERS.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(63.),DPB SIZE(2.).
;       WD. 01 -- ADDRESS OF A SIXTEEN WORD BUFFER.
;
;       BUFFER FORMAT:
;
;       WD. 00 -- FIRST HALF OF ISSUING TASK'S NAME.
;       WD. 01 -- SECOND HALF OF ISSUING TASK'S NAME.
;       WD. 02 -- FIRST HALF OF TASK'S PARTITION NAME.
;       WD. 03 -- SECOND HALF OF TASK'S PARTITION NAME.
;       WD. 04 -- FIRST HALF OF REQUESTER TASK NAME (NOT SUPPORTED).
;       WD. 05 -- SECOND HALF OF REQUESTER TASK NAME (NOT SUPPORTED).
;       WD. 06 -- TASK PRIORITY.
;       WD. 07 -- CURRENT TASK UIC.
;       WD. 10 -- NUMBER OF LOGICAL UNITS.
;       WD. 11 -- MACHINE TYPE INDICATOR (NOT SUPPORTED).
;       WD. 12 -- STD FLAGS WORD (NOT SUPPORTED).
;       WD. 13 -- ADDRESS OF TASK SST VECTOR TABLE.
;       WD. 14 -- SIZE OF TASK SST VECTOR TABLE IN WORDS.
;       WD. 15 -- SIZE OF TASK IN BYTES.
;       WD. 16 -- SYSTEM TYPE CODE.
;       WD. 17 -- PROTECTION UIC WORD.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE SIXTEEN WORD BUFFER IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF +1.
;-
        
        
        .IF DF  G$$TTK
 
$DRGTK::MOV     (R3),R3         ;GET ADDRESS OF 16. WORD BUFFER
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     #16.*2,R1       ;SET LENGTH OF BUFFER IN BYTES
        CALL    $ACHKP          ;ADDRESS CHECK PARAMETER BLOCK
 
        .ENDC
 
 
        MOV     T.NAM(R5),(R3)+ ;INSERT NAME OF TASK
        MOV     T.NAM+2(R5),(R3)+ ;
        MOV     T.PCB(R5),R0    ;GET ADDRESS OF TASK PCB
        MOV     P.NAM(R0),(R3)+ ;INSERT NAME OF PARTITION
        MOV     P.NAM+2(R0),(R3)+ ;
        CMP     (R3)+,(R3)+     ;POINT TO TASK PRIORITY ADDRESS
        MOV     T.PRI(R5),(R3)+ ;INSERT TASK PRIORITY
 
 
        .IF DF  M$$MUP
 
        MOV     H.DUIC(R4),(R3)+ ;INSERT DEFAULT UIC
 
        .IFF
 
        MOV     H.CUIC(R4),(R3)+ ;INSERT CURRENT UIC
 
        .ENDC
 
 
        MOV     H.NLUN(R4),(R3)+ ;INSERT NUMBER OF LUNS
        CMP     (R3)+,(R3)+     ;POINT TO TASK SST VECTOR ADDRESS
        MOV     H.TKVA(R4),(R3)+ ;INSERT TASK SST VECTOR ADDRESS
        MOV     H.TKVL(R4),(R3) ;INSERT LENGTH OF SST VECTOR IN WORDS
        ASR     (R3)+           ;CONVERT TO LENGTH IN WORDS
        MOV     H.WND(R4),R1    ;POINT TO NUMBER OF WINDOW BLOCKS
        MOV     W.BHVR+2(R1),(R3) ;CALCULATE TASK SIZE IN BYTES
        SUB     W.BLVR+2(R1),(R3) ;
        INC     (R3)+           ;
 
 
        .IF NDF R$$11S
 
        MOV     #1,(R3)+        ;SET CODE FOR RSX-11M
 
        .IFF
 
        MOV     #2,(R3)+        ;SET CODE FOR RSX-11S
 
        .ENDC
 
 
        MOV     H.CUIC(R4),(R3) ;RETURN PROTECTION UIC
        RETURN                  ;
 
        .ENDC
        
        
        .END
        .TITLE  DRGTP
        .IDENT  /03/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; D. N. CUTLER 30-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;+
; **-$DRGTP-GET TIME PARAMETERS
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO FILL A SPECIFIED EIGHT WORD
; BUFFER WITH THE CURRENT TIME PARAMETERS.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(61.),DPB SIZE(2.).
;       WD. 01 -- ADDRESS OF AN EIGHT WORD BUFFER.
;
;       BUFFER FORMAT:
;
;       WD. 00 -- YEAR SINCE 1900.
;       WD. 01 -- MONTH OF YEAR.
;       WD. 02 -- DAY OF MONTH.
;       WD. 03 -- HOUR OF DAY.
;       WD. 04 -- MINUTE OF HOUR.
;       WD. 05 -- SECOND OF MINUTE.
;       WD. 06 -- TICK OF SECOND.
;       WD. 07 -- TICKS PER SECOND.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE SECOND WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF BUFFER IS
;                       OUTSIDE OF ISSUING TASK'S ADDRESS SPACE.
;-
 
$DRGTP::MOV     (R3),R3         ;GET ADDRESS OF TIME PARAMETERS BUFFER
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     #8.*2,R1        ;SET LENGTH OF BUFFER IN BYTES
        CALL    $ACHKP          ;ADDRESS CHECK PARAMETER BUFFER
 
        .ENDC
 
 
        MOV     #$TTNS-14,R1    ;POINT TO CURRENT TIME VECTOR
10$:    MOV     (R1)+,(R3)+     ;INSERT TIME PARAMETER IN TASK BUFFER
        CMP     R1,#$TTNS       ;ANY MORE TO INSERT?
        BLOS    10$             ;IF LOS YES
        MOV     $TKPS,(R3)      ;SET TICKS PER SECOND
        RETURN                  ;RETURN DIRECTIVE STATUS OF +1
 
        .END
        .TITLE  DRMAP
        .IDENT  /03.01/
 
;
; COPYRIGHT (C) 1976, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03.01
;
; T. J. MILLER 8-MAR-76
;
; MODIFIED BY:
;
;       T. J. MILLER 5-JAN-77
;
;               TM071 -- CORRECT ERROR IN MAP ALGORITHM.
;
;       T. J. MILLER 20-APR-77
;
;               TM076 -- CORRECT BUG IN GET MAPPING CONTEXT DIRECTIVE.
;
;       T. J. MILLER 26-MAY-77
;
;               TM086 -- UTILIZE COMMON EVENT FLAG SETTING ROUTINE IN
;                       RECEIVE BY REFERENCE.
;
;       CHUCK SPITZ 31-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES AND USE TCB FOR
;                       ALL AST LISTHEADS.
;
;       JOHN COVERT 27-FEB-79
;               JRC002 -- RETURN ALIGNMENT ERROR ON ATTEMPT TO
;                         CREATE ZERO LENGTH ADDRESS WINDOW.
;
;       M. S. HARVEY    12-APR-79
;               MSH008 -- FIX SEND/RECEIVE BY REFERENCE SO THAT
;                        IF SENDER IS REMOVED, SENDER'S EVENT FLAG
;                        WILL NOT BE SET.
;
        .PAGE
;
; THE FOLLOWING DIRECTIVES RECEIVE AS INPUT POINTERS TO A WINDOW DEFINITION
; BLOCK, WHICH SERVES AS A COMMUNICATION AREA BETWEEN THE ISSUING TASK AND
; THE EXECUTIVE. THE FORMAT OF THE WINDOW DEFINITION BLOCK IS:
;
;               -------------------------------------------------
;       W.NID   !                       !                       !
;       W.NAPR  !       BASE APR        !       WINDOW ID       !
;               !                       !                       !
;               !-----------------------------------------------!
;               !                                               !
;       W.NBAS  !       VIRTUAL BASE ADDRESS (BYTES)            !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       W.NSIZ  !       WINDOW SIZE (32W BLOCKS)                !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       W.NRID  !       REGION ID                               !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       W.NOFF  !       OFFSET IN PARTITION (32W BLOCKS)        !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       W.NLEN  !       LENGTH TO MAP (32W BLOCKS)              !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       W.NSTS  !       STATUS WORD                             !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       W.NSRB  !       SEND/RECEIVE BUFFER ADDR (BYTES)        !
;               !                                               !
;               -------------------------------------------------
;
; MACRO LIBRARY CALLS
;


        .IF DF  P$$LAS

        .MCALL  HDRDF$,PCBDF$,TCBDF$,WDBDF$
        HDRDF$                  ;DEFINE HEADER AND WINDOW BLOCK OFFSETS
        PCBDF$                  ;DEFINE PCB AND ATTACHMENT DESCR OFFSETS
        TCBDF$                  ;DEFINE TCB OFFSETS
        WDBDF$                  ;DEFINE WINDOW DEFINITION BLOCK OFFSETS

;+
; **-$DRCRW-CREATE ADDRESS WINDOW
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO ALLOCATE AN ADDRESS WINDOW IN THE
; HEADER OF THE ISSUING TASK, UNMAPPING AND ELIMINATING ANY OVERLAPPING
; ADDRESS WINDOWS, AND OPTIONALLY TO MAP THE NEW WINDOW.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(117.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF WINDOW DEFINITION BLOCK
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE WINDOW DEFINITION BLOCK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NAPR=BASE APR OF REGION.
;               W.NSIZ=DESIRED SIZE OF ADDRESS WINDOW.
;               W.NRID=ID OF REGION TO MAP OR 0 FOR TASK REGION (IF WS.MAP=1).
;               W.NOFF=OFFSET WITHIN REGION TO MAP (IF WS.MAP=1).
;               W.NLEN=LENGTH TO MAP OR 0 TO DEFAULT TO SMALLER OF WINDOW SIZE
;                       OR SIZE LEFT IN PARTITION (IF WS.MAP=1).
;               W.NSTS=CONTROL INFORMATION.
;                       WS.MAP=1 IF MAPPING IS TO OCCUR.
;                       WS.WRT=1 IF MAPPING IS TO OCCUR WITH WRITE ACCESS.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS16' IS RETURNED IF THE SPECIFIED
;                       ACCESS IS DENIED IN THE MAPPING STAGE.
;               DIRECTIVE STATUS OF 'D.RS84' IS RETURNED IF AN INVALID APR-
;                       WINDOW SIZE COMBINATION IS SPECIFIED OR IF AN
;                       INVALID REGION OFFSET-LENGTH COMBINATION IS SPECIFIED
;                       IN THE MAPPING STAGE.
;               DIRECTIVE STATUS OF 'D.RS85' IS RETURNED IF THERE ARE NO
;                       AVAILABLE WINDOW BLOCKS.
;               DIRECTIVE STATUS OF 'D.RS86' IS RETURNED IF AN INVALID REGION
;                       ID IS SPECIFIED IN THE MAPPING STAGE.
;
;       OUTPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NID=ASSIGNED WINDOW ID.
;               W.NBAS=VIRTUAL BASE ADDRESS OF WINDOW.
;               W.NLEN=LENGTH ACTUALLY MAPPED.
;               W.NSTS=INDICATION OF ANY CHANGES IN MAPPING STATUS.
;                       WS.CRW=1 IF ADDRESS WINDOW SUCCESSFULLY ESTABLISHED.
;                       WS.ELW=1 IF ANY ADDRESS WINDOWS WERE ELIMINATED.
;                       WS.UNM=1 IF ANY ADDRESS WINDOWS WERE UNMAPPED.
;-

$DRCRW::MOV     R4,-(SP)        ;SAVE ADDRESS OF TASK HEADER
        MOV     H.WND(R4),R4    ;POINT TO NUMBER OF WINDOW BLOCKS
        MOV     (R4)+,R1        ;PICK UP NUMBER OF WINDOW BLOCKS
        MOV     (R3)+,R2        ;PICK UP APR NUMBER IN HIGH BYTE (W.NID)
        CLRB    R2              ;CLEAR OUT LOW BYTE
        CMP     R2,#7*256.      ;LEGAL APR NUMBER?
        BHI     40$             ;IF HI NO
        ASR     R2              ;CONVERT TO BASE ADDRESS IN 32W BLOCKS
        MOV     R2,(R3)         ;STORE VIRTUAL BASE ADDRESS (W.NBAS)
        ASR     (R3)            ;CONVERT TO BYTES (W.NBAS)
        ASR     (R3)            ;
        SWAB    (R3)+           ;
        TST     (R3)            ;IS W.NSIZ=0 (NOT A VALID WINDOW SIZE)  ;JRC002
        BEQ     40$             ;IF EQ YES -- RETURN ALIGNMENT ERROR    ;JRC002
        MOV     R2,-(SP)        ;CALCULATE HIGH ADDRESS
        ADD     (R3),(SP)       ;(W.NSIZ)
        BCS     40$             ;IF CS ILLEGAL SIZE
        CMP     (SP),#2000      ;LEGAL TOP ADDRESS?
        BHI     40$             ;IF HI NO
        MOV     R1,-(SP)        ;SAVE NUMBER OF WINDOWS
        CMP     -(R3),-(R3)     ;POINT TO START OF WINDOW BLOCK (W.NBAS)(W.NID)
10$:    TST     W.BSIZ(R4)      ;POINTING TO AN ESTABLISHED ADDRESS WINDOW?
        BEQ     20$             ;IF EQ NO
        MOV     W.BLVR(R4),R0   ;PICK UP LOW VIRTUAL ADDRESS
        SWAB    R0              ;CONVERT TO 32W BLOCKS
        ASL     R0              ;
        ASL     R0              ;
        CMP     2(SP),R0        ;POSSIBLE VIRTUAL ADDRESS OVERLAP?
        BLOS    30$             ;IF LOS NO
        ADD     W.BSIZ(R4),R0   ;CALCULATE HIGH ADDRESS
        CMP     R2,R0           ;VIRTUAL ADDRESS OVERLAP?
        BHIS    30$             ;IF HIS NO
        CMP     R1,(SP)         ;OVERLAPPING WINDOW 0?
        BEQ     40$             ;IF EQ YES
        CALL    ELAW            ;ELIMINATE ADDRESS WINDOW
20$:    TST     (SP)            ;HAS A WINDOW BEEN ESTABLISHED?
        BEQ     30$             ;IF EQ YES
        CMP     (R3)+,(R3)+     ;POINT TO WINDOW SIZE IN BLOCK (W.NID)(W.NBAS)
        MOV     (R3),W.BSIZ(R4) ;STORE SIZE, ESTABLISHING WINDOW (W.NSIZ)
        MOV     -(R3),W.BLVR(R4) ;SET LOW VIRTUAL ADDRESS (W.NBAS)
        MOVB    -(R3),R0        ;PICK UP FIRST APR NUMBER (W.NAPR)
        ASL     R0              ;CONVERT APR NUMBER TO WORD OFFSET
        ADD     #UISDR0,R0      ;POINT TO FIRST PDR
        MOVB    R0,W.BFPD(R4)   ;SET FIRST PDR ADDRESS
        MOVB    (SP),-(R3)      ;PICK UP TOTAL NUMBER OF WINDOWS (W.NID)
        SUB     R1,(R3)         ;SET ADDRESS WINDOW ID (W.NID)
        CLR     (SP)            ;INDICATE WINDOW HAS BEEN ESTABLISHED
30$:    ADD     #W.BLGH,R4      ;POINT TO NEXT WINDOW BLOCK
        DEC     R1              ;MORE WINDOW BLOCKS?
        BGT     10$             ;IF GT YES
        TST     (SP)+           ;WAS AN ADDRESS WINDOW ESTABLISHED?
        BNE     50$             ;IF NE NO
        TST     (SP)+           ;POP CALCULATED HIGH ADDRESS
        MOV     (SP)+,R4        ;RESTORE TASK HEADER ADDRESS
        BIS     #WS.CRW,W.NSTS(R3) ;INDICATE ADDRESS WINDOW WAS CREATED
        BIT     #WS.MAP,W.NSTS(R3) ;IS WINDOW TO BE MAPPED?
        BNE     $DRMAP          ;MAP ADDRESS WINDOW AND EXIT
        RETURN                  ;
40$:    DRSTS   D.RS84          ;ALIGNMENT ERROR
50$:    DRSTS   D.RS85          ;NO AVAILABLE WINDOWS

;+
; **-$DRELW-ELIMINATE ADDRESS WINDOW
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO ELIMINATE THE SPECIFIED ADDRESS
; WINDOW, UNMAPPING IT FIRST IF NECESSARY.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(119.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF WINDOW DEFINITION BLOCK
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE WINDOW DEFINITION BLOCK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NID=ID OF ADDRESS WINDOW TO ELIMINATE.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS87' IS RETURNED IF AN INVALID
;                       ADDRESS WINDOW WAS SPECIFIED.
;
;       OUTPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NSTS=INDICATION OF ANY CHANGES IN MAPPING STATUS.
;                       WS.ELW=1 IF ADDRESS WINDOW SUCCESSFULLY ELIMINATED.
;                       WS.UNM=1 IF THE ADDRESS WINDOW WAS UNMAPPED.
;-

$DRELW::CALL    $SRWND          ;SEARCH FOR AND VERIFY SPECIFIED WINDOW
ELAW:   CALL    $UNMAP          ;UNMAP IF NECESSARY
        BCC     10$             ;IF CC UNMAPPING WAS NOT PERFORMED
        BIS     #WS.UNM,W.NSTS(R3) ;INDICATE A WINDOW WAS UNMAPPED
10$:    CLR     W.BSIZ(R4)      ;INDICATE ADDRESS WINDOW IS ELIMINATED
        BIS     #WS.ELW,W.NSTS(R3) ;INDICATE ADDRESS WINDOW ELIMINATED
        RETURN                  ;

;+
; **-$DRMAP-MAP WINDOW TO REGION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO MAP THE SPECIFIED ADDRESS
; WINDOW TO AN OFFSET IN THE SPECIFIED REGION, UNMAPPING IF NECESSARY.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(121.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF WINDOW DEFINITION BLOCK
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE WINDOW DEFINITION BLOCK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NID=ID OF WINDOW TO MAP.
;               W.NRID=ID OF REGION TO MAP TO OR 0 TO DEFAULT TO TASK REGION.
;               W.NOFF=OFFSET WITHIN REGION TO MAP TO.
;               W.NLEN=LENGTH TO MAP OR 0 TO DEFAULT TO SMALLER OF WINDOW
;                       SIZE OR SIZE LEFT IN PARTITION.
;               W.NSTS=CONTROL INFORMATION.
;                       WS.WRT=1 IF WRITE ACCESS IS DESIRED.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS16' IS RETURNED IF THE DESIRED
;                       ACCESS TO THE REGION IS DENIED.
;               DIRECTIVE STATUS OF 'D.RS84' IS RETURNED IF AN INVALID
;                       REGION OFFSET-SIZE COMBINATION IS SPECIFIED.
;               DIRECTIVE STATUS OF 'D.RS86' IS RETURNED IF AN INVALID
;                       REGION ID IS SPECIFIED.
;               DIRECTIVE STATUS OF 'D.RS87' IS RETURNED IF AN INVALID
;                       ADDRESS WINDOW ID IS SPECIFIED.
;
;       OUTPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NLEN=LENGTH ACTUALLY MAPPED.
;               W.NSTS=INDICATION OF ANY CHANGES IN MAPPING STATUS.
;                       WS.UNM=1 IF THE WINDOW WAS UNMAPPED FIRST.
;
; THIS DIRECTIVE FIRST BUILDS AN IMAGE OF A MAPPED WINDOW BLOCK ON THE
; STACK.  THEN IF NO ERRORS ARE ENCOUNTERED, THE CORRESPONDING WINDOW IS
; UNMAPPED, IF NECESSARY, AND SET UP FROM THE STACK IMAGE.
;-

$DRMAP::CALL    $SRWND          ;SEARCH FOR AND VERIFY ADDRESS WINDOW ID
        ADD     #W.NRID,R3      ;POINT TO SPECIFIED REGION ID
        CALL    $SRATT          ;SEARCH FOR MATCHING ATTACHMENT DESCRIPTOR
        MOV     A.PCB(R5),R2    ;POINT TO ATTACHED PCB
        MOV     R2,-(SP)        ;SET PCB ADDRESS (W.BPCB)
        MOV     W.BLVR(R4),-(SP) ;COPY LOW VIRTUAL ADDRESS (W.BLVR)
        TST     (R3)+           ;POINT TO OFFSET (W.NRID)
        MOV     (R3)+,R0        ;PICK UP SPECIFIED OFFSET (W.NOFF)
        CMP     R0,P.SIZE(R2)   ;WITHIN PARTITION?
        BHIS    70$             ;IF HIS NO
        MOV     (R3),R1         ;PICK UP LENGTH TO MAP (W.NLEN)
        BNE     20$             ;IF NE ONE WAS SPECIFIED
        MOV     P.SIZE(R2),R1   ;CALCULATE SIZE TO END OF PARTITION
        SUB     R0,R1           ;
        CMP     R1,W.BSIZ(R4)   ;SIZE TO END GREATER THAN WINDOW SIZE? (W.BSIZ)
        BLOS    20$             ;IF LOS NO
        MOV     W.BSIZ(R4),R1   ;DEFAULT TO WINDOW SIZE (W.BSIZ)
20$:    MOV     R1,(R3)+        ;PASS BACK SIZE USED (W.NLEN)
        MOV     R1,-(SP)        ;CALCULATE HIGH VIRTUAL ADDRESS (W.BHVR)
        SWAB    (SP)            ;MULTIPLY BY 64
        RORB    (SP)            ;
        ROR     (SP)            ;
        ROR     (SP)            ;
        DEC     (SP)            ;POINT TO LAST ADDRESSABLE BYTE
        ADD     2(SP),(SP)      ;
        MOV     R5,-(SP)        ;STORE ADDR OF ATTACHMENT DESCRIPTOR (W.BATT)
        MOV     W.BSIZ(R4),-(SP) ;COPY WINDOW SIZE (W.BSIZ)
        CMP     R1,(SP)         ;LEGAL SIZE? (W.BSIZ)
        BHI     70$             ;IF HI NO
        BIT     #7,R0           ;64-BYTE ALIGNMENT?
        BEQ     30$             ;IF EQ NO
        BIT     #WS.64B,(R3)    ;64-BYTE ALIGNMENT BEING ALLOWED?
        BEQ     70$             ;IF EQ NO
30$:    MOV     R0,-(SP)        ;SET OFFSET IN PARTITION (W.BOFF)
        ADD     R1,R0           ;POINT PAST LAST 32W BLOCK MAPPED TO
        CMP     R0,P.SIZE(R2)   ;WITHIN PARTITION?
        BHI     70$             ;IF HI NO
        MOV     W.BFPD(R4),-(SP) ;SAVE FIRST PDR ADDRESS (W.BFPD)
        BITB    #AS.RED!AS.WRT,A.STAT(R5) ;READ ACCESS ALLOWED?
        BEQ     80$             ;IF NE NO
        MOV     #77402,-(SP)    ;SET FOR READ ACCESS, 4K SIZE (W.BLPD)
        BIT     #WS.WRT,(R3)    ;WRITE ACCESS DESIRED? (W.NSTS)
        BEQ     40$             ;IF EQ NO
        BIT     #AS.WRT,A.STAT(R5) ;WRITE ACCESS ALLOWED?
        BEQ     80$             ;IF NE NO
        MOV     #77406,(SP)     ;SET FOR 4K SIZE, READ/WRITE ACCESS (W.BLPD)
40$:    INCB    A.MPCT(R5)      ;INC MAP COUNT IN ATTACHMENT DESCRIPTOR
        CALL    $UNMAP          ;UNMAP WINDOW IF NECESSARY
        BCC     45$             ;IF CC WINDOW WAS NOT MAPPED
        BIS     #WS.UNM,(R3)    ;INDICATE A WINDOW WAS UNMAPPED (W.NSTS)
45$:    MOVB    W.BFPD(R4),R0   ;POINT TO FIRST PDR
        MOV     P.REL(R2),R2    ;CALCULATE OFFSET FOR FIRST PDR
        ADD     4(SP),R2        ;(W.BOFF)
        CLRB    3(SP)           ;INIT NUMBER OF PDR'S (W.BNPD)
50$:    INCB    3(SP)           ;INC NUMBER OF PDR'S (W.BNPD)
        MOV     R2,UISAR0-UISDR0(R0) ;SET UP USER APR
        MOV     (SP),(R0)+      ;SET UP NEXT USER PDR
        ADD     #200,R2         ;ADVANCE APR OFFSET
        SUB     #200,R1         ;DONE YET?
        BGT     50$             ;IF GT NO
        SWAB    R1              ;SHIFT UNUSED SIZE TO HIGH BYTE
        CLRB    R1              ;CLEAR LOW BYTE
        ADD     R1,(SP)         ;CALCULATE SIZE IN LAST PDR
        ADD     R1,-(R0)        ;SET LAST PDR
        MOV     R4,R3           ;COPY POINTER TO WINDOW BLOCK
        ADD     #W.BLGH,R3      ;POINT PAST END OF WINDOW BLOCK
60$:    MOV     (SP)+,-(R3)     ;COPY IMAGE OF WINDOW BLOCK INTO REAL BLOCK
        CMP     R3,R4           ;DONE YET?
        BHI     60$             ;IF HI NO
        RETURN                  ;
70$:    DRSTS   D.RS84          ;INVALID OFFSET-LENGTH COMBINATION
80$:    DRSTS   D.RS16          ;DESIRED ACCESS TO REGION DENIED

;+
; **-$DRUNM-UNMAP ADDRESS WINDOW
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO UNMAP THE SPECIFIED ADDRESS
; WINDOW.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(123.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF WINDOW DEFINITION BLOCK
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE WINDOW DEFINITION BLOCK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NID=ID OF WINDOW TO UNMAP.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS WORD RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF THE SPECIFIED
;                       ADDRESS WINDOW NOT MAPPED.
;               DIRECTIVE STATUS OF 'D.RS87' IS RETURNED IF AN INVALID
;                       ADDRESS WINDOW ID IS SPECIFIED.
;
;       OUTPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NSTS=INDICATION OF ANY CHANGES IN MAPPING STATUS.
;                       WS.UNM=1 IF THE WINDOW WAS SUCCESSFULLY UNMAPPED.
;-

$DRUNM::CALL    $SRWND          ;SEARCH FOR AND VERIFY WINDOW ID
        CALL    $UNMAP          ;UNMAP IF NECESSARY
        BCC     10$             ;IF CC WINDOW WAS NOT MAPPED
        BIS     #WS.UNM,W.NSTS(R3) ;INDICATE ADDRESS WINDOW WAS UNMAPPED
        RETURN                  ;
10$:    DRSTS   D.RS8           ;ADDRESS WINDOW WAS NOT MAPPED

;+
; **-$DRSRF-SEND BY REFERENCE
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CREATE A SPECIALLY FORMATTED
; PACKET INCLUDING A REFERENCE TO A SPECIFIED REGION WITH ADDITIONAL
; OPTIONAL INFORMATION SUPPLIED BY THE ISSUING TASK.  THE SENDER TASK
; MUST ITSELF HAVE THE ACCESS SPECIFIED IN THE REFERENCE.  THE REFERENCED
; REGION IS ATTACHED TO THE RECEIVING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(69.),DPB SIZE(5.)
;       WD. 01 -- FIRST HALF OF RECEIVER TASK NAME
;       WD. 02 -- SECOND HALF OF RECEIVER TASK NAME
;       WD. 03 -- OPTIONAL EVENT FLAG TO SET WHEN RECEIVE OCCURS
;       WD. 04 -- ADDRESS OF WINDOW DEFINITION BLOCK
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE RECEIVER TASK
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE RECEIVER TASK
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE EFN NUMBER IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NRID=ID OF REGION TO BE SENT BY REFERENCE.
;               W.NOFF=OFFSET WORD PASSED WITHOUT CHECKING.
;               W.NLEN=LENGTH WORD PASSED WITHOUT CHECKING.
;               W.NSTS=ALLOWED ACCESS (DEFAULTS TO ACCESS OF SENDER TASK).
;                       WS.RED=1 IF READ ACCESS IS TO BE ALLOWED.
;                       WS.WRT=1 IF WRITE ACCESS IS TO BE ALLOWED.
;                       WS.EXT=1 IF EXTEND ACCESS IS TO BE ALLOWED.
;                       WS.DEL=1 IF DELETE ACCESS IS TO BE ALLOWED.
;               W.NSRB=OPTIONAL ADDRESS OF 8 WORD BUFFER OF ADDITIONAL INFO.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF A SEND PACKET
;                       OR ATTACHMENT DESCRIPTOR COULD NOT BE ALLOCATED.
;               DIRECTIVE STATUS OF 'D.RS2' IS RETURNED IF AN ATTEMPT IS
;                       MADE TO SEND TO AN ACP TASK.
;               DIRECTIVE STATUS OF 'D.RS16' IS RETURNED IF THE DESIRED
;                       ACCESS TO THE REGION IS DENIED.
;               DIRECTIVE STATUS OF 'D.RS86' IS RETURNED IF AN INVALID
;                       REGION ID WAS SPECIFIED.
;               DIRECTIVE STATUS OF 'D.RS97' IS RETURNED IF AN INVALID EFN
;                       NUMBER IS SPECIFIED.
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF THE ADDRESS
;                       CHECK OF THE WINDOW DEF BLOCK OR SEND BUFFER FAILS.
;
;       OUTPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               NONE.
;
;       THE FORMAT OF THE SEND BY REFERENCE PACKET IS:
;               WD. 00 -- RECEIVE QUEUE THREAD.
;               WD. 01 -- TCB ADDRESS IF EFN SPECIFIED / 0 IF NOT.
;               WD. 02 -- EFN MASK / FIRST WORD OF SENDER TASK NAME.
;               WD. 03 -- EFN ADDRESS / SECOND WORD OF SENDER TASK NAME.
;               WD. 04 -- REGION ID (ATTACHMENT DESCRIPTOR ADDRESS).
;               WD. 05 -- OFFSET IN REGION WORD.
;               WD. 06 -- LENGTH OF MAP WORD.
;               WD. 07 -- STATUS WORD.
;               WD. 08 THRU WD. 017 -- CONTENTS OF SEND BUFFER.
;-


        .IF DF  P$$SRF

$DRSRF::BIT     #T3.ACP!T3.NSD,T.ST3(R0) ;SENDS LEGAL TO RECEIVER?
        BNE     60$             ;IF NE NO
        MOV     R0,-(SP)        ;SAVE RECEIVER TASK TCB ADDRESS
        CALL    $CEFN           ;CONVERT EFN NUMBER TO MASK AND ADDRESS
        BCS     4$              ;IF CS NO EFN WAS SPECIFIED
        INCB    T.SRCT(R5)      ;INCREMENT NUMBER OF INCOMPLETE SREFS   ;MSH008
        MOV     R5,-(SP)        ;SAVE SENDER TCB ADDRESS
        MOV     R0,-(SP)        ;SAVE EFN MASK
        MOV     R1,-(SP)        ;SAVE EFN ADDRESS
        BR      5$              ;
4$:     CLR     -(SP)           ;INDICATE NO EFN SPECIFIED
        MOV     T.NAM(R5),-(SP) ;SAVE SENDER TASK NAME
        MOV     T.NAM+2(R5),-(SP) ;
5$:     MOV     (R3),R3         ;PICK UP ADDRESS OF WINDOW DEF BLOCK
        MOV     #8.*2,R1        ;SET SIZE TO ADDRESS CHECK
        CALL    $ACHKP          ;ADDRESS CHECK AND MAP WINDOW DEF BLOCK
        ADD     #W.NRID,R3      ;POINT TO REGION ID IN BLOCK
        CALL    $SRATT          ;SEARCH FOR SPECIFIED ATTACHMENT DESCRIPTOR
        CMP     (R3)+,-(SP)     ;BUMP POINTERS FOR REGION ID (W.NRID)
        MOV     (R3)+,-(SP)     ;SAVE OFFSET WORD (W.NOFF)
        MOV     (R3)+,-(SP)     ;SAVE LENGTH WORD (W.NLEN)
        MOV     (R3)+,-(SP)     ;SAVE STATUS WORD (W.NSTS)
        BIC     #^C17,(SP)      ;CLEAR ALL BUT ACCESS
        BNE     6$              ;IF NE ACCESS SPECIFIED
        MOVB    A.STAT(R5),(SP) ;DEFAULT TO ACCESS OF SENDER TASK
6$:     MOVB    A.STAT(R5),-(SP) ;PUSH ATTACHMENT DESCRIPTOR ADDRESS
        COMB    (SP)            ;COMPUTE ACCESS DENIED MASK
        BITB    (SP)+,(SP)      ;CHECK SPECIFIED ACCESS AGAINST SENDER TASK
        BNE     70$             ;IF NE ACCESS DENIED
        MOV     (R3),R3         ;POINT TO SEND BUFFER
        BEQ     10$             ;IF EQ THERE IS NONE
        MOV     #8.*2,R1        ;SET SIZE TO ADDRESS CHECK
        CALL    $ACHKP          ;ADDRESS CHECK AND MAP SEND BUFFER
        ADD     #8.*2,R3        ;POINT TO END OF SEND BUFFER
10$:    CALL    $ALPKT          ;ALLOCATE A SEND PACKET
        ADD     #16.*2,R0       ;POINT PAST END OF SEND BY REFERENCE DATA
        MOV     #8.,R1          ;SET LOOP COUNT FOR COPY
        MOV     R1,R2           ;COPY LOOP COUNT
20$:    MOV     R3,-(R0)        ;WAS A SEND BUFFER SPECIFIED?
        BEQ     30$             ;IF EQ NO
        MOV     -(R3),(R0)      ;ELSE COPY NEXT WORD
30$:    DEC     R2              ;DONE YET?
        BGT     20$             ;IF GT NO
        MOV     (SP),R4         ;PICK UP STATUS WORD
40$:    MOV     (SP)+,-(R0)     ;INSERT SAVED WORDS ON STACK
        DEC     R1              ;DONE YET?
        BGT     40$             ;IF GT NO
        MOV     A.PCB(R5),R2    ;PICK UP PCB ADDRESS FROM ATT DESCRIPTOR
        BIT     #PS.COM,P.STAT(R2) ;COMMON PARTITION?
        BEQ     90$             ;IF EQ NO, TASK PARTITION IS ILLEGAL
        MOV     (R0),R5         ;PICK UP SAVED RECEIVER TASK ADDRESS
        MOV     R0,-(SP)        ;SAVE ADDRESS OF SEND PACKET
        CALL    $CRATT          ;ATTACH RECEIVER TASK TO REGION
        MOV     (SP)+,R0        ;RETRIEVE ADDRESS OF PACKET
        BCS     80$             ;IF CS ALLOCATION FAILURE
        MOV     R1,10(R0)       ;SET REGION ID IN PACKET
        MOV     R0,R1           ;COPY POINTER TO PACKET
        TST     (R0)+           ;POINT TO TCB ADDRESS
        TST     (R0)+           ;EFN SPECIFIED?
        BEQ     50$             ;IF EQ NO
        BIC     (R0)+,@(R0)+    ;CLEAR SPECIFIED EVENT FLAG NOW
50$:    MOV     R5,R0           ;POINT TO RECEIVE BY REFERENCE LISTHEAD
        ADD     #T.RRFL,R0      ;


        .IF DF  A$$TRP

        CALL    $QINSF          ;INSERT IN RECEIVE QUEUE
        MOV     #AS.RRA,R4      ;SET RECEIVE BY REF AST TYPE            ; CS017
        CALL    $DASTT          ;DECLARE RECEIVE BY REFERENCE AST       ;**-1
        CALLR   $DRDSE          ;DECLARE A SIGNIFICANT EVENT

        .IFF

        CALLR   $QINSF          ;INSERT IN RECEIVE QUEUE AND EXIT

        .ENDC


60$:    DRSTS   D.RS2           ;ATTEMPT TO SEND TO AN ACP TASK
70$:    DRSTS   D.RS16          ;PRIVILEGE VIOLATION
80$:    CALL    $DEPKT          ;DEALLOCATE SEND PACKET
        DRSTS   D.RS1           ;ALLOCATION FAILURE
90$:    CALL    $DEPKT          ;DEALLOCATE SEND PACKET
        DRSTS   D.RS86          ;INVALID REGION ID (NOT COMMON BLOCK)

;+
; **-$DRRRF-RECEIVE BY REFERENCE
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO DEQUEUE THE NEXT RECEIVE BY
; REFERENCE PACKET IN THE RECEIVE QUEUE, OPTIONALLY EXITING IF THERE IS
; NOT ONE THERE.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(81.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF WINDOW DEFINITION BLOCK
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE WINDOW DEFINITION BLOCK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NSTS=CONTROL INFORMATION.
;                       WS.MAP=1 IF RECEIVED REFERENCE IS TO BE MAPPED.
;                       WS.RCX=1 IF TASK EXIT DESIRED IF NO PACKET FOUND.
;               W.NSRB=OPTIONAL ADDRESS OF 10 WORD BUFFER FOR ADDITIONAL INFO.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF THERE IS NO
;                       RECEIVE BY REFERENCE ENTRY IN THE QUEUE.
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF THE ADDRESS
;                       CHECK OF THE RECEIVE BUFFER FAILS.
;
;       OUTPUT FIELDS IN THE WINDOW DEFINITION BLOCK ARE:
;               W.NRID=ASSIGNED REGION ID OF THE REFERENCED REGION.
;               W.NOFF=OFFSET WORD SPECIFIED BY SENDER TASK.
;               W.NLEN=LENGTH WORD SPECIFIED BY SENDER TASK.
;               W.NSTS=STATUS WORD SPECIFIED BY SENDER TASK.
;                       WS.RED=1 IF ATTACHED WITH READ ACCESS.
;                       WS.WRT=1 IF ATTACHED WITH WRITE ACCESS.
;                       WS.EXT=1 IF ATTACHED WITH EXTEND ACCESS.
;                       WS.DEL=1 IF ATTACHED WITH DELETE ACCESS.
;                       WS.RRF=1 IF RECEIVE WAS SUCCESSFUL.
;-

$DRRRF::MOV     KISAR6,-(SP)    ;SAVE APR6 BIAS
        MOV     R3,-(SP)        ;SAVE WINDOW DEFINITION BLOCK POINTER
        MOV     T.RRFL(R5),R2   ;PICK UP FIRST RECEIVE BY REF PACKET
        BEQ     60$             ;IF EQ THERE IS NONE
        CLR     -(SP)           ;INIT EFN ADDRESS
        CLR     -(SP)           ;INIT EFN MASK
        TST     (R2)+           ;POINT TO RECEIVER TCB ADDRESS IN PACKET
        MOV     (R2)+,R0        ;PICK UP TCB ADDRESS
        BEQ     20$             ;IF EQ NONE SPECIFIED
        DECB    T.SRCT(R0)      ;DECREMENT SENDER'S OUTSTANDING SREFS   ;MSH008
        MOV     (R2),(SP)       ;SET REAL EFN MASK
        MOV     2(R2),2(SP)     ;SET REAL EFN ADDRESS
20$:    MOV     R0,-(SP)        ;SAVE TCB ADDRESS
        CMP     (R2)+,(R2)+     ;SKIP TO REGION ID
        ADD     #W.NRID,R3      ;POINT TO REGION ID WORD IN DEF BLOCK
        MOV     (R2)+,(R3)+     ;STORE REGION ID
        MOV     (R2)+,(R3)+     ;STORE OFFSET
        MOV     (R2)+,(R3)+     ;STORE LENGTH
        BIS     (R2)+,(R3)+     ;STORE ACCESS
        MOV     (R3),R3         ;PICK UP VIRTUAL ADDR OF EXTENDED INFO BUFFER
        BEQ     40$             ;IF EQ THERE ONE WAS NOT SPECIFIED
        MOV     #10.*2,R1       ;SET SIZE TO ADDRESS CHECK
        MOV     R2,-(SP)        ;SAVE R2
        CALL    $ACHKP          ;ADDRESS CHECK THE BUFFER
        MOV     (SP)+,R2        ;RESTORE R2
        MOV     -14(R2),(R3)+   ;STORE THE TASK NAME IN THE BUFFER
        MOV     -12(R2),(R3)+   ;
        MOV     -16(R2),R0      ;PICK UP SENDER TCB ADDRESS
        BEQ     25$             ;IF EQ THERE IS NONE
        MOV     T.NAM+2(R0),-(R3) ;SET REAL TASK NAME
        MOV     T.NAM(R0),-(R3) ;
        CMP     (R3)+,(R3)+     ;POINT PAST TASK NAME
25$:    MOV     #8.,R0          ;SET LOOP COUNT FOR REST OF INFO
30$:    MOV     (R2)+,(R3)+     ;MOVE REST OF EXTRA INFO
        DEC     R0              ;DONE YET?
        BGT     30$             ;IF GT NO
40$:    MOV     R5,R3           ;SAVE RECEIVER TASK TCB ADDRESS
        MOV     (SP)+,R5        ;RETRIEVE SENDER TASK TCB ADDRESS
        MOV     (SP)+,R0        ;RETRIEVE EVENT FLAG MASK
        MOV     (SP)+,R1        ;RETRIEVE EVENT FLAG WORD ADDRESS
        BEQ     50$             ;IF EQ NO FLAG TO SET
        CALL    $SETM           ;SET THE EVENT FLAG
50$:    MOV     R3,R5           ;RESTORE TCB ADDRESS
        MOV     R5,R0           ;POINT TO RECEIVE BY REFERENCE LISTHEAD
        ADD     #T.RRFL,R0      ;
        CALL    $QRMVF          ;REMOVE PROCESSED PACKET
        MOV     R1,R0           ;COPY POINTER TO PACKET
        CALL    $DEPKT          ;DEALLOCATE PACKET
        MOV     (SP)+,R3        ;RESTORE WINDOW DEFINITION POINTER
        MOV     (SP)+,KISAR6    ;RESTORE KERNAL APR6 BIAS
        BIS     #WS.RRF,W.NSTS(R3) ;INDICATE SUCCESSFUL RECEIVE BY REFERENCE
        BIT     #WS.MAP,W.NSTS(R3) ;WINDOW MAP DESIRED?
        BEQ     80$             ;IF EQ NO
        CALLR   $DRMAP          ;MAP WINDOW
60$:    BIT     #WS.RCX,W.NSTS(R3) ;DOES TASK WISH TO EXIT?
        BEQ     70$             ;IF EQ NO
        CMP     (SP)+,(SP)+     ;CLEAN STACK
        JMP     $DREXT          ;PERFORM TASK EXIT
70$:    DRSTS   D.RS8           ;NO REFERENCES IN QUEUE
80$:    RETURN                  ;

        .ENDC


;+
; **-$DRGMX-GET MAPPING CONTEXT
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO RETURN THE MAPPING CONTEXT OF
; THE TASK, I.E. TO FILL IN UP TO N WINDOW DEFINITION BLOCKS,
; WHERE N IS THE TOTAL NUMBER OF WINDOW BLOCKS IN THE TASK HEADER.
; NO INFORMATION IS RETURNED ON UNUSED WINDOW BLOCKS.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(113.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF THE N WINDOW DEFINITION BLOCKS
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       (R3)=ADDRESS OF N WINDOW DEFINITION BLOCKS
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE WINDOW DEFINITION BLOCKS ARE:
;               NONE.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF THE ADDRESS
;                       CHECK OF THE N WINDOW BLOCKS PLUS TERMINATOR WORD
;                       FAILS.
;
;       OUTPUT FIELDS IN EACH WINDOW DEFINITION BLOCK ARE:
;               W.NID=ADDRESS WINDOW ID OF NEXT ESTABLISHED ADDRESS WINDOW.
;               W.NAPR=BASE APR OF THE WINDOW.
;               W.NBAS=VIRTUAL BASE ADDRESS OF THE WINDOW.
;               W.NSIZ=SIZE OF THE ADDRESS WINDOW.
;               W.NRID=REGION ID IF MAPPED OR UNMODIFIED.
;               W.NOFF=OFFSET IN REGION IF MAPPED OR UNMODIFIED.
;               W.NLEN=LENGTH OF MAP IF MAPPED OR UNMODIFIED.
;               W.NSTS=NECESSARY BITS TO RESTORE MAPPING OR 0 IF NOT MAPPED.
;                       WS.MAP=1 IF WINDOW IS MAPPED.
;                       WS.WRT=1 IF WINDOW IS MAPPED WITH WRITE ACCESS.
;-


        .IF DF  P$$GMX

$DRGMX::MOV     H.WND(R4),R4    ;POINT TO NUMBER OF WINDOW BLOCKS IN HEADER
        MOV     (R4)+,R1        ;PICK UP NUMBER OF WINDOW BLOCKS
        MOV     R1,-(SP)        ;SAVE NUMBER OF WINDOW BLOCKS
        ASL     R1              ;CONVERT TO BYTES TO ADDRESS CHECK
        ASL     R1              ;
        ASL     R1              ;
        INC     R1              ;(INCLUDE WORD FOR TERMINATOR)
        ASL     R1              ;
        MOV     (R3),R3         ;PICK UP VIRTUAL ADDRESS OF WINDOW BLOCKS
        CALL    $ACHKP          ;ADDRESS CHECK AND MAP TO WINDOW BLOCKS
        CLR     -(SP)           ;INITIALIZE WINDOW ID COUNTER
10$:    TST     W.BSIZ(R4)      ;IS NEXT BLOCK AN ESTABLISHED WINDOW?
        BNE     11$             ;IF NE YES
        ADD     #W.BLGH,R4      ;POINT TO NEXT WINDOW BLOCK
        BR      40$             ;BRANCH TO DETERMINE IF MORE BLOCKS
11$:    MOVB    (SP),(R3)+      ;SET WINDOW ID (W.NID)
        MOV     (R4)+,-(SP)     ;SAVE PCB ADDRESS (W.BPCB)
        MOV     (R4)+,R1        ;PICK UP LOW VIRTUAL ADDRESS (W.BLVR)
        MOVB    -1(R4),(R3)     ;GET ITS HIGH BYTE (W.BLVR+1)(W.NAPR)
        ASLB    (R3)            ;SHIFT TO FORM APR NUMBER (W.NAPR)
        ROLB    (R3)            ;
        ROLB    (R3)            ;
        ROLB    (R3)+           ;
        MOV     R1,(R3)+        ;SET VIRTUAL BASE ADDRESS (W.NBAS)
        MOV     (R4)+,R2        ;PICK UP HIGH VIRTUAL ADDRESS (W.BHVR)
        MOV     (R4)+,R0        ;PICK ATT DESCRIPTOR ADDRESS (W.BATT)
        MOV     (R4)+,(R3)+     ;SET WINDOW SIZE (W.BSIZ)(W.NSIZ)
        TST     (SP)+           ;IS THIS WINDOW MAPPED?
        BEQ     20$             ;IF EQ NO
        MOV     R0,(R3)+        ;SET REGION ID (W.NRID)
        MOV     T.ATT(R5),-(SP) ;PUSH ADDRESS OF FIRST ATTACHMENT DESCRIPTOR
        SUB     #A.TCBL,(SP)    ;POINT TO FIRST WORD
        CMP     R0,(SP)+        ;TASK REGION?
        BNE     15$             ;IF NE NO
        CLR     -2(R3)          ;SET IT TO DEFAULT TO TASK REGION (W.NRID)
15$:    MOV     (R4)+,(R3)+     ;SET OFFSET (W.BOFF)(W.NOFF)
        SUB     R1,R2           ;CALCULATE LENGTH
        ADD     #1,R2           ;
        ROL     R2              ;CONVERT TO 32W BLOCKS
        ROL     R2              ;
        ROLB    R2              ;
        SWAB    R2              ;
        MOV     R2,(R3)+        ;SET THE LENGTH (W.NLEN)
        TST     (R4)+           ;ADVANCE TO LAST PDR IMAGE (W.BFPD)
        MOV     (R4)+,(R3)      ;PICK UP LAST PDR IMAGE (W.BLPD)(W.NSTS)
        BIC     #^C4,(R3)       ;CLEAR ALL BUT WRITE ACCESS BIT (W.NSTS)
        ASR     (R3)            ;SHIFT INTO PLACE (W.NSTS)
        BIS     #WS.MAP,(R3)+   ;INDICATE WINDOW IS MAPPED (W.NSTS)
        BR      30$             ;
20$:    ADD     #W.NSTS-W.NRID,R3 ;POINT TO NEXT WINDOW ID BLOCK
        ADD     #W.BLGH-W.BOFF,R4 ;POINT TO NEXT WINDOW BLOCK
        CLR     (R3)+           ;CLEAR STATUS WORD
30$:    TST     (R3)+           ;SKIP OVER SEND/RECEIVE BUFFER ADDRESS (W.NSRB)
40$:    INC     (SP)            ;BUMP WINDOW ID
        CMP     (SP),2(SP)      ;DONE YET?
        BLO     10$             ;IF LO NO
        MOV     (SP)+,(R3)      ;STORE NUMBER OF HEADER SLOTS AS TERMINATOR
        NEG     (R3)            ;AND NEGATE
        TST     (SP)+           ;CLEAN STACK
        RETURN                  ;

        .ENDC


        .ENDC


        .END
        .TITLE  DRMKT
        .IDENT  /04/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 04
;
; D. N. CUTLER 5-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       T. J. MILLER
;
; MODIFIED BY:
;
; MARK TIME AND RUN DIRECTIVES
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  CLKDF$
        CLKDF$                  ;DEFINE CLOCK QUEUE CONTROL BLOCK OFFSETS
 
;+
; **-$DRMKT-MARK TIME
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO DECLARE A SIGNIFICANT EVENT AT A
; SPECIFIED INTERVAL FROM INSSUANCE.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(23.),DPB SIZE(5.).
;       WD. 01 -- EVENT FLAG NUMBER OF EVENT FLAG TO BE SET.
;       WD. 02 -- TIME INTERVAL MAGNITUDE.
;       WD. 03 -- TIME INTERVAL UNITS.
;       WD. 04 -- AST ENTRY POINT ADDRESS.
;
;       IF AN EVENT FLAG IS SPECIFIED, THEN IT IS CLEARED AT ISSUANCE AND
;       SET AT THE TIME OF THE SIGNIFICANT EVENT.
;
;       IF AN AST ENTRY POINT IS SPECIFIED, THEN AN ASYNCHRONOUS TRAP
;       WILL OCCUR AT THE TIME OF THE SIGNIFICANT EVENT. PS, PC, THE
;       DIRECTIVE STATUS WORD, AND THE SPECIFIED EVENT FLAG NUMBER
;       ARE PUSHED ONTO THE TASK STACK WHEN THE AST IS EFFECTED.
;
; INPUTS:
;
;       R0=EVENT FLAG MASK WORD.
;       R1=EVENT FLAG MASK ADDRESS.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE THIRD WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS WORD RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF INSUFFICIENT
;                       CORE IS AVAILABLE TO ALLOCATE CLOCK QUEUE ENTRY.
;-
 
        .ENABL  LSB
$DRMKT::MOV     -2(R3),-(SP)    ;SAVE EVENT FLAG NUMBER
        BIC     R0,(R1)         ;CLEAR EVENT FLAG
        MOV     R1,-(SP)        ;SAVE EVENT FLAG MASK ADDRESS
        MOV     R0,R4           ;SAVE EVENT FLAG MASK
        CALL    $CVRTM          ;CONVERT TIME TO CLOCK TICKS
        MOV     R0,-(SP)        ;SAVE HIGH ORDER PART OF TIME
        MOV     R1,-(SP)        ;SAVE LOW ORDER PART OF TIME
        MOV     R4,-(SP)        ;SAVE EVENT FLAG MASK
        CLR     R4              ;SET TYPE OF CLOCK QUEUE ENTRY
        MOV     (R3),-(SP)      ;SAVE AST ENTRY POINT ADDRESS
        BR      20$             ;
 
;+
; **-$DRRUN-RUN TASK
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO GENERATE A CLOCK QUEUE ENTRY
; TO CAUSE A TASK TO BE REQUESTED AT A SPECIFIED DELTA TIME FROM
; ISSUANCE AND TO OPTIONALLY REPEAT THE REQUEST PERIODICALLY.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(17.),DPB SIZE (11.).
;       WD. 01 -- FIRST HALF OF TASK NAME.
;       WD. 02 -- SECOND HALF OF TASK NAME.
;       WD. 03 -- PARTITION NAME-NOT SUPPORTED BUT MUST BE PRESENT.
;       WD. 04 -- PARTITION NAME-NOT SUPPORTED BUT MUST BE PRESENT.
;       WD. 05 -- REQUEST PRIORITY-NOT SUPPORTED BUT MUST BE PRESENT.
;       WD. 06 -- REQUEST UIC.
;       WD. 07 -- DELTA TIME MAGNITUDE.
;       WD. 10 -- DELTA TIME UNITS.
;       WD. 11 -- RESCHEDULE INTERVAL MAGNITUDE.
;       WD. 12 -- RESCHEDULE INTERVAL UNITS.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE OF THE TASK TO BE RUN.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TASK TO BE RUN.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE PARTITION NAME IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF INSUFFICIENT
;                       CORE IS AVAILABLE TO ALLOCATE CLOCK QUEUE ENTRY.
;-
 
$DRRUN::MOV     R0,R5           ;SAVE TCB ADDRESS OF TASK TO RUN
        ADD     #6,R3           ;POINT TO REQUEST UIC IN DPB
        CLR     -(SP)           ;SET DUMMY EFN NUMBER
 
 
        .IF DF  M$$MUP
 
        MOV     (R3)+,R1        ;PICK UP SPECIFIED UIC
        MOV     R3,-(SP)        ;SAVE R3
        CALL    $UISET          ;ESTABLISH DEFAULT AND CURRENT UIC'S
        MOV     (SP)+,R3        ;RESTORE R3
        BCS     30$             ;IF CS NONPRV TASK SPECIFIED DIFF UIC
        MOV     R1,-(SP)        ;SAVE CURRENT UIC
 
        .IFF
 
        MOV     (R3)+,-(SP)     ;SAVE SPECIFIED UIC
 
        .ENDC
 
 
        CALL    $CVRTM          ;CONVERT DELTA TIME TO CLOCK TICKS
        MOV     R0,-(SP)        ;SAVE HIGH ORDER PART OF TIME
        MOV     R1,-(SP)        ;SAVE LOW ORDER PART OF TIME
        MOV     #C.SSHT,R4      ;ASSUME SINGLE SHOT REQUEST
        MOV     (R3)+,R0        ;ANY RESCHEDULE INTERNAL SPECIFIED?
        BEQ     10$             ;IF EQ NO
        CMP     -(R3),-(R4)     ;ADJUST DPB ADDRESS AND ENTRY TYPE
        CALL    $CVRTM          ;CONVERT RESCHEDULE INTERNAL TO CLOCK TICKS
10$:    MOV     R0,-(SP)        ;SAVE HIGH ORDER PART OF TIME
        MOV     R1,-(SP)        ;SAVE LOW ORDER PART OF TIME
20$:    CALL    $ALCLK          ;ALLOCATE A CLOCK QUEUE CONTROL BLOCK
        MOV     (SP)+,C.RSI(R0) ;INSERT AST ADDRESS/LOW PART OF RSI
        MOV     (SP)+,C.RSI+2(R0) ;INSERT EFN MASK/HIGH PART OF RSI
        MOV     (SP)+,R2        ;RETRIEVE DELTA TIME TICKS COUNT
        MOV     (SP)+,R1        ;
        MOV     (SP)+,C.UIC(R0) ;INSERT EFN MASK ADDRESS/UIC
        MOVB    (SP)+,C.EFN(R0) ;INSERT EFN/ZERO BYTE
        CALLR   $CLINS          ;INSERT IN CLOCK QUEUE
 
 
        .IF DF  M$$MUP
 
30$:    DRSTS   D.RS16          ;PRIVILEGE VIOLATION
 
        .ENDC
 
 
        .DSABL  LSB
 
        .END
        .TITLE  DRPUT
        .IDENT  /09/
 
;
; COPYRIGHT (C) 1974, 1976, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 09
;
; D. N. CUTLER 6-SEPT-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       CHUCK SPITZ 20-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES AND MOVE
;                       ALL AST LISTHEADS TO TCB
;
;       JOHN COVERT 28-FEB-79
;               JRC003 -- RETURN IE.ITS IF TASK BUILT /-FP ATTEMPTS
;                         TO SPECIFY FLOATING EXCEPTION AST
;
; SPECIFY FLOATING POINT, POWERFAIL, AND RECEIVE AST TRAPS
;
; MACRO LIBRARY CALLS
;

        .MCALL  HDRDF$,TCBDF$,PKTDF$                                    ; CS017
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS             ;**-1
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
        PKTDF$                  ;DEFINE SPECIFIED AST TYPES             ; CS017

;+
; **-$DRFEX-SPECIFY FLOATING POINT EXCEPTION AST
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO EITHER RECORD THAT FLOATING POINT
; AST'S ARE DESIRED OR NOT DESIRED FOR THE ISSUING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(111.),DPB SIZE(2.).
;       WD. 01 -- AST ENTRY POINT ADDRESS OR ZERO.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE AST ADDRESS IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF AST'S ARE ALREADY
;                       NOT DESIRED.
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF DIRECTIVE WAS
;                       ISSUED FROM AN AST ROUTINE.
;-

        .ENABL  LSB


        .IF DF  A$$TRP&F$$LPP

$DRFEX::TST     H.FPSA(R4)      ;IS THE TASK BUILT WITH FLOATING POINT  ;JRC003
        BEQ     60$             ;IF EQ NO  -- BUILT /-FP, GIVE IE.ITS   ;JRC003
        MOV     #AS.FPA,R4      ;SET TYPE FOR FLOATING POINT AST        ; CS017
        MOV     #2,-(SP)        ;SET NUMBER OF AST PARAMETERS           ;**-1
        MOV     #9.*2,-(SP)     ;SET NUMBER OF BYTES TO ALLOCATE
        MOV     #<AS.FPA*256.>,-(SP) ;PUSH TYPE FOR FLOATING POINT AST  ; CS017
        BR      10$             ;FINISH IN COMMON CODE                  ;**-1

        .ENDC


;+
; **-$DRPUT-SPECIFY POWER RECOVERY AST
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO EITHER RECORD THAT POWER RECOVERY
; AST'S ARE DESIRED OR NOT DESIRED FOR THE ISSUING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(109.),DPB SIZE(2.).
;       WD. 01 -- AST ENTRY POINT ADDRESS OR ZERO.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE AST ADDRESS IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF AST'S ARE ALREADY
;                       NOT DESIRED.
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF DIRECTIVE WAS
;                       ISSUED FROM AN AST ROUTINE.
;-


        .IF DF  A$$TRP&P$$RFL

$DRPUT::MOV     #AS.PFA,R4      ;SET TYPE FOR POWERFAIL AST             ; CS017
        CLR     -(SP)           ;SET NUMBER OF AST PARAMETERS           ;**-1
        MOV     #7.*2,-(SP)     ;SET NUMBER OF BYTES TO ALLOCATE
        MOV     #<AS.PFA*256.>,-(SP) ;PUSH TYPE FOR POWERFAIL AST       ; CS017
        BR      10$             ;FINISH IN COMMON CODE                  ;**-1

        .ENDC


;+
; **-$DRRRA-SPECIFY RECEIVE BY REFERENCE AST
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO EITHER RECORD THAT RECEIVE
; BY REFERENCE AST'S ARE DESIRED OR NOT DESIRED FOR THE ISSUING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(21.),DPB SIZE(2.).
;       WD. 01 -- AST ENTRY POINT ADDRESS OR ZERO.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE AST ADDRESS IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF THE DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF THE DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF AST'S ARE
;                       ALREADY NOT DESIRED.
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF DIRECTIVE
;                       WAS ISSUED FROM AN AST ROUTINE.
;-


        .IF DF  A$$TRP&P$$LAS&P$$SRF

$DRRRA::MOV     #AS.RRA,R4      ;SET TYPE FOR RECEIVE BY REF AST        ; CS017
        CLR     -(SP)           ;SET NUMBER OF AST PARAMETERS           ;**-1
        MOV     #7.*2,-(SP)     ;SET NUMBER OF BYTES TO ALLOCATE
        MOV     #<AS.RRA*256.>,-(SP) ;PUSH TYPE FOR RECEIVE BY REF AST  ; CS017
        BR      10$             ;FINISH IN COMMON CODE                  ;**-1

        .ENDC


;+
; **-$DRRCV-SPECIFY RECEIVE AST
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO EITHER RECORD THAT RECEIVE
; AST'S ARE DESIRED OR NOT DESIRED FOR THE ISSUING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(107.),DPB SIZE(2.).
;       WD. 01 -- AST ENTRY POINT ADDRESS OR ZERO.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE AST ADDRESS IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF THE DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF THE DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF AST'S ARE ALREADY
;                       NOT DESIRED.
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF DIRECTIVE WAS
;                       ISSUED FROM AN AST ROUTINE.
;-


        .IF DF  A$$TRP&R$$SND

$DRRCV::MOV     #AS.RCA,R4      ;SET TYPE FOR RECEIVE DATA AST          ; CS017
        CLR     -(SP)           ;SET NUMBER OF AST PARAMETERS           ;**-1
        MOV     #7.*2,-(SP)     ;SET NUMBER OF BYTES TO ALLOCATE
        MOV     #<AS.RCA*256.>,-(SP) ;PUSH TYPE FOR RECEIVE DATA AST    ; CS017
                                                                        ;**-1
        .ENDC


        .IF DF  F$$LPP!P$$RFL!P$$SRF!R$$SND


        .IF DF  A$$TRP

10$:    BIT     #T2.AST!T2.DST,(R2) ;ISSUED FROM AST OR AST'S DISABLED?
        BNE     50$             ;IF NE YES
        MOV     (R3),R3         ;GET AST TRAP ADDRESS                   ; CS017
        BEQ     30$             ;IF EQ AST'S NOT DESIRED                ;**-1
        CALL    $SRAST          ;SEARCH FOR SPECIFIED AST CONTROL BLOCK ; CS017
        BCC     20$             ;IF CC, ONE ALREADY EXISTS              ; CS017
        CALL    $ALCLK          ;ALLOCATE AN AST CONTROL BLOCK          ; CS017
        MOV     R5,R1           ;COPY TCB ADDRESS OF CURRENT TASK       ; CS017
        MOV     T.SAST(R1),(R0) ;LINK LIST TO NEW CONTROL BLOCK         ; CS017
        MOV     R0,T.SAST(R1)   ;LINK NEW CONTROL BLOCK TO LISTHEAD     ; CS017
20$:    MOV     R0,R1           ;COPY CONTROL BLOCK ADDRESS             ; CS017
        TST     (R1)+           ;POINT TO AST TYPE IN CONTROL BLOCK     ; CS017
        MOV     (SP)+,(R1)+     ;SET AST TYPE                           ; CS017
        MOV     (SP)+,(R1)+     ;SET NUMBER OF BYTES PER AST            ; CS017
        MOV     R3,(R1)+        ;SET AST TRAP ADDRESS                   ; CS017
        MOV     (SP)+,(R1)      ;SET NUMBER OF PARAMETERS PER AST       ; CS017
        BR      40$             ;TAKE COMMON EXIT                       ; CS017
30$:    CALL    $SRAST          ;SEARCH FOR SPECIFIED AST CONTROL BLOCK ; CS017
        BCS     60$             ;IF CS, THIS TYPE NOT ENABLED           ; CS017
        MOV     (R0),(R1)       ;REMOVE THIS TYPE FROM LIST             ; CS017
        CALL    $DECLK          ;DEALLOCATE THIS CONTROL BLOCK          ; CS017
40$:    DRSTS   +1              ;RETURN SUCCESSFUL DIRECTIVE STATUS     ; CS017
50$:    DRSTS   D.RS80          ;SET DIRECTIVE STATUS                   ;**-16
60$:    DRSTS   D.RS8           ;SET DIRECTIVE STATUS

        .ENDC


        .ENDC


        .DSABL  LSB

        .END
        .TITLE  DRQIO
        .IDENT  /10.100/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 10.100
;
; D. N. CUTLER 8-OCT-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 8-MAR-77
;
;               TM075 -- ADDITION OF BLOCK LOCKING SUPPORT FOR SHARED
;                       FILES.
;
;       T. J. MILLER 27-APR-77
;
;               TM080 -- CORRECT ERROR IN CONDITIONALIZATION.
;
;       T. J. MILLER 26-JUL-77
;
;               TM097 -- DISALLOW CONTROL FUNCTIONS FROM NONPRIVILEGED
;                       TASKS TO MOUNTED MAGTAPES.
;
;               TM098 -- DO NOT CHECK DIAGNOSTIC SUBFUNCTION BIT ON
;                       DEVICES NOT SUPPORTING USER MODE DIAGNOSTICS.
;
;       T. J. MILLER 12-SEP-77
;
;               TM102 -- ALLOW MULTIPLE I/O'S FOR CHECKPOINTABLE TASKS.
;
;       B. A. O'CONNELL 12-DEC-78
;
;               BOC11 -- ACP INTERFACE CHANGES - DIRECT QUEUING TO F11ACP
;                        AND MTAACP; INTERLOCK FILE WINDOW.
;
;       B. A. O'CONNELL 30-JAN-79
;
;               BOC12 -- FOREIGN VOLUME & MULTIPLE MOUNT SUPPORT
;
;
; MACRO LIBRARY CALLS
;

        .MCALL  F11DF$,HWDDF$,PKTDF$,TCBDF$,PCBDF$
        F11DF$                  ;DEFINE FILES-11 CONTROL BLOCK OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS

;
; LOCAL DATA
;
; TEMPORARY LOCATION TO MARK STACK ADDRESS
;

MSTK:   .BLKW   1               ;

; POLISH INTERPRETER DATA BASE
;
; FUNCTION CODE DISPATCH VECTOR
;


        .IF DF  A$$CPS

FCDSP:  .WORD   FCIFC           ;10-ILLEGAL FUNCTION
        .WORD   FCPKT           ;11-FIND FILE NAME IN DIRECTORY


        .IF DF  R$$LKL

        .WORD   UNLCK           ;12-UNLOCK BLOCK

        .IFF

        .WORD   FCIFC           ;12-ILLEGAL FUNCTION

        .ENDC


        .WORD   FCPKT           ;13-REMOVE FILE NAME FROM DIRECTIRY
        .WORD   FCPKT           ;14-ENTER FILE NAME IN DIRECTORY
        .WORD   FCACC           ;15-ACCESS FILE FOR READ
        .WORD   FCACC           ;16-ACCESS FILE FOR READ AND WRITE
        .WORD   FCACC           ;17-ACCESS FILE FOR READ, WRITE, AND EXTEND
        .WORD   FCDAC           ;20-DEACCESS FILE
        .WORD   FCRVB           ;21-READ VIRTUAL BLOCK
        .WORD   FCWVB           ;22-WRITE VIRTUAL BLOCK
        .WORD   FCEXT           ;23-EXTEND FILE                         ; BOC11
        .WORD   FCCRE           ;24-CREATE FILE                         ;**-1
        .WORD   FCDEL           ;25-MARK FILE FOR DELETE/TRUNCATE FILE  ; BOC11
        .WORD   FCPKT           ;26-READ FILE ATTRIBUTES                ;**-1
        .WORD   FCPKT           ;27-WRITE FILE ATTRIBUTES
        .WORD   FCPKT           ;30-USER MAGTAPE CONTROLL FUNCTION
        .WORD   FCWVB           ;31-TRANSMIT PROCESS MESSAGE
        .WORD   FCRVB           ;32-RECEIVE PROCESS MESSAGE
        .WORD   FCCON           ;33-CONNECT TO PROCESS
        .WORD   FCDIS           ;34-DISCONNECT FROM PROCESS
        .WORD   FCNCT           ;35-NETWORK CONTROL FUNCTION
        .WORD   FCIFC           ;36-ILLEGAL FUNCTION
        .WORD   FCIFC           ;37-ILLEGAL FUNCTION


        .IF NDF M$$NET

FCCON:                          ;REF LABEL IF NO NETWORK SUPPORT
FCDIS:                          ;REF LABEL IF NO NETWORK SUPPORT
FCNCT:                          ;REF LABEL IF NO NETWORK SUPPORT

        .IFTF

;
; ILLEGAL FUNCTION
;

FCIFC:  .WORD   IEIFC           ;SET ILLEGAL FUNCTION STATUS

;
; ACCESS FILE FOR READ, READ/WRITE, OR READ/WRITE/EXTEND
;

FCACC:  .WORD   CKDMO           ;CHECK IF VOLUME MARKED FOR DISMOUNT
        .WORD   CKALN           ;CHECK IF FILE ALREADY ACCESSED ON LUN  ; BOC12
        .WORD   CKMOU           ;CHECK VOLUME MOUNTED THIS USER         ; BOC12
        .WORD   CKACP           ;SET FLAG TO QUEUE TO ACP               ; BOC12
        .WORD   BDPKT           ;BUILD AN I/O PACKET                    ;**-1
        .WORD   CKRLK           ;SYNCHRONIZE ACCESS AND EXIT

;
; DEACCESS FILE
;

FCDAC:  .WORD   CKNLN           ;CHECK IF FILE ACCESSED ON LUN
                                                                        ; BOC11
        .IF     DF,A$$NSI                                               ; BOC11
                                                                        ; BOC11
        .WORD   CKQMT           ;QUEUE TO MTAACP IF ANSI                ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
        .WORD   BDPKT           ;BUILD AN I/O PACKET
        .WORD   CKRLK           ;EXIT

;
; READ VIRTUAL BLOCK
;

FCRVB:  .WORD   CKNLN           ;CHECK IF FILE ACCESSED ON LUN
        .WORD   CKRAC           ;CHECK READ ACCESS AND EXIT

;
; WRITE VIRTUAL BLOCK
;

FCWVB:  .WORD   CKNLN           ;CHECK IF FILE ACCESSED ON LUN
        .WORD   CKWAC           ;CHECK WRITE ACCESS AND EXIT

;
; CREATE FILE
;       CREATE & ACCESS NOT LEGAL COMBINATION                           ; BOC12
;

FCCRE:  .WORD   CKDMO           ;CHECK IF VOLUME MARKED FOR DISMOUNT
        .WORD   CKALN           ;CHECK IF FILE ACCESSED ON LUN          ; BOC12
        .WORD   CKPKT           ;JOIN COMMON ACP & CHECK MOUNT          ; BOC12
                                                                        ;**-1
;                                                                       ; BOC11
; DELETE FILE -- CHECK IF REALLY TRUNCATE                               ; BOC11
; DON'T MOVE THIS - FALLS THRU TO FCPKT                                 ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
FCDEL:  .WORD   CKTRN           ;CHECK IF REALLY TRUNCATE               ; BOC11
                                                                        ; BOC11
;
; BUILD AN I/O PACKET FOR FIND, ENTER, REMOVE, READ ATTRIBUTES          ; BOC11
; AND WRITE ATTRIBUTES                                                  ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
FCPKT:  .WORD   CKACP           ;SET FLAG TO QUEUE TO ACP               ; BOC11
        .WORD   CKMOU           ;CHECK VOLUME MOUNTED THIS USER         ; BOC12
        .WORD   BDPKT           ;BUILD AN I/O PACKET                    ; BOC11
        .WORD   CKXIT           ;EXIT                                   ;**-5

;                                                                       ; BOC11
; EXTEND FILE -- INCR WINDOW TURN PENDING COUNT                         ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
FCEXT:  .WORD   CKPND           ;INCR WINDOW TURN PENDING CNT FOR EXTEND; BOC11
                                                                        ; BOC11
;
; EXPLICIT UNLOCK BLOCK FUNCTION
;


        .IF DF  R$$LKL

UNLCK:  .WORD   CKNLN           ;CHECK IF FILE ACCESSED ON LUN
        .WORD   UNLXT           ;SET REGISTERS AND EXIT

        .ENDC


        .IFF

;
; CONNECT TO PROCESS
;

FCCON:  .WORD   CKDMO           ;CHECK IF VOLUME MARKED FOR DISMOUNT
        .WORD   CKALN           ;CHECK IF PROCESS ALREADY CONNECTED ON LUN
        .WORD   CKCON           ;ADDRESS CHECK CONNECT BUFFER AND EXIT
        .WORD   CKRLK           ;INTERLOCK LUN USAGE AND EXIT

;
; DISCONNECT FROM PROCESS
;

FCDIS:  .WORD   CKNLN           ;CHECK IF PROCESS CONNECTED ON LUN
        .WORD   CKDIS           ;CHECK BUFFER AND COPY PARAMETERS
        .WORD   CKRLK           ;INTERLOCK LUN USAGE AND EXIT

;
; NETWORK CONTROL FUNCTION
;

FCNCT:  .WORD   CKDMO           ;CHECK IF VOLUME MARKED FOR DISMOUNT
        .WORD   CKCON           ;ADDRESS CHECK BUFFER
        .WORD   CKXIT           ;EXIT


        .ENDC


        .ENDC


;+
; **-$DRQIO-QUEUE I/O REQUEST
; **-$DRQIW-QUEUE I/O REQUEST AND WAIT.
;
; THESE DIRECTIVES INSTRUCT THE SYSTEM TO PLACE AN I/O REQUEST IN A
; QUEUE OF PRIORITY ORDERED REQUESTS FOR A DEVICE-UNIT SPECIFIED BY
; A LOGICAL UNIT NUMBER.  IN ADDITION, IF THE DIRECTIVE IS QIO AND
; WAIT AND AN EVENT FLAG IS SPECIFIED, THE TASK IS PUT INTO A WAIT STATE
; FOR THE SPECIFIED EVENT FLAG.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(1./3.),DPB SIZE(12.).
;       WD. 01 -- I/O FUNCTION CODE.
;       WD. 02 -- LUN AND UNUSED BYTE.
;       WD. 03 -- EVENT FLAG NUMBER AND PRIORITY (PRIORITY IS IGNORED).
;       WD. 04 -- ADDRESS OF I/O STATUS BLOCK.
;       WD. 05 -- ADDRESS OF AST SERVICE ROUTINE.
;       WD. 06 -- PARAMETER 1.
;       WD. 07 -- PARAMETER 2.
;       WD. 10 -- PARAMETER 3.
;       WD. 11 -- PARAMETER 4.
;       WD. 12 -- PARAMETER 5.
;       WD. 13 -- PARAMETER 6.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE I/O FUNCTION CODE IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS5' IS RETURNED IF SPECIFIED
;                       LUN IS NOT ASSIGNED.
;-

        .ENABL  LSB
$DRQIO::MOV     (R3)+,-(SP)     ;SAVE I/O FUNCTION CODE
        CALL    $MPLUN          ;MAP LUN TO UCB ADDRESS
        BCC     10$             ;IF CC LUN ASSIGNED
        DRSTS   D.RS5           ;SET DIRECTIVE STATUS
10$:    BIT     #1,(R1)         ;OPERATION PENDING?
        BEQ     15$             ;IF EQ NO
        ADD     #6,SP           ;REMOV FUNC, RETURN AND +1 FROM STACK
        MOV     (R4),R0         ;GET SAVED TASK STACK POINTER
        SUB     #2,4(R0)        ;BACKUP TASK PC SO EMT WILL BE RE-EXECUTED
        CALLR   $TKWSE          ;WAITFOR SIGNIFICANT EVENT
15$:                            ;


        .IF DF  L$$DRV

        MOV     (R0),R2         ;GET DCB ADDRESS
        TST     D.DSP(R2)       ;IS THE DRIVER RESIDENT?
        BNE     16$             ;IF NE YES
        DRSTS   D.RS6           ;SET DIRECTIVE STATUS
16$:                            ;

        .ENDC


        MOV     R0,-(SP)        ;SAVE POINTER TO UCB
        MOV     R1,-(SP)        ;SAVE POINTER TO SECOND LUN WORD
        MOVB    (R3),-(SP)      ;SAVE EVENT FLAG NUMBER
        CALL    $CEFN           ;CONVERT EVENT FLAG NUMBER
        BIC     R0,(R1)         ;CLEAR SPECIFIED EVENT FLAG
        MOV     R3,-(SP)        ;SAVE ADDRESS OF I/O STATUS BLOCK ADDRESS
        MOV     (R3),R0         ;GET ADDRESS OF I/O STATUS BLOCK ADDRESS
        BEQ     20$             ;IF EQ NO I/O STATUS BLOCK SPECIFIED


        .IF DF  M$$MGE

$DQLM1::CLR     -(SP)           ;ZERO I/O STATUS BLOCK
        MTPI    (R0)+           ;
        CLR     -(SP)           ;
        MTPI    (R0)            ;
$DQLM2::                        ;REF LABEL

        .IFF


        .IF DF  A$$CHK

        MOV     #4,R1           ;SET LENGTH OF I/O STATUS BLOCK
        CALL    $ACHKW          ;ADDRESS CHECK I/O STATUS BLOCK

        .ENDC


        CLR     (R0)+           ;CLEAR I/O STATUS BLOCK
        CLR     (R0)            ;

        .ENDC


20$:    CALL    $ALPKT          ;ALLOCATE AN I/O PACKET


        .IF DF  R$$LKL

        CLR     I.PRM+16(R0)    ;INITIALLY CLEAR LOCK ENTRY POINTER

        .ENDC


        INCB    T.IOC(R5)       ;INCREMENT I/O REQUEST COUNT
        MOV     (SP)+,R3        ;RETRIEVE ADDRESS OF I/O STATUS BLOCK ADDRESS
        CMPB    -10(R3),#3      ;IS FUNCTION QIO AND WAIT?
        BNE     25$             ;IF NE NO
        MOV     R0,-(SP)        ;SAVE PACKET ADDRESS
        MOVB    2(SP),R0        ;PICK UP EVENT FLAG NUMBER
        BEQ     24$             ;IF EQ NONE SPECIFIED
        CALL    $CEFI           ;CONVERT FLAG TO MASK AND ADDRESS
        CALL    $DRWFS          ;PUT TASK IN WAIT STATE
24$:    MOV     (SP)+,R0        ;RESTORE PACKET ADDRESS
25$:    MOV     R0,R4           ;COPY PACKET ADDRESS
        TST     (R4)+           ;POINT TO SECOND WORD IN PACKET
        MOVB    T.PRI(R5),(R4)+ ;PRIORITY IS THAT OF ISSUING TASK
        MOVB    (SP)+,(R4)+     ;INSERT EVENT FLAG NUMBER
        MOV     R5,(R4)+        ;INSERT TCB ADDRESS
        MOV     (SP)+,(R4)+     ;INSERT POINTER TO SECOND LUN WORD
        MOV     (SP)+,R5        ;RETRIEVE UCB ADDRESS
        MOV     R5,(R4)+        ;INSERT UCB ADDRESS
        MOV     (SP)+,(R4)      ;INSERT I/O FUNCTION CODE
                                                                        ; BOC11
        .IF     DF,A$$CPS                                               ; BOC11
                                                                        ; BOC11
        CLR     -(SP)           ;SET FLAG TO QUEUE TO DRIVER (NE 0=ACP) ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
        MOV     R0,-(SP)        ;SAVE ADDRESS OF I/O PACKET
        CLR     -(SP)           ;CLEAR ADDRESS OF SECONDARY CONTROL BLOCK
        MOV     SP,MSTK         ;MARK STACK ADDRESS
        MOV     (R4)+,-(SP)     ;SAVE I/O FUNCTION CODE
        CLR     R2              ;ASSUME NO I/O STATUS BLOCK SPECIFIED
        MOV     (R3)+,R0        ;GET ADDRESS OF I/O STATUS BLOCK
        BEQ     30$             ;IF EQ NONE SPECIFIED
        CALL    $RELOC          ;RELOCATE I/O STATUS BLOCK ADDRESS
30$:    MOV     R0,(R4)+        ;INSERT VIRTUAL ADDRESS OF I/O STATUS BLOCK
        MOV     R1,(R4)+        ;INSERT RELOCATION BIAS
        MOV     R2,(R4)+        ;INSERT DISPLACEMENT ADDRESS
        MOV     (R3)+,(R4)+     ;INSERT AST SERVICE ROUTINE ADDRESS
        MOV     (SP),R2         ;RETRIEVE I/O FUNCTION CODE
        CLRB    R2              ;CLEAR MODIFIER FLAGS
        SWAB    R2              ;SWAP FUNCTION CODE INTO RIGHT BYTE
        BEQ     FCKIL           ;IF EQ KILL I/O FUNCTION


        .IF DF  M$$MUP

        MOV     U.OWN(R5),R0    ;IS THE DEVICE OWNED?
        BEQ     35$             ;IF EQ NO
        BITB    #US.PUB,U.ST2(R5) ;PUBLIC ACCESS ALLOWED?
        BNE     35$             ;IF NE YES
        MOV     $TKTCB,R1       ;POINT TO CURRENT TASK'S TCB
        CMP     T.UCB(R1),R0    ;DEVICE OWNED BY CURRENT TASK?
        BEQ     35$             ;IF EQ YES
        BIT     #T3.PRV,T.ST3(R1) ;CURRENT TASK PRIVILEGED?
        BNE     35$             ;IF NE YES
        JMP     IEPRI           ;ELSE PRIVILEGE VIOLATION
35$:                            ;ACCESS ALLOWED

        .ENDC


        CMP     R2,#31.         ;FUNCTION CODE IN RANGE?
        BHI     IEIFC           ;IF HI NO
        MOV     (R5),R1         ;GET ADDRESS OF DEVICE DCB
        ADD     #D.MSK,R1       ;ASSUME FUNCTION CODE IN 0-15. RANGE
        CMP     R2,#15.         ;0-15. FUNCTION CODE?
        BLOS    40$             ;IF LOS YES
        ADD     #10,R1          ;POINT TO SECOND MASK SET
        SUB     #16.,R2         ;REDUCE FUNCTION CODE
40$:    ASL     R2              ;CONVERT TO WORD INDEX
        MOV     $BTMSK(R2),R2   ;GET FUNCTION MASK WORD
        BIT     R2,(R1)+        ;IS THIS A LEGAL FUNCTION?
        BEQ     IEIFC           ;IF EQ NO
        BITB    #US.OFL,U.ST2(R5) ;DEVICE OFFLINE?
        BNE     IEOFL           ;IF NE YES
        BIT     R2,(R1)+        ;IS THIS A CONTROL FUNCTION?
        BNE     FCCTL           ;IF NE YES
        BIT     R2,(R1)+        ;IS FUNCTION NOP'ED?
        BNE     ISSUC           ;IF NE YES


        .IF DF  A$$CPS

        TST     U.CW1(R5)       ;MOUNTABLE DEVICE?
        BPL     80$             ;IF PL NO
        MOVB    U.STS(R5),R0    ;GET STATUS BYTE FOR TESTS BELOW        ; BOC12
        BITB    #US.MNT!US.FOR,R0       ;DEVICE MOUNTED AND NOT FOREIGN?; BOC12
        BNE     60$             ;IF NE NO                               ;**-1
        BIT     R2,(R1)         ;ACP FUNCTION?
        BEQ     70$             ;IF EQ NO
        MOVB    1(SP),R2        ;RETRIEVE I/O FUNCTION CODE
        SUB     #10,R2          ;NORMALIZE FOR POLISH DISPATCH
        BLT     50$             ;IF LT TABLE INCONSISTANCY
        ASL     R2              ;CONVERT TO WORD INDEX
        MOV     R5,-(SP)        ;SAVE UCB ADDRESS FOR POLISH ROUTINES
        MOV     R5,R0           ;
        MOV     I.LN2-I.PRM(R4),R1 ;SAVE ADDRESS OF SECOND LUN WORD
        MOV     R1,-(SP)        ;FOR POLISH ROUTINES
        MOV     FCDSP(R2),R5    ;GET ADDRESS OF POLISH VECTOR
        JMP     @(R5)+          ;EXECUTE POLISH ROUTINE

;                                                                       ; BOC11
;       REGISTERS AT POLISH DISPATCH:                                   ; BOC11
;                                                                       ; BOC11
;       R0 -    UCB                                                     ; BOC11
;       R1 -    ADDRESS 2ND LUN WORD                                    ; BOC11
;       R2 -    NORMALIZED FCTN CODE                                    ; BOC11
;       R3 -    POINTER TO PARAMETERS, INITIALLY -> PARAMETER 1         ; BOC11
;       R4 -    POINTER INTO I/O PACKET, INITIALLY -> I.PRM             ; BOC11
;                                                                       ; BOC11
;       SP->    2ND LUN WORD ADDRESS                                    ; BOC11
;               UCB ADDRESS                                             ; BOC11
;               FUNCTION CODE                                           ; BOC11
;       MSTK -> SECONDARY CONTROL BLOCK ADDRESS (OR 0)                  ; BOC11
;               I/O PACKET ADDRESS                                      ; BOC11
;               QUEUE FLAG (0=DRIVER; NE=ACP)                           ; BOC11
;                                                                       ; BOC11
; SEE COMMENT LOCATED BETWEEN FCXIT AND $DRQRQ FOR DETAILS ON QUEUING   ; BOC11
; AND INTERLOCKING INTERFACES FOR MOUNTABLE DEVICES.                    ; BOC11
;                                                                       ; BOC11
;
; DEVICE TABLE MASK WORD INCONSISTANCY
;

50$:    CRASH                   ;

;
; DEVICE NOT MOUNTED OR MOUNTED AS FOREIGN
;

60$:    BITB    #US.MNT,R0      ;DEVICE NOT MOUNTED OR FOR?             ; BOC12
        BEQ     65$             ;BRANCH IF MOUNTED FOREIGN              ; BOC12
;                                                                       ; BOC12
; DEVICE NOT MOUNTED                                                    ; BOC12
;       ALLOW TRANSFER FUNTCTION                                        ; BOC12
;       ACP FUNCTIONS ARE ILLEGAL                                       ; BOC12
;                                                                       ; BOC12
        BIT     R2,(R1)         ;ACP FUNCTION                           ; BOC12
        BNE     75$             ;IF NE YES                              ;**-1
        BR      FCTRN           ;

;                                                                       ; BOC12
; MOUNTED FOREIGN                                                       ; BOC12
;       CHECK IF VOLUME MOUNTED THIS USER                               ; BOC12
;       IF ACP FUNCTION:                                                ; BOC12
;               ERROR IF NO ACP                                         ; BOC12
;               COPY PARAMETERS 1-6  (NO POLISH IF FOREIGN)             ; BOC12
;               QUEUE TO ACP UNLESS UC.QUE SET (U.CTL)                  ; BOC12
;       IF TRANSFER FUNCTION:                                           ; BOC12
;               ADDRESS CHECK AND RELOCATE BUFFER ADDRESS-PARM 1        ; BOC12
;               MAP ADDRESS TO 18/22 BIT PHYSICAL ADDRESS               ; BOC12
;               INCREMENT VOLUME TRANSACTION COUNT                      ; BOC12
;               COPY PARAMETERS 2-6                                     ; BOC12
;               QUEUE TO DRIVER                                         ; BOC12
;                                                                       ; BOC12
65$:                            ;                                       ; BOC12
                                                                        ; BOC12
        .IF     DF,M$$MUP                                               ; BOC12
                                                                        ; BOC12
        CALL    CXMOU           ;CHECK VOLUME MOUNTED THIS USER         ; BOC12
        BCS     75$             ;ERROR                                  ; BOC12
                                                                        ; BOC12
        .ENDC                                                           ; BOC12
                                                                        ; BOC12
        BIT     R2,(R1)         ;ACP FUNCTION?                          ; BOC12
        BEQ     FCTRN           ;NOT ACP--TRANSFER                      ; BOC12
        TST     U.ACP(R5)       ;MOUNTED WITH AN ACP?                   ; BOC12
        BEQ     75$             ;ERROR IF NO ACP                        ; BOC12
        INC     6(SP)           ;SET FLAG TO QUEUE TO ACP               ; BOC12
        MOV     U.VCB(R5),R1    ;HAVE A VCB?                            ; BOC12
        BEQ     FCXOP           ;NO VCB THEN DON'T DO ANYTHING          ; BOC12
        INC     (R1)            ;INCREMENT VOL TRANS CNT IN VCB         ; BOC12
        BR      FCXOP           ;INSERT PARAMETERS 1-6                  ; BOC12
;
; DEVICE MOUNTED AND NOT FOREIGN BUT NOT ACP FUNCTION
;

70$:    CMP     #IO.LOV,(SP)    ;LOAD OVERLAY FUNCTION?
        BEQ     FCTRN           ;IF EQ YES
        MOV     $TKTCB,R0       ;GET ADDRESS OF TCB OF CURRENT TASK
        BIT     #T3.PRV,T.ST3(R0) ;TASK PRIVILEGED?
        BNE     FCTRN           ;IF NE YES
75$:    JMP     IEPRI           ;PRIVILEGE VIOLATION

        .ENDC


;
; DEVICE IS NOT MOUNTABLE
;

80$:    BIT     R2,(R1)         ;ACP FUNCTION?
        BEQ     FCTRN           ;IF EQ NO

;
; FUNCTION IS A FILE STRUCTURE FUNCTION FOR A NONFILE STRUCTURED DEVICE. BY DEF-
; INITION THIS MUST BE A READ OR WRITE VIRUTAL SINCE ALL OTHER FUNCTIONS WOULD
; HAVE BEEN EITHER ILLEGAL OR NOP'ED. MAP FUNCTION TO IT LOGICAL COUNTERPART.
;

        MOV     #IO.RLB,I.FCN-I.PRM(R4) ;ASSUME FUNCTION IS READ VIRTUAL
        CMP     #IO.RVB,(SP)    ;READ VIRTUAL FUNCTION?
        BEQ     FCTRN           ;IF EQ YES
        MOV     #IO.WLB,I.FCN-I.PRM(R4) ;SET FUNCTION TO WRITE LOGICAL BLOCK
        .DSABL  LSB

;
; FUNCTION IS A TRANSFER FUNCTION-ADDRESS CHECK AND MAP TRANSFER
;

FCTRN:  CALL    FACHK           ;PERFORM ADDRES CHECK                   ; BOC11
                                                                        ; BOC11
        .IF     DF,M$$MGE                                               ; BOC11
                                                                        ; BOC11
        CALL    $MPPHY          ;MAP TO 18/22 BIT PHYS ADDR             ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
        CALL    FCXR1           ;INSERT RELOC DISP & BIAS; & PARM 2-6   ; BOC11
        BR      FCXTR           ;                                       ; BOC11
                                                                        ;**-36
;
; FUNCTION IS A KILL I/O FUNCTION-FLUSH I/O QUEUE OF TASK REQUESTS
;

FCKIL:  CALL    $IOKIL          ;FLUSH I/O QUEUE

;
; FUNCTION IS A NOP'ED FUNCTION-DECLARE SUCCESSFUL COMPLETION STATUS
;

ISSUC:  MOV     #IS.SUC&377,R4  ;SET SUCCESSFUL COMPLETION CODE         ;**-1
        BR      IECOM           ;                                       ; BOC11
                                                                        ;**-1
;
; FUNCTION IS AN ILLEGAL FUNCTION-DECLARE ILLEGAL FUNCTION CODE STATUS
;

IEIFC:  MOV     #IE.IFC&377,R4  ;SET ILLEGAL FUNCTION CODE
        BR      IECOM           ;                                       ; BOC11
                                                                        ;**-1
;
; SPECIFIED DEVICE IS OFFLINE
;

IEOFL:  MOV     #IE.OFL&377,R4  ;SET DEVICE OFFLINE STATUS
        BR      IECOM           ;                                       ; BOC11
                                                                        ;**-2
;
; FUNCTION IS A CONTROL FUNCTION-COPY REMAINDER OF DPB
;

FCCTL:                          ;REF LABEL


        .IF DF  A$$NSI

        TST     U.CW1(R5)       ;MOUNTABLE DEVICE?
        BPL     10$             ;IF PL NO
        BITB    #US.MNT!US.FOR,U.STS(R5) ;MOUNTED AND NOT FOREIGN?
        BNE     10$             ;IF NE NO
        BITB    #US.LAB,U.STS(R5) ;IS IT AN ANSI TAPE?
        BEQ     10$             ;IF EQ NO
        MOV     $TKTCB,R0       ;POINT TO CURRENT TASK TCB
        BIT     #T3.PRV,T.ST3(R0) ;TASK PRIVILEGED?
        BEQ     IEPRI           ;IF EQ NO

        .ENDC


10$:                            ;                                       ; BOC11
FCXOP:  CALL    FCXP1           ;INSERT PARAMETERS 1 TO 6               ; BOC11
FCXTR:                          ;REFERENCE LABEL                        ; BOC11
                                                                        ;**-6

        .IF DF  D$$IAG

        BITB    #IQ.UMD,(SP)    ;IS THIS A DIAGNOSTIC FUNCTION?
        BEQ     10$             ;IF EQ NO
        BIT     #DV.UMD,U.CW1(R5) ;DOES DEVICE SUPPORT DIAGNOSTICS?
        BEQ     10$             ;IF EQ NO
        CMPB    1(SP),#IO.ATT/256. ;IS THIS AN ATTACH FUNCTION?
        BEQ     10$             ;IF EQ YES, SKIP RELOCATION
        CMPB    1(SP),#IO.DET/256. ;IS THIS A DETACH FUNCTION?
        BEQ     10$             ;IF EQ YES
        BITB    #US.UMD,U.ST2(R5) ;IS DEVICE ATTACHED FOR DIAGNOSTICS?
        BEQ     IEPRI           ;IF EQ NO, PRIVILEGE VIOLATION
        MOV     (R4),R0         ;PICK UP REGISTER BUFFER ADDRESS


        .IF DF  A$$CHK!M$$MGE

        MOV     #40.*2,R1       ;PICK UP MAX LENGTH
        CALL    $ACHCK          ;ADDRESS CHECK REGISTER BUFFER
        BCS     IESPC           ;IF CS ADDRESS CHECK FAILED

        .ENDC


        CALL    $RELOC          ;RELOCATE REGISTER BUFFER
        MOV     R1,(R4)+        ;STORE KISAR6 BIAS
        MOV     R2,(R4)         ;STORE DISPLACEMENT
10$:                            ;REF LABEL

        .ENDC


        CMP     #IO.LOV,(SP)+   ;IS THIS A LOAD OVERLAY FUNCTION?
        BNE     FCXIT           ;IN NE NO
        TST     U.CW1(R5)       ;MOUNTABLE DEVICE?
        BPL     FCXIT           ;IF PL NO
        MOV     $TKTCB,R3       ;GET ADDRESS OF TCB OF CURRENT TASK
        MOV     T.LDV(R3),R0    ;GET UCB ADDRESS OF LOAD DEVICE
        CALL    $MPLND          ;MAP TO ACTUAL UCB ADDRESS
        CMP     R0,R5           ;LOAD DEVICE UCB MATCH SPECIFIED UCB?
        BNE     IEOVR           ;IF NE NO
        ADD     T.LBN+1(R3),-(R4) ;ADD IN LOW PART OF TASK LOGICAL
        ADC     -(R4)           ;BLOCK NUMBER
        MOVB    T.LBN(R3),R0    ;GET HIGH BYTE OF TASK LOGICAL BLOCK NUMBER
        ADD     R0,(R4)         ;ADD IN HIGH PART
FCXIT:  TST     (SP)+           ;CLEAN STACK
        MOV     (SP)+,R1        ;RETRIEVE ADDRESS OF I/O PACKET
                                                                        ; BOC11
        .IF     DF,A$$CPS                                               ; BOC11
                                                                        ; BOC11
        TST     (SP)+           ;QUEUE TO DRIVER??                      ; BOC11
        BEQ     $DRQRQ          ;IF .EQ. YES; IF .NE. Q ACP             ; BOC11
        BITB    #UC.QUE,U.CTL(R5)       ;IF SET QUEUE TO DRIVER         ; BOC11
        BNE     $DRQRQ          ;EVEN IF ACP FUNCTION                   ; BOC11
        MOV     U.ACP(R5),R0    ;                                       ; BOC11
        CALLR   $EXRQP          ;INSURE FILE SYSTEM ACTIVE              ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
;                                                                       ; BOC11
; DESCIPTION OF QUEUING AND INTERLOCKING INTERFACES                     ; BOC11
;       FOR MOUNTABLE DEVICES.                                          ; BOC11
;                                                                       ; BOC11
;       I.  NOT MOUNTED - ALLOW TRANSFER FUNCTIONS.                     ; BOC11
;               ACP FCTNS ARE ILLEGAL.                                  ; BOC11
;               ADDRESS CHECK & AND MAP BUFFER ADDRESS IN               ; BOC11
;                       PARAMETER 1                                     ; BOC11
;               QUEUE TO DRIVER.                                        ; BOC11
;                                                                       ; BOC11
;       II. MOUNTED                                                     ; BOC11
;               A. ALL CASES - IF 'UC.QUE' SET IN 'U.CTL' THEN QUEUE    ; BOC11
;                       TO DRIVER. (NECESSARY TO SUPPORT EXISTING       ; BOC11
;                       DRIVERS THAT ARE REALLY ALSO LIKE ACP'S)        ; BOC11
;                                                                       ; BOC11
;               B. MOUNTED FOREIGN                                      ; BOC11
;                       1. XFER FCTN - ADDRESS CHECK AND MAP            ; BOC11
;                               BUFFER ADDRESS IN PARAMETER 1. COPY     ; BOC11
;                               PARAMETERS 2-6. QUEUE TO DRIVER.        ; BOC11
;                       2. ACP FCTN - ERROR IF NO ACP. COPY PARAMETERS  ; BOC11
;                               1-6. NO POLISH ROUTINE PROCESSING.      ; BOC11
;                               INCREMENT VOLUME TRANSACTION COUNT.     ; BOC11
;                               QUEUE TO ACP.                           ; BOC11
;                                                                       ; BOC11
;               C. MOUNTED NOT FOREIGN                                  ; BOC11
;                       1. XFER FCTN - EITHER OVERLAY OR PRIVILEGED     ; BOC11
;                               TASK I/O.  ADDRESS CHECK AND MAP        ; BOC11
;                               BUFFER ADDRESS IN PARAMETER 1. COPY     ; BOC11
;                               PARAMETERS 2-6. QUEUE TO DRIVER.        ; BOC11
;                       2. DECNET ACP - I/O FUNCTION CODES ARE DISJOINT ; BOC11
;                               FROM FILES ACPS' FUNCTION CODES. POLISH ; BOC11
;                               ROUTINE PROCESSING.  QUEUED TO DRIVER   ; BOC11
;                               BECAUSE 'UC.QUE' SET.                   ; BOC11
;                       3. ANSI MAGTAPE ACP (MTAACP) - SAME FUNCTION    ; BOC11
;                               CODES AS DISK FILE ACP (F11ACP) BUT     ; BOC11
;                               NOT ALL ARE ALLOWED. POLISH ROUTINE     ; BOC11
;                               PROCESSING. ALL OPERATIONS QUEUED TO    ; BOC11
;                               MTAACP. NO BLOCK LOCKING. ACCESS/DEACCES; BOC11
;                               INTERLOCK BUT NO WINDOW-TURN PENDING    ; BOC11
;                               COUNT BECAUSE EVERYTHING QUEUED TO ACP. ; BOC11
;                               INCREMENT VOLUME TRANSACTION COUNT.     ; BOC11
;                       4. FILES-11 DISK ACP (F11ACP) - POLISH ROUTINE  ; BOC11
;                               PROCESSING. TABLE BELOW DESCIBES QUEUING; BOC11
;                               AND INTERLOCKING. LEGEND: A=QUEUE TO ACP; BOC11
;                               D=QUEUE TO DRIVER; I=INTERLOCK LUN;     ; BOC11
;                               P=INCREMENT WINDOW TURN PENDING COUNT.  ; BOC11
;                               VOLUME TRANSACTION COUNT INCREMENTED.   ; BOC11
;                               SEE COMMENT LOCATED NEAR CKRAC AND CKWAC; BOC11
;                               FOR DESCRIPTION OF WINDOW TURN PENDING  ; BOC11
;                               COUNT ALGORITHM.                        ; BOC11
;                                                                       ; BOC11
;                                                                       ; BOC11
;                       OPERATION                       QUEUE  INTERLOCK; BOC11
;                                                                       ; BOC11
;               FIND NAME IN DIRECTORY                  A       0       ; BOC11
;               ENTER NAME IN DIRECTORY                 A       0       ; BOC11
;               REMOVE NAME FROM DIRECTORY              A       0       ; BOC11
;               ACCESS FILE                             A       I       ; BOC11
;               DEACCESS FILE                           D       I       ; BOC11
;               READ/WRITE VIRTUAL BLOCK-MAP OK         D       0       ; BOC11
;               READ/WRITE VIRTUAL BLOCK-MAP FAIL       A       P       ; BOC11
;               READ/WRITE VIRTUAL BLOCK-PARTIAL MAP    D       I       ; BOC11
;               EXTEND FILE                             A       P       ; BOC11
;               CREATE FILE                             A       0       ; BOC11
;               MARK FILE FOR DELETE                    A       0       ; BOC11
;               TRUNCATE FILE                           D       I       ; BOC11
;               READ ATTRIBUTES                         A       0       ; BOC11
;               WRITE ATTRIBUTES                        A       0       ; BOC11
;                                                                       ; BOC11
;                                                                       ; BOC11

;+
; **-$DRQRQ-QUEUE I/O REQUEST
;
; THIS ROUTINE IS CALLED TO INSERT AN I/O PACKET IN A CONTROLLER QUEUE AND
; CALL THE DRIVER TO INITIATE ACTIVITY ON THE DEVICE.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O PACKET.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       THE I/O PACKET IS PLACED IN THE CONTROLLER QUEUE AND ACTIVITY
;       IS INITIATED ON THE DEVICE.
;
;       NOTE: R4 IS DESTROYED BY THIS ROUTINE.
;-

$DRQRQ::MOV     U.SCB(R5),R4    ;GET ADDRESS OF STATUS CONTROL BLOCK
        BITB    #UC.QUE,U.CTL(R5) ;QUEUE PACKET BEFORE CALL?
        BNE     10$             ;IF NE NO
        MOV     R4,R0           ;SET ADDRESS OF I/O QUEUE LISTHEAD
        CALL    $QINSP          ;QUEUE I/O PACKET IN DEVICE QUEUE
10$:    MOV     (R5),R2         ;RETRIEVE ADDRESS OF DEVICE CONTROL BLOCK


        .IF DF  L$$DRV&M$$MGE

        MOV     KISAR5,-(SP)    ;SAVE APR5
        MOV     D.PCB(R2),R3    ;GET DRIVER PCB ADDRESS
        BEQ     20$             ;IF EQ DRIVER IS PART OF EXEC
        MOV     P.REL(R3),KISAR5  ;MAP THE DRIVER
20$:                            ;

        .IFTF

        MOV     D.DSP(R2),R2    ;GET ADDRESS OF DRIVER DISPATCH TABLE

        .IFF

        CALLR   @D.VINI(R2)     ;CALL DEVICE INITIATOR

        .IFT

        CALL    @D.VINI(R2)     ;CALL DRIVER INITIATOR
        MOV     (SP)+,KISAR5    ;RESTORE APR5
        RETURN                  ;

        .ENDC



;
; ILLEGAL BUFFER ADDRESS SPECIFIED-DECLARE ILLEGAL BUFFER STATUS
;

IESPC:  MOV     #IE.SPC&377,R4  ;SET ILLEGAL BUFFER CODE
IECOM:  BR      IECMN           ;                                       ; BOC11
                                                                        ;**-1
;
; ILLEGAL LOAD OVERLAY UCB-DECLARE ILLEGAL LOAD OVERLAY FUNCTION STATUS
;

IEOVR:  MOV     #IE.OVR&377,R4  ;SET ILLEGAL LOAD OVERLAY CODE
        BR      IECMN           ;

;
; ILLEGAL BYTE COUNT OR ALIGNMENT-DECLARE ODD BYTE STATUS
;

IEBYT:  MOV     #IE.BYT&377,R4  ;SET ODD BYTE STATUS


        .IF DF  A$$CPS

        BR      IECMN           ;

;
; NO BUFFER SPACE AVAILABLE-SET NO BUFFER AVAILABLE STATUS
;

IENOD:  MOV     #IE.NOD&377,R4  ;SET NO BUFFER AVAILABLE CODE
        BR      IECMN           ;

;
; BAD PARAMETER-SET BAD PARAMETER STATUS
;

IEBAD:  MOV     #IE.BAD&377,R4  ;SET BAD PARAMETER CODE
        BR      IECMN           ;

;
; PRIVILEGE VIOLATION-SET PRIVILEGE VIOLATION STATUS
;

        .IFTF


        .IF DF  A$$CPS!D$$IAG

IEPRI:  MOV     #IE.PRI&377,R4  ;SET PRIVILEGE VIOLATION CODE
        BR      IECMN           ;

        .ENDC


        .IFT

;
; FILE ALREADY ACCESSED ON LUN-SET FILE ALREADY ACCESSED STATSU
;

IEALN:  MOV     #IE.ALN&377,R4  ;SET FILE ALREADY ACCESSED CODE
        BR      IECMN           ;

;
; NO FILE ACCESSED ON LUN-SET NO FILE ACCESSED STATUS
;

IENLN:  MOV     #IE.NLN&377,R4  ;SET NO FILE ACCESSED STATUS

        .IF     DF,R$$LKL                                               ; BOC11
                                                                        ; BOC11
        BR      IECMN           ;                                       ; BOC11
;                                                                       ; BOC11
;       BLOCK LOCKING ERROR OR UNLOCK PERFORMED                         ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
IELCK:  MOV     R0,R4           ;STATUS IN R0                           ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
;
; COMMON ERROR EXIT
;


        .IFTF

IECMN:  MOV     MSTK,SP         ;RESET STACK POINTER
        MOV     (SP)+,R0        ;RETRIEVE ADDRESS OF SECONDARY CONTROL BLOCK
        BEQ     10$             ;IF EQ NONE
        CALL    $DEPKT          ;DEALLOCATE SECONDARY CONTROL BLOCK
10$:    MOV     R4,R0           ;SET FINAL I/O STATUS
        CLR     R1              ;CLEAR SECOND I/O STATUS WORD
        MOV     (SP)+,R3        ;RETRIEVE ADDRESS OF I/O PACKET
                                                                        ; BOC11
        .IF     DF,A$$CPS                                               ; BOC11
                                                                        ; BOC11
        TST     (SP)+           ;CLEAN STACK                            ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
        MOV     I.UCB(R3),R5    ;RETRIEVE UCB ADDRESS
        CALLR   $IOFIN          ;FINISH OFF I/O OPERATION

;
; BUILD AN I/O PACKET
;

        .IFT

BDPKT:  MOV     #2*2,R1         ;SET LENGTH OF FILE ID BLOCK
        CALL    OPPRM           ;INSERT OPTIONAL FILE ID BLOCK

;
; BUILD ATTRIBUTE POINTER BLOCK
;

ATRBK:  MOV     (R3)+,(R4)+     ;ATTRIBUTE DESCRIPTOR BLOCK SPECIFIED?
        BEQ     MOVE3           ;IF EQ NO
        MOV     R3,-(SP)        ;SAVE ADDRESS OF NEXT DPB WORD
        MOV     #I.LGTH,R1      ;SET LENGTH OF SECONDARY CONTROL BLOCK
        CALL    $ALOCB          ;ALLOCATE SECONDARY CONTROL BLOCK
        BCS     IENOD           ;IF CS NO STORAGE AVAILABLE
        MOV     R0,@MSTK        ;SAVE ADDRESS OF SECONDARY CONTROL BLOCK


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;SAVE CURRENT MAPPING

        .ENDC


        MOV     -(R4),R3        ;RETRIEVE ADDRESS OF ATTRIBUTE DESCRIPTOR BLOCK
        MOV     R0,(R4)+        ;SET POINTER TO SECONDARY CONTROL BLOCK
        MOV     R4,-(SP)        ;SAVE ADDRESS OF NEXT WORD IN I/O PACKET
        MOV     R0,R4           ;SET ADDRESS OF FIRST ATTRIBUTE POINTER
        MOV     #6,-(SP)        ;SET MAXIMUM NUMBER OF ATTRIBUTE POINTERS
10$:    MOV     R3,R0           ;SET ADDRESS OF NEXT ATTRIBUTE DESCRIPTOR


        .IF DF  A$$CHK!M$$MGE

        MOV     #4,R1           ;SET SIZE OF ATTRIBUTE DESCRIPTOR
        CALL    $ACHCK          ;ADDRESS CHECK ATTRIBUTE DESCRIPTOR
        BCS     IESPC           ;IF CS ADDRESS CHECK FAILURE

        .ENDC


        .IF DF  M$$MGE

        CALL    $RELOM          ;RELOCATE AND MAP ATTRIBUTE DESCRIPTOR
        ADD     #4,R3           ;POINT TO NEXT ATTRIBUTE DESCRIPTOR

        .IFF

        CMP     (R3)+,(R3)+     ;POINT TO NEXT ATTRIBUTE DESCRIPTOR

        .ENDC


        MOVB    (R0)+,(R4)+     ;INSERT ATTRIBUTE NUMBER
        BEQ     20$             ;IF EQ END OF ATTRIBUTE DESCRIPTOR BLOCK
        CLR     R1              ;PICKUP SIZE OF ATTRIBUTE BLOCK
        BISB    (R0)+,R1        ;
        MOVB    R1,(R4)+        ;INSERT LENGTH OF ATTRIBUTE BLOCK
        BNE     15$             ;IF NE LENGTH OKAY
        MOV     #256.*2,R1      ;SET LENGTH FOR ZERO CASE
15$:    MOV     (R0),R0         ;GET ADDRESS OF ATTRIBUTE BLOCK


        .IF DF  A$$CHK!M$$MGE

        CALL    $ACHCK          ;ADDRESS CHECK ATTRIBUTE BLOCK
        BCS     IESPC           ;IF CS ADDRESS FAILURE

        .ENDC


        CALL    $RELOC          ;RELOCATE ATTRIBUTE BLOCK ADDRESS
        MOV     R1,(R4)+        ;INSERT RELOCATION BIAS
        MOV     R2,(R4)+        ;INSERT ATTRIBUTE BLOCK ADDRESS
        DEC     (SP)            ;ANY MORE SPACE IN POINTER BLOCK?
        BGT     10$             ;IF GT YES
20$:    TST     (SP)+           ;CLEAN STACK
        MOV     (SP)+,R4        ;RETRIEVE ADDRESS OF NEXT WORD IN I/O PACKET


        .IF DF  M$$MGE

        MOV     (SP)+,KISAR6    ;RESTORE CURRENT MAPPING

        .ENDC


        MOV     (SP)+,R3        ;RETRIEVE ADDRESS OF NEXT WORD IN DPB

;
; MOVE EXTEND AND ACCESS CONTROL WORDS INTO I/O PACKET
;

MOVE3:  MOV     (R3)+,(R4)+     ;INSERT EXTEND CONTROL WORDS
        MOV     (R3)+,(R4)+     ;
        MOV     (R3)+,(R4)+     ;INSERT ACCESS CONTROL WORD

;
; INSERT OPTIONAL FILENAME BLOCK
;

FILNM:  MOV     #13.*2,R1       ;SET LENGTH OF FILENAME BLOCK
        CALL    OPPRM           ;INSERT OPTIONAL FILENAME BLOCK
        JMP     @(R5)+          ;

;
; INTERPRET REQUIRED BLOCK ADDRESS
;

        .ENABL  LSB
RQPRM:  MOV     SP,R2           ;SET REQUIRED PARAMETER FLAG
        BR      10$             ;

;
; INTERPRET OPTIONAL BLOCK ADDRESS
;

OPPRM:  CLR     R2              ;CLEAR REQUIRED PARAMETER FLAG
10$:    MOV     (R3)+,R0        ;GET ADDRESS OF CONTROL BLOCK
        BEQ     20$             ;IF EQ NONE SPECIFIED


        .IF DF  A$$CHK!M$$MGE

        CALL    $ACHCK          ;ADDRESS CHECK BLOCK
        BCS     IESPC           ;IF CS ADDRESS CHECK FAILURE

        .ENDC


        CALL    $RELOC          ;RELOCATE BUFFER ADDRESS
        MOV     R1,(R4)+        ;INSERT RELOCATION BIAS
        MOV     R2,(R4)+        ;INSERT BLOCK ADDRESS
        BR      30$             ;
20$:    MOV     R2,(R4)+        ;PARAMETER REQUIRED?
        BNE     IEBAD           ;IF NE YES
        CLR     (R4)+           ;CLEAR SECOND WORD
30$:    RETURN                  ;
        .DSABL  LSB

;
; FILL DISCONNECT PARAMETER BUFFER AND INTERLOCK LUN USAGE
;


        .IF DF  M$$NET

        .ENABL  LSB
CKDIS:  MOV     (R3)+,(R4)+     ;COPY FIRST PARAMETER TO I/O PACKET
        BR      10$             ;FINISH IN COMMON CODE

;
; CHECK CONNECT PARAMETER BUFFER
;

CKCON:  MOV     2(R3),R1        ;GET LENGTH OF BUFFER IN BYTES
        BEQ     IESPC           ;IF EQ ZERO LENGTH
        CALL    RQPRM           ;INSERT REQUIRED PARAMETER
10$:    CALL    FCXP2           ;INSERT PARAMETERS                      ; BOC11
        JMP     @(R5)+          ;                                       ;**-5
        .DSABL  LSB

        .ENDC


;
; CHECK FOR VOLUME MARKED FOR DISMOUNT
;

CKDMO:  BITB    #US.MDM,U.STS(R0) ;VOLUME MARKED FOR DISMOUNT?
        BNE     IEPRI           ;IF NE YES
        JMP     @(R5)+          ;

;                                                                       ; BOC12
; CHECK VOLUME MOUNTED BY THIS USER                                     ; BOC12
;                                                                       ; BOC12
        .ENABL  LSB                                                     ; BOC12
CKMOU:                          ;                                       ; BOC12
                                                                        ; BOC12
        .IF     DF,M$$MUP                                               ; BOC12
                                                                        ; BOC12
        MOV     R5,-(SP)        ;SAVE REGISTER                          ; BOC12
        MOV     4(SP),R5        ;GET UCB ADDRESS                        ; BOC12
        CALL    CXMOU           ;CHECK MOUNT LIST                       ; BOC12
        BCS     15$             ;ERROR                                  ; BOC12
        MOV     (SP)+,R5        ;RESTORE REGISTER                       ; BOC12
                                                                        ; BOC12
        .IFTF                                                           ; BOC12
                                                                        ; BOC12
        JMP     @(R5)+          ;                                       ; BOC12
                                                                        ; BOC12
        .IFT                                                            ; BOC12
                                                                        ; BOC12
;                                                                       ; BOC12
; SUBROUTINE TO SEARCH MOUNT LIST TO SEE IF VOLUME                      ; BOC12
;       REALLY MOUNTED BY THIS USER                                     ; BOC12
;                                                                       ; BOC12
CXMOU:  MOV     R1,-(SP)        ;SAVE REGISTERS                         ; BOC12
        MOV     R2,-(SP)        ;                                       ; BOC12
        BITB    #US.PUB,U.ST2(R5)       ;PUBLIC DEVICE?                 ; BOC12
        BNE     8$              ;PUBLIC DEVICE OK                       ; BOC12
        MOV     $TKTCB,R1       ;IS TASK PRIVILEGED?                    ; BOC12
        BIT     #T3.PRV,T.ST3(R1)                                       ; BOC12
        BNE     8$              ;PRIVILEGED TASK OK                     ; BOC12
        MOV     T.UCB(R1),R1    ;GET USER TI: UCB ADDR AS ID            ; BOC12
        MOV     #$MOULS,R2      ;GET MOUNT LIST                         ; BOC12
                                                                        ; BOC12
5$:     SEC                     ;ASSUME FAIL                            ; BOC12
        MOV     (R2),R2         ;GET MOUNT LIST ENTRY                   ; BOC12
        BEQ     9$              ;NONE=DONE=FAIL                         ; BOC12
        CMP     2(R2),#4001     ;RIGHT TYPE OF ENTRY?                   ; BOC12
        BNE     5$              ;BRANCH NOT MOUNT ENTRY                 ; BOC12
        CMP     4(R2),R5        ;SAME DEVICE UCB?                       ; BOC12
        BNE     5$              ;BRANCH DIFFERENT DEVICE                ; BOC12
        CMP     6(R2),R1        ;SAME USER TI:                          ; BOC12
        BNE     5$              ;BRANCH DIFFERENT USER                  ; BOC12
                                                                        ; BOC12
8$:     CLC                     ;SUCCESS                                ; BOC12
9$:     MOV     (SP)+,R2        ;RESTORE REGISTERS                      ; BOC12
        MOV     (SP)+,R1        ;                                       ; BOC12
        RETURN                  ;                                       ; BOC12
                                                                        ; BOC12
        .ENDC                                                           ; BOC12
                                                                        ; BOC12
                                                                        ; BOC12
;
; CHECK FOR READ ACCESS PRIVILEGES                                      ; BOC11
;                                                                       ;**-1

CKRAC:  MOV     #WI.RDV,R2      ;SET READ ACCESS MASK WORD              ;**-1
        BR      10$             ;

;
; CHECK FOR WRITE ACCESS PRIVILEGES                                     ; BOC11
;                                                                       ;**-1

CKWAC:  MOV     #WI.WRV,R2      ;SET WRITE ACCESS MASK WORD
10$:    BIT     R2,@(R1)+       ;DESIRED ACCESS PERMITTED?              ; BOC11
        BNE     20$             ;IF NE YES                              ;**-11
15$:    JMP     IEPRI           ;PRIVILEGE VIOLATION                    ; BOC12
;                                                                       ; BOC11
;       ADDRESS CHECK & INSERT RELOC BIAS, DISP  & PARM 2-6             ; BOC11
;                                                                       ; BOC11
20$:    MOV     R0,R5           ;GET UCB ADDRESS                        ; BOC11
        CALL    FACHK           ;PERFORM ADDRESS CHECK                  ; BOC11
        CALL    FCXR1           ;COPY PARAMETERS                        ; BOC11
                                                                        ; BOC11
        .IF     DF,M$$NET                                               ; BOC11
                                                                        ; BOC11
        CMP     #IO.WVB,4(SP)   ;DECNET FUNCTION??                      ; BOC11
        BLT     50$             ;EXIT HERE IF DECNET                    ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
;                                                                       ; BOC11
;       ONLY READ/WRITE VIRTUAL FUNCTIONS COME HERE                     ; BOC11
;                                                                       ; BOC11
;       IF ANSI - QUEUE TO MTAACP                                       ; BOC11
;       IF F11ACP - PERFORM BLOCK LOCKING AND MAP VIRTUAL TO LOGICAL    ; BOC11
;               MAP OK - QUEUE TO DRIVER                                ; BOC11
;               MAP FAIL - INCREMENT PENDING & QUEUE TO ACP             ; BOC11
;               PARTIAL MAP - INTERLOCK & QUEUE TO DRIVER               ; BOC11
;                                                                       ; BOC11
;                                                                       ; BOC11
;       THE ROUTING OF WINDOW TURN REQUESTS DEPENDS ON THE ABILITY      ; BOC11
;       TO DISTINGUISH BETWEEN REQUESTS THAT MAP TO DISJOINT LBN'S.     ; BOC11
;       ANY NUMBER OF (SUCCESSFULLY MAPPED) REQUESTS FOR THIS LUN       ; BOC11
;       MAY BE IN THE DRIVER QUEUE ALREADY.  IF THE ACP QUEUE IS EMPTY  ; BOC11
;       THEN ANY NEXT REQUEST IS OK.  IF THE ACP QUEUE CONTAINS ONE     ; BOC11
;       REQUEST (FROM THE TRANSITION ZERO TO ONE) THEN ANY REQUEST      ; BOC11
;       THAT MAPS SUCCESSFULLY IS DISJOINT AND OK. IF THE ACP QUEUE     ; BOC11
;       HAS TWO REQUESTS (OR ONE FROM THE TRANSITION TWO TO ONE) THEN   ; BOC11
;       WE MUST WAIT FOR ZERO IN ORDER FOR THE SUCCESSFUL MAPPING OF    ; BOC11
;       VIRTUAL TO LOGICAL TO INDICATE DISJOINT LBNS.  AT THIS POINT    ; BOC11
;       THE LUN IS INTERLOCKED. (EXAMPLE: THREE REQUESTS TO SAME BLOCK; ; BOC11
;       FIRST CAUSES WINDOW TURN AND IS COMPLETED; SECOND STILL REMAINS ; BOC11
;       IN ACP QUEUE; THE THIRD WILL MAP OK BUT IT CAN NOT BE PERFORMED ; BOC11
;       SAFELY UNTIL THE SECOND IS COMPLETE.)                           ; BOC11
;       AN ALTERNATIVE ALGORITHM WOULD BE TO ROUTE ALL VIRTUAL I/O      ; BOC11
;       REQUESTS TO THE ACP IF THE 'ACP VIRTUAL PENDING COUNT' WERE     ; BOC11
;       GREATER THAN ZERO. INTERLOCK WOULD OCCUR WHEN COUNT=MAX         ; BOC11
;       (I.E. NO BITS TO COUNT HIGHER).  THE IMPLEMENTED ALGORITHM      ; BOC11
;       YIELDS BETTER PERFORMANCE WHEN LIMITED TO TWO BITS FOR PENDING  ; BOC11
;       COUNT AND INTERLOCK: THERE IS LESS LATENCY FOR ANY SECOND       ; BOC11
;       REQUEST-IT IS QUEUED TO THE DRIVER IF IT CAN BE MAPPED          ; BOC11
;       SUCCESSFULLY; BOTH ALGORITHMS CAN HANDLE ABOUT THE SAME         ; BOC11
;       NUMBER OF REQUESTS BEFORE FORCED INTERLOCK OCCURS.  IRRESPECTIVE; BOC11
;       OF THE NUMBER OF BITS AVAILABLE, THE ALTERNATIVE ALGORITHM      ; BOC11
;       ALWAYS HAS THE PROBLEM OF POSSIBLY ROUTING VIRTUAL REQUESTS     ; BOC11
;       INDEFINITELY TO THE ACP INSTEAD OF THE DRIVER.                  ; BOC11
;                                                                       ; BOC11
;       PARTIALLY MAPPED REQUESTS OBVIOUSLY SCREW UP EVERYTHING         ; BOC11
;       BECAUSE OF THE POSSIBILITY OF ACCESSING THE SAME DISK           ; BOC11
;       BLOCKS SEPARATELY, ONE BLOCK AT A TIME.                         ; BOC11
;       PARTIALLY MAPPED REQUESTS ARE QUEUED TO DRIVER FOR CORRECT      ; BOC11
;       SEQUENCING: THEY WILL BE PROCESSED AFTER THE OUTSTANDING        ; BOC11
;       MAPPED REQUESTS IN THE DISK QUEUE; $GTPKT WILL ROUTE            ; BOC11
;       THESE REQUESTS TO THE ACP SO THEY WILL ALSO FOLLOW ANY          ; BOC11
;       OUTSTANDING REQUESTS IN THE ACP QUEUE. INTERLOCK IS SET         ; BOC11
;       SO THAT ANY NEW REQUESTS WILL BE PROCESSED AFTER THE            ; BOC11
;       PARTIALLY MAPPED ONE IS COMPLETE AND THE WINDOW TURNED.         ; BOC11
;                                                                       ; BOC11
;                                                                       ; BOC11
;               WINDOW TURN PENDING COUNT ALGORITHM                     ; BOC11
;                                                                       ; BOC11
;       CURRENT         ARRIVE          ARRIVE          DEPART          ; BOC11
;       STATE           'P' CASES       'I' CASES       ALL             ; BOC11
;                       (RWVB MAP       (ACCESS,        CASES           ; BOC11
;                       FAIL, EXTEND)   DEACCESS,                       ; BOC11
;                                       RWVB PARTIAL                    ; BOC11
;                                       MAP, TRUNCATE)                  ; BOC11
;                                                                       ; BOC11
;       0  0            0  P            I  0            XXXX            ; BOC11
;       0  P            I  P            I  P            0  0            ; BOC11
;       I  0            XXXX            XXXX            0  0            ; BOC11
;       I  P            XXXX            XXXX            I  0            ; BOC11
;                                                                       ; BOC11
;                                                                       ; BOC11
;       NOTE: F11ACP RAISES WINDOW TURN PENDING TO INTERLOCK WHILE      ; BOC11
;       A WINDOW TURN OPERATION IS IN PROGRESS.  THIS MAY INVOLVE       ; BOC11
;       THE FOLLOWING STATE TRANSITION:                                 ; BOC11
;               0  P  ->  I  0                                          ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
CKLCK:                                                                  ; BOC11
                                                                        ; BOC11
        .IF     DF,A$$NSI                                               ; BOC11
                                                                        ; BOC11
        BITB    #US.LAB,U.STS(R5)       ;ANSI MAGTAPE??                 ; BOC11
        BNE     40$             ;IF ANSI-NO LOCKING, Q TO ACP           ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
        MOV     10(SP),R1       ;GET ADDRESS I/O PACKET                 ; BOC11
                                                                        ; BOC11
        .IF     DF,R$$LKL                                               ; BOC11
                                                                        ; BOC11
        CALL    $LCKPR          ;PERFORM LOCK PROCESSING                ; BOC11
        BCC     22$             ;CS IF ERROR OR UNLOCK DONE             ; BOC11
        JMP     IELCK           ;                                       ; BOC11
22$:                            ;REFERENCE LABEL                        ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
        CALL    $MPPKT          ;MAP VBN TO LBN                         ; BOC11
        MOV     (SP),R1         ;GET ADDRESS 2ND LUN WORD               ; BOC11
        BCS     30$             ;MAP FAILURE                            ; BOC11
        TST     R0              ;ALL BLOCKS MAPPED??                    ; BOC11
        BEQ     50$             ; IF .EQ. YES                           ; BOC11
        INC     (R1)            ;PARTIAL MAP-SET INTERLOCK              ; BOC11
        BR      50$             ;AND EXIT HERE                          ; BOC11
30$:    CALL    FCPND           ;MAP FAILURE - INCR WINDOW PENDING      ; BOC11
40$:    INC     12(SP)          ;MAG TAPE OR MAP FAIL - Q TO ACP        ; BOC11
50$:    TST     (SP)+           ;CLEAN STACK                            ; BOC11
        MOV     (SP)+,R5        ;RESTORE TO UCB ADDRESS                 ; BOC11
        TST     (SP)+           ;CLEAN STACK                            ; BOC11
CKJXT:  JMP     FCXIT                                                   ; BOC11
        .DSABL  LSB                                                     ;**-3

;
; CHECK FOR FILE ALREADY ACCESSED ON LUN
;

        .ENABL  LSB
CKALN:  TST     (R1)            ;FILE ACCESSED ON LUN?
        BEQ     CKJR5                   ;IF EQ NO                       ; BOC12
        JMP     IEALN           ;ERROR                                  ;**-1

;
; CHECK FOR FILE ACCESSED ON LUN
;

CKNLN:  TST     (R1)            ;FILE ACCESSED ON LUN?
        BNE     CKJR5                   ;IF NE YES                      ; BOC12
        JMP     IENLN           ;ERROR                                  ;**-1

;                                                                       ;**-10
; SET UP REGISTERS FOR UNLOCK AND EXIT TO CONTROL FUNCTION
;


        .IF DF  R$$LKL

UNLXT:  TST     (R4)+           ;ADVANCE POINTER                        ; BOC11
        MOV     R0,R5           ;UCB ADDRESS                            ; BOC11
        CALL    FCXP1           ;COPY PARAMETERS                        ; BOC11
        BR      CKLCK           ;                                       ; BOC11
                                                                        ;**-3
        .ENDC


;
; SET ACCESS/DEACCESS INTERLOCK
;

CKRLK:  INC     @(SP)           ;SET ACCESS/DEACCESS PENDING INTERLOCK

;
; EXIT POLISH TO FUNCTION EXIT
;

CKXIT:  TST     (SP)+           ;REMOVE ADDRESS OF SECOND LUN WORD
        MOV     (SP)+,R5        ;RETRIEVE UCB ADDRESS                   ;**-1
        TST     (SP)+           ;ADJUST STACK PTR                       ; BOC11
        MOV     U.VCB(R5),R1    ;INCREMENT VOLUME TRANSACTION COUNT     ; BOC11
        BEQ     CKJXT           ;IN ANY VCB                             ; BOC11
        INC     (R1)            ;                                       ; BOC11
        BR      CKJXT           ;EXIT POLISH                            ; BOC11
                                                                        ; BOC11
        .ENABL  LSB                                                     ; BOC11
;                                                                       ; BOC11
; SET FLAG TO QUEUE TO ACP IF ANSI MAGTAPE                              ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
        .IF     DF,A$$NSI                                               ; BOC11
                                                                        ; BOC11
CKQMT:: BITB    #US.LAB,U.STS(R0)       ; ANSI MAGTAPE?                 ; BOC11
        BEQ     10$                     ; IF .EQ. NOT ANSI              ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
;                                                                       ; BOC11
; SET FLAG TO QUEUE TO ACP                                              ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
CKACP:: INC     12(SP)          ;SET FLAG TO QUEUE TO ACP               ; BOC11
10$:    JMP     @(R5)+          ;                                       ; BOC11
        .DSABL  LSB                                                     ; BOC11
                                                                        ; BOC11
;                                                                       ; BOC11
; INCREMENT WINDOW TURN PENDING COUNT FOR EXTEND                        ; BOC11
; PENDING COUNT NOT MAINTAINED ANSI MAGTAPE                             ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
CKPND::                                                                 ; BOC11
                                                                        ; BOC11
        .IF     DF,A$$NSI                                               ; BOC11
                                                                        ; BOC11
        BITB    #US.LAB,U.STS(R0)       ; ANSI MAGTAPE?                 ; BOC11
        BNE     CKPKT                   ; IF .NE. YES - SKIP INCR PEND  ; BOC11
                                                                        ; BOC11
        .ENDC                                                           ; BOC11
                                                                        ; BOC11
        TST     (R1)            ;HAVE A WINDOW?                         ; BOC11
        BEQ     CKPKT           ;NO - DON'T INCR WINDOW PEND NO WINDOW  ; BOC11
        CALL    FCPND           ;INCREMENT WINDOW TURN PENDING COUNT    ; BOC11
CKPKT:  MOV     #FCPKT,R5       ;JOIN COMMON ACP REQUESTS               ; BOC11
CKJR5:  JMP     @(R5)+          ;                                       ; BOC11
                                                                        ; BOC11
;                                                                       ; BOC11
; CHECK IF DELETE OR TRUNCATE OPERATION                                 ; BOC11
;       ONLY F11ACP ALLOWS DELETE, ILLEGAL DECNET & MTAACP              ; BOC11
;               DELETE - FALL THRU SO QUEUE TO ACP                      ; BOC11
;               TRUNCATE BUT NO WINDOW - TREAT LIKE DELETE              ; BOC11
;                       CANT SET INTERLOCK SO MUST Q TO ACP             ; BOC11
;               TRUNCATE - ADVANCE R5 SO NO QUEUE TO ACP                ; BOC11
;                       & SET INTERLOCK                                 ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
CKTRN:: TST     (R1)            ;HAVE A WINDOW                          ; BOC11
        BEQ     10$             ;NO WINDOW - DON'T DO ANYTHING          ; BOC11
        TST     4(R3)           ;NEG PARAMETER = TRUNCATE               ; BOC11
        BPL     10$             ;FALL THRU IF NORMAL DELETE             ; BOC11
        TST     (R5)+           ;SKIP OVER Q TO ACP                     ; BOC11
        INC     (R1)            ;SET INTERLOCK                          ; BOC11
10$:    JMP     @(R5)+          ;                                       ; BOC11
                                                                        ; BOC11
;                                                                       ; BOC11
; SUBROUTINE TO INCREMENT WINDOW TURN PENDING COUNT                     ; BOC11
;                                                                       ; BOC11
;       INPUTS: R1 - ADDRESS OF 2ND LUN WORD                            ; BOC11
;                                                                       ; BOC11
;       OUTPUTS: ALL REGISTERS PRESERVED                                ; BOC11
;               WI.PND SET IN WINDOW                                    ; BOC11
;               INTERLOCK SET IF WI.PND WAS ALREADY SET                 ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
        .IF     NDF,WI.PND      ;DEBUG                                  ; BOC11
        WI.PND=20000                                                    ; BOC11
        .GLOBL  WI.PND                                                  ; BOC11
        .ENDC                   ; END DEBUG                             ; BOC11
FCPND:  BIT     #WI.PND,@(R1)+  ;PENDING BIT ALREADY SET??              ; BOC11
        BNE     10$             ;BR IF SET - DO INTERLOCK               ; BOC11
        BIS     #WI.PND,@-(R1)  ;SET PENDING BIT                        ; BOC11
        RETURN                                                          ; BOC11
10$:    INC     -(R1)           ;SET INTERLOCK                          ; BOC11
        RETURN                                                          ; BOC11
                                                                        ; BOC11
        .ENDC                   ; END A$$CPS                            ; BOC11
                                                                        ; BOC11
;                                                                       ; BOC11
; SUBROUTINES TO COPY PARAMETERS INTO I/O PACKET                        ; BOC11
;                                                                       ; BOC11
;       INPUTS:                                                         ; BOC11
;               FCXR1 - R1 RELOCATION BIAS                              ; BOC11
;                       R2 DISPLACEMENT BIAS                            ; BOC11
;                       R3 PARAMETER PTR                                ; BOC11
;                       R4 I/O PACKET PTR                               ; BOC11
;                       COPIES R1, R2, AND PARAMETERS 2-6               ; BOC11
;                                                                       ; BOC11
;               FCXP2 - R3, R4                                          ; BOC11
;                       COPIES PARAMETERS 2-6                           ; BOC11
;                                                                       ; BOC11
;               FCXP1 - R3,R4                                           ; BOC11
;                       COPIES PARAMETERS 1-6                           ; BOC11
;                                                                       ; BOC11
;       OUTPUTS: R3, R4 UPDATED PTR'S                                   ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
FCXR1:  MOV     R1,(R4)+        ;INSERT RELOCATION BIAS                 ; BOC11
        MOV     R2,(R4)+        ;INSERT DISPLACEMENT BIAS               ; BOC11
        BR      FCXP2           ;COPY PARAMETERS 2-6                    ; BOC11
FCXP1:  MOV     (R3)+,(R4)+     ;INSERT PARAMETER 1                     ; BOC11
FCXP2:  MOV     (R3)+,(R4)+     ;INSERT PARAMETER 2                     ; BOC11
        MOV     (R3)+,(R4)+     ;INSERT PARAMETER 3                     ; BOC11
        MOV     (R3)+,(R4)+     ;INSERT PARAMETER 4                     ; BOC11
        MOV     (R3)+,(R4)+     ;INSERT PARAMETER 5                     ; BOC11
        MOV     (R3),(R4)       ;INSERT PARAMETER 6                     ; BOC11
        RETURN                  ;                                       ; BOC11
                                                                        ; BOC11
;                                                                       ; BOC11
; SUBROUTINE TO PERFORM ADDRESS CHECK AND MAP TRANSFER                  ; BOC11
;                                                                       ; BOC11
                                                                        ; BOC11
FACHK:  MOV     (R3)+,R0        ;GET ADDRESS OF USER BUFFER             ; BOC11
                                                                        ; BOC11
        .IF     DF,A$$CHK ! M$$MGE                                      ; BOC11
                                                                        ; BOC11
        MOVB    U.CTL(R5),R1    ;GET CONTROL BYTE                       ; BOC11
        BPL     10$             ;IF PL BYTE ALLOWED                     ; BOC11
        BIT     #1,R0           ;IS BUFFER BYE ALIGNED                  ; BOC11
        BNE     30$             ;IF NE YES-ALIGNMENT ERROR              ; BOC11
10$:    BIC     #^C<UC.LGH>,R1  ;CLEAR ALL BUT LENGTH MODULO BITS       ; BOC11
        BIT     R1,(R3)         ;DOES LENGTH HAVE CORRECT MODULUS       ; BOC11
        BNE     30$             ;IF NE NO ALIGNMENT ERROR               ; BOC11
        MOV     (R3),R1         ;GET LENGTH OF BUFFER IN BYTES          ; BOC11
        BEQ     40$             ;IF EQ ILLEGAL BUFFER                   ; BOC11
        CALL    $ACHKB          ;ADDRESS CHECK BUFFER                   ; BOC11
        BCS     40$             ;IF CS ADDRESS CHECK ERROR              ; BOC11
                                                                        ; BOC11
        .IFTF                                                           ; BOC11
                                                                        ; BOC11
        CALLR   $RELOC          ;RELOCATE USER BUFFERR ADDRESS          ; BOC11
                                                                        ; BOC11
        .IFT                                                            ; BOC11
                                                                        ; BOC11
30$:    JMP     IEBYT           ;                                       ; BOC11
40$:    JMP     IESPC           ;ILLEGAL BUFFER ADDRESS                 ; BOC11
                                                                        ; BOC11
                                                                        ; BOC11
                                                                        ;**-2
        .ENDC


        .END
        .TITLE  DRRAS
        .IDENT  /08/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 08
;
; D. N. CUTLER 4-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 26-MAY-77
;
;               TM086 -- MODIFY TO USE COMMON EVENT FLAG SETTING
;                       ROUTINE.
;
;       T. J. MILLER 17-SEP-77
;
;               TM107 -- ADDITION OF SUPPORT FOR RECEIVE FROM SPECIFIED
;                       TASK.
;
;       CHUCK SPITZ 30-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES ANDUSE TCB FOR ALL
;                       AST LISTHEADS
;
;       ALAN GROUPE 5-FEB-79
;               AG016 -- ADD TI: UCB AND UIC TO SEND PACKET
;                       REGARDLESS OF M$$MUP
;
; RECEIVE AND SEND DIRECTIVES
;
; MACRO LIBRARY CALLS
;

        .MCALL  HDRDF$,TCBDF$
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$DRREC-RECEIVE DATA AND RECEIVE DATA OR EXIT
; **-$DRRCS-RECEIVE DATA OR STOP                                        ; CS017
;
; THESE DIRECTIVES INSTRUCT THE SYSTEM TO DEQUEUE A DATA BLOCK FROM THE
; ISSUING TASK'S RECEIVE QUEUE. IF THE DIRECTIVE IS RECEIVE DATA OR EXIT,
; THEN A TASK EXIT WILL BE EFFECTED IF NO DATA IS QUEUED.  IF THE       ; CS017
; DIRECTIVE IS RECEIVE OR STOP, THEN THE ISSUING TASAK WILL BE SUSPENDED; CS017
; IF NO DATA IS QUEUED.                                                 ; CS017
;                                                                       ;**-1
; DPB FORMAT:
;
;       WD. 00 -- DIC(75., 77. OR 139.),DPB SIZE(4.).                   ; CS017
;       WD. 01 -- FIRST HALF OF SENDER TASK NAME OR 0 FOR ANY TASK.     ;**-1
;       WD. 02 -- SECOND HALF OF SENDER TASK NAME.
;       WD. 03 -- ADDRESS OF A FIFTEEN WORD RECEIVE BUFFER.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE SECOND WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;               DIRECTIVE STATUS OF 'D.RS22' IS RETURNED IF NO DATA     ; CS017
;                       IS RECEIVED ON RECEIVE OR STOP.                 ; CS017
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF NO DATA
;                       IS QUEUED IN TASK'S RECEIVE QUEUE ON RECEIVE    ; CS017
;                       DATA DIRECTIVE.                                 ; CS017
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF THE ISSUING ; CS017
;                       TASK IS AT AST STATE AND ISSUED THE RECEIVE OR  ; CS017
;                       STOP DIRECTIVE.                                 ; CS017
;                                                                       ; CS017
;-                                                                      ;**-1


        .IF DF R$$SND

        .IF DF S$$TOP                                                   ; CS017
                                                                        ; CS017
        .ENABL  LSB                                                     ; CS017
                                                                        ; CS017
$DRRCS::TST     (R2)            ;ISSUING TASK AT AST STATE?             ; CS017
        BMI     50$             ;IF MI, YES                             ; CS017
                                                                        ; CS017
        .ENDC   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
$DRREC::MOV     -2(R3),-(SP)    ;SAVE DIC CODE OF DIRECTIVE
        MOV     (R3)+,-(SP)     ;SAVE FIRST HALF OF SENDER TASK NAME
        MOV     (R3)+,-(SP)     ;SAVE SECOND HALF OF SENDER TASK NAME
        MOV     (R3),R3         ;GET ADDRESS OF RECEIVE BUFFER


        .IF DF  A$$CHK!M$$MGE

        MOV     #15.*2,R1       ;SET SIZE OF BUFFER
        CALL    $ACHKP          ;ADDRESS CHECK RECEIVE BUFFER

        .ENDC


        MOV     R3,R4           ;SAVE ADDRESS OF RECEIVE BUFFER
        MOV     (SP)+,R3        ;RETRIEVE 2ND HALF OF SENDER TASK NAME
        MOV     (SP)+,R2        ;RETRIEVE FIRST HALF OF SENDER TASK NAME
        MOV     R5,R0           ;CALCULATE ADDRESS OF TASK RECEIVE
        ADD     #T.RCVL,R0      ;QUEUE LISTHEAD
        MOV     R0,R1           ;COPY LISTHEAD ADDRESS
3$:     MOV     (R1),R1         ;POINT TO NEXT ENTRY IN RECEIVE LIST
        BEQ     20$             ;IF EQ THERE IS NONE
        TST     R2              ;TASK NAME SPECIFIED?
        BEQ     4$              ;IF EQ NO, DEQUEUE FIRST BLOCK
        CMP     2(R1),R2        ;MATCH ON FIRST WORD OF TASK NAME?
        BNE     3$              ;IF NE NO
        CMP     4(R1),R3        ;MATCH ON SECOND WORD OF TASK NAME?
        BNE     3$              ;IF NE NO
4$:     CALL    $QRMVT          ;DEQUEUE THE APPROPRIATE PACKET


                                                                        ;AG016
                                                                        ;**-1
        BIT     #T3.SLV,T.ST3(R5) ;IS RECEIVER A SLAVE TASK?
        BEQ     5$              ;IF EQ NO
        MOV     40(R1),T.UCB(R5) ;SET TI ADDRESS OF RECEIVER            ; CS017
        MOV     $HEADR,R2       ;PICK UP CURRENT TASK HEADER ADDRESS    ;**-2
        MOV     42(R1),H.CUIC(R2) ;SET CURRENT UIC OF RECEIVER
        MOV     42(R1),H.DUIC(R2) ;SET DEFAULT UIC OF RECEIVER

                                                                        ;AG016
                                                                        ;**-1

5$:     MOV     R1,R0           ;SAVE ADDRESS OF ENTRY REMOVED
        CMP     (R1)+,(SP)+     ;POINT TO SENDER TASK NAME AND CLEAN STA
        MOV     #15.,R2         ;SET LOOP COUNT
10$:    MOV     (R1)+,(R4)+     ;MOVE DATA BLOCK TO TASK BUFFER
        DEC     R2              ;ANY MORE WORDS TO MOVE?
        BGT     10$             ;IF GT YES
        CALLR   $DEPKT          ;DEALLOCATE RECEIVE QUEUE PACKET
                                                                        ; CS017
        .IF DF S$$TOP                                                   ; CS017
                                                                        ; CS017
20$:    CMPB    #77.,(SP)       ;RECEIVE DATA OR EXIT DIRECTIVE?        ; CS017
                                                                        ; CS017
        .IFF    ;S$$TOP                                                 ; CS017
                                                                        ; CS017
20$:    CMPB    #77.,(SP)+      ;RECEIVE DATA OR EXIT DIRECTIVE?
                                                                        ; CS017
        .IFTF   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
        BNE     30$             ;IF NE NO
                                                                        ; CS017
        .IFT    ;S$$TOP                                                 ; CS017
                                                                        ; CS017
        TST     (SP)+           ;CLEAN STACK                            ; CS017
                                                                        ; CS017
        .IFTF   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
        JMP     $DREXT          ;EXIT TASK
                                                                        ; CS017
        .IFT    ;S$$TOP                                                 ; CS017
                                                                        ; CS017
30$:    CMPB    #139.,(SP)+     ;RECEIVE OR STOP DIRECTIVE              ; CS017
        BNE     40$             ;IF NE, NO JUST A RECEIVE DATA          ; CS017
        CALL    $STPCT          ;STOP CURRENT TASK                      ; CS017
        DRSTS   D.RS22          ;RETURN IS.SET                          ; CS017
40$:    DRSTS   D.RS8           ;NO PACKET TO RECEIVE                   ; CS017
50$:    DRSTS   D.RS80          ;ISSUING TASK IS AT AST STATE           ; CS017
                                                                        ; CS017
        .DSABL  LSB                                                     ; CS017
                                                                        ; CS017
        .IFF    ;S$$TOP                                                 ; CS017
                                                                        ; CS017
30$:    DRSTS   D.RS8           ;SET DIRECTIVE STATUS
                                                                        ; CS017
        .ENDC   ;S$$TOP                                                 ; CS017
                                                                        ; CS017

;+
; **-$DRSND-SEND DATA
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO QUEUE A THIRTEEN WORD DATA BLOCK
; IN A SPECIFIED TASK'S RECEIVE QUEUE.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(71.),DPB SIZE(5.).
;       WD. 01 -- FIRST HALF OF RECEIVER TASK NAME.
;       WD. 02 -- SECOND HALF OF RECEIVER TASK NAME.
;       WD. 03 -- ADDRESS OF THIRTEEN WORD DATA BLOCK.
;       WD. 04 -- EVENT FLAG NUMBER (OPTIONAL).
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE RECEIVER TASK.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE RECEIVER TASK.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE DATA BLOCK ADDRESS IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF INSUFFICIENT
;                       CORE IS AVAILABLE TO QUEUE THE DATA BLOCK.
;               DIRECTIVE STATUS OF 'D.RS2' IS RETURNED IF RECEIVER
;                       TASK IS AN ANCILLARY CONTROL PROCESSOR.
;-

$DRSND::BIT     #T3.ACP!T3.NSD,T.ST3(R0) ;SENDS ALLOWED TO RECEIVER?
        BNE     20$             ;IF NE NO
        MOV     R0,-(SP)        ;SAVE TCB ADDRESS OF RECEIVER TASK
        MOVB    2(R3),-(SP)     ;SAVE EVENT FLAG NUMBER
        MOV     (R3),R3         ;GET ADDRESS OF DATA BUFFER


        .IF DF  A$$CHK!M$$MGE

        MOV     #13.*2,R1       ;SET SIZE OF BUFFER
        CALL    $ACHKP          ;ADDRESS CHECK DATA BUFFER

        .ENDC


        MOVB    (SP)+,R0        ;RETRIEVE OPTIONAL EVENT FLAG NUMBER
        CALL    $SETF           ;SET THE EVENT FLAG
        CALL    $ALPKT          ;ALLOCATE SEND PACKET


                                                                        ;AG016
                                                                        ;**-1
        MOV     T.UCB(R5),40(R0) ;SET UCB ADDRESS
        MOV     H.CUIC(R4),42(R0) ;SET CURRENT (PROTECTION) UIC

                                                                        ;AG016
                                                                        ;**-1

        MOV     R3,R4           ;SAVE ADDRESS OF DATA BUFFER
        MOV     R0,R1           ;COPY ADDRESS OF ALLOCATED PACKET
        TST     (R0)+           ;POINT TO SECOND WORD OF PACKET
        MOV     T.NAM(R5),(R0)+ ;INSERT SENDER TASK NAME IN SEND PACKET
        MOV     T.NAM+2(R5),(R0)+ ;
        MOV     #13.,R2         ;SET LOOP COUNT
10$:    MOV     (R4)+,(R0)+     ;MOVE DATA TO SEND PACKET
        DEC     R2              ;ANY MORE WORDS TO MOVE?
        BGT     10$             ;IF GT YES
        MOV     (SP),R0         ;CALCULATE ADDRESS OF RECEIVER TASK'S
        ADD     #T.RCVL,R0      ;RECEIVE QUEUE LISTHEAD
        CALL    $QINSF          ;INSERT SEND PACKET IN RECEIVE QUEUE
        MOV     #AS.RCA,R4      ;SET CODE FOR RECEIVE DATA AST          ; CS017
        MOV     (SP)+,R5        ;RETRIEVE RECEIVER TASK TCB ADDRESS     ;**-1
        CALL    $DASTT          ;DECLARE RECEIVE AST
        CALLR   $DRDSE          ;DECLARE A SIGNIFICANT EVENT
20$:    DRSTS   D.RS2           ;SET DIRECTIVE STATUS

        .ENDC


        .END
        .TITLE  DRREG
        .IDENT  /02/
 
;
; COPYRIGHT (C) 1976, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 01
;
; T. J. MILLER 12-MAR-76
;
; MODIFIED BY:
;
;       T. J. MILLER 7-DEC-76
;
;               TM069 -- ADD CHECK FOR OUTSTANDING TERMINAL I/O.
;
;       CHUCK SPITZ     26-MAR-79
;               CS040 -- ALLOCATE REGIONS FROM THE TOP OF A SYSTEM
;                       CONTROLLED PARTITION
        .PAGE
;
; THE FOLLOWING DIRECTIVES RECEIVE AS INPUT A POINTER TO A REGION DEFINITION
; BLOCK WHICH SERVES AS A COMMUNICATION AREA BETWEEN THE ISSUING TASK AND
; THE EXECUTIVE.  THE REGION DEFINITION BLOCK HAS THE FOLLOWING FORMAT:
;
;               -------------------------------------------------
;               !                                               !
;       R.GID   !       REGION ID                               !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       R.GSIZ  !       SIZE OF REGION (32W BLOCKS)             !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;               !                                               !
;               !                                               !
;       R.GNAM  !       NAME OF REGION (RAD50)                  !
;               !                                               !
;               !                                               !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;               !                                               !
;               !                                               !
;       R.GPAR  !       REGION'S MAIN PARTITION NAME (RAD50)    !
;               !                                               !
;               !                                               !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       R.GSTS  !       REGION STATUS WORD                      !
;               !                                               !
;               !-----------------------------------------------!
;               !                                               !
;       R.GPRO  !       PROTECTION CODE OF REGION               !
;               !                                               !
;               -------------------------------------------------
;

;
; GLOBAL SYMBOL DEFINITION
;
; DEFINE $DETRG FOR MCR IF PLAS IS NOT SELECTED
;


        .IF NDF P$$LAS

$DETRG==1                       ;SET TO TRAP IF REFERENCED

        .IFF

;
; MACRO LIBRARY CALLS
;

        .MCALL  HDRDF$,PCBDF$,RDBDF$,TCBDF$
        HDRDF$                  ;DEFINE HEADER AND WINDOW BLOCK OFFSETS
        PCBDF$                  ;DEFINE PCB AND ATTACHMENT DESCRIPTOR OFFSETS
        RDBDF$                  ;DEFINE REGION DEFINITION BLOCK OFFSETS
        TCBDF$                  ;DEFINE TCB OFFSETS

;+
; **-$DRCRR-CREATE REGION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CREATE A REGION AND OPTIONALLY
; ATTACH TO IT.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(55.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF REGION DEFINITION BLOCK
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE REGION DEFINITION BLOCK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE REGION DEFINITION BLOCK ARE:
;               R.GSIZ=SIZE OF REGION TO CREATE.
;               R.GNAM=NAME OF REGION TO CREATE OR 0 FOR NO NAME.
;               R.GPAR=NAME OF SYSTEM PARTITION IN WHICH TO ALLOCATE REGION
;                       OR 0 FOR MAIN SYSTEM PARTITION OF TASK.
;               R.GSTS=CONTROL INFORMATION.
;                       RS.NDL=1 IF REGION SHOULD NOT BE DELETED ON LAST
;                               DETACH.
;                       RS.ATT=1 IF CREATED REGION SHOULD BE ATTACHED.
;                       RS.RED=1 IF READ ACCESS IS DESIRED ON ATTACH.
;                       RS.WRT=1 IF WRITE ACCESS IS DESIRED ON ATTACH.
;                       RS.EXT=1 IF EXTEND ACCESS IS DESIRED ON ATTACH.
;                       RS.DEL=1 IF DELETE ACCESS IS DESIRED ON ATTACH.
;               R.GPRO=PROTECTION CODE FOR REGION [DEWR,DEWR,DEWR,DEWR].
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF A PCB OR ATTACH-
;                       MENT DESCRIPTOR COULD NOT BE ALLOCATED.
;               DIRECTIVE STATUS OF 'D.RS16' IS RETURNED IF THE DESIRED
;                       ACCESS IS DENIED IN THE ATTACHMENT STAGE.
;               DIRECTIVE STATUS OF 'D.RS84' IS RETURNED IF THE SPECIFIED
;                       PARTITION IN WHICH THE REGION IS TO BE ALLOCATED
;                       DOES NOT EXIST, OR IF NO PARTITION NAME HAS BEEN
;                       SPECIFIED AND RS.ATT=0.
;
;       OUTPUT FIELDS IN THE REGION DEFINITION BLOCK ARE:
;               R.GID=ASSIGNED REGION ID (RS.ATT=1).
;               R.GSTS=DIRECTIVE COMPLETION INFORMATION.
;                       RS.CRR=1 IF REGION WAS CREATED.
;-

        .ENABL  LSB
$DRCRR::                        ;


        .IF DF  D$$YNM&M$$MGE

        ADD     #R.GPAR,R3      ;PNT TO NAME OF PAR IN WHICH TO ALLOCATE
        MOV     T.PCB(R5),R2    ;ASSUME ALLOCATING IN TASK'S PARTITION
        MOV     P.MAIN(R2),R2   ;POINT TO MAIN PARTITION PCB
        TST     (R3)            ;PARTITION NAME SPECIFIED?
        BEQ     5$              ;IF EQ NO
        CALL    $SRNAM          ;SEARCH FOR NAMED PARTITION'S PCB
        BCS     90$             ;IF CS, PARTITION NOT IN SYSTEM
        CMP     R2,P.MAIN(R2)   ;IS IT A MAIN PARTITION?
        BNE     90$             ;IF NE NO
5$:     BIT     #PS.SYS,P.STAT(R2) ;IS IT A SYSTEM CONTROLLED PARTITION?
        BEQ     90$             ;IF EQ NO
        MOV     R2,R0           ;COPY POINTER TO PCB
        TST     -(R3)           ;POINT TO REGION NAME (R.GNAM+2)
        TST     -(R3)           ;REGION NAME SPECIFIED? (R.GNAM)
        BEQ     10$             ;IF EQ NO

        .IFF

        CMP     (R3)+,(R3)+     ;POINT TO REGION NAME (R.GID)(R.GSIZ)

        .IFTF

        CALL    $SRNAM          ;DETERMINE IF NAME IS UNIQUE

        .IFF

        BCS     90$             ;IF CS REGION DOES NOT EXIST

        .IFT

        BCC     35$             ;IF CC, NAME IS NOT UNIQUE
10$:    MOV     R3,-(SP)        ;PUSH NONZERO WORD (P.ATT+2)
        CLR     -(SP)           ;(P.ATT)
        MOV     R.GPRO-R.GNAM(R3),-(SP) ;SET PROTECTION MASK (P.PRO)
        BIC     #210,(SP)       ;INSURE OWNER AND SYSTEM DELETE ACCESS (P.PRO)
        CLR     -(SP)           ;CLEAR HEADER POINTER (P.HDR)
        MOV     #PS.COM!PS.DEL!PS.PIC!PS.SYS,-(SP) ;SET STATUS WORD (P.STAT)
        MOV     H.CUIC(R4),-(SP) ;SET OWNER UIC (P.OWN)
        CLR     -(SP)           ;CLEAR BUSY FLAGS (P.BUSY)
        CLR     -(SP)           ;CLEAR SWAP SIZE (P.SWSZ)
        CLR     -(SP)           ;CLEAR WAIT QUEUE POINTER (P.WAIT)
        MOV     R.GSIZ-R.GNAM(R3),-(SP) ;STORE SIZE OF REGION (P.SIZE)
        CLR     -(SP)           ;CLEAR RELOCATION BIAS (P.REL)
        MOV     R0,-(SP)        ;SET MAIN PCB POINTER (P.MAIN)
        CLR     -(SP)           ;CLEAR SUBPARTITION LINK (P.LNK)
        MOV     2(R3),-(SP)     ;SET SECOND WORD OF PAR NAME (R.GNAM+2)(P.NAM+2)
        MOV     (R3),-(SP)      ;SET FIRST WORD OF PAR NAME (R.GNAM)(P.NAM)
        BNE     30$             ;IF NE NAME WAS SPECIFIED
        BIT     #RS.ATT,R.GSTS-R.GNAM(R3) ;IS REGION TO BE ATTACHED
        BEQ     90$             ;IF EQ NO, PARTITION NAME ERROR
        CLR     2(SP)           ;ELSE CLEAR SECOND WORD OF NAME (P.NAM+2)
30$:    CLR     -(SP)           ;ZERO I/O COUNT AND PRIORITY (P.IOC)
        CLR     -(SP)           ;CLEAR LINK WORD (P.LNK)
        MOV     SP,R2           ;COPY POINTER TO PCB ON STACK

        .IFTF

35$:    BIT     #RS.ATT,R.GSTS-R.GNAM(R3) ;ATTACH DESIRED?
        BEQ     36$             ;IF EQ NO
        CALL    ATT             ;ATTACH REGION
36$:                            ;REF LABEL

        .IFT

        TST     (SP)            ;WAS THE REGION CREATED?
        BNE     80$             ;IF NE NO, DONE
        MOV     R1,R5           ;COPY POINTER TO ATTACHMENT DESCRIPTOR
        MOV     #P.LGTH,R1      ;PICK UP PCB SIZE
        CALL    $ALOCB          ;ALLOCATE A PCB
        BCS     110$            ;IF CS ALLOCATION FAILURE
        MOV     #P.LGTH/2,R1    ;PICK UP PCB SIZE IN WORDS
        MOV     R0,R4           ;COPY POINTER TO PCB
40$:    MOV     (SP)+,(R0)+     ;FILL IN PCB
        DEC     R1              ;DONE YET?
        BGT     40$             ;IF GT NO
        CMP     -(R0),-(R0)     ;WAS THE PCB ATTACHED?
        BEQ     50$             ;IF EQ YES
        MOV     R0,2(R0)        ;SET UP LISTHEAD
        CMP     -(R3),-(R3)     ;POINT TO REGION ID (R.GSIZ)(R.GID)
        BR      60$             ;
                                                                        ; CS040
        .IFTF                                                           ; CS040
                                                                        ; CS040
90$:    DRSTS   D.RS94          ;PARTITITON NAME ERROR                  ; CS040
                                                                        ; CS040
        .IFT                                                            ; CS040
                                                                        ; CS040
50$:    MOV     (R0),R5         ;PICK UP ADDRESS OF ATTACHMENT DESCRIPTOR
        MOV     R4,A.PCB(R5)    ;POINT IT TO THE REAL PCB
60$:    MOV     P.MAIN(R4),R5   ;POINT TO MAIN PCB
        CLR     -(SP)           ;INDICATE NO PCB FOUND YET              ; CS040
        MOV     R5,R0           ;COPY MAIN PCB ADDRESS                  ; CS040
62$:    MOV     P.SUB(R0),R1    ;POINT TO NEXT SUBPARTITION             ; CS040
        BEQ     66$             ;IF EQ, THIS IS THE LAST ONE            ; CS040
        MOV     P.REL(R1),R2    ;GET BASE OF NEXT SUBPARTITION          ; CS040
        SUB     P.REL(R0),R2    ;SUBTRACT BASE OF THIS SUBPARTITION     ; CS040
        BEQ     64$             ;IF EQ, FIRST SUB STARTS AT BEGINNING   ; CS040
                                ;OF MAIN, GO ON TO NEXT SUB             ; CS040
        SUB     P.SIZE(R0),R2   ;SUBTRACT SIZE OF THIS SUBPARTITION,    ; CS040
                                ;GIVING THE SPACE ABOVE IT              ; CS040
        CMP     P.SIZE(R4),R2   ;IS THERE ENOUGH ROOM FOR THE NEW PAR?  ; CS040
        BHI     64$             ;IF HI, NO, GO ON TO NEXT SUBPARTITION  ; CS040
        MOV     R0,(SP)         ;INDICATE A HOLE BIG ENOUGH             ; CS040
64$:    MOV     R1,R0                                                   ; CS040
        BR      62$             ;GO ON TO NEXT SUBPARTITION             ; CS040
66$:    MOV     P.REL(R5),R2    ;PICK UP BASE OF MAIN PARTITION         ; CS040
        ADD     P.SIZE(R5),R2   ;ADD SIZE, GIVING TOP OF PARTITION      ; CS040
        SUB     P.REL(R0),R2    ;SUBTRACT BASE OF LAST SUB              ; CS040
        CMP     R0,R5           ;ANY SUBPARTITIONS?                     ; CS040
        BEQ     68$             ;IF EQ, NO, R2 NOW HAS SIZE OF MAIN     ; CS040
        SUB     P.SIZE(R0),R2   ;R2 GETS SIZE OF HOLE AT END OF MAIN    ; CS040
68$:    CMP     P.SIZE(R4),R2   ;IS THERE ENOUGH ROOM FOR NEW PAR?      ; CS040
        BHI     70$             ;IF HI, NO                              ; CS040
        MOV     R0,(SP)         ;INDICATE SPACE FOUND                   ; CS040
70$:    MOV     (SP)+,R2        ;WAS THERE SPACE?                       ; CS040
        BEQ     120$            ;IF EQ, NO                              ; CS040
        MOV     P.SUB(R2),R0    ;COPY POINTER TO NEXT SUB               ; CS040
        MOV     R0,P.SUB(R4)    ;POINT NEW SUB TO IT                    ; CS040
        BNE     72$             ;IF NE, THERES A SUB ABOVE NEW          ; CS040
        MOV     R5,R0           ;NEW IS GOING IN AT END OF MAIN         ; CS040
72$:    MOV     R4,P.SUB(R2)    ;POINT LAST SUB TO NEW ONE              ; CS040
        CMP     R0,R5           ;PUTTING NEW AT END OF MAIN?            ; CS040
        BNE     74$             ;IF NE, YES                             ; CS040
        MOV     P.SIZE(R0),R1   ;PICK UP SIZE OF MAIN                   ; CS040
74$:    ADD     P.REL(R0),R1    ;POINT TO TOP OF NEW SUB                ; CS040
        SUB     P.SIZE(R4),R1   ;SUBTRACT SIZE, GIVING BASE             ; CS040
        MOV     R1,P.REL(R4)    ;PLUG IN BASE                           ; CS040
        BIS     #RS.CRR,R.GSTS(R3) ;INDICATE REGION WAS CREATED         ;**-2
        BIT     #RS.NDL,R.GSTS(R3) ;IS NO DELETION DESIRED?
        BEQ     80$             ;IF EQ NO
        BIC     #PS.DEL,P.STAT(R4) ;CLEAR DELETE ON LAST DETACH FLAG

        .IFTF

80$:    RETURN                  ;
                                                                        ;**-1
        .IFT

110$:   BIC     #PS.SYS,P.STAT(SP) ;INSURE DETACH DOES NOT ATTEMPT TO DEALLOCATE
        MOV     SP,R4           ;POINT TO PCB ON STACK
        MOV     #80$,(SP)       ;POINT TO NULL ROUTINE
        BR      125$            ;JOIN COMMON CODE
120$:   MOV     #$DEACB,(SP)    ;ASSUME PCB MUST BE DEALLOCATED
125$:   MOV     (R3),R5         ;PICK UP ATT DESCRIPTOR ADDRESS (R.GID)
        MOV     R4,R0           ;POINT TO PCB TO DEALLOCATE
        MOV     #P.LGTH,R1      ;PICK UP PCB SIZE
        TST     P.ATT(R4)       ;WAS THE PCB ATTACHED?
        BEQ     126$            ;IF EQ NO
        MOV     #$DETRG,(SP)    ;SET TO DETACH REGION
126$:   CALL    @(SP)+          ;CALL APPRORIATE ROUTINE
        DRSTS   D.RS1           ;ALLOCATION FAILURE

        .IFTF

;+
; **-$DRATR-ATTACH REGION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO ATTACH THE SPECIFIED REGION
; TO THE CURRENT TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(57.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF REGION DEFINITION BLOCK
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE REGION DEFINITION BLOCK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE REGION DEFINITION BLOCK ARE:
;               R.GNAM=NAME OF REGION TO ATTACH TO OR 0 FOR TASK REGION.
;               R.GSTS=DESIRED ACCESS TO REGION.
;                       RS.RED=1 IF READ ACCESS IS DESIRED.
;                       RS.WRT=1 IF WRITE ACCESS IS DESIRED.
;                       RS.EXT=1 IF EXTEND ACCESS IS DESIRED.
;                       RS.DEL=1 IF DELETE ACCESS IS DESIRED.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF AN ATTACHMENT
;                       DESCRIPTOR CANNOT BE ALLOCATED.
;               DIRECTIVE STATUS OF 'D.RS16' IS RETURNED IF THE DESIRED
;                       ACCESS IS DENIED.
;               DIRECTIVE STATUS OF 'D.RS84' IS RETURNED IF THE SPECIFIED
;                       REGION NAME DOES NOT EXIST.
;
;       OUTPUT FIELDS IN THE REGION DEFINITION BLOCK ARE:
;               R.GID=ASSIGNED REGION ID.
;               R.GSIZ=SIZE OF ATTACHED REGION.
;-

$DRATR::ADD     #R.GNAM,R3      ;POINT TO SPECIFIED REGION NAME
        TST     (R3)            ;REGION NAME SPECIFIED?
        BEQ     90$             ;IF EQ NO, ILLEGAL
        CALL    $SRNAM          ;SEARCH FOR NAMED REGION
        BCS     90$             ;IF CS NAMED REGION DOES NOT EXIST
ATT:    BIT     #PS.COM,P.STAT(R2) ;IS THE PARTITION COMMON?
        BEQ     90$             ;IF EQ NO

        .IFT

        BIT     #PS.SYS,P.STAT(R2) ;IS IT A SYSTEM CONTROLLED PARTITION?
        BEQ     130$            ;IF EQ NO
        CMP     R2,P.MAIN(R2)   ;IS IT THE MAIN SYSTEM CONTROLLED PARTITION?
        BR      140$            ;

        .IFTF

130$:   BITB    P.BUSY(R2),P.BUSY+1(R2) ;IS COMMON BLOCK NOT LOADED?
140$:   BEQ     90$             ;IF EQ YES
        MOV     R.GSTS-R.GNAM(R3),R0 ;PICK UP STATUS WORD
        BIT     #17,R0          ;ATTACH DESIRED?
        BNE     147$            ;IF NE YES
        MOV     T.ATT(R5),R1    ;POINT TO FIRST ATTACHMENT DESCRIPTOR
146$:   SUB     #A.TCBL,R1      ;POINT TO START OF DESCRIPTOR
        CMP     A.PCB(R1),R2    ;ATTACHED TO THIS PCB?
        BEQ     155$            ;IF EQ YES
        MOV     A.TCBL(R1),R1   ;POINT TO NEXT ATTACHMENT DESCRIPTOR
        BNE     146$            ;IF NE THERE IS ONE
        DRSTS   D.RS86          ;NO SUCH REGION ID
147$:   MOV     H.CUIC(R4),R1   ;PICK UP CURRENT TASK UIC
        MOV     R0,R4           ;COPY STATUS WORD

        .IFT

        CMP     R2,PC           ;IS REGION BEING CREATED?
        BLO     150$            ;IF LO YES, SKIP PROTECTION CHECK

        .IFTF

        BIT     #T3.PRV,T.ST3(R5) ;ISSUING TASK PRIVILEGED?
        BNE     150$            ;IF NE YES, SKIP ACCESS CHECK
        CALL    $CKACC          ;DETERMINE IF DESIRED ACCESS IS ALLOWED
150$:   CALL    $CRATT          ;CREATE ATT DESCRIPTOR AND LINK IT IN
        BCS     160$            ;IF CS ALLOCATION FAILURE
155$:   MOV     P.SIZE(R2),-(R3) ;RETURN SIZE OF REGION (R.GSIZ)
        MOV     R1,-(R3)        ;STORE DESCRIPTOR ADDR AS REG ID (R.GID)
        RETURN                  ;
160$:   DRSTS   D.RS1           ;ALLOCATION FAILURE
        .DSABL  LSB

;+
; **-$DRDTR-DETACH REGION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO DETACH THE SPECIFIED REGION,
; UNMAPPING IF NECESSARY.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(59.),DPB SIZE(2.)
;       WD. 01 -- ADDRESS OF REGION DEFINITION BLOCK
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE REGION DEFINITION BLOCK.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
;       INPUT FIELDS IN THE REGION DEFINITION BLOCK ARE:
;               R.GID=REGION ID OF REGION TO DETACH.
;               R.GSTS=CONTROL INFORMATION.
;                       RS.MDL=1 IF REGION SHOULD BE MARKED FOR DELETE ON
;                               THE LAST DETACH.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS16' IS RETURNED IF AN ATTEMPT IS MADE
;                       TO MARK THE REGION FOR DELETE WITHOUT DELETE ACCESS.
;               DIRECTIVE STATUS OF 'D.RS86' IS RETURNED IF AN INVALID REGION
;                       ID IS SPECIFIED OR IF AN ATTEMPT IS MADE TO DETACH
;                       REGION 0.
;
;       OUTPUT FIELDS IN THE REGION DEFINITION BLOCK ARE:
;               R.GSTS=INDICATION OF ANY CHANGES IN MAPPING CONTEXT.
;                       RS.UNM=1 IF ANY WINDOWS WERE UNMAPPED.
;-

        .ENABL  LSB
$DRDTR::TSTB    T.IOC(R5)       ;ANY OUTSTANDING I/O?
        BNE     70$             ;IF NE YES, REJECT FOR NOW


        .IF DF  A$$TRP&C$$CKP&T$$BUF

        BIT     #T2.TIO,(R2)    ;TASK HAVE OUTSTANDING TERMINAL I/O?
        BNE     70$             ;IF NE YES

        .ENDC


        CALL    $SRATT          ;SEARCH FOR AND VERIFY REGION ID
        MOV     A.PCB(R5),R0    ;POINT TO PCB
        BIT     #PS.COM,P.STAT(R0) ;DETACHING FROM COMMON REGION?
        BEQ     60$             ;IF EQ NO, DETACHING FROM TASK REGION
        MOV     H.WND(R4),R4    ;POINT TO NUMBER OF WINDOW BLOCKS
        TST     (R4)+           ;POINT TO FIRST WINDOW BLOCK

        .IFT

        BIT     #PS.SYS,P.STAT(R0) ;SYSTEM CONTROLLED PARTITION?
        BEQ     10$             ;IF EQ NO
        BIT     #RS.MDL,R.GSTS(R3) ;MARK FOR DELETE DESIRED?
        BEQ     10$             ;IF EQ NO
        BITB    #AS.DEL,A.STAT(R5) ;DOES TASK HAVE DELETE ACCESS?
        BEQ     70$             ;IF EQ NO
        BIS     #PS.DEL,P.STAT(R0) ;MARK REGION FOR DELETE

        .IFTF

10$:    CMP     W.BATT(R4),R5   ;THIS WINDOW MAPPED TO REGION TO DETACH
        BNE     20$             ;IF NE NO
        CALL    $UNMAP          ;UNMAP WINDOW
        BIS     #RS.UNM,R.GSTS(R3) ;INDICATE WINDOW WAS UNMAPPED
20$:    ADD     #W.BLGH,R4      ;POINT TO NEXT WINDOW BLOCK
        TSTB    A.MPCT(R5)      ;ANY MORE WINDOWS MAPPED TO THIS REGION?
        BNE     10$             ;IF NE YES

;+
; **-$DETRG-DETACH REGION BY ATTACHMENT DESCRIPTOR ADDRESS
;
; THIS ROUTINE DETACHES A TASK FROM A REGION AND DEALLOCATES THE ATTACHMENT
; DESCRIPTOR.  ON THE LAST DETACH OF A REGION IT IS CHECKED FOR DELETION.
; WHEN APPRORIATE, $NXTSK IS CALLED.
;
; INPUTS:
;
;       R5=ADDRESS OF ATTACHMENT DESCRIPTOR
;
; OUTPUTS:
;
;       R0,R1,R2,R3 ARE MODIFIED.
;-

$DETRG::MOV     A.PCB(R5),R0    ;POINT TO PCB OF REGION
        ADD     #P.ATT,R0       ;POINT TO ATTACHMENT DESCR LISTHEAD
        CLR     R1              ;CLEAR SEARCH KEY
        MOV     A.TCB(R5),-(SP) ;SAVE TCB ADDRESS
        CLR     A.TCB(R5)       ;MARK ATTACHMENT DESCRIPTOR FOR REMOVAL
        CALL    $QRMVT          ;REMOVE DESCRIPTOR FROM PCB'S QUEUE

        .IFT

        TST     (R0)            ;IS ANYONE ELSE ATTACHED? (P.ATT)
        BNE     50$             ;IF NE YES
        BIT     #PS.SYS,P.STAT-P.ATT(R0) ;IS PARTITION SYSTEM CONTROLLED?
        BEQ     50$             ;IF EQ NO
        TST     P.NAM-P.ATT(R0) ;IS THIS A NAMED REGION?
        BEQ     25$             ;IF EQ NO, FORCE DELETION
        BIT     #PS.DEL,P.STAT-P.ATT(R0) ;IS REGION MARKED FOR DELETE?
        BEQ     55$             ;IF EQ NO
25$:    SUB     #P.ATT,R0       ;POINT TO START OF PCB
        MOV     P.MAIN(R0),R1   ;POINT TO MAIN PARTITION PCB
30$:    CMP     P.SUB(R1),R0    ;DOES THIS PARTITION LINK TO ONE TO DELETE?
        BEQ     40$             ;IF EQ YES
        MOV     P.SUB(R1),R1    ;POINT TO NEXT SUBPARTITION
        BNE     30$             ;IF NE THERE IS ONE
        BR      45$             ;SKIP UNLINK OF PCB (THIS INDICATES $DRCRR CALL)
40$:    MOV     P.SUB(R0),P.SUB(R1) ;UNLINK DETACHED PARTITION
45$:    MOV     #P.LGTH,R1      ;PICK UP SIZE FOR DELETE
        CALL    $DEACB          ;DEALLOCATE PCB

        .ENDC


        .IF DF  D$$ISK

49$:    MOV     A.PCB(R5),R0    ;POINT TO DETACHED PCB
        MOV     R0,R1           ;COPY PCB POINTER
        MOV     P.MAIN(R1),R3   ;POINT TO MAIN PARTITION PCB
        CALL    $RLPR1          ;RELEASE THE PARTITION
        BR      55$             ;
50$:    BIT     #PS.COM!PS.SYS,P.STAT-P.ATT(R0) ;FIXED TASK PARTITION?
        BEQ     49$             ;IF EQ NO, RELEASE FIXED TASK PARTITION

        .IFF

50$:                            ;REF LABEL

        .ENDC


55$:    MOV     (SP)+,R0        ;RESTORE TCB ADDRESS
        ADD     #T.ATT,R0       ;POINT TO ATTACHMENT DESCRIPTOR LISTHEAD
        CLR     R1              ;CLEAR SEARCH KEY
        CLR     A.PCB(R5)       ;MARK ATTACHMENT DESCRIPTOR FOR REMOVAL
        CALL    $QRMVT          ;REMOVE DESCRIPTOR FROM TCB'S LIST
        MOV     R5,R0           ;COPY DESCRIPTOR ADDRESS
        MOV     #A.LGTH,R1      ;SET SIZE TO DEALLOCATE
        CALLR   $DEACB          ;DEALLOCATE ATTACHMENT DESCRIPTOR
60$:    DRSTS   D.RS86          ;INVALID REGION ID
70$:    DRSTS   D.RS16          ;ATTEMPT TO MARK FOR DELETE WITHOUT ACCESS
        .DSABL  LSB

        .ENDC


        .END
        .TITLE  DRREQ
        .IDENT  /04/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 04
;
; D. N. CUTLER 13-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       CHUCK SPITZ 24-OCT-78
;               CS018 -- IF PARENT OFFSPRING SUPPORT INCLUDED,
;                       DRREQ IS FOUND IN DRSPW.
;
; REQUEST TASK DIRECTIVE
;
; MACRO LIBRARY CALLS
;

                                                                        ; CS018
        .IF NDF P$$OFF                                                  ; CS018
                                                                        ; CS018
        .MCALL  TCBDF$
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$DRREQ-REQUEST TASK
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO REQUEST THE EXECUTION
; OF A SPECIFIED TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(11.),DPB SIZE(7.).
;       WD. 01 -- FIRST HALF OF TASK NAME.
;       WD. 02 -- SECOND HALF OF TASK NAME.
;       WD. 03 -- PARTITION NAME-NOT SUPPORTED BUT MUST BE PRESENT.
;       WD. 04 -- PARTITION NAME-NOT SUPPORTED BUT BUST BE PRESENT.
;       WD. 05 -- REQUEST PRIORITY-NOT SUPPORTED BUT MUST BE PRESENT.
;       WD. 06 -- REQUEST UIC.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TASK TO BE REQUESTED.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TASK TO BE REQUESTED.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE PARTITION NAME IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF PARTITION
;                       CONTROL BLOCK CANNOT BE ALLOCATED.
;               DIRECTIVE STATUS OF 'D.RS7' IS RETURNED IF SPECIFIED.
;                       TASK IS ALREADY ACTIVE.
;-

$DRREQ::MOV     6(R3),R1        ;GET REQUEST UIC


        .IF DF  M$$MUP

        CALL    $UISET          ;ESTABLISH DEFAULT AND CURRENT UIC'S

        .ENDC


        MOV     T.UCB(R5),R2    ;GET ADDRESS OF REQUESTER TI UCB
        CALL    $TSKRP          ;REQUEST TASK EXECUTION
        BCS     10$             ;IF CS TASK ALREADY ACTIVE
        RETURN                  ;RETURN DIRECTIVE STATUS OF +1


        .IF DF  D$$YNM&M$$MGE

10$:    BEQ     20$             ;IF EQ TASK ALREADY ACTIVE
        DRSTS   D.RS1           ;SET DIRECTIVE STATUS
20$:    DRSTS   D.RS7           ;SET DIRECTIVE STATUS

        .IFF

10$:    DRSTS   D.RS7           ;SET DIRECTIVE STATUS

        .ENDC

        .ENDC   ;NDF P$$OFF                                             ; CS018

        .END
        .TITLE  DRRES
        .IDENT  /06/
 
;
; COPYRIGHT (C) 1974,1976,1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 06
;
; D. N. CUTLER 31-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       T. J. MILLER
;
; MODIFIED BY:
;
;       CHUCK SPITZ 8-JUN-78
;               CS014 -- ALLOW NON-PRIVILEGED TASK TO ALTER HIS PRIORITY
;                       UP TO HIS INSTALLED PRIORITY.
;
;       CHUCK SPITZ     20-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES AND DON'T ALTER
;                       PRIORITY OF IO PACKETS IF BREAKTHROUGH WRITE.
;
; MACRO LIBRARY CALLS
;

        .MCALL  HDRDF$,PKTDF$,PCBDF$,TCBDF$
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
                                                                        ; CS017
        .ENABL  LSB                                                     ; CS017
                                                                        ; CS017
        .IF DF S$$TOP                                                   ; CS017
                                                                        ; CS017
;+                                                                      ; CS017
; **-$DRUNS-UNSTOP TASK                                                 ; CS017
;                                                                       ; CS017
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO UNSTOP A TASK THAT HAS STOPPED ; CS017
; ITSELF VIA A STOP DIRECTIVE OR A RECEIVE OR STOP DIRECTIVE.           ; CS017
;                                                                       ; CS017
; DPB FORMAT:                                                           ; CS017
;                                                                       ; CS017
;       WD. 00 -- DIC(133.),DPB SIZE(3.).                               ; CS017
;       WD. 01 -- FIRST HALF OF TASK NAME.                              ; CS017
;       WD. 02 -- SECOND HALF OF TASK NAME.                             ; CS017
;                                                                       ; CS017
; INPUTS:                                                               ; CS017
;                                                                       ; CS017
;       R0=ADDRESS OF THE TCB OF THE TASK TO BE UNSTOPPED.              ; CS017
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TASK TO BE UNSTOPPED. ; CS017
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.         ; CS017
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.                       ; CS017
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.                   ; CS017
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.                      ; CS017
;                                                                       ; CS017
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)                   ; CS017
;                                                                       ; CS017
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.                     ; CS017
;               DIRECTIVE STATUS OF +1 IS RETURNED.                     ; CS017
;       C=1 IF DIRECTIVE IS REJECTED.                                   ; CS017
;               DIRECTIVE STATUS OF 'D.RS7' IS RETURNED IF THE SPECIFIED; CS017
;                       TASK IS NOT ACTIVE.                             ; CS017
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF THE SPECIFIED; CS017
;                       TASK IS NOT STOPPED, OR STOPPED FOR EVENT       ; CS017
;                       FLAG(S) OR BUFFERED I/O.                        ; CS017
;-                                                                      ; CS017
                                                                        ; CS017
$DRUNS::TST     (R1)+           ;SPECIFIED TASK ACTIVE?                 ; CS017
        BMI     20$             ;IF MI NO                               ; CS017
        BIT     #T2.SEF!T2.TIO,(R1) ;LEGAL TO UNSTOP SPECIFIED TASK?    ; CS017
        BNE     30$             ;IF NE NO                               ; CS017
        MOV     #T2.STP,R2      ;PICK UP STOP BIT                       ; CS017
        BR      5$              ;JOIN COMMON CODE WITH RESUME           ; CS017
                                                                        ; CS017
        .IFTF   ;S$$TOP                                                 ; CS017

;+
; **-$DRRES-RESUME TASK EXECUTION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO RESUME THE EXECUTION OF A TASK THAT
; HAS ISSUED A SUSPEND DIRECTIVE.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(47.),DPB SIZE(3.).
;       WD. 01 -- FIRST HALF OF TASK NAME.
;       WD. 02 -- SECOND HALF OF TASK NAME.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TASK TO BE RESUMED.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TASK TO BE RESUMED.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS7 IS RETURNED IF THE SPECIFIED
;                       TASK IS NOT ACTIVE.
;               DIRECTIVE STATUS OF 'D.RS8' IS RETURNED IF THE SPECIFIED
;                       TASK IS NOT SUSPENDED.
;-

$DRRES::TST     (R1)+           ;TASK ACTIVE?                           ;**-1
        BMI     20$             ;IF MI NO
        MOV     #T2.SPN,R2      ;GET SUSPEND BIT
5$:     BIT     R2,(R1)         ;TASK CURRENTLY SUSPENDED?              ; CS017
        BNE     10$             ;IF NE YES                              ;**-1
        TST     (R1)            ;AST IN PROGRESS?
        BPL     30$             ;IF PL NO
        ASL     R2              ;SET PRE AST SUSPEND BIT
        BIT     R2,(R1)         ;WAS TASK SUSPENDED?
        BEQ     30$             ;IF EQ NO
                                                                        ; CS017
10$:                            ;REF LABEL                              ; CS017
                                                                        ; CS017
        .IFT    ;S$$TOP                                                 ; CS017
                                                                        ; CS017
        CMPB    $DICSV,#133.    ;IS THIS AN UNSTOP DIRECTIVE?           ; CS017
        BEQ     15$             ;IF EQ YES                              ; CS017
                                                                        ; CS017
        .IFTF   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
        BIC     R2,(R1)         ;CLEAR TASK'S SUSPEND BIT               ; CS017
        CALLR   $SETCR          ;SET A CONDITIONAL SCHEDULE REQUEST     ; CS017
                                                                        ; CS017
        .IFT    ;S$$TOP                                                 ; CS017
                                                                        ; CS017
15$:    CALLR   $EXRQN          ;UNSTOP SPECIFIED TASK                  ; CS017
                                                                        ; CS017
        .IFTF   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
20$:    DRSTS   D.RS7           ;SET DIRECTIVE STATUS                   ; CS017
30$:    DRSTS   D.RS8           ;SET DIRECTIVE STATUS                   ; CS017
                                                                        ; CS017
                                                                        ; CS017
        .IFT    ;S$$TOP                                                 ; CS017
                                                                        ; CS017
;+                                                                      ; CS017
; **-$DRSTP-STOP TASK                                                   ; CS017
;                                                                       ; CS017
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO STOP THE ISSUING TASK.         ; CS017
;                                                                       ; CS017
; DPB FORMAT:                                                           ; CS017
;                                                                       ; CS017
;       WD. 00 -- DIC(131.),DPB SIZE(1.).                               ; CS017
;                                                                       ; CS017
; INPUTS:                                                               ; CS017
;                                                                       ; CS017
;       R2=ADDRESS OF THE SECOND TASK STATUS WORD OF THE CURRENT TASK.  ; CS017
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.                       ; CS017
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.                   ; CS017
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.                      ; CS017
;                                                                       ; CS017
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)                   ; CS017
;                                                                       ; CS017
;       C=0 IF DIRECTIVE SUCCESSFULLY COMPLETED.                        ; CS017
;               DIRECTIVE STATUS OF 'D.RS22' IS RETURNED.               ; CS017
;       C=1 IF DIRECTIVE IS REJECTED.                                   ; CS017
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF THE ISSUING ; CS017
;                       TASK IS AT AST STATE.                           ; CS017
;-                                                                      ; CS017
                                                                        ; CS017
$DRSTP::TST     (R2)            ;IS ISSUING TASK AT AST STATE?          ; CS017
        BMI     33$             ;IF MI YES                              ; CS017
        CALL    $STPCT          ;STOP ISSUING TASK                      ; CS017
        DRSTS   D.RS22          ;RETURN SUCCESS WITH +2                 ; CS017
33$:    DRSTS   D.RS80          ;ISSUING TASK IS AT AST STATE           ; CS017
                                                                        ; CS017
        .ENDC   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
;+                                                                      ;**-5
; **-$DRSPN-SUSPEND EXECUTION
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO SUSPEND THE EXECUTION OF THE ISSUING
; TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(45.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF 'D.RS22'.
;-

$DRSPN::BIS     #T2.SPN,(R2)    ;SUSPEND CURRENT TASK
        CALL    $SETRT          ;FORCE A REDISPATCHING OF PROCESSOR
        DRSTS   D.RS22          ;SET DIRECTIVE STATUS

;+
; **-$DRATP-ALTER TASK PRIORITY
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CHANGE THE TASK PRIORITY
; OF THE SPECIFIED TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(9.),DPB SIZE(4.)
;       WD. 01 -- FIRST HALF OF TASK NAME.
;       WD. 02 -- SECOND HALF OF TASK NAME.
;       WD. 03 -- NEW PRIORITY.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TASK TO BE ALTERED.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TASK TO BE ALTERED.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS7' IS RETURNED IF THE
;                       TASK IS NOT ACTIVE.
;               DIRECTIVE STATUS OF 'D.RS95' IS RETURNED IF THE
;                       NEW PRIORITY SPECIFIED IS INVALID.
;
;-


        .IF DF  A$$PRI

$DRATP::                        ;REF LABEL


        .IF DF  M$$MUP

        BIT     #T3.PRV,T.ST3(R5) ;ISSUING TASK PRIVILEGED?
        BNE     35$             ;IF NE YES                              ; CS014
        CMP     R0,R5           ;MODIFYING OWN PRIORITY?                ; CS014
        BNE     180$            ;IF NE NO - PRIVILEGE VIOLATION         ; CS014
        CMPB    (R3),T.DPRI(R0) ;RAISING ABOVE INSTALLED PRIORITY?      ; CS014
        BHI     180$            ;IF HI YES - PRIVILEGE VIOLATION        ; CS014
35$:                            ;REF LABEL                              ; CS014
                                                                        ;**-1
        .ENDC


        MOV     R0,R5           ;SAVE TCB ADDR OF TASK TO BE ALTERED
        TST     (R1)            ;TASK ACTIVE?
        BMI     20$             ;IF MI NO
        MOV     (R3),R3         ;GET NEW PRIORITY AND TEST IT
        BNE     40$             ;IF NE ONE WAS SPECIFIED
        BISB    T.DPRI(R5),R3   ;USE DEFAULT PRIORITY
40$:    CMP     R3,#250.        ;NEW PRIORITY .GT. 250?
        BHI     170$            ;IF HI YES
        MOVB    R3,T.PRI(R5)    ;SET NEW PRIORITY
        TSTB    T.IOC(R5)       ;ANY I/O ACTIVE?
        BEQ     100$            ;IF EQ NO
        CLR     -(SP)           ;PUSH INITIAL LUN NUMBER - 1
50$:    MOV     T.PCB(R5),R4    ;GET PCB ADDR
        MOV     P.HDR(R4),R4    ;GET TASK HEADER OF TASK TO BE ALTERED
        CMP     (SP),H.NLUN(R4) ;PAST LAST LUN?
        BHIS    90$             ;IF HIS YES
        MOV     (SP),R1         ;GET LUN -1
        CALL    $MPLNE          ;MAP LUN TO UCB ADDRESS
        BCS     80$             ;IF CS LUN IS NOT ASSIGNED


        .IF DF  A$$CPS

        MOV     R0,-(SP)        ;SAVE UCB ADDRESS

        .IFTF

        MOV     U.SCB(R0),R4    ;GET PTR TO SCB FOR THIS UCB
        CALL    130$            ;REORDER I/O QUEUE

        .IFT

        MOV     (SP)+,R0        ;RETRIEVE UCB ADDRESS
        TST     U.CW1(R0)       ;DEVICE MOUNTABLE?
        BPL     80$             ;IF PL NO
        BITB    #US.MNT!US.FOR,U.STS(R0) ;MOUNTED AND NOT FOREIGN?
        BNE     80$             ;IF NE NO
        MOV     U.ACP(R0),R4    ;PICK UP TCB OF ACP
        ADD     #T.RCVL,R4      ;POINT TO RECEIVE QUEUE LISTHEAD
        CALL    130$            ;REORDER ACP QUEUE

        .ENDC


80$:    INC     (SP)            ;UPDATE LUN NUMBER
        BR      50$             ;CONTINUE THROUGH LUN LOOP
90$:    TST     (SP)+           ;POP LUN NUMBER FROM STACK
100$:   MOV     R5,R0           ;GET TCB ADDR OF TASK TO BE ALTERED
        CALL    $ACTRM          ;REMOVE TCB FROM ATL
        BCS     110$            ;IF CS TCB NOT YET IN ATL
        CALL    $ACTTK          ;RE-INSERT TCB IN ATL
110$:                           ;REF LABEL


        .IF DF  D$$ISK

        MOV     T.PCB(R5),R4    ;GET PCB ADDR
        MOV     P.MAIN(R4),R0   ;GET MAIN PCB ADDR
        ADD     #P.WAIT,R0      ;GET LISTHEAD FOR PARTITION WAIT QUEUE
        MOV     R5,R1           ;POINT TO TASK TCB
        CALL    $QRMVT          ;TRY TO REMOVE TCB FROM QUEUE
        BCS     120$            ;IF CS TCB NOT IN WAIT QUEUE
        CALL    $QINSP          ;RE-INSERT TCB BY NEW PRIORITY
120$:   MOV     R4,R0           ;GET PCB ADDR
        CALL    $NXTSK          ;RE-SCHEDULE PARTITION

        .ENDC


        CALLR   $DRDSE          ;DECLARE SIGNIFICANT EVENT
130$:   MOV     #-2,-(SP)       ;CONSTRUCT TEMPORARY LISTHEAD ON STACK
        ADD     SP,(SP)         ;
        CLR     -(SP)           ;
140$:   MOV     R4,R0           ;GET I/O PACKET LISTHEAD ADDR
        MOV     R5,R1           ;GET TCB ADDR OF TASK TO BE ALTERED
        CALL    $QRMVT          ;REMOVE I/O PACKET BY TCB ADDR
        BCS     150$            ;IF CS NO I/O PACKET FOUND
        CMPB    I.PRI(R1),#250. ;PRIORITY HIGHER THAN 250?              ; CS017
        BHI     145$            ;IF HI YES, DON'T CHANGE, BRKTHRU WRITE ; CS017
        MOVB    T.PRI(R5),I.PRI(R1) ;SET NEW PRIORITY                   ; CS017
145$:   MOV     SP,R0           ;SET TEMPORARY LISTHEAD ADDR            ; CS017
        CALL    $QINSF          ;INSERT I/O PACKET IN TEMPORARY LIST    ;**-2
        BR      140$            ;CONTINUE THROUGH PACKET REMOVAL LOOP
150$:   MOV     SP,R0           ;SET TEMPORARY LISTHEAD ADDR
        CALL    $QRMVF          ;REMOVE FIRST I/O PACKET FROM LIST
        BCS     160$            ;IF CS NO I/O PACKET FOUND
        MOV     R4,R0           ;GET I/O PACKET LISTHEAD ADDR
        CALL    $QINSP          ;RE-INSERT I/O PACKET BY NEW PRIORITY
        BR      150$            ;CONTINUE THROUGH PACKET INSERTION LOOP
160$:   CMP     (SP)+,(SP)+     ;CLEAN TEMPORARY LISTHEAD OFF STACK
        RETURN                  ;
170$:   DRSTS   D.RS95          ;SET DIRECTIVE STATUS


        .IF DF  M$$MUP

180$:   DRSTS   D.RS16          ;PRIVILEGE VIOLATION

        .ENDC


        .ENDC


        .DSABL  LSB

        .END
        .TITLE  DRSED
        .IDENT  /09/
 
;
; COPYRIGHT (C) 1974, 1976, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 09
;
; D. N. CUTLER 2-SEP-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       CHUCK SPITZ 20-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES
;
;       CHUCK SPITZ 7-DEC-78
;               CS020 -- ADD GROUP GLOBAL EF'S
;       CHUCK SPITZ 14-FEB-79
;               CS031 -- UNSTOP A TASK THAT IS STOPPED FOR EVENT FLAGS,
;                       WHEN IT SETS ONE OF ITS EF'S AT AST STATE.
;       CHUCK SPITZ 29-MAR-79
;               CS043 -- ADD READ EXTENDED EVENT FLAGS DIRECTIVE
;
; SIGNIFICANT EVENT AND EVENT FLAG DIRECTIVES
;
; MACRO LIBRARY CALLS
;

        .MCALL  HDRDF$,TCBDF$,PKTDF$                                    ; CS020
        PKTDF$                  ;DEFINE EVENT FLAG GROUP OFFSETS        ; CS020
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS             ;**-1
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$DRCEF-CLEAR EVENT FLAG
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CLEAR AN EVENT FLAG AND
; REPORT ITS POLARITY BEFORE CLEARING.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(31.),DPB SIZE(2.).
;       WD. 01 -- EVENT FLAG NUMBER OF FLAG TO BE CLEARED.
;
; INPUTS:
;
;       R0=EVENT FLAG MASK WORD.
;       R1=EVENT FLAG MASK ADDRESS.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF 'D.RS00' IF THE FLAG WAS
;               CLEAR OR 'D.RS22' IF THE FLAG WAS SET.
;-

        .ENABL  LSB
$DRCEF::BIT     R0,(R1)         ;TEST FLAG
        BEQ     20$             ;IF EQ FLAG IS CLEAR
        BIC     R0,(R1)         ;CLEAR FLAG
10$:    DRSTS   D.RS22          ;SET DIRECTIVE STATUS

;+
; **-$DRDSE-DECLARE SIGNIFICANT EVENT
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO DECLARE A SIGNIFICANT EVENT.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(35.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF +1.
;
;       NOTE: THIS DIRECTIVE IS ALSO CALLED A SUBROUTINE
;-

$DRDSE::MOV     $ACTHD,$RQSCH   ;SET DISPATCH TO FRONT OF LIST
        CLR     $SIGFL          ;CLEAR TASK WAITING FOR SIGNIFICANT EVENT
        RETURN                  ;RETURN DIRECTIVE STATUS  OF +1

;+
; **$DRRAF-READ ALL EVENT FLAGS OR READ EXTENDED EVENT FLAGS            ; CS043
;                                                                       ;**-1
; THESE DIRECTIVES INSTRUCT THE SYSTEM TO FILL A FOUR (OR SIX) WORD     ; CS043
; BUFFER WITH THE ISSUING TASKS LOCAL, COMMON, AND GROUP GLOBAL         ; CS043
; EVENT FLAGS.                                                          ; CS043
;                                                                       ;**-2
; DPB FORMAT:
;
;       WD. 00 -- DIC(39.),DPB SIZE(2. OR 3.).                          ; CS043
;       WD. 01 -- ADDRESS OF A FOUR OR SIX WORD BUFFER.                 ; CS043
;                                                                       ;**-2
;       BUFFER FORMAT:
;
;       WD. 00 -- TASK LOCAL EVENT FLAGS 1-16.
;       WD. 01 -- TASK LOCAL EVENT FLAGS 17-32.
;       WD. 02 -- COMMON EVENT FLAGS 33-48.
;       WD. 03 -- COMMON EVENT FLAGS 49-64.
;       WD. 04 -- GROUP GLOBAL EVENT FLAGS 65.-80.                      ; CS043
;       WD. 05 -- GROUP GLOBAL EVENT FLAGS 81.-96.                      ; CS043
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE BUFFER ADDRESS IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED FOR READ ALL EVENT   ; CS043
;                       FLAGS.                                          ; CS043
;               DIRECTIVE STATUS OF +1 IS RETURNED FOR READ EXTENDED    ; CS043
;                       EVENT FLAGS IF THE ISSUING TASKS GROUP GLOBAL   ; CS043
;                       EVENT FLAGS EXIST.                              ; CS043
;               DIRECTIVE STATUS OF 'D.RS00' IS RETURNED FOR READ       ; CS043
;                       EXTENDED EVENT FLAGS IF THE ISSUING TASK'S GROUP; CS043
;                       GLOBAL EVENT FLAGS DO NOT EXIST.  IN THIS CASE, ; CS043
;                       WORDS 4 AND 5 OF THE BUFFER ARE CLEARED.        ; CS043
;       C=1 IF DIRECTIVE IS REJECTED.                                   ;**-1
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF BUFFER IS
;                       OUTSIDE OF ISSUING TASK'S ADDRESS SPACE.
;-

$DRRAF::MOV     (R3),R3         ;GET ADDRESS OF EVENT FLAG BUFFER


        .IF DF  A$$CHK!M$$MGE

        MOV     #4*2,R1         ;SET LENGTH OF BUFFER IN BYTES
                                                                        ; CS043
        .IF DF G$$EFN                                                   ; CS043
                                                                        ; CS043
        MOVB    $DICSV+1,R4     ;GET DPB SIZE                           ; CS043
        CMPB    #2,R4           ;READ ALL EVENT FLAGS DIRECTIVE?        ; CS043
        BEQ     12$             ;IF EQ, YES                             ; CS043
        CMPB    #3,R4           ;READ EXTENDED EVENT FLAGS DIRECTIVE?   ; CS043
        BNE     14$             ;IF NE, NO, INVALID DPB SIZE            ; CS043
        CMP     (R1)+,(R1)+     ;ADD 2 TO SIZE OF BUFFER                ; CS043
12$:                            ;REF LABEL                              ; CS043
                                                                        ; CS043
        .ENDC   ;G$$EFN                                                 ; CS043
                                                                        ; CS043
        CALL    $ACHKP          ;ADDRESS CHECK PARAMETER BUFFER

        .ENDC


        MOV     T.EFLG(R5),(R3)+ ;INSERT LOCAL FLAGS 1-16
        MOV     T.EFLG+2(R5),(R3)+ ;INSERT LOCAL FLAGS 17-32
        MOV     $COMEF,(R3)+    ;INSERT COMMON FLAGS 33-48
        MOV     $COMEF+2,(R3)+  ;INSERT COMMON FLAGS 49.-64.            ; CS043
                                                                        ; CS043
        .IF DF  G$$EFN                                                  ; CS043
                                                                        ; CS043
        CMPB    #2,R4           ;READ ALL EVENT FLAGS DIRECTIVE?        ; CS043
        BEQ     13$             ;IF EQ, YES                             ; CS043
        CLR     (R3)+           ;CLEAR WORD 4 OF BUFFER                 ; CS043
        CLR     (R3)            ;CLEAR WORD 5 OF BUFFER                 ; CS043
        MOV     $HEADR,R4       ;GET CURRENT TASK HEADER                ; CS043
        MOV     H.CUIC+1(R4),R4 ;GET TASK'S GROUP NUMBER                ; CS043
        CALL    $SRGEF          ;SEARCH FOR GROUP GLOBAL EVENT FLAGS    ; CS043
        BCS     20$             ;IF CS, THEY DON'T EXIST                ; CS043
        MOV     G.EFLG+2(R1),(R3) ;MOVE FLAGS 81.-96. TO BUFFER         ; CS043
        MOV     G.EFLG(R1),-(R3) ;MOVE FLAGS 65.-80. TO BUFFER          ; CS043
13$:                            ;REF LABEL                              ; CS043
                                                                        ; CS043
        .IFTF   ;G$$EFN                                                 ; CS043
                                                                        ; CS043
        RETURN                  ;                                       ;**-1
                                                                        ; CS043
        .IFT    ;G$$EFN                                                 ; CS043
                                                                        ; CS043
14$:    DRSTS   D.RS99          ;INVALID DPB SIZE                       ; CS043
                                                                        ; CS043
        .ENDC   ;G$$EFN                                                 ; CS043
                                                                        ; CS043

;+
; **-$DRSEF-SET EVENT FLAG
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO SET AN EVENT FLAG AND
; REPORT IS POLARITY BEFORE SETTING.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(33.),DPB SIZE(2.).
;       WD. 01 -- EVENT FLAG NUMBER OF FLAG TO BE SET.
;
; INPUTS:
;
;       R0=EVENT FLAG MASK WORD.
;       R1=EVENT FLAG MASK ADDRESS.
;       R3=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF 'D.RS00' IF THE FLAG WAS
;               CLEAR OR 'D.RS22' IF THE FLAG WAS SET.
;-

$DRSEF::                        ;REF LABEL                              ; CS031
                                                                        ; CS031
        .IF DF S$$TOP                                                   ; CS031
                                                                        ; CS031
        BIT     #T2.SEF,(R2)    ;TASK STOPPED FOR EVENT FLAGS?          ; CS031
        BEQ     15$             ;IF EQ, NO                              ; CS031
        BIC     #T2.STP*2!T2.STP,(R2) ;UNSTOP HIM. NOTE THAT THERE IS   ; CS031
                                ;NO NEED TO CALL $NXTSK OR $SETCR       ; CS031
                                ;SINCE HE IS THE ACTIVE TASK.           ; CS031
15$:                            ;REF LABEL                              ; CS031
                                                                        ; CS031
        .ENDC   ;S$$TOP                                                 ; CS031
                                                                        ; CS031
        BIT     R0,(R1)         ;TEST FLAG                              ; CS031
        BNE     10$             ;IF NE FLAG IS SET                      ;**-1
        BIS     R0,(R1)         ;SET FLAG
20$:    DRSTS   D.RS00          ;SET DIRECTIVE STATUS
        .DSABL  LSB

;+
; **-$TKWSE-TASK WAITFOR SIGNIFICANT EVENT
;
; THIS ROUTINE IS CALLED TO EXECUTE A WAITFOR SIGNIFICANT EVENT DIRECTIVE FOR
; THE CURRENT TASK FROM WITHIN THE EXECUTIVE.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       A WAITFOR SIGNIFICANT EVENT DIRECTIVE IS EXECUTED FOR THE CURRENT
;       TASK AND A RETURN TO THE CALLER IS EXECUTED.
;-

$TKWSE::MOV     $TKTCB,R5       ;GET ADDRESS OF CURRENT TASK TCB

;+
; **-$DRWSE-WAITFOR SIGNIFICANT EVENT
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO SUSPEND THE EXECUTION OF THE
; ISSUING TASK UNTIL THE NEXT SIGNIFICANT EVENT.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(49.),DPB SIZE(1.).
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF +1.
;-

$DRWSE::MOV     T.ACTL(R5),R0   ;GET TCB ADDRESS OF NEXT TASK
        MOV     R5,$SIGFL       ;SET TASK WAITING FOR SIGNIFICANT EVENT
        CALLR   $SETRQ          ;FORCE REDISPATCHING OF THE PROCESSOR

                                                                        ; CS017
        .IF DF S$$TOP                                                   ; CS017
                                                                        ; CS017
;+                                                                      ; CS017
; **-$DRSTS-STOP FOR SINGLE EVENT FLAG                                  ; CS017
;                                                                       ; CS017
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO STOP THE ISSUING TASK UNTIL    ; CS017
; A SPECIFIED LOCAL EVENT FLAG IS SET.                                  ; CS017
;                                                                       ; CS017
; DPB FORMAT:                                                           ; CS017
;                                                                       ; CS017
;       WD. 00 -- DIC(135.),DPB SIZE(2.).                               ; CS017
;       WD. 01 -- EVENT FLAG NUMBER OF FLAG TO WAITFOR.                 ; CS017
;                                                                       ; CS017
; INPUTS:                                                               ; CS017
;                                                                       ; CS017
;       R0=EVENT FLAG MASK WORD.                                        ; CS017
;       R1=EVENT FLAG MASK ADDRESS.                                     ; CS017
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.         ; CS017
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.                       ; CS017
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.                   ; CS017
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.                      ; CS017
;                                                                       ; CS017
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)                   ; CS017
;                                                                       ; CS017
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.                     ; CS017
;               DIRECTIVE STATUS OF +1 IS RETURNED.                     ; CS017
;       C=1 IF DIRECTIVE IS REJECTED.                                   ; CS017
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF THE ISSUING ; CS017
;                       TASK IS AT AST STATE.                           ; CS017
;               DIRECTIVE STATUS OF 'D.RS97' IS RETURNED IF AN EVENT    ; CS017
;                       FLAG NUMBER OTHER THAN A LOCAL EVENT FLAG       ; CS017
;                       NUMBER IS SPECIFIED.                            ; CS017
;-                                                                      ; CS017
                                                                        ; CS017
        .ENABL  LSB                                                     ; CS017
                                                                        ; CS020
        .IF DF G$$EFN                                                   ; CS020
                                                                        ; CS020
$DRSTS::CMP     -2(R3),#32.     ;LOCAL EVENT FLAG NUMBER?               ; CS020
                                                                        ; CS020
        .IFF    ;G$$EFN                                                 ; CS020
                                                                        ; CS020
$DRSTS::CMP     -(R3),#32.      ;LOCAL EVENT FLAG NUMBER?               ; CS020
                                                                        ; CS020
        .ENDC   ;G$$EFN                                                 ; CS020
                                                                        ; CS020
        BHI     20$             ;IF HI NO, ILLEGAL                      ; CS017
        BIS     #T2.SEF,(R2)    ;SET STOPPED FOR EVENT FLAG BIT         ; CS017
        BPL     $DRWFS          ;IF PL TASK NOT AT AST STATE            ; CS017
10$:    BIC     #T2.SEF,(R2)    ;CLEAR STOPPED FOR EVENT FLAG BIT       ; CS017
        DRSTS   D.RS80          ;ISSUING TASK IS AT AST STATE           ; CS017
20$:    DRSTS   D.RS97          ;ILLEGAL EVENT FLAG NUMBER              ; CS017
                                                                        ; CS017
;+                                                                      ; CS017
; **-$DRSTL-STOP FOR LOGICAL OR OF EVENT FLAGS                          ; CS017
;                                                                       ; CS017
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO STOP THE ISSUING TASK UNTIL    ; CS017
; ANY OF THE SPECIFIED LOCAL EVENT FLAGS IS SET.                        ; CS017
;                                                                       ; CS017
; DPB FORMAT:                                                           ; CS017
;                                                                       ; CS017
;       WD. 00 -- DIC(137.),DPB SIZE(3.).                               ; CS017
;       WD. 01 -- EVENT FLAG SET INDICATOR.                             ; CS017
;       WD. 02 -- EVENT FLAG MASK WORD.                                 ; CS017
;                                                                       ; CS017
;       EVENT FLAG SETS:                                                ; CS017
;                                                                       ; CS017
;       SET 0 -- EVENT FLAGS 1.-16.     LOCAL                           ; CS017
;       SET 1 -- EVENT FLAGS 17.-32.    LOCAL                           ; CS017
;       SET 2 -- EVENT FLAGS 33.-48.    GLOBAL - INVALID                ; CS017
;       SET 3 -- EVENT FLAGS 49.-64.    GLOBAL - INVALID                ; CS017
;       SET 4 -- EVENT FLAGS 65.-80.    GROUP GLOBAL - INVALID          ; CS020
;       SET 5 -- EVENT FLAGS 81.-96.    GROUP GLOBAL - INVALID          ; CS020
;                                                                       ; CS017
; INPUTS:                                                               ; CS017
;                                                                       ; CS017
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.         ; CS017
;       R3=ADDRESS OF THE SECOND WORD IN THE DPB.                       ; CS017
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.                   ; CS017
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.                      ; CS017
;                                                                       ; CS017
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)                   ; CS017
;                                                                       ; CS017
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.                     ; CS017
;               DIRECTIVE STATUS OF +1 IS RETURNED.                     ; CS017
;       C=1 IF DIRECTIVE IS REJECTED.                                   ; CS017
;               DIRECTIVE STATUS OF 'D.RS80' IS RETURNED IF THE         ; CS017
;                       ISSUING TASK IS AT AST STATE.                   ; CS017
;               DIRECTIVE STATUS OF 'D.RS97' IS RETURNED IF AN          ; CS017
;                       ILLEGAL EVENT FLAG SET OR A ZERO EVENT          ; CS017
;                       FLAG MASK IS SPECIFIED.                         ; CS017
;-                                                                      ; CS017
                                                                        ; CS017
$DRSTL::CMP     (R3),#1         ;LOCAL EVENT FLAG GROUP SPECIFIED?      ; CS017
        BHI     20$             ;IF HI NO                               ; CS017
        TST     2(R3)           ;NONZERO MASK WORD?                     ; CS017
        BEQ     20$             ;IF EQ NO, ILLEGAL                      ; CS017
        BIS     #T2.SEF,(R2)    ;SET STOPPED FOR EVENT FLAG BIT         ; CS017
        BMI     10$             ;IF MI TASK AT AST STATE, ILLEGAL       ; CS017
        .DSABL  LSB                                                     ; CS017
                                                                        ; CS017
        .ENDC   ;S$$TOP                                                 ; CS017
;+
; **-$DRWFL-WAIT FOR LOGICAL OR OF EVENT FLAGS
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO SUSPEND THE EXECUTION OF THE
; ISSUING TASK UNTIL ANY OF THE SPECIFIED EVENT FLAGS IS SET.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(43.),DPB SIZE(3.).
;       WD. 01 -- EVENT FLAG SET INDICATOR.
;       WD. 02 -- EVENT FLAG MASK WORD.
;
;       EVENT FLAG SETS:
;
;       SET 0 -- EVENT FLAGS 1.-16.
;       SET 1 -- EVENT FLAGS 17.-32.
;       SET 2 -- EVENT FLAGS 33.-48.
;       SET 3 -- EVENT FLAGS 49.-64.
;       SET 4 -- EVENT FLAGS 65.-80.                                    ; CS020
;       SET 5 -- EVENT FLAGS 81.-96.                                    ; CS020
                                                                        ; CS020
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE SECOND WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS97' IS RETURNED IF AN
;                       ILLEGAL EVENT FLAG SET OR A ZERO EVENT
;                       FLAG MASK IS SPECIFIED.
;-

        .ENABL  LSB                                                     ; CS020
$DRWFL::MOV     (R3)+,R1        ;GET EVENT FLAG SET
                                                                        ; CS020
        .IF DF G$$EFN                                                   ; CS020
                                                                        ; CS020
        CMP     R1,#5           ;LEGAL SET?                             ; CS020
                                                                        ; CS020
        .IFF    ;G$$EFN                                                 ; CS020
                                                                        ; CS020
        CMP     R1,#3           ;LEGAL SET?
                                                                        ; CS020
        .ENDC   ;G$$EFN                                                 ; CS020
                                                                        ; CS020
        BHI     10$             ;IF HI NO
        ASL     R1              ;CONVERT TO WORD INDEX
        MOV     (R3),R0         ;GET EVENT FLAG MASK WORD
        BEQ     10$             ;IF EQ NO FLAGS SPECIFIED
        CMP     R1,#3           ;COMMON GLOBAL FLAG SET?
        BLT     20$             ;IF LT NO
                                                                        ; CS020
        .IF DF G$$EFN                                                   ; CS020
                                                                        ; CS020
        CMP     R1,#7           ;GROUP GLOBAL SET?                      ; CS020
        BLT     5$              ;IF LT NO, COMMON GLOBAL                ; CS020
        MOV     R4,-(SP)        ;SAVE REGISTERS                         ; CS020
        MOV     R0,-(SP)        ;                                       ; CS020
        MOV     R1,-(SP)        ;SAVE EVENT FLAG SET INDEX              ; CS020
        MOVB    H.CUIC+1(R4),R4 ;GET GROUP NUMBER                       ; CS020
        CALL    $SRGEF          ;SEARCH FOR GROUP GLOBAL EVENT FLAGS    ; CS020
        BCS     10$             ;IF CS GROUP NOT FOUND                  ; CS020
        ADD     (SP)+,R1        ;POINT TO PROPER GROUP GLOBAL EF WORD   ; CS020
        ADD     #G.EFLG-10,R1   ;  IN THE GROUP GLOBAL EVENT FLAG BLOCK ; CS020
        MOV     (SP)+,R0        ;RESTORE REGISTERS                      ; CS020
        MOV     (SP)+,R4        ;                                       ; CS020
        CMP     -2(R3),#4       ;IN FIRST SIXTEEN GROUP GLOBAL FLAGS?   ; CS020
        BEQ     40$             ;IF EQ YES                              ; CS020
        BR      30$             ;IT'S IN SECOND GROUP OF SIXTEEN        ; CS020
5$:                             ;REF LABEL                              ; CS020
                                                                        ; CS020
        .ENDC   ;G$$EFN                                                 ; CS020
                                                                        ; CS020
        ADD     #$COMEF-4,R1    ;POINT TO PROPER COMMON FLAG WORD
        BR      $DRWFS          ;FINISH UP AS IF SINGLE FLAG
10$:    DRSTS   D.RS97          ;SET DIRECTIVE STATUS
20$:    ADD     R5,R1           ;ADD ADDRESS OF TASK TCB
        ADD     #T.EFLG,R1      ;POINT TO PROPER TASK FLAGS WORD

;+
; **-$DFWFS-WAITFOR SINGLE EVENT FLAG
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO SUSPEND THE EXECUTION OF THE
; ISSUING TASK UNTIL A SPECIFIED EVENT FLAG IS SET.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(41.),DPB SIZE(2.).
;       WD. 01 -- EVENT FLAG NUMBER OF FLAG TO WAITFOR.
;
; INPUTS:
;
;       R0=EVENT FLAG MASK WORD.
;       R1=EVENT FLAG MASK ADDRESS.
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE LAST WORD IN THE DPB+2.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 WITH A DIRECTIVE STATUS OF +1.
;-

$DRWFS::                        ;REF LABEL                              ; CS020
                                                                        ; CS020
        .IF DF G$$EFN                                                   ; CS020
                                                                        ; CS020
        CMP     -2(R3),#64.     ;GROUP GLOBAL EVENT FLAG?               ; CS020
        BLOS    50$             ;IF LOS NO                              ; CS020
        CMP     -2(R3),#80.     ;IS FLAG IN FIRST WORD?                 ; CS020
        BLOS    40$             ;IF LOS YES                             ; CS020
30$:    INC     G.CNT-<G.EFLG+2>(R1) ;INCREMENT GROUPS ACCESS COUNT     ; CS020
        BR      50$             ;                                       ; CS020
40$:    INC     G.CNT-G.EFLG(R1) ;INCREMENT GROUPS ACCESS COUNT         ; CS020
                                                                        ; CS020
        .ENDC   ;G$$EFN                                                 ; CS020
                                                                        ; CS020
50$:    INC     T.ST2(R5)       ;PUT TASK IN WAIT FOR STATE             ; CS020
        MOV     R0,H.EFLM(R4)   ;SET WAITFOR MASK WORD                  ;**-1
        MOV     R1,H.EFLM+2(R4) ;SET WAITFOR MASK ADDRESS
        CALLR   $SETRT          ;SET A SCHEDULE REQUEST
        .DSABLE LSB                                                     ; CS020

        .END
        .TITLE  DRSPW
        .IDENT  /1.04/
 
;
; COPYRIGHT (C) 1978,1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 1.04
;
; T. J. MILLER 26-MAY-77
;       INCLUDES TM100, JP084, AND JP090.
;
; FOR RSX-11M:
;
;       CHUCK SPITZ 26-OCT-78
;
;       B. S. MCCARTHY 29-NOV-78 (BUG FIXES)
;
; MODIFIED BY:
;
;       M. S. HARVEY    9-MAY-79
;               MSH021 -- DON'T RETURN EXIT STATUS FROM ACPS
;
;       CHUCK SPITZ     16-MAY-79
;               CS053 -- TEST FOR T3.CLI INSTEAD OF TCB = $MCRPT
;
; THIS MODULE CONTAINS THE DIRECTIVE ROUTINES AND PRIMARY SUBROUTINES
; WHICH PROVIDE PARENT-OFFSPRING TASKING SUPPORT.
;
; MACRO LIBRARY CALLS
;


        .IF DF  P$$OFF

        .MCALL  DCBDF$,PKTDF$,TCBDF$,UCBDF$
        DCBDF$                  ;DEFINE DEVICE CONTROL BLOCK SYMBOLS
        PKTDF$                  ;DEFINE I/O PACKET AND OCB OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK SYMBOLS
        UCBDF$                  ;DEFINE UNIT CONTROL BLOCK SYMBOLS


;+
; **-$DRCNC-CONNECT TO TASK
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO CONNECT THE ISSUING TASK TO
; THE SPECIFIED (ACTIVE) TARGET TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(143.),DPB SIZE(6.).
;       WD. 01 -- FIRST WORD OF TASK NAME IN RAD50.
;       WD. 02 -- SECOND WORD OF TASK NAME IN RAD50.
;       WD. 03 -- EFN, LENGTH OF ESB (DEFAULT=2).
;       WD. 04 -- ADDRESS OF AST ROUTINE TO ENTER UPON STATUS.
;       WD. 05 -- ADDRESS OF THE EXIT STATUS BLOCK.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TARGET TASK.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TARGET TASK.
;       R2=ADDRESS OF THE SECOND TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE EVENT FLAG NUMBER IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF AN OFFSPRING
;                       CONTROL BLOCK COULD NOT BE ALLOCATED.
;               DIRECTIVE STATUS OF 'D.RS2' IS RETURNED IF AN ATTEMPT IS
;                       BEING MADE TO CONNECT TO A CLI TASK.
;               DIRECTIVE STATUS OF 'D.RS7' IS RETURNED IF THE TARGET
;                       TASK IS NOT ACTIVE.
;               DIRECTIVE STATUS OF 'D.RS97' IS RETURNED IF AN INVALID
;                       EVENT FLAG NUMBER IS SPECIFIED.
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF THE EXIT
;                       STATUS BLOCK IS NOT ENTIRELY IN THE USER'S
;                       SPACE.
;-

$DRCNC::MOV     #ERRSV,-(SP)    ;PUSH ADDRESS OF ERROR SAVE ROUTINE
        TST     (R1)            ;IS TARGET TASK ACTIVE?
        BMI     10$             ;IF MI NO
        BIT     #T3.CLI,T.ST3(R0) ;TARGET TASK A CLI?
        BEQ     CNRQT           ;IF EQ NO
        DRSTS   D.RS2           ;CONNECTING TO CLI TASK
10$:    DRSTS   D.RS7           ;SPECIFIED TASK NOT ACTIVE

;+
; **-$DRREQ-REQUEST OR SPAWN TASK
;
; THIS ROUTINE INSTRUCTS THE SYSTEM TO REQUEST OR SPAWN THE SPECIFIED
; TASK, DEPENDING ON THE DPB SIZE.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(11.),DPB SIZE(7., 13., OR 14.).
;       WD. 01 -- FIRST HALF OF TASK NAME IN RAD50.
;       WD. 02 -- SECOND HALF OF TASK NAME IN RAD50.
;       WD. 03 -- FIRST WORD OF PARTITION NAME - NOT SUPPORTED.
;       WD. 04 -- SECOND WORD OF PARTITION NAME - NOT SUPPORTED.
;       WD. 05 -- REQUEST PRIORITY - NOT SUPPORTED.
;       WD. 06 -- REQUEST UIC.
;       WD. 07 -- EFN, LENGTH OF ESB (IGNORED, LENGTH OF 2 USED).
;       WD. 08 -- ADDRESS OF AST ROUTINE TO ENTER UPON STATUS.
;       WD. 09 -- EXIT STATUS BLOCK ADDRESS.
;       WD. 10 -- ADDRESS OF COMMAND LINE TO QUEUE FOR TARGET TASK.
;       WD. 11 -- LENGTH OF COMMAND LINE.
;       WD. 12 -- TERMINAL UNIT NUMBER FOR TI:.
;       WD. 13 -- ASCII DEVICE NAME FOR TI:.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TARGET TASK.
;       R1=ADDRESS OF THE TASK STATUS WORD OF THE TARGET TASK.
;       R2=ADDRESS OF THE SECOND TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE PARTITION NAME WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS1' IS RETURNED IF AN ALLOCATION
;                       FAILURE OCCURS ON A PARTITION CONTROL BLOCK,
;                       OFFSPRING CONTROL BLOCK, OR A COMMAND LINE BUFFER.
;               DIRECTIVE STATUS OF 'D.RS2' IS RETURNED IF AN ATTEMPT IS
;                       MADE TO ISSUE A SPAWN TO A COMMAND LINE INTER-
;                       PRETER WITHOUT SPECIFYING A COMMAND LINE.
;               DIRECTIVE STATUS OF 'D.RS7' IS RETURNED IF THE SPECIFIED
;                       TASK IS ALREADY ACTIVE (WITH EXCEPTION OF A
;                       SPAWN TO A COMMAND LINE INTERPRETER).
;               DIRECTIVE STATUS OF 'D.RS92' IS RETURNED IF AN INVALID
;                       TERMINAL UNIT IS SPECIFIED FOR TI:.
;               DIRECTIVE STATUS OF 'D.RS97' IS RETURNED IF AN INVALID
;                       EVENT FLAG NUMBER IS SPECIFIED.
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF THE EXIT
;                       STATUS BLOCK OR THE COMMAND LINE IS NOT ENTIRELY
;                       IN THE TASK'S ADDRESSING SPACE.
;               DIRECTIVE STATUS OF 'D.RS99' IS RETURNED IF AN ILLEGAL
;                       DPB SIZE IS SPECIFIED (NOT 7., 13., OR 14.).
;-

        .ENABL  LSB
$DRREQ::CALL    ERRSV           ;INITIALIZE ERROR RECOVERY
        .WORD   NULL            ;NO IMMEDIATE ACTION
        .WORD   NULL            ;NO RECOVERY ACTION
        ADD     #6,R3           ;POINT TO UIC WORD IN DPB
        MOV     (R3)+,R4        ;PICK UP SPECIFIED UIC FOR REQUEST
        MOV     T.UCB(R5),R5    ;ASSUME CURRENT UCB REQUIRED FOR REQUEST
        CMPB    $DICSV+1,#7.    ;IS THIS A SIMPLE REQUEST?
        BNE     5$              ;IF NE NO
        JMP     RQST            ;DO REQUEST PROCESSING
5$:     MOV     (PC)+,R5        ;ASSUME ILLEGAL DPB SIZE
        DRSTS   D.RS99          ;
        CMPB    $DICSV+1,#13.   ;IS IT A VALID SPAWN REQUEST?
        BEQ     CNRQT           ;IF EQ YES
        CMPB    $DICSV+1,#14.   ;IS IT A SPAWN REQUEST WITH TI SPECIFIED
        BEQ     CNRQT           ;IF EQ YES
10$:    JMP     ERROR           ;ILLEGAL DPB SIZE

;
; CONNECT PROCESSING (CNCT, SPWN).
;
; COMMON CONNECT AND REQUEST PROCESSING BEGINS HERE FOR REQUEST AND
; CONNECT.  THE FOLLOWING
; SECTION PERFORMS THE CONNECT PROCESSING.  AN OFFSPRING CONTROL BLOCK
; IS ALLOCATED AND QUEUED TO THE OFFSPRING TASK'S OCB QUEUE.  THEN THE
; EVENT FLAG AND EXIT STATUS BLOCK PARAMETERS ARE CHECKED AS THE OFF-
; SPRING CONTROL BLOCK IS INITIALIZED.  IF AN OCB IS SUCCESSFULLY
; ALLOCATED, ITS ADDRESS IS STORED IN $TEMP1 AS A FLAG THAT IT MUST BE
; QUEUED TO THE TARGET TASK ON SUCCESSFUL EXIT.
;
; REGISTER CONTENTS AT THIS POINT:
;
;       R0=ADDRESS OF THE TCB OF THE OFFSPRING TASK
;       R3=PTR TO THE EVENT FLAG NUMBER IN THE DPB.
;

CNRQT:  MOV     #O.LGTH,R1      ;PICK UP OCB SIZE
        CALL    @(SP)+          ;ALLOCATE OCB WITH TRAIL TO DEALLOCATE
        .WORD   $ALOCB          ;ALLOCATION ROUTINE ADDRESS
        .WORD   $DEACB          ;DEALLOCATION ROUTINE ADDRESS
        BCC     20$             ;IF CC ALLOCATION SUCCESSFUL
        JMP     ALLER           ;ELSE REPORT ALLOCATION FAILURE
20$:    MOV     R0,$TEMP1       ;STORE OCB ADDRESS FOR CONNECT
        MOV     (PC)+,R5        ;ASSUME INVALID EVENT FLAG NUMBER
        DRSTS   D.RS97          ;
        MOV     R0,R4           ;COPY OCB POINTER
        MOV     (R3)+,R0        ;PICK UP SPECIFIED EVENT FLAG

        .IF DF G$$EFN

        CMP     R0,#96.         ;VALID EVENT FLAG NUMBER?

        .IFF    ;G$$EFN

        CMP     R0,#64.         ;VALID EVENT FLAG NUMBER?

        .IFTF   ;G$$EFN

        BHI     10$             ;IF HI NO

        .IFT    ;G$$EFN

        CMP     R0,#64.         ;IS IT A GROUP GLOBAL EVENT FLAG?
        BLOS    25$             ;IF LOS NO
        MOV     R4,R5           ;SAVE R4
        MOV     $HEADR,R4       ;GET ADDRESS OF CURRENT TASK'S HEADER
        MOVB    H.CUIC+1(R4),R4 ;GET CUURRENT TASK'S GROUP NUMBER
        CALL    $SRGEF          ;SEARCH FOR GROUP GLOBAL EVENT FLAGS
        BCS     10$             ;IF CS, INVALID EVENT FLAG SPECIFIED
        MOV     R5,R4           ;RESTORE R4
25$:                            ;REFERENCE LABEL

        .ENDC   ;G$$EFN

        MOV     $TKTCB,R5       ;PICK UP CURRENT TASK TCB ADDRESS
        MOV     R0,-(SP)        ;SAVE EVENT FLAG NUMBER
        CALL    $CEFI           ;CONVERT EVENT FLAG NUMBER TO MASK & ADD
        BIC     R0,(R1)         ;CLEAR EVENT FLAG
        TST     (R4)+           ;SKIP OVER OCB LINK WORD (O.LNK)
        CLR     (R4)+           ;INITIALLY CLR MCR LINE PTR (O.MCRL)
        MOV     R5,(R4)+        ;SET PARENT TCB ADDRESS (O.PTCB)
        MOV     (R3)+,(R4)+     ;SET AST ADDRESS (O.AST)
        MOV     (SP)+,(R4)+     ;SET EVENT FLAG NUMBER (O.EFN)
        MOV     (R3)+,R0        ;PICK UP EXIT STATUS BLOCK ADDRESS
        MOV     R0,(R4)+        ;STORE IT IN OCB (O.ESB)
        MOV     T.NAM(R5),(R4)+ ;STORE PARENT TASK NAME (O.STAT)
        MOV     T.NAM+2(R5),(R4) ;(O.STAT+2)

        .IF DF A$$CHK!M$$MGE

        TST     R0              ;EXIT STATUS BLOCK SPECIFIED?
        BEQ     30$             ;IF EQ NO, BYPASS ADDRESS CHECK
        MOV     #2,R1           ;PICK UP SIZE OF EXIT STATUS BLOCK
        CALL    $ACHCK          ;ADDRESS CHECK EXIT STATUS BLOCK
        BCC     30$             ;IF CS ADDRESS CHECK OK
        JMP     ADCER           ;ADDRESS CHECK FAILURE

        .ENDC   ;A$$CHK!M$$MGE

30$:    CMPB    $DICSV,#143.    ;IS DIRECTIVE A CONNECT?
        BLO     35$             ;IF LO IT IS SPAWN
        JMP     SUCCESS         ;IT IS CONNECT, RETURN SUCCESS
35$:

;
; TI: DETERMINATION AND COMMAND LINE PROCESSING (SPWN).
;
; HERE THE TARGET TASK'S TI: IS DETERMINED FOR THE SUBSEQUENT REQUEST
; AND COMMAND LINE PROCESSING IS INITIATED.  IF A TERMINAL UNIT
; HAS BEEN SPECIFIED, THEN IT IS VERIFIED AND ITS UCB IS FOUND.
; OTHERWISE THE ISSUING TASK'S UCB IS PROPAGATED.
;
; REGISTER CONTENTS AT THIS POINT:
;
;       R3=PTR TO COMMAND LINE BUFFER ADDRESS IN THE DPB.
;


        CMPB    $DICSV+1,#14.   ;WAS TI: SPECIFIED?
        BNE     45$             ;IF NE NO
        TST     6(R3)           ;DEVICE NAME SPECIFIED?
        BNE     64$             ;IF NE YES
45$:    MOV     T.UCB(R5),R5    ;PICK UP PARENT UCB ADDRESS

        .IF DF M$$CRX

61$:    JMP     CMLPR           ;PERFORM COMMAND LINE PROCESSING

        .IFF    ;M$$CRX

61$:    MOV     -10(R3),R4      ;PICK UP SPECIFIED UIC FOR REQUEST
        JMP     RQST            ;JUMP TO REQUEST TASK

        .ENDC   ;M$$CRX

64$:    BIT     #T3.PRV,T.ST3(R5) ;IS CALLER PRIVILEGED?
        BEQ     PRVER           ;IF EQ NO
        MOV     R3,R1           ;SAVE POINTER TO CMD LINE BUF ADD IN DPB
        MOV     #$SCDVT,-(SP)   ;SET UP TO SCAN DEVICE TABLES
66$:    CALL    @(SP)+          ;GET ADDRESS OF NEXT DCB
        BCS     ILUER           ;IF CS DEVICE NOT FOUND
        MOV     #1,S$$SPC(SP)   ;SET UP TO SKIP THIS DCB IF NO MATCH
        CMP     D.NAM(R3),6(R1) ;DEVICE NAMES MATCH?
        BNE     66$             ;IF NE NO
        CMPB    D.UNIT+1(R3),4(R1) ;UNIT ASSOCIATED WITH THIS DCB?
        BLO     66$             ;IF LO NO
        ADD     #S$$SPA,SP      ;ABORT DEVICE SCAN
        BIT     #DV.TTY,U.CW1(R5) ;IS SPECIFIED DEVICE A TERMINAL?
        BEQ     ILUER           ;IF EQ NO
        MOVB    4(R1),R0        ;GET UNIT NUMBER SPECIFIED
        SUB     D.UNIT(R3),R0   ;CALCULATE NUMBER OF UCBS TO SKIP
        MOV     R3,R4           ;COPY DCB ADDRESS
        MOV     R1,R3           ;RESTORE ADDRESS OF COMMAND LINE
68$:    DECB    R0              ;IS THIS THE CORRECT UCB?
        BLT     61$             ;IF LT R5 HAS THE ADDRESS OF THE UCB
        ADD     D.UCBL(R4),R5   ;POINT TO NEXT UCB
        BR      68$             ;CONTINUE SCAN

;
; COMMON REQUEST PROCESSING (RQST, SPWN).
;
; HERE THE COMMON REQUEST PROCESSING IS PERFORMED FOR REQUEST AND
; SPAWN.  DEFAULT AND PROTECTION UIC DETERMINATION IS
; PERFORMED AND THE TASK IS REQUESTED VIA $TSKRP.  A TASK REQUEST
; FAILURE IS JUDGED IN LIGHT OF THE DIRECTIVE BEING PERFORMED.
;
; REGISTER CONTENTS AT RQST:
;
;       R4=REQUEST UIC
;       R5=TARGET TASK UCB ADDRESS
;

80$:    CLR     R4              ;SET TO PROPAGATE ISSUING TASK'S UIC
        MOV     T.UCB(R5),R5    ;SET TI: UCB ADDRESS

RQST:   MOV     $TEMP0,R0       ;RESTORE POINTER TO TARGET TCB

110$:   MOV     $MCRCB,R2       ;PICK UP FIRST ENTRY IN GMCR QUEUE
        BEQ     120$            ;IF EQ THERE IS NONE
        TST     (R2)+           ;POINT TO TCB ADDRESS
        TST     (R2)            ;QUEUED IN THIS DIRECTIVE?
        BNE     120$            ;IF NE NO
        MOV     R0,(R2)         ;SET TCB ADDRESS IN COMMAND LINE
120$:   MOV     R4,R1           ;COPY SPECIFIED UIC ADDRESS
        MOV     $TKTCB,R2       ;PICK UP CURRENT TCB ADDRESS
        ADD     #T.ST2,R2       ;POINT TO SECOND TASK STATUS WORD
        MOV     $HEADR,R4       ;POINT TO CURRENT TASK HEADER


        .IF DF  M$$MUP

        CALL    $UISET          ;CALCULATE DEFAULT AND PROTECTION UIC'S

        .ENDC


        MOV     R5,R2           ;PICK UP TARGET UCB ADDRESS
        MOV     R0,R5           ;SAVE ADDRESS OF TARGET TASK TCB
        CALL    $TSKRP          ;REQUEST THE TASK
        BCC     RQSUC           ;IF CC SUCCESS
        BNE     ALER1           ;IF NE ALLOCATION FAILURE
        MOV     (PC)+,R5        ;PICK UP TASK ALREADY ACTIVE STATUS
        DRSTS   D.RS7           ;
        BR      ERROR           ;RETURN ERROR STATUS
        .DSABL  LSB

;
; LOCAL ERROR RETURN ROUTINES.
;
; THE FOLLOWING ROUTINES INTERFACE TO $DRTHR AND $ERREC FOR DIRECTIVE
; ERROR STATUS RETURNS AND ERROR RECOVERY.  R5 IS USED TO STORE THE
; ERROR STATUS TRAP INSTRUCTION.
;

ADCPOP: TST     (SP)+           ;CLEAN STACK BEFORE RETURNING ERROR
ADCER:  MOV     (PC)+,R5        ;PICK UP ADDRESS CHECK ERROR STATUS
        DRSTS   D.RS98          ;
        BR      ERROR           ;RETURN ERROR STATUS
ALLER:  ADD     #6,SP           ;POP THREAD TO DEALLOCATE ROUTINE
ALER1:  MOV     (PC)+,R5        ;PICK UP ALLOCATION FAILURE STATUS
        DRSTS   D.RS1           ;
ERROR:  JMP     $ERREC          ;THREAD THROUGH ERROR RECOVERY
CMLER:  MOV     (PC)+,R5        ;PICK UP COMMAND LINE ERROR STATUS
        DRSTS   D.RS2           ;
        BR      ERROR           ;RETURN ERROR STATUS
ILUER:  MOV     (PC)+,R5        ;PICK UP ILLEGAL DEVICE UNIT ERROR
        DRSTS   D.RS92          ;
        BR      ERROR           ;RETURN ERROR STATUS
PRVER:  MOV     (PC)+,R5        ;PICK PRIVILEGE VIOLATION ERROR
        DRSTS   D.RS16          ;
        BR      ERROR           ;RETURN ERROR STATUS
RQSUC:
SUCCES: MOV     $TEMP1,R1       ;IS THERE AN OCB TO QUEUE?
        BEQ     10$             ;IF EQ NO
        MOV     O.PTCB(R1),R2   ;PICK UP PARENT TCB ADDRESS
        INC     T.RDCT(R2)      ;INCREMENT PARENT'S RUNDOWN COUNT
        MOV     $TEMP0,R0       ;PICK UP TARGET TCB ADDRESS
        ADD     #T.OCBH,R0      ;POINT TO OCB LISTHEAD
        CALL    $QINSF          ;INSERT THE OCB IN THE QUEUE
10$:    DRSTS   +1              ;SUCCESSFUL COMPLETION OF DIRECTIVE

;
; COMMAND LINE PROCESSING (SPWN).
;
; THIS SECTION PERFORMS THE COMMAND LINE PROCESSING FOR THE SPAWN
; DIRECTIVE.  FIRST A STANDARD SIZE COMMAND LINE BUFFER IS ALLOCATED
; AND THEN ADDRESS CHECKING OF THE USER SPECIFIED COMMAND LINE IS
; PERFORMED.  THE COMMAND LINE IS THEN TRANSFERRED TO THE ALLOCATED
; BUFFER AND TERMINATED WITH AN ESCAPE CHARACTER.  IF THE TARGET TASK
; IS NOT MCR, THEN THE COMMAND LINE IS QUEUED
; FOR THE TASK TO $MCRCB, MAKING IT AVAILABLE VIA THE GET MCR COMMAND
; LINE DIRECTIVE.  IF THE TARGET TASK IS MCR,
; THEN THE COMMAND LINE IS QUEUED TO THE MCR'S RECEIVE QUEUE AND $EXRQN
; IS CALLED TO INSURE THAT MCR IS ACTIVE AND NOT STOPPED (VIA THE ROUTINE
; $QMCRL).  SPAWN PROCESSING FOR MCR IS COMPLETE AT THIS POINT.
;
; THIS SECTION LOGICALLY FALLS IN LINE AFTER THE TI: DETERMINATION ABOVE
; BUT HAS BEEN PLACED HERE FOR CONVENIENCE TO MAKE ALL BRANCHES REACH.
;
; REGISTER CONTENTS AT THIS POINT:
;
;       R3=PTR TO COMMAND LINE ADDRESS IN THE DPB.
;       R5=TARGET TASK UCB ADDRESS.
;

        .IF DF M$$CRX

CMLPR:  MOV     (R3),R1         ;COMMAND LINE SPECIFIED?
        BEQ     10$             ;IF EQ NO
        MOV     #M$$CRB,R1      ;PICK UP SIZE OF BLOCK TO ALLOCATE
        CALL    @(SP)+          ;ALLOCATE BUF WITH TRAIL TO DEALLOCATE
        .WORD   $ALOCB          ;ALLOCATION ROUTINE ADDRESS
        .WORD   $DEACB          ;DEALLOCATION ROUTINE ADDRESS
        BCS     ALLER           ;IF CS ALLOCATION FAILURE
        MOV     R0,R4           ;SAVE ADDRESS OF ALLOCATED BUFFER
        TST     (R4)+           ;SKIP OVER LINK WORD
        CLR     (R4)+           ;CLEAR TCB ADDRESS
        MOV     2(R3),R1        ;PICK UP SIZE OF COMMAND LINE
        BEQ     6$              ;IF EQ, DON'T BOTHER MOVING IT
        CMP     R1,#79.         ;IS COMMAND LINE TOO LARGE?
        BHI     ADCER           ;IF HI YES
        MOV     (R3),R0         ;PICK UP ADDRESS

        .IF DF A$$CHK!M$$MGE

        MOV     R1,-(SP)        ;SAVE BUFFER LENGTH
        CALL    $ACHKB          ;ADDRESS CHECK COMMAND LINE BUFFER
        BCS     ADCPOP          ;IF CS ADDRESS CHECK FAILURE

        .ENDC   ;A$$CHK!M$$MGE

        .IF DF M$$MGE

        CALL    $RELOC          ;RELOCATE USER ADDRESS
        SUB     #20000,R2       ;CONVERT SOURCE TO KISAR5 DISPLACEMENT
        MOV     (SP)+,R0        ;RESTORE COUNT FOR $BLXIO
        CALL    $BLXIO          ;COPY USER'S COMMAND LINE

        .IFF    ;M$$MGE

        .IF DF A$$CHK

        MOV     (SP)+,R1        ;PICK UP SIZE OF COMMAND LINE

        .ENDC   ;A$$CHK

4$:     MOVB    (R0)+,(R4)+     ;MOVE IT
        DEC     R1              ;MORE TO MOVE?
        BGT     4$              ;IF GT, YES

        .ENDC   ;M$$MGE

6$:     MOVB    #33,(R4)        ;TERMINATE LINE WITH ESCAPE
        MOV     2(SP),R1        ;RETRIEVE SAVED BUFFER ADDRESS
10$:    MOV     $TEMP0,R0       ;PICK UP TARGET TASK TCB ADDRESS
        BIT     #T3.CLI,T.ST3(R0) ;TARGET TASK A CLI?                   ; CS053
        BNE     20$             ;IF NE, YES                             ; CS053
        TST     R1              ;COMMAND LINE SPECIFIED?                ;**-2
        BEQ     15$             ;IF EQ NO
        MOV     #$MCRCB,R0      ;POINT TO GET MCR LINE LISTHEAD
        CALL    @(SP)+          ;QUEUE THE COMMAND WITH TRAIL TO DEQUEUE
        .WORD   QMCRB           ;ROUTINE TO QUEUE THE COMMAND LINE
        .WORD   DMCRB           ;ROUTINE TO DEQUEUE THE LINE
15$:    MOV     -10(R3),R4      ;PICK UP SPECIFIED UIC FOR REQUEST
        JMP     RQST            ;JUMP TO REQUEST TASK
20$:    MOV     $TEMP1,R2       ;PICK UP OCB POINTER
        MOV     R1,O.MCRL(R2)   ;STORE POINTER TO MCR COMMAND LINE
        BEQ     CMLER           ;IF EQ NO LINE FOR CLI
        MOV     R5,2(R1)        ;STORE UCB ADDRESS IN COMMAND LINE BUF
        CALL    @(SP)+          ;PUSH ROUTINE TO REMOVE LINE
        .WORD   NULL            ;NO IMMEDIATE ACTION
        .WORD   40$             ;ROUTINE TO REMOVE LINE
        CALL    $QMCRL          ;QUEUE THE LINE TO MCR
        BCC     SUCCES          ;IF CC SUCCESSFUL REQUEST
        BEQ     SUCCES          ;IF EQ CLI WAS ALREADY ACTIVE - SUCCESS
        BR      ALER1           ;ELSE REQUEST FAILED FOR PCB ALLOCATION
40$:    ADD     #T.RCVL,R0      ;POINT TO CLI'S RECEIVE QUEUE
        CALLR   $QRMVT          ;REMOVE THE COMMAND LINE

        .ENDC   ;M$$CRX

;+
; **-$DREXS-EXIT WITH STATUS
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO PASS A STATUS WORD TO ALL
; PARENT TASKS AND EXIT.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(29.),DPB SIZE(2.)
;       WD. 01 -- STATUS WORD.
;
; INPUTS:
;
;       R2=ADDRESS OF THE SECOND STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE STATUS WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       NO STATUS IS RETURNED TO THE ISSUING TASK SINCE THIS DIRECTIVE
;       TERMINATES ITS EXECUTION.
;-

$DREXS::BIT     #T3.ACP,T.ST3(R5) ;IS THIS AN ACP?                      ;MSH021
        BNE     5$              ;IF NE YES                              ;MSH021
        MOV     (R3),T.EFLG+2(R5) ;SET EXIT STATUS IN TCB               ;MSH021
5$:     CALLR   $CEXIT          ;INITIATE TASK EXIT PROCESS             ;MSH021
                                                                        ;**-2
;
; LOCAL ROUTINES.
;
; THE FOLLOWING ROUTINES ARE USED TO INSERT AND REMOVE AN ELEMENT FROM
; THE FRONT OF A LIST.  SPECIFICALLY THESE ROUTINES ARE CALLED TO
; OPERATE ON THE MCR COMMAND LINE LIST AT $MCRCB.
;

QMCRB:  MOV     (R0),(R1)       ;LINK NEW LINE TO FIRST IN LIST
        MOV     R1,(R0)         ;LINK LISTHEAD TO NEW LINE
        RETURN                  ;
DMCRB:  MOV     (R1),(R0)       ;UNLINK NEW COMMAND LINE
NULL:   RETURN                  ;(NULL ROUTINE)

;
; ROUTINE TO INITIALIZE ERROR RECOVERY FOR CONNECT, REQUEST, SEND
; REQUEST AND CONNECT, AND SPAWN.
;

ERRSV:  MOV     R0,$TEMP0       ;SAVE TARGET TCB ADDRESS
        CLR     $TEMP1          ;INITIALIZE OCB POINTER
        JMP     $DRTHR          ;INITIALIZE ERROR RECOVERY THREADING

        .ENDC   ;P$$OFF


        .END
        .TITLE  DRSST
        .IDENT  /03/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; D. N. CUTLER 30-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;
; MODIFIED BY:
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HDRDF$
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
 
;+
; **-$DRSDV-SPECIFY DEBUGGING AID SST VECTOR
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO RECORD THE ADDRESS AND LENGTH
; OF A VECTOR OF SST SERVICE ROUTINE ENTRY POINTS FOR USE BY AN INTRA-
; TASK DEGUGGING AID (E.G. ODT)
;
; DPB FORMAT:
;
;       WD. 00 -- DIC (103.),DPB SIZE(3.).
;       WD. 01 -- ADDRESS OF THE SST VECTOR.
;       WD. 02 -- NUMBER OF ENTRIES IN THE SST VECTOR.
;
;       SST VECTOR FORMAT:
;
;               WD. 00 -- TRAPS TO 4 (ODD ADDRESS, NONEX MEM, ETC.).
;               WD. 01 -- SEGMENT FAULT.
;               WD. 02 -- TRACE TRAP (T-BIT) OR EXECUTION OF BPT INSTRUCTION.
;               WD. 03 -- EXECUTION OF AN IOT INSTRUCTION.
;               WD. 04 -- EXECUTION OF AN ILLEGAL OR RESERVED INSTRUCTION.
;               WD. 05 -- EXECUTION OF A NON RSX EMT INSTRUCTION.
;               WD. 06 -- EXECUTION OF A TRAP INSTRUCTION.
;               WD. 07 -- PDP 11/40 FLOATING POINT EXCEPTION FAULT.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE SECOND WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IS RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF PART OF VECTOR
;                       IS OUTSIDE OF ISSUING TASK'S ADDRESS SPACE,
;                       VECTOR ADDRESS OF ZERO IS SPECIFIED, OR  THE
;                       VECTOR SIZE IS GREATER THAN 31. WORDS.
;-
 
        .ENABL  LSB
$DRSDV::ADD     #H.ODVL,R4      ;POINT TO ODT VECTOR LENGTH IN HEADER
        BR      10$             ;FINISH UP IN COMMON CODE
 
;+
; **-$DRSTV-SPECIFY TASK SST VECTOR
;
; THIS DIRECTIVE INSTRUCTS THE SYSTEM TO RECORD THE ADDRESS AND LENGTH OF
; A VECTOR OF SST SERVICE ROUTINE ENTRY POINT FOR USE BY THE ISSUING TASK.
;
; DPB FORMAT:
;
;       WD. 00 -- DIC(105.),DPB SIZE(3.).
;       WD. 01 -- ADDRESS OF THE SST VECTOR.
;       WD. 02 -- NUMBER OF ENTRIES IN THE SST VECTOR.
;
;       SST VECTOR FORMAT:
;
;               WD. 00 -- TRAPS TO 4 (ODD ADDRESS, NONEX MEM, ETC.).
;               WD. 01 -- SEGMENT FAULT.
;               WD. 02 -- TRACE TRAP (T-BIT) OR EXECUTION OF A BPT INSTRUCTION.
;               WD. 03 -- EXECUTION OF AN IOT INSTRUCTION.
;               WD. 04 -- EXECUTION OF AN ILLEGAL OR RESERVED INSTRUCTION.
;               WD. 05 -- EXECUTION OF A NON RSX EMT INSTRUCTION.
;               WD. 06 -- EXECUTION OF A TRAP INSTRUCTION.
;               WD. 07 -- PDP 11/40 FLOATING POINT EXCEPTION FAULT.
;
; INPUTS:
;
;       R2=ADDRESS OF THE TASK STATUS WORD OF THE CURRENT TASK.
;       R3=ADDRESS OF THE SECOND WORD IN THE DPB.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS: (DIRECTIVE STATUS AND PS RETURNED TO TASK)
;
;       C=0 IF DIRECTIVE IS SUCCESSFULLY COMPLETED.
;               DIRECTIVE STATUS OF +1 IF RETURNED.
;       C=1 IF DIRECTIVE IS REJECTED.
;               DIRECTIVE STATUS OF 'D.RS98' IS RETURNED IF PART OF VECTOR
;                       IS OUTSIDE OF ISSUING TASK'S ADDRESS SPACE,
;                       VECTOR ADDRESS OF ZERO IS SPECIFIED, OR THE
;                       VECTOR SIZE IS GREATER THAN 31. WORDS.
;-
 
$DRSTV::ADD     #H.TKVL,R4      ;POINT TO TASK VECTOR LENGTH IN HEADER
10$:    MOV     (R3)+,R0        ;GET ADDRESS OF VECTOR
        BEQ     20$             ;IF EQ DEASSIGN VECTOR
        MOV     (R3),R1         ;GET LENGTH OF SST VECTOR
        BEQ     15$             ;IF EQ DEASSIGN VECTOR
        CMP     (R3),#31.       ;VECTOR TOO BIG?
        BHI     30$             ;IF HI YES
 
 
        .IF DF  A$$CHK!M$$MGE
 
        ASL     R1              ;CONVERT LENGTH TO BYTES
        CALL    $ACHKW          ;ADDRESS CHECK SST VECTOR
 
        .ENDC
 
 
15$:    MOV     (R3),(R4)       ;SET SST VECTOR LENGTH
        ASL     (R4)            ;CONVERT LENGTH TO BYTES
20$:    MOV     -(R3),-(R4)     ;SET SST VECTOR ADDRESS
        RETURN                  ;RETURN DIRECTIVE STATUS OF +1
30$:    DRSTS   D.RS98          ;SET DIRECTIVE STATUS
        .DSABL  LSB
 
        .END
        .TITLE  DSDRV
        .IDENT  /07.2/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 07.2
;
; D. N. CUTLER 14-FEB-74
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;       D. N. CUTLER
;       C. A. D'ELIA
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 30-NOV-76
;
;               PB009 -- CORRECT OUT OF RANGE BRANCHES WHEN A
;                       MULTI-CONTROLLER DRIVER IS GENERATED.
;
;       P. J. BEZEREDI 07-FEB-77
;
;               PB013 -- ADDITION OF EXPANDED WRITE CHECK CAPABILITY.
;
;       P. J. BEZEREDI 14-FEB-77
;
;               PB014 -- LOAD SECOND STATUS WORD WITH BYTES ACTUALLY
;                       TRANSFERED BEFORE CALLING $IODON.
;
;       P. J. BEZEREDI 22-FEB-77
;
;               PB016 -- LOAD PROPER ADDRESS EXTENSION REGISTER FOR
;                       MIXED MASSBUS CONFIGURATIONS.
;
;       P. J. BEZEREDI 16-MAY-77
;
;               PB030 -- POWERFAIL RECOVERY SUPPORT.
;
;       P. J. BEZEREDI 07-SEP-77
;
;               PB037 -- USE R1 FOR I/O PACKET ADDRESS IN FUNCTION
;
;       R. T. PERRON 15-JAN-79
;
;               RP007 -- ADDITION OF RH11 SUPPORT FOR 22-BIT ADDRESSING
;
; RH11-RS03/RS04 FIXED HEAD DISK DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS


        .IF DF  D$$IAG

        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS

        .ENDC


;
; EQUATED SYMBOLS
;

RETRY=8.                        ;ERROR RETRY COUNT
RSWC=2                          ;WORD COUNT REGISTER
RSCS2=10                        ;SECOND STATUS REGISTER
RSDS=12                         ;DRIVE STATUS REGISTER
RSER=14                         ;ERROR REGISTER
RSBAE=30                        ;BUS ADDRESS EXTENSION REGISTER


        .IF DF  M$$IXD

RSBAE=74                        ;MIXED MASSBUS ADDRESS EXT. REGISTER

        .ENDC


;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLER NUMBER)
;

CNTBL:  .BLKW   R$$JS1          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   R$$JS1          ;RETRY COUNT FOR CURRENT OPERATION


        .IF GT  R$$JS1-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC

;
; DRIVER DISPATCH TABLE
;

$DSTBL::.WORD   DSINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DSCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DSOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   DSPWF           ;POWERFAIL ENTRY POINT

;+
; **-DSINI-RH11-RS03/RS04 FIXED HEAD DISK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
DSINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     DSCAN           ;IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; RH11-RS03/RS04 FIXED HEAD DISK I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB OR IO.WLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- MEMORY EXTENSION BITS (BITS 4 AND 5) OF I/O TRANSFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- LOW BYTE MUST BE ZERO AND HIGH BYTE NOT USED.
;       WD. 17 -- LOGICAL BLOCK NUMBER OF I/O REQUEST.
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. ADRS ELSE NOT USED
;       WD. 21 -- DIAGNOSTIC REG. BLK ADRS (REAL OR DISPL.+140000)
;

        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB


        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUSS DEVICE?           ; RP007
        BNE     1$              ;IF NE YES -- DOES NOT USE UMR'S        ; RP007
        CALL    $STMAP          ;SET UP UNIBUS MAP                      ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
        ASL     U.BUF(R5)       ;SHIFT ADDRESS EXTENSION BITS INTO PLACE; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
        ASL     U.BUF(R5)       ;                                       ; RP007
1$:                             ;REF LABEL                              ; RP007
                                                                        ;**-8

        .IF DF  D$$IAG

        CMP     #IO.WCK!IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC WRITE CHECK?
        BNE     5$              ;IF NE NO
        BIS     #151,U.BUF(R5)  ;YES, SET FUNCTION CODE
        BR      10$             ;

        .ENDC


5$:     MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        BIS     #171,U.BUF(R5)  ;ASSUME READ LOGICAL FUNCTION
        CMPB    #IO.RLB/256.,I.FCN+1(R1) ;READ LOGICAL FUNCTION?
        BHIS    6$              ;IF HIS FUNCTION IS LEGAL
        JMP     70$             ;FUNCTION IS ILLEGAL
6$:     BEQ     10$             ;IF EQ FUNCTION IS READ
        SUB     #10,U.BUF(R5)   ;CONVERT TO WRITE LOGICAL FUNCTION
10$:    MOV     #RETRY,RTTBL(R3) ;SET RETRY COUNT
        CALL    $BLKCK          ;CHECK LOGICAL BLOCK NUMBER
        TST     U.CW2(R5)       ;RS04 DRIVE?
        BMI     20$             ;IF MI YES
        ASL     R0              ;MULTIPLY RS03 BLOCK
20$:    ASL     R0              ;CONVERT TO SECTOR AND TRACK ADDRESS
        MOV     R0,I.PRM+12(R3) ;SAVE DISK ADDRESS


        .IF DF  M$$IXD          ;

        CALL    $RQCH           ;REQUEST CHANNEL

        .ENDC


;
; INITIATE I/O OPERATION
;

30$:                            ;REF LABEL                              ; RP007
                                                                        ; RP007
                                                                        ; RP007
        .IF DF  M$$EXT                                                  ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASS BUS DEVICE?            ; RP007
        BNE     300$            ;IF NE YES -- DOES NOT USE UMR'S        ; RP007
        CALL    $MPUBM          ;MAP UNIBUS TO MEMORY                   ; RP007
300$:                           ;REF LABEL                              ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR                     ; RP007
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS                 ;**-1
        MOVB    S.ITM(R4),S.CTM(R4)  ;SET CURRENT DEVICE TIMEOUT COUNT
        ADD     #RSCS2,R2       ;POINT TO SECOND CSR
        MOV     #40,(R2)        ;CLEAR RH11 CONTROLLER AND ALL DRIVES
        MOVB    U.UNIT(R5),(R2) ;SELECT PROPER DRIVE
        MOV     I.PRM+12(R1),-(R2)  ;INSERT DISK ADDRESS
        MOV     U.BUF+2(R5),-(R2)  ;INSERT BUFFER ADDRESS
        MOV     U.CNT(R5),-(R2) ;INSERT NUMBER OF BYTES TO TRANSFER
        ROR     (R2)            ;CONVERT TO WORD COUNT
        NEG     (R2)            ;MAKE NEGATIVE WORD COUNT
        TST     -(R2)           ;POINT TO CSR REGISTER
        MOV     #IE.DNR&377,R0  ;ASSUME DRIVE NOT READY
        MOV     RSDS(R2),R3     ;GET CONTENTS OF DRIVE STATUS REGISTER
        COM     R3              ;COMPLEMENT STATUS
        BIT     #10200,R3       ;DRIVE READY AND ON-LINE?
        BEQ     32$             ;IF EQ YES


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;IS DRIVE SPINNING UP?
        BNE     35$             ;IF NE YES

        .IFTF


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC OPERATION?
        BEQ     31$             ;IF EQ NO
        JMP     45$             ;LOG DIAGNOSTIC DRIVE NOT READY
31$:                            ;REF LABEL

        .ENDC


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DRIVE NOT READY ERROR

        .ENDC


        JMP     60$             ;FINISH I/O
32$:                            ;REF LABEL

        .IFT

        BICB    #US.SPU,U.STS(R5)  ;RESET DRIVE SPINNING UP

        .ENDC


                                                                        ;**-5

        .IF DF  E$$DVC

        CALL    $BMSET          ;SET I/O ACTIVE BIT IN MAP

        .ENDC


        .IF DF  M$$EXT&M$$MGE                                           ; RP007
                                                                        ; RP007
        BIT     #DV.MBC,U.CW1(R5)  ;;;IS IT A MASS BUS DEVICE?          ; RP007
        BEQ     34$             ;;;IF EQ NO -- DOES USE UMR'S           ; RP007
        MOVB    U.BUF+1(R5),RSBAE(R2)  ;;;SET ADDRESS EXTENSION BITS    ; RP007
        MOVB    U.BUF(R5),(R2)  ;;;START FUNCTION                       ; RP007
        RETURN                  ;;;                                     ; RP007
                                                                        ; RP007
        .ENDC                                                           ; RP007
                                                                        ; RP007
                                                                        ; RP007
34$:    MOV     U.BUF(R5),(R2)  ;;;START FUNCTION                       ; RP007
                                                                        ;**-9

;
; CANCEL I/O OPERATION IS A NOP FOR FILE STRUCTURED DEVICES.
;

DSCAN:  RETURN                  ;;;NOP FOR RS03/RS04

;+
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND
; CAUSES NO IMMEDIATE ACTION ON THE UNIT.  THE CURRENT TIMEOUT
; COUNT IS EXTENDED SO THAT IF THE UNIT WAS BUSY IT WILL HAVE
; SUFFICIENT TIME TO SPN BACK UP.  THE NEXT I/O REQUEST TO ANY
; UNIT WILL BE SUSPENDED FOR AT LEAST THE EXTENDED TIMEOUT UNLESS
; THE UNIT IS ALREADY READY.
;-

DSPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        TSTB    S.STS(R4)       ;IS THE DRIVE CURRENTLY BUSY?
        BEQ     36$             ;IF EQ NO
        MOVB    #2,S.STS(R4)    ;WAIT A MAXIMUM OF 30 SECONDS
35$:    MOVB    #15.,S.CTM(R4)  ;15 SECONDS AT A TIME
36$:    BISB    #US.SPU,U.STS(R5)  ;SET UNIT SPINNING UP

        .ENDC


        RETURN                  ;WAIT FOR UNIT TO RESPOND


;+
; **-$DSINT-RH11-RS03/RS04 FIXED HEAD DISK CONTROLLER INTERRUPTS
;-

        INTSE$  DS,PR5,R$$JS1   ;;;SAVE REGISTERS AND SET PRIORITY
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;DIAGNOSTIC FUNCTION EXECUTED?
        BNE     45$             ;IF NE YES

        .ENDC


        BIT     #60000,(R2)     ;ANY ERRORS?
        BEQ     55$             ;IF EQ NO


        .IF DF  E$$DVC

        CALL    $DVERR          ;LOG DEVICE ERROR

        .ENDC


        MOV     #IE.VER&377,R0  ;ASSUME UNRECOVERABLE ERROR
        MOV     RSER(R2),R1     ;GET CONTENTS OF ERROR REGISTER
        BIT     #47007,R1       ;HARD ERROR?
        BNE     40$             ;IF NE YES
        BIT     #14000,RSCS2(R2)  ;NEM OR NED?
        BEQ     50$             ;IF EQ NO
40$:    BIT     #4000,R1        ;WRITE LOCK ERROR?
        BEQ     57$             ;IF EQ NO
        MOV     #IE.WLK&377,R0  ;SET WRITE LOCK ERROR
        BR      60$             ;

;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING REPEATED
; UNLESS THE REQUEST WAS DIAGNOSTIC.  TIMEOUTS ARE USUALLY CAUSED
; BY POWERFAILURE BUT MAY ALSO BE THE RESULT OF A HARDWARE FAILURE.
;

DSOUT:                          ;;;TIMEOUT ENTRY POINT


        .IF DF  P$$RFL

        BITB    #US.SPU,U.STS(R5)  ;;;IS DRIVE SPINNING UP?
        BEQ     44$             ;;;IF EQ NO
        DECB    S.STS(R4)       ;;;HAVE WE WAITED ENOUGH YET?
        BEQ     44$             ;;;IF EQ YES
        MTPS    #0              ;;;ALLOW INTERRUPTS
        JMP     30$             ;RETRY ENTIRE OPERATION
44$:    INCB    S.STS(R4)       ;;;LEAVE CONTROLLER BUSY
        BICB    #US.SPU,U.STS(R5)  ;;;RESET DRIVE SPINNING UP

        .ENDC


        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT


        .IF DF  D$$IAG

        BCC     50$             ;IF CC TIMEOUT DURING NORMAL FUNCTION
45$:    CALL    $CRPAS          ;PASS CONTROLLER REGISTERS TO TASK
        BR      60$             ;DIAGNOSTIC PROCESSING COMPLETE

        .ENDC


50$:    MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        BITB    #IQ.X,I.FCN(R1) ;INHIBIT RETRIES?
        BNE     57$             ;IF NE YES
        DEC     RTTBL(R3)       ;RETRY FUNCTION?
        BLE     57$             ;IF LE NO
51$:    JMP     30$             ;RETRY OPERATION

55$:                            ;REF LABEL


        .IF DF  D$$WCK

        BITB    #IO.WLC&377,I.FCN(R1)  ;WRITE FOLLOWED BY WRITE CHECK?
        BNE     56$             ;IF NE YES
        BITB    #US.WCK,U.STS(R5)  ;WRITE CHECK ENABLED BY MCR?
        BEQ     60$             ;IF EQ NO
56$:    MOVB    U.BUF(R5),R1    ;GET LAST FUNCTION
        CMPB    #171,R1         ;WAS IT A READ?
        BEQ     60$             ;IF EQ YES
        MOVB    #151,U.BUF(R5)  ;ASSUME A WRITE CHECK OPERATION
        CMPB    #161,R1         ;WAS LAST FUNCTION A WRITE?
        BNE     60$             ;IF NE NO
        MOV     #RETRY,RTTBL(R3);REINITIALIZE RETRY COUNT
        BR      51$             ;START WRTIE CHECK OPERATION

        .IFTF

57$:                            ;REF LABEL

        .IFT

        BIT     #40000,RSCS2(R2)  ;WRITE CHECK ERROR?
        BEQ     60$             ;IF EQ NO
        MOV     #IE.WCK&377,R0  ;SET WRITE CHECK ERROR

        .ENDC


60$:    MOV     RSWC(R2),R1     ;GET WORDS REMAINING TO TRANSFER
        ASL     R1              ;CONVERT TO BYTES LEFT TO TRANSFER
        ADD     U.CNT(R5),R1    ;CALCULATE BYTES ACTUALLY TRANSFERED
        MOV     #40011,(R2)     ;CLEAR CONTROLLER AND DRIVE
70$:                            ;REF LABEL


        .IF DF  E$$DVC

        MOVB    S.CON(R4),R3    ;RETREIVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ;GET FINAL ERROR RETRY COUNT
        BIS     #RETRY*256.,R2  ;MERGE STARTING RETRY COUNT

        .ENDC


        .IF DF  M$$IXD

        CALL    $RLCH           ;RELEASE CHANNEL

        .ENDC


        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DSINI           ;PROCESS NEXT REQUEST
        .DSABL  LSB

        .END
        .TITLE  DSSDI
        .IDENT  /00/
 
;
; COPYRIGHT (C) 1975, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 00
;
; C. A. MONIA   18-JUL-75
;
; FORTRAN INTERFACE TO READ CONTACT SENSE MODULES
;
; LOCAL DATA
;
; LINK TO DSS11 DEVICE COMMON BLOCK
;
 
        .IF DF  M$$MGE!I$$SCM
 
        .PSECT  ISCOM,RW,GBL,OVR,D
 
        .BLKB   I$$SSC&77       ; COMPUTE OFFSET FROM 32W BOUNDARY
ISCOM:                          ; REF LABEL
 
        .IFF
 
        .ASECT
 
.=I$$SSC
ISCOM:                          ; REF LABEL
 
        .ENDC
 
        .PSECT
 
;
; TABLE OF OFFSETS TO DSS11 DATA REGISTERS
;
 
DSSMP:                          ;
 
OFFST=2
        .REPT   I$$SDS
        .REPT   3
        .BYTE   OFFST
OFFST=OFFST+2
        .ENDR
OFFST=OFFST+2
        .ENDR
 
        .EVEN
 
;+
; **-DI; DIW -  FORTRAN CALLABLE SUBROUTINE TO READ CONTACT SENSE
;               DSS11 MODULES
;
; CALLING SEQUENCE
;
;       CALL    DI(INM,ICNT,IDATA,[ISTS],[IUN])
;
; WHERE:
;
;       INM = INTEGER SPECIFYING NUMBER OF SAMPLES
;       ICNT = INTEGER ARRAY. EACH ELEMENT CONTAINS AN INITIAL POINT
;               DEFINING A 16 BIT FIELD.
;
;       IDATA = INTEGER ARRAY TO RECEIVE CONTACT SENSE INFORMATION.
;
;       ISTS = 2-WORD, INTEGER ARRAY TO RECEIVE STATUS.
;
;       ISTS(1) RECEIVES STATUS PER ISA/DEC CONVENTION AS FOLLOWS:
;
;               STATUS          DEFINITION
;               ------          -----------
;
;               +1              SUCCESS ALL DATA READ
;               =>3             FAILURE
;                3              '0' SAMPLES REQUESTED
;               >300            INVALID POINT SPECIFIED
;
;       IUN = UNIT SPECIFICATION (IGNORED)
;
; THIS CALL DOES NOT PERFORM A QIO, INSTEAD THE EXTERNAL PAGE IS ACCESSED
; DIRECTLY.
;
; ACCESS IN A MAPPED SYSTEM IS VIA A SPECIAL COMMON AREA. THE UNMAPPED
; SYSTEM MAY ACCESS THE DSS DIRECTLY.
;-
 
DI::                            ;
DIW::                           ;
        MOV     #3,R0           ; GET ARGUMENT COUNT-2
        CALL    .MLTPH          ; SET FOR MULTIPOINT SAMPLE
 
;
; THE ABOVE CALL RETURNS THE FOLLOWING:
;
;       C-CLEAR:
;       R3=NUMBER OF SAMPLES
;       R4=POINTER TO CONTROL ARRAY
;       R5=POINTER TO DATA ARRAY
;
;       (SP)+2=UNDEFINED
;       (SP)  =TWO-WORD I/O STATUS BLOCK ADDRESS
;
;       C-SET:
;
;       NUMBER OF SAMPLES=0
;
;       STACK SETUP AS DESCRIBED ABOVE
;
 
        BCS     40$             ; IF C/S 0 SAMPLES REQUESTED
10$:                            ;
        MOV     (R4),R0         ; GET POINT NUMBER
        CALL    .DIV16          ; DIVIDE BY 16
        MOV     R0,R2           ; SAVE BUS INDEX
        CALL    RDSS            ; READ DSS11 INPUT
        BCS     50$             ; IF C/S ILLEGAL POINT OR MODULE
        MOV     R0,(R5)         ; RETURN RESULT TO CALLER
        TST     R1              ; POINT ON MODULE BOUNDARY?
        BEQ     30$             ; IF EQ YES
        MOV     R2,R0           ; GET MODULE NUMBER AGAIN
        INC     R0              ; INCREMENT TO NEXT IN SEQUENCE
        CALL    RDSS            ; READ DSS11 INPUT
        BCS     50$             ; IF C/S ILLEGAL POINT OR MODULE
20$:                            ;
        ASR     R0              ; ROTATE MASK1
        ROR     (R5)            ; ROTATE MASK2
        DEC     R1              ; DECREMENT REMAINDER
        BGT     20$             ; IF GT GO AGAIN
30$:                            ;
        CMP     (R4)+,(R5)+     ; POINT TO NEXT SET OF ARGUMENTS
        DEC     R3              ; DECREMENT POINT COUNT
        BNE     10$             ; IF NE GO AGAIN
        JMP     .NRMRT          ; TAKE NORMAL EXIT
40$:                            ;
        JMP     .ILCSQ          ; ILLEGAL CALLING SEQUENCE
50$:                            ;
        JMP     .ILMRQ          ; NONEXISTENT MODULE REQUESTED
 
;
; READ DSS11 INPUT REGISTER
;
 
RDSS:                           ;
        CMP     #<I$$SDS*3>-1,R0 ; LEGAL POINT?
        BLO     10$             ; IF LO NO
        MOVB    DSSMP(R0),R0    ; GET OFFSET TO BUS ADDRESS
        MOV     ISCOM(R0),R0    ; GET MODULE DATA
10$:                            ;
        RETURN                  ;
 
        .END
        .TITLE  DTDRV
        .IDENT  /08.01/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 08.01
;
; D. N. CUTLER 1-DEC-73
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;       F. L. STRAIGHT
;
; MODIFIED BY:
;
;       E. L. BAATZ 18-JUN-78
;
;               EB148 -- REMOVE EXPLICIT PS REFERENCE
;
; TC11 DECTAPE CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$,HWDDF$,PKTDF$
        ABODF$                  ;DEFINE TASK ABORT CODES
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS

;
; EQUATED SYMBOLS
;

WAIT=100000                     ;WAITING TO SELECT UNIT (1=YES)
ABRT=40000                      ;ABORT CURRENT FUNCTION (1=YES)
RETRY=5.                        ;ERROR RETRY COUNT


        .IF DF  D$$IAG

        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS

        .ENDC


;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;
; DIAGNOSTIC FUNCTIONS IO.RNF AND IO.RNR USE BIT 7 OF RTTBL AS
; A FLAG FOR INTERRUPT SERVICING.

CNTBL:  .BLKW   T$$C11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   T$$C11          ;ERROR RETRY COUNT AND DRIVE RESET FLAG


        .IF GT  T$$C11-1

TEMP:   .BLKW   1               ;TEMPORY STORAGE FOR CONTROLLER NUMBER

        .ENDC

;
; DRIVER DISPATCH TABLE
;

$DTTBL::.WORD   DTINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   DTCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   DTOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   DTPWF           ;POWERFAIL ENTRY POINT

;+
; **-DTINI-TC11 DECTAPE CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
DTINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     DTPWF           ;IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R3=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; TC11 DECTAPE I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB,IO.RLV,IO.WLB, OR IO.WLV).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- MEMORY EXTENSION BITS (BITS 4 AND 5) OF I/O TRANSFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- LOW BYTE MUST BE ZERO AND HIGH BYTE NOT USED.
;       WD. 17 -- LOGICAL BLOCK NUMBER OF I/O REQUEST.
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. BLK. ADDRESS
;       WD. 21 -- DIAGNOSTIC REG. BLK. ADDRESS (REAL OR DISPL. + 140000)
;

        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB


        .IF DF  M$$EXT&M$$MGE

        CALL    $STMAP          ;SET UP UNIBUS MAPPING ADDRESS

        .ENDC


        MOV     #<8.*256.>+RETRY,RTTBL(R3) ;SET ROCK AND RETRY COUNTS


        .IF DF  D$$IAG

        MOV     R1,R0           ;COPY I/O PACKET ADDRESS
        ADD     #I.FCN,R0       ;POINT TO FUNCTION CODE
        BITB    #IQ.UMD,(R0)    ;DIAGNOSTIC FUNCTION CALL?
        BEQ     4$              ;IF EQ NO
        CLRB    RTTBL(R3)       ;NO RETRIES FOR DIAGNOSTIC OPERATIONS
        CMP     #IO.RNF!IQ.UMD,(R0)  ;READ BLOCK FORWARD?
        BNE     2$              ;IF NE NO
        MOV     #IO.RLB!IQ.UMD,(R0)  ;CONVERT TO READ LOGICAL FORWARD
        BR      3$              ;
2$:     CMP     #IO.RNR!IQ.UMD,(R0)  ;READ BLOCK REVERSE?
        BNE     4$              ;IF NE NO
        MOV     #IO.RLV!IQ.UMD,(R0)  ;CONVERT TO READ LOGICAL REVERSE
3$:     BIS     #200,RTTBL(R3)  ;SET READ BLOCK NUMBER FLAG

        .ENDC


4$:     MOV     #IE.IFC&377,R0  ;ASSUME ILLEGAL FUNCTION
        MOV     R5,R3           ;COPY ADDRESS OF UCB
        ADD     #U.BUF+1,R3     ;POINT TO HIGH BYTE OF MEM.EXT WORD
        MOVB    R2,(R3)         ;INSERT DRIVE NUMBER
        BISB    #105,-(R3)      ;ASSUME READ LOGICAL FUNCTION
        CMPB    #IO.RLB/256.,I.FCN+1(R1)  ;READ LOGICAL FUNCTION?
        BHIS    5$              ;IF HIS FUNCTION IS LEGAL
        JMP     195$            ;ILLEGAL FUNCTION
5$:     BEQ     10$             ;IF EQ FUNCTION IS READ
        BIS     #10,(R3)        ;CONVERT TO WRITE LOGICAL FUNCTION
10$:    BIT     #IO.WLV&377,I.FCN(R1)  ;REVERSE DIRECTION?
        BEQ     20$             ;IF EQ NO
        BIS     #4000,(R3)      ;SET REVERSE DIRECTION BIT
20$:    CLRB    U.CW2+1(R5)     ;CLEAR ABORT FLAG
        CALL    $BLKCK          ;CHECK LOGICAL BLOCK NUMBER
        MOV     R0,U.VCB+2(R5)  ;SAVE LOGICAL BLOCK NUMBER

;
; INITIATE I/O OPERATION
;

30$:                            ;REF LABEL


        .IF DF  M$$EXT&M$$MGE

        CALL    $MPUBM          ;MAP UNIBUS TO TRANSFER

        .ENDC


        MOV     S.CSR(R4),R0    ;GET ADDRESS OF CSR
        CMP     (R0)+,(R0)+     ;POINT TO BUFFER ADDRESS REGISTER
        MOV     U.BUF+2(R5),(R0) ;INSERT BUFFER ADDRESS
        MOV     U.CNT(R5),-(R0) ;INSERT LENGTH OF TRANSFER IN BYTES
        CLR     U.VCB+4(R5)     ;CLEAR FINAL ERROR STATUS
        ROR     (R0)            ;CONVERT LENGTH TO WORD COUNT
        NEG     (R0)            ;MAKE NEGATIVE WORD COUNT
        MOVB    U.BUF+1(R5),-(R0) ;INSERT UNIT AND DIRECTION BIT
        BIS     #WAIT,U.CW2(R5) ;SET WAITING TO SELECT UNIT
        MOVB    #11,-(R0)       ;STOP TRANSPORT (SELECT UNIT)
35$:    BIT     #100200,(R0)    ;SELECT ERROR?
        BMI     40$             ;IF MI YES
        BEQ     35$             ;IF EQ DRIVE NOT SELECTED
        BIC     #WAIT,U.CW2(R5) ;CLEAR WAITING TO SELECT UNIT
        MOVB    S.ITM(R4),S.CTM(R4) ;SET CURRENT DEVICE TIMEOUT COUNT
        MOVB    #103,(R0)       ;START SEARCH FOR BLOCK.

;
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE. THIS IS DONE TO AVOID A RACE CONDITION
; THAT COULD EXIST IN RESTARTING THE I/O OPERATION.
;

DTPWF:  RETURN                  ;

;
; OUTPUT SELECT ERROR MESSAGE
;

40$:    MOV     #T.NDSE,R0      ;SET FOR DEVICE SELECT ERROR MESSAGE
        MOVB    #1,S.CTM(R4)    ;RESET CURRENT DEVICE TIMEOUT COUNT
        DECB    S.STS(R4)       ;TIME TO OUTPUT MESSAGE?
        BNE     DTPWF           ;IF NE NO
        MOVB    #15.,S.STS(R4)  ;SET TO OUTPUT NEXT MESSAGE IN 15. SECONDS
        CALLR   $DVMSG          ;OUTPUT MESSAGE

;
; CANCEL I/O OPERATION - FORCE I/O TO COMPLETE IF DEVICE NOT READY
;

DTCAN:  CMP     R1,I.TCB(R0)    ;;;REQUEST FOR CURRENT TASK?
        BNE     50$             ;;;IF NE NO
        BIS     #ABRT,U.CW2(R5) ;;;SET FOR ABORT IF DEVICE NOT READY
50$:    RETURN                  ;;;

;
; DEVICE TIMEOUT USUALLY OCCURS BECAUSE THE DRIVER IS WAITING TO
; SELECT A UNIT. TIMEOUTS MAY ALSO OCCUR AS A RESULT OF A HARDWARE
; FAILURE OR A POWERFAILURE.
;

DTOUT:                          ;REF LABEL


        .IF DF  D$$IAG

        MOV     S.PKT(R4),R1    ;;;GET I/O PACKET ADDRESS
        BITB    #IQ.UMD,I.FCN(R1) ;;;DIAGNOSTIC FUNCTION CALL?
        BNE     165$            ;;;IF NE YES

        .ENDC


        MOV     U.CW2(R5),R1    ;;;WAITING TO SELECT A UNIT?
        BMI     55$             ;;;IF MI YES
        CALL    $DTOER          ;;;LOG DEVICE TIMEOUT
55$:    MTPS    #0              ;;;ALLOW DEVICE INTERRUPTS                      ; EB148
        MOV     #IE.ABO&377,R0  ;ASSUME REQUEST IS TO BE ABORTED                ;**-1
        ASL     R1              ;ABORT REQUEST?
        BPL     30$             ;IF PL NO


        .IF DF  D$$IAG

        JMP     190$            ;ABORT REQUEST

        .IFF

        BR      190$            ;

        .ENDC


;+
; **-$DTINT-TC11 DECTAPE CONTROLLER INTERUPTS
;-

        INTSE$  DT,PR6,T$$C11   ;;;SAVE REGISTERS AND SET PRIORITY
        MOV     R3,-(SP)        ;;;SAVE R3
        MOV     U.SCB(R5),R3    ;;;GET ADDRESS OF STATUS CONTROL BLOCK
        MOVB    S.ITM(R3),S.CTM(R3) ;;;RESET CURRENT DEVICE TIMEOUT COUNT
        MOV     S.CSR(R3),R3    ;;;GET ADDRESS OF COMMAND REGISTER


        .IF DF  D$$IAG

        TSTB    RTTBL(R4)       ;DIAGNOSTIC READ BLOCK NO.?
        BMI     150$            ;IF MI YES

        .ENDC


        BIT     #2,(R3)         ;;;BLOCK SEARCH IN PROGRESS?
        BEQ     150$            ;;;IF EQ NO
        TST     (R3)            ;;;SEARCH ERROR?
        BPL     70$             ;;;IF PL NO
        TST     -(R3)           ;;;END ZONE?
        BMI     110$            ;;;IF MI YES
        BIT     #20000,(R3)+    ;;;MARK TRACK ERROR?
        BNE     120$            ;;;IF NE YES-TRY TO BYPASS IT
60$:    MOV     #100000,U.VCB+4(R5) ;;;SET UNRECOVERABLE ERROR
        BIC     #100,(R3)       ;;;CLEAR INTERRUPT ENABLE
        BR      160$            ;;;
70$:    MOV     6(R3),-(SP)     ;;;GET CURRENT BLOCK NUMBER
        CMPB    U.BUF+1(R5),1(R3) ;;;MOVING IN FINAL DIRECTION?
        BNE     80$             ;;;IF NE NO
        CMP     (SP),U.VCB+2(R5) ;;;BLOCK NUMBER MATCH?
        BEQ     130$            ;;;IF EQ YES
80$:    BIT     #4000,(R3)      ;;;MOVING IN FORWARD DIRECTION?
        BEQ     90$             ;;;IF EQ YES
        ADD     #2,(SP)         ;;;ADD TURN AROUND BIAS
        CMP     U.VCB+2(R5),(SP)+ ;;;TURN AROUND NECESSARY?
        BR      100$            ;;;
90$:    SUB     #2,(SP)         ;;;SUBTRACT TURN AROUND BIAS
        CMP     (SP)+,U.VCB+2(R5) ;;;TURN AROUND NECESSARY?
100$:   BLE     120$            ;;;IF LE NO
        TST     -(R3)           ;;;POINT TO ERROR REGISTER
110$:   TST     (R3)+           ;;;POINT TO COMMAND REGISTER
        DECB    RTTBL+1(R4)     ;;;DRIVE HUNG?
        BLT     60$             ;;;IF LT YES
        MOV     #4000,-(SP)     ;;;GET DIRECTION BIT
        BIC     (R3),(SP)       ;;;.NOT.COMMAND REGISTER.AND.DIRECTION BIT
        BIC     #4000,(R3)      ;;;.NOT.DIRECTION BIT.AND.COMMAND REGISTER
        BIS     (SP)+,(R3)      ;;;DIRECTION BIT.OR.COMMAND REGISTER
120$:   INC     (R3)            ;;;CONTINUE SEARCH
        BR      140$            ;;;
130$:   TST     (SP)+           ;;;REMOVE BLOCK NUMBER FROM STACK


        .IF DF  E$$DVC

        MOV     U.SCB(R5),R4    ;;;RETRIEVE ADDRESS OF SCB
        BIS     S.BMSK(R4),$IOABM ;;;SET I/O ACTIVE BIT IN MAP

        .IFTF

        MOV     U.BUF(R5),(R3)  ;;;START READ/WRITE FUNCTION
140$:   MOV     (SP)+,R3        ;;;RESTORE R3
        RETURN                  ;;;
150$:   BICB    #100,(R3)       ;;;CLEAR INTERRUPT ENABLE
        TST     (R3)            ;;;ANY ERRORS?
        BPL     160$            ;;;IF PL NO ERRORS
        MOV     -(R3),U.VCB+4(R5) ;;;SAVE ERROR STATUS
160$:   MOV     (SP)+,R3        ;;;RESTORE R3
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF STATUS CONTROL BLOCK
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL COMPLETION


        .IF DF  D$$IAG

        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        BITB    #IQ.UMD,I.FCN(R1) ;DIAGNOSTIC FUNCTION CALL?
165$:   BNE     180$            ;IF NE YES

        .ENDC


        MOV     U.VCB+4(R5),R2  ;RETRIEVE ERROR STATUS
        BEQ     180$            ;IF EQ SUCCESS

        .IFT

        CALL    $DVERR          ;LOG DEVICE ERROR

        .IFTF

        BIT     #63000,R2       ;RECOVERABLE ERROR?
        BEQ     170$            ;IF EQ NO
        DECB    RTTBL(R3)       ;ANY MORE RETRIES?
        BLE     170$            ;IF LE NO
        MOVB    #8.,RTTBL+1(R3) ;RESET ROCK COUNT
        JMP     30$             ;TRY AGAIN
170$:   MOV     #IE.WLK&377,R0  ;ASSUME DRIVE WRITE LOCKED
        BIT     #10000,R2       ;DRIVE WRITE LOCKED?
        BNE     180$            ;IF NE YES
        MOV     #IE.VER&377,R0  ;UNRECOVERABLE ERROR
180$:   MOV     S.CSR(R4),R2    ;GET ADDRESS OF COMMAND REGISTER


        .IF DF  D$$IAG

185$:   MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        BITB    #IQ.UMD,I.FCN(R1) ;DIAGNOSTIC FUNCTION CALL?
        BEQ     187$            ;IF EQ NO
        CALL    $CRPAS          ;PASS UNIBUS DEVICE REGISTERS
187$:                           ;REF. LABEL

        .ENDC


        MOV     U.CNT(R5),R1    ;GET ORIGINAL BYTE COUNT
        ADD     2(R2),R1        ;CALCULATE NUMBER OF BYTES TRANSFERED
        ADD     2(R2),R1        ;
190$:   MOVB    #11,(R2)        ;STOP TAPE MOTION

        .IFT

        MOVB    RTTBL(R3),R2    ;GET FINAL ERROR RETRY COUNT
        BIS     #RETRY*256.,R2  ;MERGE STARTING RETRY COUNT

        .ENDC


195$:   CALL    $IODON          ;FINISH I/O OPERATION
        JMP     DTINI           ;GO AGAIN
        .DSABL  LSB

        .END

        .TITLE  DXDRV
        .IDENT  /03.03/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03.03
;
; H. LEV 16-JAN-75
;
; PREVIOUSLY MODIFIED BY:
;
;       C. A. D'ELIA
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 30-NOV-76
;
;               PB009 -- CORRECT OUT OF RANGE BRANCHES WHEN A
;                       MULTI-CONTROLLER DRIVER IS GENERATED.
;
;       P. J. BEZEREDI 03-FEB-77
;
;               PB012 -- ADDITION OF ONLINE ERROR LOGGING AND
;                       INHIBIT RETRY SUPPORT.
;
;       P. J. BEZEREDI 12-DEC-77
;
;               PB045 - ALLOW ALL RX11 REGISTERS TO BE ERROR LOGGED.
;
;       P. J. BEZEREDI 13-DEC-77
;
;               PB049 -- PRESET BYTES TO TRANSFER TO 128.
;
;       P. J. BEZEREDI 05-APR-78
;
;               PB070 -- REMOVE IO.WDD FUNCTION CODE CONFLICTS.
;
;
; RX01 - RX11  FLOPPY DISK DRIVER
;
; FUNCTIONS RECOGNIZED:
;       IO.RPB  - READ PHYSICAL BLOCK (MAY READ ANY SECTOR ON DISK)
;       IO.WPB  - WRITE PHYSICAL BLOCK (MAY WRITE ANY SECTOR ON DISK)
;       IO.WDD  - WRITE DELETED DATA - WRITE ANY SECTOR ON DISK
;                 SETTING THE DELETED DATA MARK IN SECTOR HEADER
;       THE FOLLOWING TWO FUNCTION CODES OPERATE ON 256 WORD BLOCKS
;       OF DATA (4 SECTORS)  THE DRIVER AUTOMATICALLY INTERLEAVES
;       AND SKEWS SECTORS TO OPTIMIZE THE TRANSFER OF DATA
;       SO THAT A LONG READ/WRITE MAY BE DONE WITHOUT LOOSING
;       A REVOLUTION OF THE DISK.  THE INTERLEAVE FACTOR IS 2
;       AND THE SKEW FACTOR IS 6.
;       IO.RLB  - READ LOGICAL BLOCKS OF 256. WORDS
;       IO.WLB  - WRITE LOGICAL BLOCKS OF 256. WORDS.
;
;       IF DELETED DATA IS READ, THE STATUS CODE RETURNED WILL
;       BE IS.RDD, OTHERWISE IT IS IS.SUC
;

        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ; DEFINE HARDWARE REGISTERS
        PKTDF$                  ; DEFINE I/O PACKET OFFSETS

;
; EQUATED SYMBOLS
;

RETRY   =       8.              ; ERROR RETRY COUNT
DXNUM   =       4               ; NUMBER OF REGISTERS TO ERROR LOG      ; PB045
                                                                        ;**-1
;
; RX11 DEVICE REGISTER OFFSETS AND BIT DEFINITIONS
;

RXCS    =       0               ; CONTROL STATUS REGISTER
RXDB    =       2               ; DATA BUFFER
UNIT    =       20              ; UNIT SELECT BIT
DONE    =       40              ; RX11 DONE
INTEBL  =       100             ; INTERRUPT ENABLE
TR      =       200             ; RX11 TRANSFER READY BIT (CPU-SILO)
INIT    =       40000           ; INITIALIZE RX11

;
; FUNCTION CODES
;
GO      =       1               ; GO BIT
FILL    =       0+GO            ; FILL SILO
EMPTY   =       2+GO            ; EMPTY SILO
WRITE   =       4+GO            ; WRITE A SECTOR
READ    =       6+GO            ; READ A SECTOR
WRTDD   =       14+GO           ; WRITE DELETED DATA
RDERC   =       16+GO           ; READ ERROR CODE                       ; PB045

;                                                                       ; PB070
; STATUS REGISTER BIT DEFINITIONS                                       ; PB070
;                                                                       ; PB070
                                                                        ; PB070
DD      =       100             ; DELETED DATA READ                     ; PB070
                                                                        ; PB070
;
; LOCAL DATA
;
;
; CONTROLLER TABLE AND RETRY COUNT TABLE ( INDEXED BY CONTROLLER NUMBER)
;
CNTBL:  .BLKW   R$$X11          ; ADDRESS OF CURRENT UCB FOR CONTROLLER
RTTBL:  .BLKW   R$$X11          ; ERROR RETRY COUNT FOR CURRENT UNIT
                                                                        ; PB045
                                                                        ; PB045
        .IF DF  E$$DVC                                                  ; PB045
                                                                        ; PB045
CSRSV:  .BLKW   R$$X11          ; CSR SAVE AREA                         ; PB045
                                                                        ; PB045
        .ENDC                                                           ; PB045
                                                                        ; PB045
                                                                        ; PB045

        .IF     GT R$$X11-1

TEMP:   .BLKW   1               ; TEMPORARY STORAGE FOR CURRENT CONTROLLER NUMBER

        .ENDC


;
; DRIVER DISPATCH TABLE
;
$DXTBL::.WORD   DXINI           ; DEVICE INITIATOR ENTRY
        .WORD   DXCAN           ; CANCEL I/O OPERATION ENTRY
        .WORD   DXOUT           ; DEVICE TIME OUT ENTRY
        .WORD   DXPWF           ; POWERFAIL ENTRY POINT

;+
; *** - DXINI  FLOPPY DISK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QIO DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPOGATE THE
; EXECUTION OF THE DRIVER.  IF THE SPECIFIED CONTROLLER IS NOT BUSY,
; THEN AN ATTEMPT IS MADE TO DEQUEUE THE NEXT I/O REQUEST.  OTHERWISE
; A RETURN TO THE CALLER IS EXECUTED.  IF THE DEQUEUE ATTEMPT IS SUCCESSFUL
; THE NEXT I/O OPERATION IS INITIATED.  A RETURN TO THE CALLER IS THEN
; EXECUTED.
;
; INPUTS:
;       R5 - ADDRESS OF UCB WHICH IS ASSOCIATED WITH CONTROLLER TO BE INITIATED
;
; OUTPUTS:
;       IF THE CONTROLLER ASSOCIATED WITH THE SPECIFIED UCB IS NOT
;       BUSY AND AN I/O REQUEST IS WAITING TO BE PROCESSED, THE REQUEST
;       IS DEQUEUED AND THE DRIVER INITIATES THE REQUESTED FUNCTION.
;
;-
        .ENABL  LSB
1$:     RETURN                  ;                                       ; PB070
DXINI:  CALL    $GTPKT          ; GET NEXT I/O PACKET TO PROCESS        ; PB070
        BCS     1$              ; IF CS BUSY OR NO PACKET               ; PB070
                                                                        ;**-2
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT
;
;       R1 - ADDRESS OF THE I/O PACKET
;       R2 - PHYSICAL UNIT NUMBER OF THE DEVICE TO PERFORM FUNCTION ON
;       R3 - CONTROLLER NUMBER MULTIPLIED BY TWO
;       R4 - ADDRESS OF SCB
;       R5 - ADDRESS OF UCB FOR DEVICE TO PERFORM FUNCTION ON
;
; RX11 FLOPPY DISK I/O REQUEST PACKET FORMAT
;
;       WD. 00 -- I/O QUEUE THREAD WORD
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER
;       WD. 02 -- ADDRESS OF TCB OF THE REQUESTING TASK
;       WD. 03 -- POINTER TO SECOND LUN WORD OF REQUESTING TASKS HEADER
;       WD. 04 -- CONTENTS OF FIRST LUN WORD ( UCB ADDRESS)
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB, IO.RPB, IO.WLB, OR IO.WPB)
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000)
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER
;       WD. 14 -- NUMBER OF BYTES TO TRANSFER
;       WD. 15 -- NOT USED (IGNORED)
;       WD. 16 -- LOW BYTE MUST BE ZERO, HIGH BYTE NOT USED
;       WD. 17 -- LOGICAL OR PHYSICAL BLOCK NUMBER
;       WD. 20 -- NOT USED
;
; DRIVER USAGE OF WORDS IN I/O PACKET
;       I.PRM+6  (WD. 15) - STATUS REGISTER AFTER INTERRUPT
;       I.PRM+10 (WD. 16) - LOGICAL OR PHYSICAL SECTOR NUMBER
;       I.PRM+12 (WD. 17) - SIZE OF "THIS" TRANSFER
;       I.PRM+14 (WD. 20) - PHYSICAL SECTOR NUMBER (1-26.)
;       I.PRM+15 (WD. 20) - PHYSICAL TRACK NUMBER (0-77.)
;
;
; INITIALIZE DRIVER
;
        MOV     R5,CNTBL(R3)    ; SAVE UCB ADDRESS OF CURRENT REQUEST
10$:    MOV     #RETRY,RTTBL(R3) ; SET RETRY COUNT
        TSTB    I.PRM+10(R1)    ; HIGH BLOCK SPECIFIED?
        BEQ     20$             ; NO
15$:    JMP     180$            ; YES, ERROR
;
; SET UP FIRST BLOCK OR SECTOR NUMBER
;
20$:    MOV     I.PRM+12(R1),R0 ; GET PHYSICAL OR LOGICAL BLOCK NUMBER
        MOV     #128.,I.PRM+12(R1)  ; PRESET TRANSFER SIZE              ; PB049
        BITB    #IO.RPB&377,I.FCN(R1)  ; PHYSICAL BLOCK FUNCTION?       ; PB070
        BNE     30$             ; YES                                   ;**-1
        ASL     R0              ; CONVERT TO LOGICAL SECTOR NUMBER
        ASL     R0              ; WHICH IS LBN*4
30$:    MOV     R0,I.PRM+10(R1) ; STORE IT
35$:    MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS
        CALL    TRKSEC          ; CONVERT BLOCK # TO TRACK/SECTOR
        BCS     15$             ; IF CS BAD BLOCK NUMBER
        MOV     S.CSR(R4),R2    ; GET ADDRESS OF CSR
        CMPB    #IO.WLB/256.,I.FCN+1(R3)  ; WRITE FUNCTION?
        BNE     140$            ;IF NE NO
;
; FILL SILO BEFORE WRITE
;
        CALL    SETBUF          ; SET UP BUFFER POINTER AND MAPPING REGISTER
        MOV     #FILL,(R2)      ; SET "FILL BUFFER" FUNCTION
70$:    CLR     R3              ; ASSUME NO DATA TO TRANSFER
        DEC     R1              ; MORE DATA TO TRANSFER?
        BLT     74$             ; NO
        MOVB    (R0)+,R3        ; YES, GET NEXT BYTE
74$:    BITB    #TR!DONE,(R2)   ; CONTROLLER DONE?
        BMI     75$             ; IF MI YES
        BEQ     74$             ; IF EQ NO
        BR      90$             ; SILO IS FULL
75$:    MOVB    R3,RXDB(R2)     ; PUT NEXT BYTE IN SILO
        BR      70$             ; AND WAIT TILL IT'S ACCEPTED
90$:    TST     R1              ; ALL BYTES TRANSFERED?
        BMI     130$            ; IF MI YES
95$:    JMP     DXRTY           ; RETRY LAST FUNCTION
;
; EMPTY SILO AFTER READ
;
100$:   MOV     #EMPTY,(R2)     ; SET "EMPTY BUFFER" FUNCTION
        CALL    SETBUF          ; SET BUFFER POINTER AND MAPPING REGISTER
110$:   BITB    #TR!DONE,(R2)   ; CONTROLLER DONE?
        BMI     111$            ; IF MI YES
        BEQ     110$            ; IF EQ NO
        BR      120$            ; SILO IS EMPTY
111$:   MOVB    RXDB(R2),R3     ; GET NEXT BYTE FROM SILO
        DEC     R1              ; DO WE WANT IT?
        BLT     110$            ; NO
        MOVB    R3,(R0)+        ; YES, PUT IT IN BUFFER
        BR      110$            ; GET NEXT BYTE
120$:   TST     R1              ; ALL BYTES TRANSFERED?
        BGT     95$             ; IF GT ERROR
        MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS
        CALL    NXTSEC          ; UPDATE TO NEXT SECTOR
        BEQ     193$            ; ALL DONE
        BR      35$             ; CONTINUE
;
; INITIATE TRANSFER BETWEEN SILO AND DISK
;
130$:   MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS
        MOV     #WRITE,R0       ; ASSUME WRITE FUNCTION
        MOV     I.FCN(R3),R1    ; COPY FUNCTION CODE                    ; PB070
        BIC     #7,R1           ; REMOVE QUALIFIER BITS                 ; PB070
        CMP     #IO.WDD,R1      ; WRITE DELETED DATA?                   ; PB070
        BNE     141$            ; IF NE NO                              ; PB070
        MOV     #WRTDD,R0       ; SET "WRITE DELETED DATA" FUNCTION     ;**-2
        BR      141$            ;
140$:   MOV     #READ,R0        ; SET READ FUNCTION
141$:   TSTB    U.UNIT(R5)      ; UNIT 1?
        BEQ     142$            ; IF EQ YES
        BIS     #UNIT,R0        ; YES, SET TO SELECT UNIT 1
142$:                           ; REF LABEL                             ; PB045
                                                                        ; PB045
                                                                        ; PB045
        .IF DF  E$$DVC                                                  ; PB045
                                                                        ; PB045
        MOVB    S.CON(R4),R1    ; RETREIVE CONTROLLER INDEX             ; PB045
        MOV     R0,CSRSV(R1)    ; SAVE FUNCTION AND UNIT NUMBER         ; PB045
                                                                        ; PB045
        .ENDC                                                           ; PB045
                                                                        ; PB045
                                                                        ; PB045
        MOV     R0,(R2)         ; INITIATE THE FUNCTION                 ; PB045
143$:   BITB    #TR!DONE,(R2)   ; TRANSFER READY OR DONE?               ;**-1
        BMI     150$            ; IF MI TRANSFER READY
        BEQ     143$            ; IF EQ LOOP
        BR      95$             ; ERROR, NO TRANSFER REQUEST
150$:   MOVB    I.PRM+14(R3),RXDB(R2)  ; LOAD SECTOR NUMBER
151$:   BITB    #TR!DONE,(R2)   ; TRANSFER READY OR DONE?
        BMI     152$            ; IF MI TRANSFER READY
        BEQ     151$            ; IF EQ LOOP
        BR      95$             ; ERROR, NO TRANSFER REQUEST
152$:   MOVB    I.PRM+15(R3),RXDB(R2)  ; LOAD TRACK NUMBER
155$:   MOVB    S.ITM(R4),S.CTM(R4) ; SET TIME OUT COUNT


        .IF DF  E$$DVC

        CALL    $BMSET          ; SET I/O ACTIVE IN BITMAP

        .ENDC


        BIS     #INTEBL,(R2)    ; SET INTERRUPT ENABLE
;
; DXPWF - POWER FAIL ENTRY POINT
;       POWER FAIL IS HANDLED BY THE DEVICE TIMING OUT, THEREFORE
;       NO WNRK IS DNNE HERE.  IT WILL BE HANDLED WHEN THE DEVICE
;       TIME OUT ENTRY IS EXECUTED.
;
DXPWF:

;
; DXCAN - CANCEL I/O ENTRY POINT
;       CANCEL I/O IS A NOP OP FOR FILE STRUCTURED DEVICES
;
DXCAN:  RETURN                  ;

;+
; *** - $DXINT  - RX11 FLOPPY DISK INTERRUPT ENTRY POINT
;
;-
        INTSE$  DX,PR5,R$$X11   ;;; GENERATE INTERRUPT SAVE CODE
        MOV     R3,-(SP)        ;;; SAVE REGISTER
        MOV     U.SCB(R5),R4    ;;; GET SCB ADDRESS
        MOV     S.PKT(R4),R3    ;;; GET I/O PACKET ADDRESS
        MOV     S.CSR(R4),R4    ;;; GET CSR ADDRESS
        MOV     RXDB(R4),I.PRM+6(R3)  ;;; SAVE CONTROLLER STATUS
        MOV     (SP)+,R3        ;;; RESTORE REGISTER
        BIC     #INTEBL,(R4)    ;;; DISABLE INTERRUPTS
        CALL    $FORK           ;;; CREATE A SYSTEM PROCESS
        MOV     R4,R2           ; COPY CSR ADDRESS
        MOV     U.SCB(R5),R4    ; GET SCB ADDRESS
        MOVB    S.CON(R4),R3    ; GET CONTROLLER INDEX
        TST     (R2)            ; ANY ERRORS?
        BPL     160$            ; IF PL NO


        .IF DF  E$$DVC

        CALL    LOGERR          ; LOG DEVICE ERROR                      ; PB045
                                                                        ;**-1
        .ENDC


        BR      DXRTY           ; RETRY FUNCTION
160$:   ASRB    RTTBL+1(R3)     ; INITIALIZE IN PROGRESS?
        BCS     170$            ; IF CS YES
        MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS
        CMPB    #IO.RLB/256.,I.FCN+1(R3)  ; READ?
        BNE     165$            ; IF NE NO
        JMP     100$            ; GO EMPTY SILO
165$:   CALL    NXTSEC          ; UPDATE TO NEXT SECTOR
        BEQ     195$            ; ALL DONE
170$:   JMP     35$             ; WRITE MORE DATA
180$:   MOV     #IE.BLK&377,R0  ; SET BAD BLOCK ERROR
        BR      210$            ;
190$:   MOV     #IE.VER&377,R0  ; SET UNRECOVERABLE ERROR
        BR      200$            ;
193$:   BITB    #IO.RPB&377,I.FCN(R3)  ; READ PHYSICAL BLOCK FUNCTION?  ; PB070
        BEQ     195$            ; NO, THEN IGNORE DELETED DATA MARK     ;**-1
        MOV     #IS.RDD&377,R0  ; YES, DEFAULT ON READ TO DELETED DATA
        BIT     #DD,I.PRM+6(R3) ; WAS DELETED DATA READ?                ; PB070
        BNE     200$            ; YES                                   ;**-1
195$:   MOV     #IS.SUC&377,R0  ; NO, SET NORMAL SUCCESS
200$:   MOV     S.PKT(R4),R1    ; GET I/O PACKET ADDRESS
        MOV     I.PRM+4(R1),R1  ; SET BYTES TRANSFERED
        SUB     U.CNT(R5),R1    ; CALCULATE BYTES ACTUALLY TRANSFERED


        .IF DF  E$$DVC

        MOVB    S.CON(R4),R3    ; RETREIVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ; SET FINAL RETRY COUNT
        BIS     #RETRY*256.,R2  ; SET INITIAL RETRY COUNT

        .ENDC


210$:   CALL    $IODON          ; SET DONE
        JMP     DXINI           ; TRY FOR ANOTHER REQUEST
;
;+
; *** - DXOUT - FLOPPY DISK TIMEOUT ENTRY POINT
;-

DXOUT:                          ;;; TIMEOUT ENTRY POINT                 ; PB045
                                                                        ; PB045
                                                                        ; PB045
        .IF DF  E$$DVC                                                  ; PB045
                                                                        ; PB045
        CALL    LOGTMO          ;;; LOG DEVICE TIMEOUT                  ; PB045
                                                                        ; PB045
        .IFF                                                            ; PB045
                                                                        ; PB045
        CALL    $DTOER          ;;; LOG DEVICE TIMEOUT                  ; PB045
                                                                        ; PB045
        .ENDC                                                           ; PB045
                                                                        ; PB045
                                                                        ;**-1
;
; RETRY LAST FUNCTION
;
DXRTY:  MOVB    S.CON(R4),R3    ; RESTORE CONTROLLER INDEX
        MOV     S.PKT(R4),R1    ; GET I/O PACKET ADDRESS
        BITB    #IQ.X,I.FCN(R1) ; INHIBIT RETRIES?
        BNE     190$            ; IF NE YES
        DECB    RTTBL(R3)       ; ANY RETRIES LEFT?
        BEQ     190$            ; NO, ERROR
        MOVB    #1,RTTBL+1(R3)  ; YES, SET INITIALIZE IN PROGRESS
                                                                        ; PB045
                                                                        ; PB045
        .IF DF  E$$DVC                                                  ; PB045
                                                                        ; PB045
        MOV     #INIT,CSRSV(R3) ; SAVE FUNCTION CODE                    ; PB045
                                                                        ; PB045
        .ENDC                                                           ; PB045
                                                                        ; PB045
                                                                        ; PB045
        MOV     #INIT,(R2)      ; INITIALIZE RX01 DRIVES
        JMP     155$            ; AND DO IT
        .DSABL  LSB

                                                                        ; PB045
        .IF DF  E$$DVC                                                  ; PB045
                                                                        ; PB045
;+                                                                      ; PB045
; **-LOGERR-LOG DEVICE ERROR                                            ; PB045
; **-LOGTMO-LOG DEVICE TIMEOUT                                          ; PB045
;                                                                       ; PB045
; THESE ROUTINES WILL ALLOCATE A CORE BLOCK, FILL IT WITH THE           ; PB045
; REGISTER INFORMATION, CALL THE APPROPRIATE EXECUTIVE ERROR            ; PB045
; LOGGING ROUTINE, DEALLOCATE THE CORE BLOCK, AND RETURN BACK TO        ; PB045
; THE CALLER.                                                           ; PB045
;                                                                       ; PB045
; INPUTS:                                                               ; PB045
;       R3=CONTROLLER INDEX                                             ; PB045
;       R4=SCB ADDRESS                                                  ; PB045
;       R5=UCB ADDRESS                                                  ; PB045
;                                                                       ; PB045
; OUTPUTS:                                                              ; PB045
;       R2=CSR ADDRESS                                                  ; PB045
;       R4=SCB ADDRESS                                                  ; PB045
;       R5=UCB ADDRESS                                                  ; PB045
;                                                                       ; PB045
; R0, R1 AND R3 ARE DESTROYED.                                          ; PB045
;-                                                                      ; PB045
                                                                        ; PB045
        .ENABL  LSB                                                     ; PB045
LOGERR: MOV     #$DVERR,-(SP)   ; LOG DEVICE ERROR                      ; PB045
        BR      10$             ;                                       ; PB045
LOGTMO: MOV     #$DTOER,-(SP)   ;;; LOG DEVICE TIMEOUT                  ; PB045
10$:    MOV     #DXNUM*2,R1     ; GET NUMBER OF BYTES TO ALLOCATE       ; PB045
        CALL    $ALOCB          ; ALLOCATE THE ERROR BLOCK              ; PB045
        BCC     20$             ; IF CC OK                              ; PB045
        INC     $ERRSQ          ; INDICATE A MISSED ERRO                ; PB045
        CMP     (SP)+,#$DTOER   ; TIMEOUT?                              ; PB045
        BNE     30$             ; IF NE NO                              ; PB045
        BIC     #INTEBL,@S.CSR(R4)  ;;; CLEAR INTERRUPT ENABLE          ; PB045
        MTPS    #0              ;;; ALLOW INTERRUPTS                    ; PB045
        BR      30$             ;                                       ; PB045
20$:    MOV     R0,R1           ; COPY CORE BLOCK ADDRESS               ; PB045
        MOV     S.CSR(R4),R2    ; RETREIVE CSR ADDRESS                  ; PB045
        MOV     (R2),(R1)       ; SAVE CSR CONTENTS                     ; PB045
        BIS     CSRSV(R3),(R1)+ ; SET BITS 0-4 IN RXCS                  ; PB045
        MOV     RXDB(R2),(R1)+  ; SAVE RXDB                             ; PB045
        MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS                ; PB045
        MOV     I.PRM+6(R3),(R1)+  ; SAVE RXES                          ; PB045
        MOV     #RDERC,(R2)     ; EXECUTE READ ERROR CODE FUNCTION      ; PB045
25$:    BITB    #DONE,(R2)      ; WAIT UNTIL DONE                       ; PB045
        BEQ     25$             ; IF EQ NO                              ; PB045
        MOV     RXDB(R2),(R1)+  ; SAVE RXER                             ; PB045
        MOV     R0,S.CSR(R4)    ; SET CORE BLOCK TO CSR ADDRESS         ; PB045
        MOV     R0,R1           ; COPY CORE BLOCK ADDRESS               ; PB045
        CALL    @(SP)+          ; LOG THE ERROR                         ; PB045
        MOV     R2,S.CSR(R4)    ; RESTORE CSR ADDRESS                   ; PB045
        MOV     R1,R0           ; COPY CORE BLOCK ADDRESS               ; PB045
        MOV     #DXNUM*2,R1     ; GET NUMBER OF BYTES TO DEALLOCATE     ; PB045
        CALL    $DEACB          ; DEALLOCATE THE ERROR BLOCK            ; PB045
30$:    MOV     S.CSR(R4),R2    ; RETREIVE CSR ADDRESS                  ; PB045
        RETURN                  ;                                       ; PB045
        .DSABL  LSB                                                     ; PB045
                                                                        ; PB045
        .ENDC                                                           ; PB045
                                                                        ; PB045
                                                                        ; PB045
;+
; *** - TRKSEC  -  CONVERT LOGICAL OR PHYSICAL BLOCK NUMBER TO
;       TRACK-SECTOR PAIR
; FROM ALGORITHM BY J GILBERT MODIFIED BY H. JACOBS
;
; INPUT:
;       R3 - I/O PACKET ADDRESS
;       I.PRM+10(R3) - LOGICAL OR PHYSICAL SECTOR
;
; OUTPUT:
;       I.PRM+14(R3) - SECTOR (1-26.)
;       I.PRM+15(R3) - TRACK (0-77.)
;       R3 - UNCHANGED
;       C CLEAR - VALID BLOCK
;       C SET - BAD BLOCK NUMBER (PHYSICAL OR LOGICAL)
;
;-
TRKSEC: MOV     I.PRM+10(R3),R1 ; GET LOGICAL OR PHYSICAL BLOCK
        MOV     #8.,R0          ; SET LOOP COUNT
        MOV     #6400,R2        ; SET DIVISOR
1$:     CMP     R2,R1           ; DOES 26 GO INTO DIVIDEND?
        BHI     2$              ; BRANCH IF NOT, C CLEAR
        SUB     R2,R1           ; SUBTRACT 26 FROM DIVIDEND
        SEC                     ; SET CARRY
2$:     ROL     R1              ; SHIFT DIVIDEND AND QUOTIENT
        DEC     R0              ; DONE?
        BGT     1$              ; NO, LOOP
        MOVB    R1,R0           ; GET TRACK NUMBER
        CLRB    R1              ; CLEAR TRACK NUMBER
        SWAB    R1              ; SHIFT DONE SECTOR NUMBER
        BITB    #IO.RPB&377,I.FCN(R3)  ; PHYSICAL BLOCK WANTED?         ; PB070
        BNE     10$             ; YES                                   ;**-1
        CMP     #12.,R1         ; NO, C=1 IF 13<=R1<=25
        ROL     R1              ; DOUBLE FOR INTERLEAVE FACTOR
        ASL     R0              ; ADD TRACK -TRACK SKEW
        ADD     R0,R1           ; SKEW BY 2*TRACK
        ADD     R0,R1           ; SKEW BY 4*TRACK
        ADD     R0,R1           ; SKEW BY 6*TRACK
        ASR     R0              ; RESTORE TRACK NUMBER
        MOV     #26.,R2         ; SET MODULUS
5$:     SUB     R2,R1           ; MODULO SECTOR INTO RANGE -26. TO -1.
        BGE     5$              ; LOOP TILL REMAINDER GOES NEG
        ADD     R2,R1           ; CONVERT TO RANGE 0-25.
        INC     R0              ; LBN0 STARTS ON TRACK 1
10$:    INC     R1              ; CONVERT TO RANGE 1-26.
        MOV     R1,I.PRM+14(R3) ; SAVE SECTOR NUMBER
        MOVB    R0,I.PRM+15(R3) ; SAVE TRACK NUMBER
        CMP     #77.*256.,I.PRM+14(R3)  ; IS IT A VALID TRACK/SECTOR?
        RETURN                  ;

;+
; *** - NXTSEC  -  UPDATE BLOCK NUMBER , BUFFER ADDRESS
;                       AND BUFFER POINTER
;
; INPUT:
;       R3 - I/O PACKET ADDRESS
;       R5 - UCB ADDRESS
;       I.PRM+10(R3) - CURRENT BLOCK NUMBER
;       I.PRM+12(R3) - BYTES TRANSFERED DURING LAST FUNCTION
;       U.CNT(R5) - BYTES LEFT TO TRANSFER
;       U.BUF(R5) - BUFFER ADDRESS
;
; OUTPUT:
;       I.PRM+10(R3) - UPDATED BLOCK NUMBER
;       U.BUF(R5) - UPDATED BY 128. BYTES
;       U.CNT(R5) - UPDATED BY NUMBER OF WORDS TRANSFERED
;       Z SET - ALL BYTES TRANSFERED
;       Z CLEAR - MORE BYTES TO TRANSFER
;       C CLEAR - VALID TRACK/SECTOR
;       C SET - BAD BLOCK NUMBER
;
;+
NXTSEC: INC     I.PRM+10(R3)    ; UPDATE BLOCK NUMBER


        .IF NDF M$$MGE

        ADD     #128.,U.BUF+2(R5) ; UPDATE BUFFER POINTER

        .IFF

        ADD     #2.,U.BUF(R5)   ; UPDATE MEMORY BLOCK NUMBER

        .ENDC


        SUB     I.PRM+12(R3),U.CNT(R5)  ; UPDATE BYTES LEFT TO TRANSFER
        RETURN                  ;

;+
; *** - SETBUF  -  SET UP BUFFER POINTER FOR CPU - SILO TRANSFERS
;
; INPUT:
;       R3 - I/O PACKET ADDRESS
;       R5 - UCB ADDRESS
;
; OUTPUT:
;       I.PRM+12(R3) - BYTES TO TRANSFER
;       R0 - BUFFER ADDRESS
;       R1 - BYTES TO TRANSFER
;       IF MAPPED SYSTEM KISAR6 IS MAPPED TO BUFFER AND R1 IS BASE 140000
;
;-
SETBUF: MOV     U.BUF+2(R5),R0  ; GET BUFFER ADDRESS
        MOV     #128.,R1        ; DEFAULT TO 128. BYTE TRANSFER
        CMP     U.CNT(R5),R1    ; 128. BYTES LEFT TO TRANSFER?
        BHIS    10$             ; YES
        MOV     U.CNT(R5),R1    ; NO, GET RESIDUAL COUNT
10$:    MOV     R1,I.PRM+12(R3) ; STORE BYTES TO TRANSFER


        .IF DF  M$$MGE

        MOV     U.BUF(R5),@#KISAR6 ; SET MAPPING REGISTER

        .ENDC

        RETURN                  ;

        .END
        .TITLE  DYDRV
        .IDENT  /01/
;
;
; COPYRIGHT (C) 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 01
;
; M. BAGGETT/R. PERRON 22-MAR-79
;
; RX211- NPR FLOPPY DISK DRIVER
;
; FUNCTIONS RECOGNIZED:
;       IO.RPB  - READ PHYSICAL BLOCK (MAY READ ANY SECTOR ON DISK)
;       IO.WPB  - WRITE PHYSICAL BLOCK (MAY WRITE ANY SECTOR ON DISK)
;       IO.WDD  - WRITE DELETED DATA - WRITE ANY SECTOR ON DISK
;                 SETTING THE DELETED DATA MARK IN SECTOR HEADER
;
; THE FOLLOWING FUNCTION CODES OPERATE ON 256. WORD BLOCKS OF DATA
; (4 SECTORS FOR SINGLE DENSITY OR 2 SECTORS FOR DOUBLE DENSITY).
; THE DRIVER AUTOMATICALLY INTERLEAVES AND SKEWS SECTORS TO OPTIMIZE
; THE TRANSFER OF DATA SO THAT A LONG TRANSFER MAY BE DONE WITHOUT
; LOOSING A REVOLUTION OF THE DISK.  THE INTERLEAVE FACTOR IS 2 AND
; THE SKEW FACTOR IS 6.
;       IO.RLB  - READ LOGICAL BLOCKS OF 256. WORDS
;       IO.WLB  - WRITE LOGICAL BLOCKS OF 256. WORDS.
;
; THE FOLLOWING FUNCTION CODES ARE USED TO INITIALIZE THE FLOPPY
; TO SINGLE OR DOUBLE DENSITY AND TO REPORT WHICH DENSITY THE CURRENT
; FLOPPY IS.
;       IO.SMD - SET MEDIA DENSITY
;       IO.SEC - SENSE MEDIA CHARACTERISTICS
;
; IF DELETED DATA IS READ, THE STATUS CODE RETURNED WILL BE IS.RDD,
; OTHERWISE IT WILL BE IS.SUC.
;
 
        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ; DEFINE HARDWARE REGISTERS
        PKTDF$                  ; DEFINE I/O PACKET OFFSETS
 
;
; EQUATED SYMBOLS
;
 
RETRY   =       10              ; ERROR RETRY COUNT
ERR1    =       2000            ; TIMEOUT ERROR BIT (U.CW2)
DEN     =       4000            ; DENSITY BIT (U.CW2)
SSIDED  =       20000           ; SECOND SIDE INDICATOR BIT (U.CW2)
SCHAR   =       40000           ; SENSE MEDIA CHARACTERISTICS (U.CW2)
SILO    =       100000          ; FCN ISSUED WAS A SILO FUNCTION (U.CW2)
SINSIN  =       494.            ; SINGLE SIDED AND SINGLE DENSITY
SINDOU  =       988.            ; SINGLE SIDED AND DOUBLE DENSITY
DOUDOU  =       1976.           ; DOUBLE SIDED DOUBLE DENSITY
 
;
; DEVICE REGISTER OFFSETS AND BIT DEFINITIONS
;
 
RXCS=   0                       ; CONTROL STATUS REGISTER

GO      =       1               ; GO BIT
UNIT    =       20              ; UNIT SELECT BIT
DONE    =       40              ; DONE BIT
INTEBL  =       100             ; INTERRUPT ENABLE
TR      =       200             ; TRANSFER READY BIT (CPU-SILO)
SDEN    =       400             ; DENSITY BIT 
DSIDED  =       1000            ; HEAD SELECT BIT 
RX211   =       4000            ; RX211 INDICATOR BIT
INIT    =       40000           ; INITIALIZATION BIT
ERR     =       100000          ; ERROR BIT

RXDB    =       2               ; DATA BUFFER REGISTER

RXES    =       2               ; RX211 ERROR STATUS REGISTER

CRCERR  =       1               ; CRC ERROR BIT
SIDES   =       2               ; DOUBLE SIDED MEDIA
INITDN  =       4               ; INITIALIZE DONE BIT
RXACLO  =       10              ; RX221 AC LOW BIT
DENERR  =       20              ; DENSITY ERROR BIT
DRVDEN  =       40              ; SELECTED DRIVE'S DENSITY BIT
DELDAT  =       100             ; DELETED DATA BIT
DRVRDY  =       200             ; SELECTED DRIVE READY BIT
UNTSEL  =       400             ; UNIT SELECTED BIT
WCOVFL  =       2000            ; WORD COUNT OVERFLOW BIT
NXM     =       4000            ; NON-EXISTENT MEMORY BIT
 
;
; FUNCTION CODES
;

FILL    =       INTEBL!0!GO     ; FILL SILO
EMPTY   =       INTEBL!2!GO     ; EMPTY SILO
WRITE   =       INTEBL!4!GO     ; WRITE A SECTOR
READ    =       INTEBL!6!GO     ; READ A SECTOR
SETDEN  =       INTEBL!10!GO    ; SET MEDIA DENSITY
MRDS    =       INTEBL!12!GO    ; MAINTENANCE READ STATUS
WRTDD   =       INTEBL!14!GO    ; WRITE DELETED DATA
RDERC   =       INTEBL!16!GO    ; READ ERROR CODE
 
;
; LOCAL DATA
;
; IMPURE DATA TABLES INDEXED BY CONTROLLER NUMBER
;
CNTBL:  .BLKW   R$$X21          ; ADDRESS OF CURRENT UCB FOR CONTROLLER
RTTBL:  .BLKW   R$$X21          ; ERROR RETRY COUNT FOR CURRENT UNIT
 

        .IF     GT R$$X21-1
 
TEMP:   .BLKW   1               ; TEMPORARY STORAGE FOR CONTROLLER NUMBER
 
        .ENDC
 
        
;
; DRIVER DISPATCH TABLE
;
$DYTBL::.WORD   DYINI           ; DEVICE INITIATOR ENTRY
        .WORD   DYCAN           ; CANCEL I/O OPERATION ENTRY
        .WORD   DYOUT           ; DEVICE TIME OUT ENTRY
        .WORD   DYPWF           ; POWERFAIL ENTRY POINT
 
;+
; *** - DYINI  FLOPPY DISK CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QIO DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPOGATE THE
; EXECUTION OF THE DRIVER.  IF THE SPECIFIED CONTROLLER IS NOT BUSY,
; THEN AN ATTEMPT IS MADE TO DEQUEUE THE NEXT I/O REQUEST.  OTHERWISE
; A RETURN TO THE CALLER IS EXECUTED.  IF THE DEQUEUE ATTEMPT IS SUCCESSFUL
; THE NEXT I/O OPERATION IS INITIATED.  A RETURN TO THE CALLER IS THEN
; EXECUTED.
;
; INPUTS:
;       R5 - ADDRESS OF UCB OF CONTROLLER TO BE INITIATED
;
; OUTPUTS:
;       IF THE CONTROLLER ASSOCIATED WITH THE SPECIFIED UCB IS NOT
;       BUSY AND AN I/O REQUEST IS WAITING TO BE PROCESSED, THE REQUEST
;       IS DEQUEUED AND THE DRIVER INITIATES THE REQUESTED FUNCTION.
;
;-
        .ENABL  LSB
DYINI:  CALL    $GTPKT                  ; TRY TO GET AN I/O PACKET
        BCC     5$                      ;
        JMP     DYPWF                   ; IF CS BUSY OR NO PACKET

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT
;
;       R1 - ADDRESS OF THE I/O PACKET
;       R2 - PHYSICAL UNIT NUMBER OF DEVICE TO BE INITIATED
;       R3 - CONTROLLER INDEX
;       R4 - ADDRESS OF SCB
;       R5 - ADDRESS OF THE UCB
;
;       FLOPPY DISK I/O REQUEST PACKET FORMAT
;
;       WD. 00 -- I/O QUEUE THREAD WORD
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER
;       WD. 02 -- ADDRESS OF TCB OF THE REQUESTING TASK
;       WD. 03 -- POINTER TO SECOND LUN WORD OF REQUESTING TASKS HEADER
;       WD. 04 -- CONTENTS OF FIRST LUN WORD ( UCB ADDRESS)
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB, IO.RPB, IO.WLB, IO.WPB,
;                 IO.WDD, IO.SMD OR IO.SEC)
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000)
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER
;       WD. 14 -- NUMBER OF BYTES TO TRANSFER
;       WD. 15 -- NOT USED (IGNORED)
;       WD. 16 -- LOW BYTE MUST BE ZERO, HIGH BYTE NOT USED
;       WD. 17 -- LOGICAL OR PHYSICAL BLOCK NUMBER
;       WD. 20 -- NOT USED
;
; DRIVER USAGE OF WORDS IN I/O PACKET
;       I.PRM+6  (WD. 15) - STATUS REGISTER AFTER INTERRUPT
;       I.PRM+10 (WD. 16) - LOGICAL OR PHYSICAL BLOCK NUMBER
;       I.PRM+12 (WD. 17) - SIZE OF "THIS" TRANSFER
;       I.PRM+14 (WD. 20) - PHYSICAL SECTOR NUMBER (1-26.)
;       I.PRM+15 (WD. 20) - PHYSICAL TRACK NUMBER (0-76.)
;
;
; INITIALIZE DRIVER
;
5$:     MOV     R5,CNTBL(R3)    ; SAVE UCB ADDRESS OF CURRENT REQUEST
        MOV     #RETRY,RTTBL(R3); SET RETRY COUNT
        TSTB    I.PRM+10(R1)    ; HIGH BLOCK SPECIFIED?
        BEQ     15$             ; IF EQ NO
10$:    JMP     180$            ; YES, ERROR
;
; CHECK FOR A VALID FUNCTION
;
15$:    MOV     S.CSR(R4),R2    ; PUT ADDRESS OF CSR IN R2
        CMPB    #IO.SEC/256.,I.FCN+1(R1)  ; VALID FUNCTION?
        BNE     27$             ; IF NE IT MUST BE READ OR WRITE
        MOV     I.FCN(R1),R0    ; GET FUNCTION CODE
        BIC     #7,R0           ; REMOVE QUALIFIER BITS
        CMP     #IO.SEC,R0      ; SENSE CHARACTERISTICS?
        BNE     20$             ; IF NE NO
        JMP     DYSEC           ; GET DISKETTE CHARACTERISTICS
20$:    CMP     #IO.SMD,R0      ; SET MEDIA DENSITY?
        BNE     25$             ; IF NE NO
        MOV     R0,I.FCN(R1)    ; SET FUNCTION CODE WITHOUT MODIFIERS
        JMP     DYSMD           ; SET DISKETTE DENSITY
25$:    MOV     #IE.IFC&377,R0  ; RETURN ERROR CODE
        JMP     200$            ; EXIT
27$:                            ; REF LABEL
;
; SET UP MAPPING AND FIRST DISK ADDRESS
;


        .IF DF  M$$EXT&M$$MGE

        CALL    $STMAP          ; SET UP 11/70 UNIBUS MAPPING ADDRS

        .ENDC


        .IF DF  M$$MGE

        SWAB    U.BUF(R5)       ; POSITION EXTENDED MEMORY BITS

        .ENDC


        MOV     I.PRM+12(R1),R0 ; GET PHYSICAL OR LOGICAL BLOCK NUMBER
        BITB    #IO.RPB&377,I.FCN(R1)  ; IS IT READ/WRITE PHYSICAL?
        BNE     30$             ; IF NE YES
        ASL     R0              ; CONVERT TO LOGICAL SECTOR NO. (LBN*2)
        BIT     #DEN,U.CW2(R5)  ; DOUBLE DENSITY?
        BNE     30$             ; IF NE YES
        ASL     R0              ; SINGLE DEN - LBN*4
30$:    MOV     R0,I.PRM+10(R1) ; STORE IT
35$:    MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS
        CALL    TRKSEC          ; CONVERT BLOCK # TO TRACK/SECTOR
        BCS     10$             ; IF CS BAD BLOCK NUMBER
        MOV     S.CSR(R4),R2    ; GET ADDRESS OF CSR
        CMPB    #IO.WLB/256.,I.FCN+1(R3)  ; WRITE FUNCTION?
        BNE     140$            ; IF NE NO
;
; FILL SILO BEFORE WRITE
;
        MOVB    #FILL,U.BUF(R5) ; SET FILL SILO FUNCTION
50$:    BIT     #DEN,U.CW2(R5)  ; DOUBLE DENSITY?
        BEQ     52$             ; IF EQ NO
        BIS     #SDEN,U.BUF(R5) ; YES-SET DOUBLE DENSITY BIT
52$:    BIS     #SILO,U.CW2(R5) ; SILO FUNCTION FLAG
        MOV     U.BUF(R5),(R2)  ; INITIATE FUNCTION


        .IF DF  M$$MGE&M$$EXT

        MOV     R2,-(SP)        ; SAVE REGISTER
        CALL    $MPUBM          ; MAP 11/70 UNIBUS TO TRANSFER
        MOV     (SP)+,R2        ; RESTORE REGISTER

        .ENDC


        MOV     U.BUF+2(R5),R0  ; GET BUFFER ADDRESS
        MOV     #128.,R1        ; DEFAULT TO A 128. BYTE TRANSFER
        BIT     #DEN,U.CW2(R5)  ; DOUBLE DENSITY DISKETTE?
        BEQ     53$             ; IF EQ NO
        ASL     R1              ; CHANGE DEFAULT TO 256. BYTES
53$:    CMP     U.CNT(R5),R1    ; FULL TRANSFER LEFT?
        BHIS    54$             ; IF HIS YES
        MOV     U.CNT(R5),R1    ; NO, GET RESIDUAL COUNT
54$:    MOV     R1,I.PRM+12(R3) ; STORE BYTES BEING TRANSFERED
55$:    BITB    #TR!DONE,(R2)   ; TRANSFERRED?
        BMI     60$             ; IF MI YES
        BEQ     55$             ; IF EQ NO
        BR      70$             ; ERROR
60$:    ASR     R1              ; WORD COUNT
        MOV     R1,RXDB(R2)     ; LOAD WORD COUNT
65$:    BITB    #TR!DONE,(R2)   ; TRANSFERRED?
        BMI     155$            ; IF MI YES - R0 HAS BUFFER ADDR
        BEQ     65$             ; IF EQ NO
70$:    MOV     RXES(R2),I.PRM+6(R3)  ; SAVE STATUS
        JMP     DYRTY           ; ERROR, RETRY OPERATION
;
; EMPTY SILO AFTER READ
;
75$:    MOVB    #EMPTY,U.BUF(R5); SET EMPTY SILO FUNCTION
        BR      50$             ; SAME AS FILL SILO
;
; INITIATE TRANSFER BETWEEN SILO AND DISK
;
130$:   MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS
        MOV     S.CSR(R4),R2    ; GET CSR ADDR
        MOVB    #WRITE,U.BUF(R5);ASSUME WRITE FUNCTION
        MOV     I.FCN(R3),R1    ; GET FUNCTION CODE
        BIC     #7,R1           ; REMOVE QUALIFIER BITS
        CMP     #IO.WDD,R1      ; WRITE WITH DELETED DATA?
        BNE     141$            ; IF NE NO
        MOVB    #WRTDD,U.BUF(R5) ; SET "WRITE DELETED DATA" FUNCTION
        BR      141$            ;
140$:   MOVB    #READ,U.BUF(R5) ; SET READ FUNCTION
141$:   BIT     #DEN,U.CW2(R5)  ; DOUBLE DENSITY?
        BEQ     144$            ; IF EQ NO
        BIS     #SDEN,U.BUF(R5) ; YES-SET DENSITY BIT
144$:   TSTB    U.UNIT(R5)      ; UNIT 1?
        BEQ     142$            ; IF EQ NO
        BIS     #UNIT,U.BUF(R5) ; YES, SET TO SELECT UNIT 1
142$:   BIT     #SSIDED,U.CW2(R5) ; IS IT SECOND SIDE OPERATION ?
        BEQ     147$            ; IF EQ NO
        BIS     #DSIDED,U.BUF(R5) ; USE SECOND SIDE
147$:   MOV     U.BUF(R5),(R2)  ; INITIATE FUNCTION
149$:   BITB    #TR!DONE,(R2)   ; TRANSFER READY OR DONE?
        BMI     150$            ; IF MI TRANSFER READY
        BEQ     149$            ; IF EQ LOOP
        BR      70$             ; ERROR, NO TRANSFER REQUEST
150$:   MOVB    I.PRM+14(R3),RXDB(R2)  ; LOAD SECTOR NUMBER
151$:   BITB    #TR!DONE,(R2)   ; TRANSFER READY OR DONE?
        BMI     152$            ; IF MI TRANSFER READY
        BEQ     151$            ; IF EQ LOOP
        BR      70$             ; ERROR, NO TRANSFER REQUEST
152$:   MOVB    I.PRM+15(R3),R0 ; LOAD TRACK NUMBER IN R0
155$:   MOVB    S.ITM(R4),S.CTM(R4) ; SET TIMEOUT COUNT
160$:                           ; REF LABEL


        .IF DF  E$$DVC

        BIS     S.BMSK(R4),$IOABM  ; SET I/O ACTIVE IN BITMAP

        .ENDC


        MOV     R0,RXDB(R2)     ; LOAD TRACK, BUFFER ADDRESS, OR ASCII I
;
; DYPWF - POWER FAIL ENTRY POINT
;       POWER FAIL IS HANDLED BY THE DEVICE TIMING OUT, THEREFORE
;       NO WORK IS DONE HERE.  IT WILL BE HANDLED WHEN THE DEVICE
;       TIME OUT ENTRY IS EXECUTED.
;
;
; DYCAN - CANCEL I/O ENTRY POINT
;       CANCEL I/O IS A NOP OP FOR FILE STRUCTURED DEVICES
;
DYPWF:                          ;;;
DYCAN:  RETURN                  ;;;

;+
; *** - $DYINT  - RX11 FLOPPY DISK INTERRUPT ENTRY POINT
;
;-
        INTSE$  DY,PR5,R$$X21   ;;; GENERATE INTERRUPT SAVE CODE
        MOV     R3,-(SP)        ;;; SAVE REGISTER
        MOV     U.SCB(R5),R4    ;;; GET SCB ADDRESS
        MOV     S.PKT(R4),R3    ;;; GET I/O PACKET ADDRESS
        MOV     S.CSR(R4),R4    ;;; GET CSR ADDRESS
        MOV     RXDB(R4),I.PRM+6(R3)  ;;; SAVE CONTROLLER STATUS
        MOV     (SP)+,R3        ;;; RESTORE REGISTER
        CLR     (R4)            ;;; DISABLE INTERRUPTS
        CALL    $FORK           ;;; CREATE A SYSTEM PROCESS
        MOV     R4,R2           ; COPY CSR ADDRESS
        MOV     U.SCB(R5),R4    ; GET SCB ADDRESS
        MOVB    S.CON(R4),R3    ; GET CONTROLLER INDEX
        BIT     #SCHAR,U.CW2(R5); SENSE CHARACTERISTICS?
        BNE     DYSEN           ; IF NE YES
        TST     (R2)            ; ANY ERRORS?
        BPL     161$            ; IF PL NO ERRORS
        JMP     DYRTY           ; YES-RETRY FUNCTION
161$:   ASRB    RTTBL+1(R3)     ; INITIALIZE IN PROGRESS?
        BCS     170$            ; IF CS YES
        MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS
        CMP     #IO.SMD,I.FCN(R3)  ; SET MEDIA DENSITY?
        BNE     164$            ; IF NE NO
        JMP     195$            ; YES, FINISH I/O
164$:   CMPB    #IO.RLB/256.,I.FCN+1(R3)  ; READ?
        BNE     166$            ; IF NE NO
        TST     U.CW2(R5)       ; SILO FUNCTION?
        BMI     165$            ; IF MI YES
        JMP     75$             ; NO - GO EMPTY SILO
165$:   BIC     #SILO,U.CW2(R5) ; CLEAR SILO BIT
        CALL    NXTSEC          ; UPDATE TO NEXT SECTOR
        BEQ     193$            ; IF EQ ALL FINISHED
        BR      170$            ; INITIATE NEXT READ
166$:   TST     U.CW2(R5)       ; FILL SILO FUNCTION?
        BPL     167$            ; IF PL NO
        BIC     #SILO,U.CW2(R5) ; YES - CLEAR SILO BIT
        JMP     130$            ; GO WRITE SECTOR
167$:   CALL    NXTSEC          ; UPDATE TO NEXT SECTOR
        BEQ     195$            ; IF EQ ALL FINISHED
170$:   BIC     #ERR1,U.CW2(R5) ; CLEAR TIMEOUT ERROR BIT
        JMP     35$             ; RETRY CURRENT OPERATION NOW
180$:   MOV     #IE.BLK&377,R0  ; SET BAD BLOCK ERROR
        BR      210$            ;
190$:   MOV     #IE.VER&377,R0  ; SET UNRECOVERABLE ERROR
        BR      200$            ;
193$:   MOV     I.FCN(R3),R1    ; GET FUNCTION CODE
        BIC     #7,R1           ; REMOVE QUAILFIER BITS
        CMP     #IO.RPB,R1      ; READ PHYSICAL BLOCK?
        BNE     195$            ; IF NE NO
        MOV     #IS.RDD&377,R0  ; YES, DEFAULT ON READ TO DELETED DATA
        BIT     #100,I.PRM+6(R3); WAS DELETED DATA READ?
        BNE     200$            ; IF NE YES
195$:   MOV     #IS.SUC&377,R0  ; NO, SET NORMAL SUCCESS
200$:   MOV     S.PKT(R4),R1    ; GET I/O PACKET ADDRESS
        MOV     I.PRM+4(R1),R1  ; SET BYTES TRANSFERED
        SUB     U.CNT(R5),R1    ; CALCULATE BYTES ACTUALLY TRANSFERED
205$:                           ; REF LABEL


        .IF DF  E$$DVC

        MOVB    S.CON(R4),R3    ; RETREIVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ; SET FINAL RETRY COUNT
        BIS     #RETRY*256.,R2  ; SET INITIAL RETRY COUNT

        .ENDC


210$:   BIC     #SILO!SCHAR!SSIDED!ERR1,U.CW2(R5)  ; CLEAR ALL BITS
                                ; EXCEPT DENSITY AND DSIDED
        CALL    $IODON          ; SET DONE
        JMP     DYINI           ; TRY FOR ANOTHER REQUEST

;
; INTERRUPT PROCESSING POINT FOR DETERMINING THE
; DISKETTE UNIT STATUS.
;

DYSEN:  MOV     S.PKT(R4),R3    ; RETREIVE I/O PACKET ADDRESS
        TST     (R2)            ; ANY ERRORS ?
        BPL     240$            ; IF PL NO
        BIT     #DENERR,I.PRM+6(R3)  ; IS IT A DENSITY ERROR ?
        BEQ     DYRTY           ; IF EQ NO
240$:   BIC     #SCHAR!DEN!DSIDED,U.CW2(R5) ; CLEAR FLAGS
        MOV     #SINSIN,U.CW3(R5)  ; ASSUME SINGLE DENSITY, SINGLE SIDED
        BIT     #DRVDEN,I.PRM+6(R3)  ;IS IT DOUBLE DENSITY ?
        BEQ     245$            ; IF EQ NO
        ASL     U.CW3(R5)       ; DOUBLE THE MAXIMUM LBN'S
        BIS     #DEN,U.CW2(R5)  ; SET THE DENSITY BIT
245$:   BIT     #SIDES,I.PRM+6(R3)  ; IS IT DOUBLE SIDED ?
        BEQ     250$            ; IF EQ NO
        ASL     U.CW3(R5)       ; DOUBLE THE MAXIMUM LBN'S
        BIS     #DSIDED,U.CW2(R5)  ; SET THE DOUBLE SIDED BIT
250$:   MOV     #IS.SUC&377,R0  ; SET SUCCESS
        MOV     U.CW2(R5),R1    ; RETURN DEVICE CHARACTERISTICS
        BR      205$            ;
;
;       SENSE CHARACTERISTIC PROCESSING
;
DYSEC:  BIS     #SCHAR,U.CW2(R5) ; INDICATE SENSE CHARACTERISTIC
        MOV     #MRDS,R0        ; SET MAINTENANCE READ STATUS
        TSTB    U.UNIT(R5)      ; UNIT 1 ?
        BEQ     255$            ; IF EQ NO
        BIS     #UNIT,R0        ; YES SELECT UNIT 1
255$:   MOV     R0,(R2)         ; INITIATE FUNCTION
        MOVB    S.ITM(R4),S.CTM(R4)  ; SET TIMEOUT COUNT


        .IF DF  E$$DVC

        BIS     S.BMSK(R4),$IOABM  ; SET I/O ACTIVE IN BITMAP

        .ENDC


        RETURN                  ;

;
; SET MEDIA DENSITY
;
DYSMD:  MOV     #SETDEN,R0      ; SET FUNCTION CODE
        BIC     #DEN,U.CW2(R5)  ; CLEAR FLAG
        MOV     #SINSIN,U.CW3(R5)  ; ASSUME SINGLE DENSITY
        TST     I.PRM(R1)       ; SINGLE DENSITY?
        BEQ     306$            ; IF EQ YES
        CMP     #2,I.PRM(R1)    ; DOUBLE DENSITY?
        BNE     306$            ; IF NE NO, TREAT AS SINGLE DENSITY
        BIS     #SDEN,R0        ; DOUBLE DENSITY
        BIS     #DEN,U.CW2(R5)  ; UPDATE STATUS
        ASL     U.CW3(R5)       ; DOUBLE MAXIMUM LBN'S
306$:   TSTB    U.UNIT(R5)      ; UNIT 1 ?
        BEQ     307$            ; IF EQ NO
        BIS     #UNIT,R0        ; YES SELECT UNIT 1
307$:   MOV     R0,(R2)         ; INITIATE FUNCTION
310$:   BITB    #TR!DONE,(R2)   ; TRANSFERRED?
        BMI     315$            ; IF MI YES
        BEQ     310$            ; IF EQ NO
        MOV     S.PKT(R4),R3    ; GET I/O PACKET ADDRESS
        MOV     RXES(R2),I.PRM+6(R3) ; SAVE STATUS
        BR      DYRTY           ; ERROR
315$:   MOV     #'I,R0          ; ASCII "I"
        MOVB    #30.,S.CTM(R4)  ; TIMEOUT COUNT
        JMP     160$            ;

;+
; **-DYOUT-FLOPPY DISK TIMEOUT ENTRY POINT
;-

DYOUT:  CALL    $DTOER          ;;; LOG DEVICE TIMEOUT
        BIS     #ERR1,U.CW2(R5) ; SET TIMEOUT ERROR
        BR      DYRTY1          ;

;
; RETRY LAST FUNCTION
;
DYRTY:                          ; REF LABEL


        .IF DF  E$$DVC

        CALL    $DVERR          ; LOG ERROR

        .ENDC


DYRTY1: MOVB    S.CON(R4),R3    ; RESTORE CONTROLLER INDEX
        MOV     S.PKT(R4),R1    ; GET I/O PACKET ADDRESS
        BITB    #IQ.X,I.FCN(R1) ; INHIBIT RETRIES ?
        BNE     500$            ; IF NE YES
400$:   DECB    RTTBL(R3)       ; ANY RETRIES LEFT?
        BEQ     500$            ; IF EQ NO, ERROR
        BIT     #ERR1,U.CW2(R5) ; TIMEOUT ERROR ?
        BNE     460$            ; IF NE YES
        BIT     #CRCERR,I.PRM+6(R1)  ; CRC ERRORS ?
        BNE     450$            ; IF NE YES
410$:   CMP     #IO.SMD,I.FCN(R1)  ; SET MEDIA DENSITY?
        BNE     420$            ; IF NE NO
        JMP     DYSMD           ; RETRY SET MEDIA DENSITY
420$:   MOV     I.PRM+10(R1),R0 ; GET LOGICAL SECTOR NUMBER
        BIT     #WCOVFL!DENERR,I.PRM+6(R1)  ; WORD COUNT OVERFLOW OR
                                ; DENSITY ERROR ?
        BEQ     450$            ; IF EQ NO
        BIT     #DRVDEN,I.PRM+6(R1)  ; IS IT DOUBLE DENSITY ?
        BNE     430$            ; IF NE YES
        BIC     #DEN,U.CW2(R5)  ; CORRECT IT TO SINGLE DENSITY
        ASL     R0              ; MULTIPLY LSN BY 2
        MOV     #SINSIN,U.CW3(R5)  ; CHANGE MAX LBN'S TO SINGLE DENSITY,
                                ; SINGLE SIDED
        BR      440$            ;
430$:   BIS     #DEN,U.CW2(R5)  ; CHANGE TO DOUBLE DENSITY
        ASR     R0              ; DIVIDE LSN BY 2
        MOV     #SINDOU,U.CW3(R5)  ; CHANGE MAX LBN'S TO DOUBLE DENSITY,
                                ; SINGLE SIDED
440$:   BIT     #SIDES,I.PRM+6(R1)  ; IS IT DOUBLE SIDED ?
        BEQ     445$            ; IF EQ NO
        BIS     #DSIDED,U.CW2(R5)  ; SET DOUBLE SIDED BIT
        ASL     U.CW3(R5)       ; DOUBLE MAX LBN'S
445$:   MOV     R0,I.PRM+10(R1) ; STORE LOGICAL SECTOR NUMBER
450$:   BIC     #ERR1,U.CW2(R5) ; CLEAR TIMEOUT ERROR
        JMP     35$             ; RETRY FUNCTION
460$:   MOVB    #1,RTTBL+1(R3)  ; SET INITIALIZE IN PROGRESS
        MOV     #INIT!INTEBL,(R2) ; INITIALIZE RX211 DRIVES
        MOVB    S.ITM(R4),S.CTM(R4) ; SET TIMEOUT COUNTER
        RETURN                  ;
500$:   BIT     #DRVRDY,I.PRM+6(R1)  ; DRIVE READY ?
        BNE     520$            ; IF NE YES
510$:   MOV     #IE.DNR&377,R0  ; SET DEVICE NOT READY ERROR
        JMP     200$            ; EXIT
520$:   BIT     #RXACLO,I.PRM+6(R1)  ; SUBSYSTEM READY ?
        BNE     510$            ; IF NE NO
        JMP     190$            ; EXIT
        .DSABL  LSB

;+
; *** - TRKSEC  -  CONVERT LOGICAL OR PHYSICAL BLOCK NUMBER TO
;       TRACK-SECTOR PAIR
;
; INPUT:
;       R3 - I/O PACKET ADDRESS
;       I.PRM+10(R3) - LOGICAL OR PHYSICAL SECTOR
;
; OUTPUT:
;       I.PRM+14(R3) - SECTOR (1-26.)
;       I.PRM+15(R3) - TRACK (0-76.)
;       R3 - UNCHANGED
;       C CLEAR - VALID BLOCK
;       C SET - BAD BLOCK NUMBER (PHYSICAL OR LOGICAL)
;
;-

TRKSEC: MOV     I.PRM+10(R3),R1 ; GET LOGICAL OR PHYSICAL BLOCK
        MOV     #8.,R0          ; SET LOOP COUNT
        MOV     #6400,R2        ; SET DIVISOR
1$:     CMP     R2,R1           ; DOES 26 GO INTO DIVIDEND?
        BHI     2$              ; IF HI NO (C=0)
        SUB     R2,R1           ; SUBTRACT 26 FROM DIVIDEND
        SEC                     ; SET CARRY
2$:     ROL     R1              ; SHIFT DIVIDEND AND QUOTIENT
        DEC     R0              ; DONE?
        BGT     1$              ; IF GT NO
        MOVB    R1,R0           ; GET TRACK NUMBER
        CMP     R0,#76.         ; IS IT SECOND SIDE?
        BLT     4$              ; IF LT NO
        BITB    #IO.RPB&377,I.FCN(R3)  ; PHYSICAL BLOCK FUNCTION?
        BEQ     6$              ; IF EQ NO, IT'S A LOGICAL BLOCK
        CMP     #76.,R0         ; YES
        BEQ     4$              ; IF EQ ALLOW ACCESS TO #76.
        SUB     #77.,R0         ; CHANGE SIDES - PHYBLK ACCESS
        BR      7$              ; CHANGE READ HEADS
6$:     SUB     #76.,R0         ; ADJUST FOR SECOND SIDE
7$:     BIT     #DSIDED,U.CW2(R5) ; TWO SIDE MEDIA?
        BEQ     11$             ; IF EQ NO, BAD BLOCK
        BIS     #SSIDED,U.CW2(R5)  ; SET HEAD 1 SELECT BIT
4$:     CLRB    R1              ; CLEAR TRACK NUMBER
        SWAB    R1              ; SHIFT DONE SECTOR NUMBER
        BITB    #IO.RPB&377,I.FCN(R3) ; IS IT A PHYSICAL BLOCK NUMBER?
        BNE     10$             ; IF NE YES
        CMP     #12.,R1         ; NO, C=1 IF 13<=R1<=25
        ROL     R1              ; DOUBLE FOR INTERLEAVE FACTOR
        ASL     R0              ; ADD TRACK -TRACK SKEW
        ADD     R0,R1           ; SKEW BY 2*TRACK
        ADD     R0,R1           ; SKEW BY 4*TRACK
        ADD     R0,R1           ; SKEW BY 6*TRACK
        ASR     R0              ; RESTORE TRACK NUMBER
        MOV     #26.,R2         ; SET MODULUS
5$:     SUB     R2,R1           ; MODULO SECTOR INTO RANGE -26. TO -1.
        BGE     5$              ; IF GE LOOP UNTIL NEGATIVE
        ADD     R2,R1           ; CONVERT TO RANGE 0-25.
        INC     R0              ; LBN0 STARTS ON TRACK 1
10$:    INC     R1              ; CONVERT TO RANGE 1-26.
        MOV     R1,I.PRM+14(R3) ; SAVE SECTOR NUMBER
        BR      12$             ; - BRANCH
11$:    SEC                     ; SIGNAL BAD BLOCK ERROR
        MOVB    R0,I.PRM+15(R3) ; SAVE TRACK NUMBER
        BR      14$             ; RETURN
12$:    MOVB    R0,I.PRM+15(R3) ; SAVE TRACK NUMBER
        CMP     #77.*256.,I.PRM+14(R3)  ; IS IT A VALID TRACK/SECTOR?
14$:    RETURN                  ;

;+
; *** - NXTSEC  -  UPDATE BLOCK NUMBER , BUFFER ADDRESS
;                       AND BUFFER POINTER
;
; INPUT:
;       R3 - I/O PACKET ADDRESS
;       R5 - UCB ADDRESS
;       I.PRM+10(R3) - CURRENT BLOCK NUMBER
;       I.PRM+12(R3) - BYTES TRANSFERED DURING LAST FUNCTION
;       U.CNT(R5) - BYTES LEFT TO TRANSFER
;       U.BUF(R5) - BUFFER ADDRESS
;
; OUTPUT:
;       I.PRM+10(R3) - UPDATED BLOCK NUMBER
;       U.BUF(R5) - UPDATED BY 128./256. BYTES
;       U.CNT(R5) - UPDATED BY NUMBER OF WORDS TRANSFERED
;       Z SET - ALL BYTES TRANSFERED
;       Z CLEAR - MORE BYTES TO TRANSFER
;       C CLEAR - VALID TRACK/SECTOR
;       C SET - BAD BLOCK NUMBER
;
;+

NXTSEC: INC     I.PRM+10(R3)    ; UPDATE BLOCK NUMBER
        ADD     #128.,U.BUF+2(R5)  ;  UPDATE BUFFER POINTER
        BIT     #DEN,U.CW2(R5)  ; SINGLE DENSITY?
        BEQ     10$             ; IF EQ YES
        ADD     #128.,U.BUF+2(R5)  ; UPDATE BUFFER POINTER AGAIN
10$:    BCC     15$             ; IF CC, SKIP NEXT ADD


        .IF DF  M$$MGE

        ADD     #10000,U.BUF(R5) ; CARRY INTO EXTENDED MEMORY BITS

        .ENDC


15$:    SUB     I.PRM+12(R3),U.CNT(R5)  ; UPDATE BYTES LEFT TO TRANSFER
        RETURN                  ;

        .END
        .TITLE  ERROR
        .IDENT  /04.2/
 
;
; COPYRIGHT (C) 1976, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 04
;
; GARY H. MENDELSOHN 19-MAY-75
;
; PREVIOUSLY MODIFIED BY:
;
;       T. J. MILLER
;
; MODIFIED BY:
;
;       D. L. GIRDLER 10-MAY-77
;
;               DLG001 -- DON'T INCREMENT ERROR COUNT IF ERROR
;                       LOGGING IS NOT TURNED ON.
;
;       E. L. BAATZ 13-NOV-77
;
;               EB099 -- GUARANTEE THAT $QEMB, $ALEB1, $DVERR, AND
;                       $DVCER WILL ALWAYS BE DEFINED
;
;       CHUCK SPITZ 9-DEC-78
;               CS022 -- RETURN CARRY SET FROM $ALEB1 WHEN NO ERROR
;                       LOGGING.
;
;       P. J. BEZEREDI 12-JAN-79
;
;               PB097 -- LOG RHBAE AND RHCS3 REGISTERS ON 11/70
;                       PROCESSORS.
;
;        R.R.ADAMS  21-MAR-79
;         RA011 -- V4.2  LOG SYSTEM I/O ACTIVE BITMAP IF UNIT'S
;         BITMAP IS ZERO
;
; ERROR LOGGING
;

        .IF DF  E$$DVC!E$$NSI!E$$PER

;
; EQUATED SYMBOLS
;

WRTLIM=520.                     ;LOGGER WRITE THRESHOLD
ERRTIM=5.*K$$TPS                ;TIME LIMIT IN QUEUE BEFORE WRITE

        .IFTF

        .MCALL  HWDDF$
        HWDDF$                  ;DEFINE CPU REGISTERS

        .IFT

;
; MACRO LIBRARY CALLS
;

        .MCALL  CLKDF$,HDRDF$,PCBDF$,PKTDF$,TCBDF$
        CLKDF$                  ;DEFINE CLOCK OFFSETS AND CODES
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        PCBDF$                  ;DEFINE PARTITION OFFSETS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS AND CODES

;
; LOCAL STORAGE
;

        .IF DF  E$$DVC

;
; DEVICE TIMEOUT STORAGE
;

DTOTMP: .BLKW   1               ;SAVED CSR CONTENTS

        .ENDC

        .IF DF  E$$NSI

;
; NONSENSE INTERRUPT STORAGE
;
; ADJACENCY ASSUMED
;

        .BLKW   3               ;FORK BLOCK
TEMP:   .BLKB   1               ;PS STORAGE
NSI:    .BYTE   -1              ;RECURSION COUNTER
OPS:    .BLKW   1               ;OLD PS STORAGE
OPC:    .BLKW   1               ;OLD PC STORAGE

        .ENDC

;+
; **-$ALEMB-ALLOCATE AN ERROR MESSAGE BLOCK
; **-$ALEB1-ALLOCATE AN ERROR MESSAGE BLOCK (ALTERNATE ENTRY)
;
; THIS ROUTINE IS CALLED TO ALLOCATE AN ERROR MESSAGE BLOCK AND         ; PB097
; INCREMENT THE ERROR SEQUENCE NUMBER.  THE EMB WILL ALSO BE            ; PB097
; INITIALIZED WITH THE ERROR CODE, ERROR SEQUENCE NUMBER AND THE        ; PB097
; CURRENT DATE AND TIME.                                                ; PB097
;                                                                       ; PB097
; INPUTS:                                                               ; PB097
;                                                                       ; PB097
;       R1=SIZE OF EMB TO ALLOCATE IN BYTES                             ; PB097
;       (SP)=RETURN TO CALLER                                           ; PB097
;       2(SP)=ERROR CODE                                                ; PB097
;                                                                       ; PB097
; OUTPUTS:                                                              ; PB097
;                                                                       ; PB097
;       C=0 IF EMB SUCCESSFULLY ALLOCATED                               ; PB097
;               R0=ADDRESS OF FIRST UNFILLED BYTE IN EMB                ; PB097
;               R1=ADDRESS OF THE EMB                                   ; PB097
;       C=1 IF ALLOCATION FAILED OR ERROR LOGGING NOT TURNED ON.        ; PB097
;                                                                       ; PB097
;       THE ERROR CODE IS ALWAYS REMOVED FROMTHE STACK.                 ; PB097
;                                                                       ; PB097
; NOTE: R2 AND R3 ARE DESTROYED BY $ALEMB THRU $ALOCB                   ; PB097
;-                                                                      ;**-21

        .ENABL  LSB
$ALEMB::TST     $ERRPT          ;ERROR LOG TURNED ON?
        SEC                     ;ASSUME NO ALLOCATION
        BEQ     20$             ;IF EQ NO, DON'T COUNT ERROR
        INC     $ERRSQ          ;COUNT THE ERROR
$ALEB1::SEC                     ;ASSUME ALLOCATION WILL NOT OCCUR
        MOV     $ERRPT,R0       ;ERROR LOGGING TURNED ON?
        BEQ     20$             ;IF EQ NO
        MOV     $ERRLM,R0       ;IS THERE ROOM AVAILABLE?
        BMI     20$             ;NO IF MI
        CALL    $ALOCB          ;ALLOCATE THE EMB
        BCS     20$             ;UNSUCCESSFUL IF CS
        SUB     R1,$ERRLM       ;UPDATE ROOM LEFT
        MOV     R1,E.SIZE+2(R0) ;FILL IN SIZE OF EMB
        MOV     R0,R1           ;COPY EMB POINTER
        CMP     (R0)+,(R0)+     ;ADVANCE OVER LINK AND E.SIZE
        MOV     2(SP),(R0)+     ;FILL CODE
        MOV     #$TTNS,R2       ;POINT PAST CURRENT SECOND
10$:    DEC     R2              ;SKIP BYTE
        MOVB    -(R2),(R0)+     ;FILL TIME
        CMP     R2,#$TTNS-14    ;DONE YET?
        BHI     10$             ;IF HI NO
        MOV     $ERRSQ,(R0)+    ;FILL SEQUENCE NUMBER
        CLC                     ;INDICATE SUCCESS
20$:    MOV     (SP)+,(SP)      ;REMOVE ERROR CODE
        RETURN                  ;EXIT
        .DSABL  LSB

        .IFF

$ALEB1::SEC                     ;SET CARRY TO INDICATE FAILURE          ; CS021
        RETURN                  ;EXIT                                   ; CS021
                                                                        ;**-1
        .ENDC

        .IF DF  E$$DVC

;+
; **-$BMSET-SET A DRIVER'S BIT IN THE I/O ACTIVE BITMAP
;
; THIS COROUTINE RAISES THE PROCESSOR PRIORITY TO SEVEN AND             ; PB097
; SETS THE MASK WORD IN THE SCB INTO THE SYSTEM WIDE I/O                ; PB097
; ACTIVE MASK.  IT THEN RECALLES THE CALLER WHO WILL START              ; PB097
; THE FUNCTION AND RETURN HERE TO ALLOW INTERRUPTS.                     ; PB097
;                                                                       ; PB097
; INPUTS:                                                               ; PB097
;                                                                       ; PB097
;       R4=SCB ADDRESS.                                                 ; PB097
;                                                                       ; PB097
; OUTPUTS:                                                              ; PB097
;                                                                       ; PB097
;       $IOABM IS MODIFIED.                                             ; PB097
;-                                                                      ;**-12

$BMSET::MTPS    #PR7            ;LOCK OUT INTERRUPTS
        BIS     S.BMSK(R4),$IOABM ;;;UPDATE BITMAP
        CALL    @(SP)+          ;;;CALL THE CALLER
        MTPS    #0              ;;;ALLOW INTERRUPTS AND CLEAR C.
        RETURN                  ;EXIT

;+
; **-$DTOER-DEVICE TIMEOUTS
;
; THIS ROUTINE IS CALLED TO LOG A DEVICE TIMEOUT ERROR CONDITION.       ; PB097
; THE CONTROLLER'S INTERRUPT ENABLE BIT IS RESET AND THE PROCESSOR      ; PB097
; PRIORITY IS DROPPED TO ZERO.  IF A DIAGNOSTIC FUNCTION WAS IN         ; PB097
; PROGRESS, NO ERROR IS LOGGED.                                         ; PB097
;                                                                       ; PB097
; INPUTS:                                                               ; PB097
;                                                                       ; PB097
;       R2=CSR ADDRESS.                                                 ; PB097
;       R4=SCB ADDRESS.                                                 ; PB097
;                                                                       ; PB097
; OUTPUTS:                                                              ; PB097
;                                                                       ; PB097
;       R1=ADDRESS OF I/O PACKET (IF DIAGNOSTICS ENABLED)               ; PB097
;       C=0 IF FUNCTION WAS NOT A USER MODE DIAGNOSTIC FUNCTION.        ; PB097
;               THE EMB IS FILLED AND THE SCB CONTAINS A POINTER        ; PB097
;               TO IT AND THE ERROR IN PROGRESS FLAG IS SET IN          ; PB097
;               THE SCB.                                                ; PB097
;       C=1 IF FUNCTION WAS A USER MODE DIAGNOSTIC FUNCTION.            ; PB097
;               IN THIS CASE ONLY THE INTERRUPT ENABLE BIT IS           ; PB097
;               CLEARED AND THE PRIORITY IS LOWERED TO ZERO.            ; PB097
;-                                                                      ;**-34

        .IFTF

        .ENABL  LSB
$DTOER::                        ;;;REFERENCE LABEL

        .IFT

        MOV     (R2),DTOTMP     ;;;SAVE CSR CONTENTS

        .IFTF

        BIC     #100,(R2)       ;;;TURN OFF DEVICE INTERRUPTS
        MTPS    #0              ;;;ALLOW INTERRUPTS


        .IF DF  D$$IAG

        MOV     S.PKT(R4),R1    ;PICK UP ADDRESS OF I/O PACKET
        SEC                     ;ASSUME USER-MODE DIAGNOSTIC FUNCTION
        BITB    #IQ.UMD,I.FCN(R1) ;DIAGNOSTIC FUNCTION?
        BNE     100$            ;IF NE YES
        CLC                     ;INDICATE CSR SAVED

        .ENDC


        .IFT

        MOV     #EC.DTO,-(SP)   ;INDICATE DEVICE TIMEOUT
        BR      10$             ;ENTER COMMON CODE

;+
; **-$DVCER-DEVICE ERROR BIT SET
;
; THIS ROUTINE IS CALLED TO LOG A DEVICE ERROR.  AN EMB WILL BE         ; PB097
; ALLOCATED AND THE CONTEXT OF THE CURRENT TRANSFER WILL BE SAVED.      ; PB097
; IF AN ERROR IS ALREADYIN PROGRESS FOR THIS DEVICE, THE ERROR          ; PB097
; WILL BE IGNORED.                                                      ; PB097
;                                                                       ; PB097
; INPUTS:                                                               ; PB097
;                                                                       ; PB097
;       R4=SCB ADDRESS.                                                 ; PB097
;       R5=UCB ADDRESS.                                                 ; PB097
;                                                                       ; PB097
; OUTPUTS:                                                              ; PB097
;                                                                       ; PB097
;       IF THIS IS THE FIRST OCCURRENCE OF THE ERROR, THE EMB IS        ; PB097
;       FILLED AND THE SCB IS SET TO POINT TO THE EMB ADDRESS AND       ; PB097
;       THE ERROR IN PROGRESS BIT IS SET.                               ; PB097
;                                                                       ; PB097
; NOTE: ALL REGISTERS ARE PRESERVED.                                    ; PB097
;-                                                                      ;**-27

$DVERR::                        ; TEMPORARY * * *
$DVCER::MOV     #EC.DVC,-(SP)   ;INDICATE DEVICE ERROR
        SEC                     ;INDICATE NO CSR ADDRESS
10$:    MOV     R2,-(SP)        ;SAVE R2
        MOV     R1,-(SP)        ;SAVE R1
        MOV     R0,-(SP)        ;SAVE R0
        MOV     R2,-(SP)        ;SAVE CSR ADDRESS
        BCC     20$             ;WAS THAT A CSR ADDRESS?
        CLR     (SP)            ;NO IF CS
20$:    MOV     10(SP),-(SP)    ;MOVE ERROR CODE
        MOV     R3,12(SP)       ;SAVE R3

;
; AT THIS POINT THE STACK CONTAINS:
;
;        0(SP)=ERROR CODE
;        2(SP)=CSR ADDRESS OR 0
;        4(SP)=SAVED R0
;        6(SP)=SAVED R1
;       10(SP)=SAVED R2
;       12(SP)=SAVED R3
;       14(SP)=RETURN
;
        BITB    #SP.EIP!SP.ENB,S.PRI(R4) ;ERROR IN PROGRESS OR LOGGING OFF?
        BNE     80$             ;YES IF NE
        BISB    #SP.EIP,S.PRI(R4) ;INDICATE ERROR IN PROGRESS
        MOVB    S.RCNT(R4),R1   ;GET NUMBER OF DEVICE REGS
        ASL     R1              ;MAKE BYTE COUNT
        ADD     #E.LGTH+2,R1    ;MAKE REQUIRED EMB SIZE
                                                                        ; PB097
                                                                        ; PB097
        .IF DF  M$$EXT                                                  ; PB097
                                                                        ; PB097
        BIT     #DV.MBC,U.CW1(R5)  ;MASSBUS DEVICE?                     ; PB097
        BEQ     25$             ;IF EQ NO                               ; PB097
        ADD     #4,R1           ;YES, ADD SPACE FOR 2 MORE REGISTERS    ; PB097
                                                                        ; PB097
        .ENDC                                                           ; PB097
                                                                        ; PB097
                                                                        ; PB097
25$:    CALL    $ALEMB          ;ATTEMPT TO ALLOCATE AN EMB             ; PB097
        BCC     30$             ;SUCCESS IF CC                          ;**-1
        CLR     S.BMSV(R4)      ;INDICATE NO EMB
        BR      90$             ;AND EXIT
30$:    MOV     S.BMSV(R4),(R0)+ ;FILL SAVED BITMAP
        BNE     35$             ;IF NE UNIT ACTIVE                      ; RA011
        MOV     $IOABM,-2(R0)   ;LOG THE SYSTEM BITMAP                  ; RA011
35$:    MOV     R1,S.BMSV(R4)   ;SAVE POINTER TO EMB                    ; RA011
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS                 ;**-1
        CLR     (R0)+           ;SAVE ROOM FOR RETRY COUNTS
        MOV     I.TCB(R1),R2    ;GET TCB ADDRESS
        MOV     T.PRI(R2),(R0)+ ;FILL I/O CNT (AND PRIORITY)
        MOV     T.NAM(R2),(R0)+ ;FILL TASK NAME
        MOV     T.NAM+2(R2),(R0)+ ;
        MOV     T.PCB(R2),R2    ;GET PCB ADDRESS
        MOV     P.REL(R2),(R0)+ ;FILL 1/64TH REAL ADDRESS
        MOV     P.HDR(R2),R2    ;POINT TO HEADER
        MOV     H.CUIC(R2),(R0)+ ;FILL TASK UIC
        MOV     I.UCB(R1),(R0)+ ;FILL DEVICE ID
        MOV     I.FCN(R1),(R0)+ ;FILL FUNCTION CODE
        ADD     #I.PRM,R1       ;POINT TO PARAMETERS
        MOV     #7,R2           ;SET UP LOOP
40$:    MOV     (R1)+,(R0)+     ;FILL PARAMETERS
        DEC     R2              ;DONE?
        BNE     40$             ;NO IF NE
        MOVB    S.RCNT(R4),R2   ;GET NUMBER OF DEVICE REGS
        MOV     R2,(R0)+        ;FILL REG COUNT
                                                                        ; PB097
                                                                        ; PB097
        .IF DF  M$$EXT                                                  ; PB097
                                                                        ; PB097
        BIT     #DV.MBC,U.CW1(R5)  ;MASSBUS DEVICE?                     ; PB097
        BEQ     45$             ;IF EQ NO                               ; PB097
        ADD     #2,-2(R0)       ;YES, ADD 2 MORE REGISTERS              ; PB097
                                                                        ; PB097
        .ENDC                                                           ; PB097
                                                                        ; PB097
                                                                        ; PB097
45$:    MOVB    S.ROFF(R4),R1   ;GET OFFSET TO FIRST REGISTER           ; PB097
        ADD     S.CSR(R4),R1    ;POINT TO FIRST REG                     ;**-1
50$:    CMP     R1,(SP)         ;IS THIS THE CSR?
        BNE     60$             ;NO IF NE
        MOV     DTOTMP,(R0)+    ;FILL SAVED CSR CONTENTS
        TST     (R1)+           ;ADJUST R1
        BR      70$             ;
60$:    MOV     (R1)+,(R0)+     ;FILL REGISTER
70$:    DEC     R2              ;DONE?
        BNE     50$             ;NO IF NE
        BR      90$             ;
80$:    TST     (SP)+           ;REMOVE ERROR CODE
90$:    TST     (SP)+           ;REMOVE CSR ADDRESS
        MOV     (SP)+,R0        ;RESTORE R0
        MOV     (SP)+,R1        ;RESTORE R1
        MOV     (SP)+,R2        ;RESTORE R2
        MOV     (SP)+,R3        ;RESTORE R3

        .IFTF

100$:   RETURN                  ;EXIT
        .DSABL  LSB

        .IFF

$DVERR::                        ;
$DVCER::                        ;

        .ENDC

        .IF DF  E$$NSI

;+
; **-$NS0,$NS1,$NS2,$NS3,$NS4,$NS5,$NS6,$NS7-
;       NONSENSE INTERRUPT IDENTIFIER ROUTINES
;
; EACH OF THESE ROUTINES IS VECTORED TO BY ONE OF A GROUP OF 16
; UNUSED VECTORS.  THE VECTORS ARE SUB-CODED IN THE PS CONDITION CODES.
;-

$NS0:   :CALL   NSIER           ;;;CALL COMMON CODE
        .WORD   0               ;;;GROUP 0-17
$NS1::  CALL    NSIER           ;;;
        .WORD   20              ;;;GROUP 20-37
$NS2::  CALL    NSIER           ;;;
        .WORD   40              ;;;GROUP 40-57
$NS3::  CALL    NSIER           ;;;
        .WORD   60              ;;;GROUP 60-77
$NS4::  CALL    NSIER           ;;;
        .WORD   100             ;;;GROUP 100-117
$NS5::  CALL    NSIER           ;;;
        .WORD   120             ;;;GROUP 120-137
$NS6::  CALL    NSIER           ;;;
        .WORD   140             ;;;GROUP 140-157
$NS7::  CALL    NSIER           ;;;
        .WORD   160             ;;;GROUP 160-177

;+
; **-NSIER-NONSENSE INTERRUPT ERRORS
;
; THIS ROUTINE IDENTIFIES THE INTERRUPTING VECTOR AND LOGS
; THE ERROR.
;
; INPUTS:
;
;       @(SP)=BITS 06:04 OF UNUSED VECTOR NUMBER
;
; OUTPUTS:
;
;       AN EMB IS ALLOCATED AND QUEUED TO THE LOGGER WHICH
;       CONTAINS THE VECTOR NUMBER AND THE I/O ACTIVE BITMAP.
;-

NSIER:  MFPS    -(SP)           ;;;SAVE VECTOR ID(MODULO 20)
        INCB    NSI             ;;;NSI IN PROGRESS?
        BEQ     10$             ;;;NO IF EQ
        CMP     (SP)+,(SP)+     ;;;YES, CLEAR STACK
        RTI                     ;;;AND RETURN
10$:    BIC     #177760,(SP)    ;;;ISOLATE VECTOR ID(MOD 20)
        MOV     (SP)+,TEMP      ;;;SAVE VECTOR ID(MOD 20)
        BIS     @(SP)+,TEMP     ;;;ADD GROUP BIAS
        MOV     (SP),OPC        ;;;SAVE PREINTERRUPT PC
        MOV     2(SP),OPS       ;;;SAVE PREINTERRUPT PS
        CALL    $INTSV,PR7      ;;;SWITCH STACKS
        MOV     $IOABM,R5       ;;;COPY IOABM
        MOV     #TEMP,R4        ;;;POINT PAST FORK BLOCK
        CALL    $FORK1          ;;;AND FORK,SAVING R5
        MOV     #E.OPC+2+2,R1   ;SET
        MOV     #EC.NSI,-(SP)   ; UP TO
        CALL    $ALEMB          ;  CREATE EMB
        BCS     20$             ;FAILED IF CS
        MOV     R5,(R0)+        ;FILL BITMAP
        MOV     TEMP,(R0)+      ;FILL ID AND COUNT
        MOV     OPS,(R0)+       ;FILL OLD PS
        MOV     OPC,(R0)        ;FILL OLD PC
        MOV     #$QEMB,-(SP)    ;SET UP TO CALL $QEMB
20$:    MOV     #-1,TEMP        ;RESET RECURSION COUNTER
        RETURN                  ;EXIT

        .ENDC

        .IF DF  E$$DVC!E$$NSI

;+
; **-$QEMB-QUEUE AN EMB
;
; THIS IS THE COMMON POINT FOR ALL EMBS. THE EMB IS QUEUED
; FIFO IN THE ERROR QUEUE.  IF THERE ARE
; ENOUGH BYTES OF EMBS IN THE POOL, THE LOGGER TASK IS AWAKENED.
; ELSE, IF THE QUEUE WAS EMPTY, A SCHEDULE REQUEST IS MADE
; SO A QUEUED EMB WILL BE WRITTEN WITHIN A TIME LIMIT.
; ELSE, A RETURN IS MADE.
;
; INPUTS:
;
;       (R1)=ADDRESS OF THE EMB
;
; OUTPUTS:
;
;       THE EMB IS QUEUED. CONDITIONALLY, THE LOGGER IS WAKED
;       OR A SCHEDULE REQUEST IS MADE FOR THE LOGGER
;
; NOTE: REGISTERS R0-R3 ARE DESTROYED
;-

        .ENABL  LSB
$QEMB:: SAVNR                   ;SAVE R4 AND R5
        MOV     $ERRPT,R5       ;GET ERRLOG TCB
        BEQ     30$             ;NOT INITIALIZED IF EQ
        MOV     #$ERRHD,R0      ;POINT TO ERROR QUEUE LISTHEAD
        MOV     (R0),-(SP)      ;SAVE CONTENTS OF LISTHEAD
        CALL    $QINSF          ;QUEUE THE EMB FIFO
        ADD     E.SIZE+2(R1),$ERRSZ ;UPDATE POOL USAGE
        CMP     $ERRSZ,#WRTLIM  ;ENOUGH TO WRITE
        BGE     10$             ;YES IF GE
        TST     (SP)+           ;WAS ERROR QUEUE EMPTY?
        BNE     20$             ;NO IF NE

;
; ERROR QUEUE WAS EMPTY. SET A SCHEDULE REQUEST FOR THE
; LOGGER AT ERRTIM FROM NOW, SO THAT THE EMB WILL BE
; WRITTEN IF NO MORE ERRORS OCCUR BEFORE THEN.
;

        MOV     #C.LGTH,R1      ;SIZE OF CLOCK QUEUE ENTRY
        CALL    $ALOCB          ;TRY TO GET SOME CORE
        BCS     15$             ;UNAVAILABLE IF CS
        CLR     C.UIC(R0)       ;INDICATE DEFAULT UIC
        CLR     R1              ;HIGH TIME=0
        MOV     #ERRTIM,R2      ;LOW TIME
        MOV     #C.SSHT,R4      ;SINGLE-SHOT TASK REQUEST
        CALLR   $CLINS          ;MAKE REQUEST

;
; REQUEST THE LOGGER NOW
;

10$:    TST     (SP)+           ;CLEAN STACK
15$:    MOV     R5,R0           ;COPY LOGGER TCB
        TST     T.STAT(R0)      ;ERRLOG RUNNING?
        BPL     20$             ;YES IF PL
        CLR     R1              ;INDICATE DEFAULT UIC
        CALLR   $TSKRT          ;REQUEST LOGGER
20$:    RETURN                  ;EXIT
30$:    CRASH                   ;NO ERRORS ARE QUEUED IF
                                ;NO LOGGER IS PRESENT
        .DSABL  LSB

        .IFF

$QEMB::                         ;

        .ENDC

        .END
        .TITLE  EXDBT
        .IDENT  /04/
 
;
; COPYRIGHT (C) 1975, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 02
;
; D. N. CUTLER 7-DEC-74
;
; PREVIOUSLY MODIFIED BY:
;
;       E. L. BAATZ
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 30-AUG-75
;
;               TM002 -- ADD CHECKS COMPATIBLE WITH THOSE MADE IN SSTSR
;                       FOR SYNCHRONOUS TRAPS IN MAPPED EXEC.
;
;       T. J. MILLER 15-JUN-76
;
;               TM045 -- ADDITION OF "TE" AND "SO" REPORT.
;
;       T. J. MILLER 27-AUG-76
;
;               TM057 -- CORRECT USE OF FLOATING POINT CONDITIONAL.
;
;       E. L. BAATZ 7-OCT-76
;
;               EB006 -- CORRECT A FEW COMMENTS
;
;       J. E. PROVINO 27-OCT-77
;
;               JP028 -- FIX 'X' COMMAND SO THAT IT PROPERLY HANDLES
;                        A STACK OVERFLOW CONDITION.
;
;       C. SPITZ 13-MAR-78
;               CS009 -- REMOVE FLOATING POINT SUPPORT
;
; EXECUTIVE ODT
;
; THIS IS A VERSION OF ODT THAT MAY BE USED TO DEBUG RSX-11M EXECUTIVE
; MODULES. IT IS AN OUTGROWTH OF THE STANDARD RSX-11 ODT WHICH WAS PRO-
; DUCED BY M. SMITH , H. LEV ET. AL.
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS

;
; EQUATED SYMBOLS
;

BPT=3                           ;BREAKPOINT INSTRUCTION CODE
BKP=16                          ;NUMBER OF BREAKPOINTS -1 X 2
LPB=177516                      ;LINE PRINTER BUFFER REGISTER
LPS=177514                      ;LINE PRINTER STATUS REGISTER
RLR=16                          ;NUMBER OF RELOCATION REGISTERS -1 X 2
TBT=20                          ;T-BIT MASK FOR PROCESSOR STATUS WORD
TKB=177562                      ;CONSOLE TERMINAL INPUT BUFFER REGISTER
TKS=177560                      ;CONSOLE TERMINAL INPUT STATUS REGISTER
TPB=177566                      ;CONSOLE TERMINAL OUTPUT BUFFER REGISTER
TPS=177564                      ;CONSOLE TERMINAL OUTPUT STATUS REGISTER

;
; LOCAL MACROS
;
; DECODE NEXT COMMAND
;

        .MACRO  DECODE
        IOT
        .ENDM

;
; ERROR
;

        .MACRO  ERROR
        EMT     0
        .ENDM

;
; TEST MODE FOR EXEC OR USER
;

        .MACRO  TESTM ADDR
        JSR     R5,TESTM
        .WORD   ADDR
        .ENDM

;
; TYPE OUT CHARACTER(S)
;
;       TYPE OUT IS EFFECTED WITH A TRAP INSTRUCTION WITH THE BOTTOM
;       BYTE ENCODED AS FOLLOWS:
;
;               300 = OUTPUT BOTH BYTES IN R0.
;               200 = OUTPUT LOW BYTE IN R0.
;               340 = OUTPUT A <CR><LF> SEQUENCE.
;               240 = OUTPUT A <CR> SEQUENCE.
;
;               ALL OTHER COMBINATIONS ARE TREATED AS THE ACTUAL BYTE
;               TO OUTPUT.

        .MACRO  TYPE ARG
        .IF IDN <ARG>,<R0>
        TRAP    200
        .IFF
        .IF IDN <ARG>,<R0+R0>
        TRAP    300
        .IFF
        .IF IDN <ARG>,<CRLF>
        TRAP    340
        .IFF
        .IF IDN <ARG>,<CR>
        TRAP    240
        .IFF
        TRAP    ARG&177
        .ENDC
        .ENDC
        .ENDC
        .ENDC
        .ENDM

;
; LOCAL DATA
;
; CONTEXT VARIABLES
; THE ORDER OF THESE ITEMS IS INTENTIONAL, SEE REGISTER MAPPING SCHEME
;

INTBEG  =.      ;STARTING ADDRESS OF INTERNAL REGISTERS

UR0:    0                       ;USER R0                        $0
        0                       ;     R1                        $1
        0                       ;     R2                        $2
        0                       ;     R3                        $3
        0                       ;     R4                        $4
        0                       ;     R5                        $5
USP:    0                       ;USER SP                        $6
UPC:    $INITL                  ;USER PC                        $7
UST:    PR7                     ;USER PS                        $S
ARG:    0                       ;ARGUMENT REGISTER              $A
LOW:    0                       ;LOW LIMIT                      $L
HI:     0                       ;HIGH LIMIT                     $H
CNST:   $XDT                    ;CONSTANT REGISTER              $C
QUAN:   0                       ;QUANTITY REGISTER              $Q
FORM:   0                       ;FORMAT REGISTER                $F

;
; INTERNAL TABLES
;

INTINX  =.              ;STARTING ADDRESS OF INTERNAL TABLES

;
; BREAKPOINT CONTROL LISTS, AND EXTRA SLOT FOR SINGLE STEP
;

ADR1:           ;ADDRESS OF THE BREAKPOINT      ($0B-$7B)
        .WORD   TRTC,TRTC,TRTC,TRTC,TRTC,TRTC,TRTC,TRTC,TRTC

CT:             ;PROCEED COUNT  ($0G-$7G)
        .WORD   1,1,1,1,1,1,1,1,1

UIN:            ;USER INSTRUCTION SAVE LOCATION ($0I-$7I)
        .WORD   BPT,BPT,BPT,BPT,BPT,BPT,BPT,BPT,BPT

;
; RELOCATION REGISTERS
;

RELT:           ;RELOCATION TABLES      ($0R-$7R)
        .WORD   -1,-1,-1,-1,-1,-1,-1,-1

INTEND=.-2                      ;END OF INTERNAL REGISTERS AND TABLES

;
; EXEC SST TRAP VECTOR ADDRESSES
;

SSTVEC:  +      ODDA            ;0-ODD ADDRESS, OR HALT, VECTOR @4


        .IF     DF M$$MGE

         +      SGMT            ;1-SEGMENT FAULT

        .IFF

        +       $NONSI          ; NO SEGMENT FAULT POSSIBLE

        .ENDC


         +      BPTI            ;2-T-BIT OR BPT
         +      IOTX            ;3-IOT
         +      ILLI            ;4-RESERVED OR ILLEGAL INSTRUCTION
         +      NEMT            ;5-EMT
         +      TRPI            ;6-TRAP

                                                                                ;**-11
;
; WORDS AND ORDERED BYTES, ITEMS MUST BE KEPT FROM COMMAND TO COMMAND
;

CAD:    .WORD   0               ;ADDRESS OF CURRENTLY OPEN REGISTER
DOT:    .WORD   0               ;ADDRESS OF LAST EXPLICITLY OPENED CELL
BW:     .WORD   0               ;LAST OPEN MODE 1=BYTE, 2=WORD
OPN:    .WORD   0               ;LOCATION OPEN FLAG 0=NOT OPEN, NON-ZERO=OPEN
D.ARGS: .WORD   0               ;SEMI COLON PUSH WORD

;
; THE FOLLOWING ITEMS NEED NOT BE KEPT FROM COMMAND TO COMMAND
; THEIR ORDER IS INTENTIONAL SO KNOW THY MAKER!
;

OP:     .BYTE   0               ;CURRENT ARITHMETIC OPERATOR
SMFD:   .BYTE   0               ;SEMI-COLON COUNTER
EXP:    .WORD   0               ;EXPRESSION BUCKET
OUTB:   .WORD   TPB             ;CONSOLE PRINTER BUFFER ADDRESS
OUTS:   .WORD   TPS             ;CONSOLE PRINTER STATUS REGISTER
PPC:    .BLKW   1               ;SAVED PC LAST BREAKPOINT

;
; THE FOLLOWING ITEMS MUST BE KEPT FROM COMMAND TO COMMAND.
;

T:      .BYTE   0               ;T BIT IN USE FLAG
P:      .BYTE   -1              ;PROCEED ALLOW FLAG
S:      .BYTE   0               ;SINGLE INSTRUCTION MODE, 0=NORMAL, >0=ENABLE
FM:     .BYTE   2               ;OUTPUT FORMAT MODE, BYTE, WORD, ANSII, RAD50
OBW:    .BYTE   2               ;OPEN CELL TYPE, 1=BYTE, 2=WORD
SEQ:    .BYTE   0               ;CHANGE SEQUENCE INDICATIOR

;
; THE BELOW LOCATION IS USED IN BREAKPOINT PROCESSING
;

TRTC:   BPT             ;TRACE TRAP PROTOTYPE

;
; ALL XDT TYPE ERRORS JUST GO TO "ERR" OR SOMEWHERE ELSE
;

SSTXDT:  +      ERR             ;0-ODD ADDRESS
         +      ERR             ;1-SEGMENT FAULT
         +      ERR             ;2-BPT OR T-BIT ("MCR" CALL)
         +      DCD             ;3-IOT ("DECODE")
         +      ERR             ;4-RESERVED OR ILLEGAL INSTRUCTION
         +      ERR             ;5-EMT ("ERROR")
         +      TYPE            ;6-TRAP
                                                                                ;**-1
;
; SST VECTOR ADDRESS TABLE
;

SSTADR: .WORD   4               ;ODD ADDRESS
        .WORD   250             ;SEGMENT FAULT
        .WORD   14              ;BPT
        .WORD   20              ;IOT
        .WORD   10              ;ILLEGAL INSTRUCTION
        .WORD   30              ;EMT
        .WORD   34              ;TRAP
                                                                                ;**-1
;
; INTERNAL REGISTER NAME AND CONTROL TABLES
;
; NON-INDEXED REGISTER NAMES
;

NIXMAP: .ASCII  /01234567/      ;USER REGISTER NAMES FOR MAPPING

NIXREG: .BYTE   'S              ;UST    USER STATUS
        .BYTE   'A              ;ARG    ARGUMENT
        .BYTE   'L              ;LOW    LOW SCAN LIMIT
        .BYTE   'H              ;HI     HIGH SCAN LIMIT
        .BYTE   'C              ;CNST   CONSTANT
        .BYTE   'Q              ;QUAN   QUANTITY
        .BYTE   'F              ;FORM   FORMAT CONTROL
        .BYTE   0               ;END OF THIS LIST

;
; INDEXED REGISTER NAMES
;

INXREG: .BYTE   'B              ;ADR1   BKPT ADDRESSES
        .BYTE   'G              ;CT     BKPT PROCEED COUNTS
        .BYTE   'I              ;UIN    BKPT USER INSTRUCTIONS
        .BYTE   'R              ;RELT   RELOCATION REGISTERS
        .BYTE   0               ;END OF THIS LIST

;
; INDEXED REGISTER TABLE BASES
;

        .EVEN
INXTBL: .WORD   ADR1            ;BKPT ADDRESS TABLE
        .WORD   CT              ;BKPT PROCEED COUNTS
        .WORD   UIN             ;BKPT'D INSTRUCTION
        .WORD   RELT            ;RELOCATION TABLES
        .WORD   INTEND+2        ;END OF TABLE AREA FOR ADDRESS MAPPING

;
; CHARACTER CONVERSION LISTS.
;

ALTTAB: .BYTE   033,175,176     ;ALTERNATE ALT-MODE FORMS
        .BYTE   0               ;END OF THIS LIST TOO

;
; COMMAND NAME AND DISPATCH TABLES
;

COMTAB:         ;ADDRESS OF THE CHARACTER TABLE

;
; OPEN REGISTER COMMANDS (ORDER AND POSITION CRITICAL)
;

        .BYTE   '\,'/,'','",'%

;
; CLOSE REGISTER COMMANDS
;

        .BYTE   015,012,'^,'_,'@,'>,'<

;
; SPECIAL FORMS
;

        .BYTE   '$,'=,'C,'Q,'.

;
; OPERATORS (ORDER OF -+* IS CRITCAL)
;

        .BYTE   ';,'-,'+,'*,',

;
; COMMANDS
;

        .ASCII  /BGKLOPRSX/
        .BYTE   0               ;******* END OF THE LIST *******
        .EVEN

;
; THE DISPATCH TABLE, ORDERED ON ABOVE TABLE
;
; OPEN REGISTER COMMANDS
;

COMDIS: .WORD   OCBYTE          ;\      OPEN OCTAL BYTE
        .WORD   OCWORD          ;/      OPEN OCTAL WORD
        .WORD   ANBYTE          ;'      OPEN ANSII BYTE
        .WORD   ANWORD          ;"      OPEN ANSII WORD
        .WORD   MODULO          ;%      OPEN RADIX 50 WORD

;
; CLOSE REGISTER COMMANDS
;

        .WORD   CLCRET          ;<CR>   CLOSE, NO SUCESSIVE OPEN
        .WORD   CLLNFD          ;<LF>   CLOSE, OPEN NEXT
        .WORD   CLUPAR          ;^      CLOSE, OPEN PREVIOUS
        .WORD   CLBACK          ;_      CLOSE, OPEN PC RELATIVE MODE
        .WORD   CLATSG          ;@      CLOSE, OPEN INDIRECT
        .WORD   CLGRTH          ;>      CLOSE, OPEN PC OFFSET AS BRANCH
        .WORD   CLLSTH          ;<      CLOSE, OPEN OLD SEQUENCE

;
; SPECIAL FORMS
;

        .WORD   REGT            ;$      INTERNAL REGISTER REFERENCE
        .WORD   EQUALS          ;=      PRINT LEFT SIDE IN OCTAL
        .WORD   CHRCEE          ;C      CONSTANT REGISTER CONTENTS
        .WORD   CHRQUE          ;Q      QUANTITY REGISTER CONTENTS
        .WORD   CHRDOT          ;.      LAST OPENED LOCATION'S ADDRESS

;
; OPERATORS
;

        .WORD   SEMI            ;;      MULTIPLE ARGUMENT DELIMITER
        .WORD   MINS            ;-      SUBTRACTION
        .WORD   PLUS            ;+      .WORD   ADDITION
        .WORD   STAR            ;*      MULTIPLY BY 50
        .WORD   COMM            ;,      RELOCATION COMPUTE

;
; COMMANDS
;

        .WORD   SEBK            ;B      SET / CLEAR BREAKPOINTS
        .WORD   GOTO            ;G      GO TO USER'S DATA
        .WORD   KILO            ;K      KOMPUTE AND TYPE RELOCATION DATA
        .WORD   LIST            ;L      LIST MEMORY ON SPECIFIED DEVICE
        .WORD   OFST            ;O      TYPE PC RELATIVE OFFSETS
        .WORD   PROC            ;P      PROCEED FROM BREAKPOINT
        .WORD   RELO            ;R      SET / RESET RELOCATION REGISTERS
        .WORD   SNGL            ;S      SET / RESET SINGLE STEP MODE
        .WORD   EXIT            ;X      EXIT TO CRASH ROUTINE

;+
; **-$XDT-RSX-11M EXECUTIVE ODT
;-

        .ENABL  LSB
$XDT::  MTPS    #PR7            ;LOCK OUT INTERRUPTS
        MOV     SP,USP          ;SAVE ENTRY STACK POINTER
        MOV     #USP,SP         ;SET NEW STACK POINTER ADDRESS
        MOV     R5,-(SP)        ;SAVE REGISTERS R5 THRU R0
        MOV     R4,-(SP)        ;
        MOV     R3,-(SP)        ;
        MOV     R2,-(SP)        ;
        MOV     R1,-(SP)        ;
        MOV     R0,-(SP)        ;
        MOV     PC,SP           ;CHANGE STACK POINTER
        MOV     #SSTADR,R0      ;POINT TO TRAP VECTOR ADDRESS TABLE
        MOV     #SSTXDT,R1      ;POINT TO XDT TRAP VECTOR TABLE
10$:    MOV     (R1)+,@(R0)+    ;INSERT XDT TRAP VECTOR ADDRESSES
        CMP     R1,#SSTADR      ;ANY MORE TO SET?
        BLO     10$             ;IF LO YES
        MOV     PC,SP           ;LENGTHEN STACK
        TYPE    CRLF            ;PLACE TERMINAL CARRIAGE IN PROPER POSITION
        TYPE    'X              ;OUTPUT XDT IDENTIFICATION
        TYPE    'D              ;
        TYPE    'T              ;
        TYPE    ':              ;
        TYPE    40              ;
        MOV     $SYSID,R0       ;GET SYSTEM IDENTIFICATION
        TYPE    R0+R0           ;OUTPUT SYSTEM IDENTIFICATION
        TYPE    CRLF            ;PLACE TERMINAL CARRIAGE IN PROPER POSITION
        JSR     SP,DCD          ;DECODE NEXT COMMAND
XDTSTK:                         ;REF LABEL - START OF XDT STACK
        .DSABL  LSB

        .SBTTL  COMMAND PROCESSORS, SECTION ONE ( $ B R K A Q . )

.SBTTL "$,<ALT-MODE>" PROCESSOR - INTERNAL REGISTER MAPPER

;SYNTAX--
;$L             DELIVER INTERNAL ADDRESS OF L
;$NL            DELIVER INTERNAL ADDRESS OF L+2N
;$N             DELIVER INTERNAL ADDRESS OF USER REGISTER N

;SEE MAPPING TABLES, RANGE OF N IS 0-7

REGT:   JSR     PC,GETNUM       ;GET AN OCTAL NUMBER
        JSR     PC,RTST         ;CHECK FOR ERROR
        BCS     ERR0            ;MPY R4 X 2
        TST     R2              ;SEE IF ANYTHING TYPED
        BNE     10$             ;IF SO IS INDEXED OR USER REGISTER
        JSR     R5,LOOKUP       ;SEE IF NON-INDEXED
         +      NIXREG
        BCS     12$             ;NON-INDEXED TURNS INTO A COMMAND
        MOV     R1,R4           ;PLACE IN LIST IS INTERNAL ORDER
        ADD     #UST,R4         ;GET ADDRESS IN R4, GOTTA READ CHAR
        BR      20$
10$:    JSR     R5,LOOKUP       ;SEE IF INDEXED
         +      INXREG
        BCC     15$             ;WAS TRULY INDEXED
12$:    CMP     #7+7,R4         ;INTERNAL USER REGISTER RANGE CHECK
        BLO     ERR0
        ADD     #UR0,R4         ;SET ACCESS TO R0-R7 OF THE USER
        BR      25$             ;AVOID READING OF COMMAND
15$:    ADD     INXTBL(R1),R4   ;COMPUTE ADDRESS TO INDEXED TABLE
20$:    JSR     PC,GET          ;GET THE ASSUMED TERMINATOR
25$:    INC     R2              ;SHOW THEM THAT R4 GOT VALID DATA
        JMP     CLGL            ;RE-USE CHARACTER, R2 IS NON-ZERO

.SBTTL "B" PROCESSOR - SET AND REMOVE BREAKPOINTS

;SYNTAX--
;B                      CLEAR ALL BREAKPOINTS
;NB                     CLEAR BKPT N
;A;B                    SET BKPT AT A, USE FIRST FREE  BKPT
;A;NB                   SET BKPT N AT A

;DEPENDS MIGHTILY UPON LOCATION "TRTC" CONTAINING A TRAP INST.
;AND THAT A FREE BKPT CONTAINS THE ADDRESS "TRTC".

SEBK:   ASL     R4              ;MPY R4 X2, JUST IN CASE ALL IS GO
        MOV     #TRTC,R0        ;SET MAGIC VALUE IN R0, JUST IN CASE
        TST     R3              ;CHECK FOR THE REAL CASE
        BEQ     REMB            ;REMOVAL CASES, CLEAR THEM UP
        BIT     #1,R5           ;LOOK AT ADDRESS
        BNE     ERR             ;THAT'S ODD ?
        TST     R2              ;SEE IF I GET TO PICK IT OR NOT
        BNE     15$             ;OR NOT, DISAPPOINTMENT
10$:    CMP     R0,ADR1(R4)     ;LOOK FOR LOCATION WITH FREE ADDRESS
        BEQ     15$             ;A HIT
        TST     (R4)+           ;KEEP AT FOR A LONG WHILE
        BR      10$             ;LOOOOOOOOP
15$:    MOV     R5,R0           ;R0 HAS ADDRESS OF BREAKPOINT
        BR      RE02            ;GO TUCK IT IN

;REMOVE SOME BREAKPOINTS

REMB:   TST     R2              ;SEE IF ONE OR ALL
        BEQ     RALL            ;ALL
RE02:   JSR     PC,SETBRK       ;SET THE ONE SET UP TO SET
        BCC     DCD             ;IT HAPPENED
ERR0:   ERROR                   ;SOME THING WENT WRONG

;
; REMOVE ALL BREAKPOINTS
;

RALL:   CLR     R4              ;R4 IS ZERO
10$:    JSR     PC,SETBRK       ;SET THEM TILL
        BCC     10$             ;THEY GET OUTTA
        DECODE                  ;HAND!!!!

;
; SUBROUTINE TO SET/CLEAR BREAKPOINTS
;

SETBRK: CMP     #BKP,R4         ;LEGAL BREAKPOINT NUMBER?
        BLO     10$             ;IF LO NO
        MOV     R0,ADR1(R4)     ;SET BREAKPOINT ADDRESS
        MOV     (R0),UIN(R4)    ;SAVE CONTENTS OF BREAKPOINT LOCATION
        MOV     #1,CT(R4)       ;SET INITIAL PROCEED COUNT
        TST     (R4)+           ;ADVANCE BREAKPOINT NUMBER
10$:    RETURN                  ;

.SBTTL "R" PROCESSOR - RELOCATION REGISTER PROCESSING

;DETERMINE IF CLEAR OR SET

RELO:   TSTB    SMFD            ;SEMI-COLON ABSENT MEANS CLEAR
        BEQ     10$             ;CLEAR DISPATCH, OR FALL TO SETTING

;FORMS HERE--
; A;NR                  SET RELOC(N) TO A
;ABSENT A OR N DEFAULTS TO 0

        JSR     PC,RTST         ;PROTECTION EDITING
        BCS     ERR             ;ILLEGAL REGISTER NUMBER ?
        MOV     R5,RELT(R4)     ;SET THE APPROPRIATE REGISTER
        DECODE                  ;GO GET NEXT COMMAND

;FORMS HERE--
;R                      RESET ALL TO -1 FOR RELOC(0-7)
;NR                     RESET ONLY RELOC(N)

10$:    TST     R2              ;SEE IF NR OR JUST R
        BEQ     15$             ;CLEAR ALL
        JSR     PC,RUCL         ;CLEAR THE ONE IN R4
        BCS     ERR             ;ERROR, INVALID REGISTER ?
        DECODE                  ;NEXT COMMAND
15$:    JSR     PC,RUAL         ;DO THEM ALL
        DECODE                  ;OFF AND ON

;
; SUBROUTINE TO RESET RELOCATION BASE REGISTER
;

        .ENABL  LSB
RUCL:   CALL    RTST            ;TEST FOR LEGAL REGISTER
        BCS     10$             ;IF CS ILLEGAL REGISTER
        MOV     #-1,RELT(R4)    ;RESET RELOCATION REGISTER
        ASR     R4              ;CONVERT BACK TO REGISTER NUMBER
10$:    RETURN                  ;

;
; SUBROUTINE TO CLEAR ALL RELOCATION REGISTERS
;

RUAL:   CLR     R4              ;START WITH REGISTER 0
20$:    CALL    RUCL            ;CLEAR NEXT RELOCATION REGISTER
        BCS     10$             ;IF CS ALL DONE
        INC     R4              ;ADVANCE TO NEXT REGISTER
        BR      20$             ;
        .DSABL  LSB

.SBTTL "K" PROCESSOR - COMPUTE AND PRINT RELOCATION

;SYNTAX--
;AK                             TYPE RELOCATION DEAL FROM DOT TO A
;L;AK                           TYPE RELOCATION DEAL FROM L TO A

;IF A IS NULL THE THE OLD BEST FIT RULE APPLIES
;TYPES  =N,DDDDDD       WHERE N IS THE RELOCATION REGISTER
;                               AND D-D IS THE RELOCATION BIAS

KILO:   TST     R2              ;SEE WHO PICKS THE REGISTER
        BNE     10$
        TST     R3              ; ADDRESS SPECIFIED?
        BNE     5$              ; YES
        MOV     CAD,R4          ; NO, GET CURRENT ADDRESS
        BR      7$              ;
5$:     MOV     R5,R4           ; GET ADDRESS SPECIFIED ON COMMAND
7$:     JSR     PC,LOCA         ; GET CLOSEST RELOCATION REGISTER
        MOV     R0,R4           ;DID WE FIND A RELOCATION REGISTER?
        BMI     ERR             ;CAN'T FIND ONE THATS GOOD
10$:    BIC     #177770,R4      ;EDIT REGISTER
        TYPE    '=              ;OUTPUT CUE
        TYPE    40              ;
        MOVB    R4,R0           ;TYPE REGISTER & A ,
        ADD     #"0,,R0
        TYPE    R0+R0           ;
        ASL     R4              ;GO GET IT AS TABLE INDEX
        TST     R3              ;SEE WHO TYPED THE ADDRESS
        BNE     15$
        MOV     CAD,R5          ;THAT CAD!
15$:    SUB     RELT(R4),R5
        MOV     R5,R0           ;BIAS COMPUTE
        JSR     PC,CADW         ;PRINT AS WORD
        DECODE

.SBTTL "A-Q-." PROCESSORS - SPECIAL VALUES

;MERELY SUBSTITUTE THE VALUE IN R4 WITH THE CONTENTS OF THE SPECIFIED
;REGISTER.

CHRQUE: MOV     QUAN,R4         ;LAST QUANTITY PRINTED
        BR      CHR001
CHRCEE: MOV     CNST,R4         ;CONSTANT REGISTER
        BR      CHR001
CHRDOT: MOV     CAD,R4          ;CURRENT LOCATION
CHR001: INC     R2              ;ALLOW AS R4 IS REAL
        JSR     PC,GET          ;GET NEXT CHARACTER AND ASSUME
        BR      CLGL            ;IT IS A TERMINATOR

        .SBTTL  COMMAND DE-CODER AND MAIN LOOP OF ODT

; COMMAND DECODER - ODT

;  ALL REGISTERS MAY BE USED (R0-R5),

;ERROR ENTRY, TYPE FLAG AND GO DO COMMAND

ERR:    CALL    SETCN           ;SET OUTPUT FOR CONSOLE
        TYPE    '?              ;OUTPUT ERROR INDICATION

;
; DECODE FROM THE TOP, CLOSE ALL AND DO CR/LF/_
;

DCD:    MOV     #XDTSTK,SP      ;SET THE STACK FOR SANITY
        CALL    SETCN           ;SET OUTPUT FOR CONSOLE
        TYPE    CRLF            ;PLACE TERMINAL CARRIAGE IN PROPER POSITION
        CLR     OPN             ;SET NO LOCATION OPEN
        TYPE    'X              ;OUTPUT INPUT SOLICITATION
        TYPE    'D              ;
        TYPE    'T              ;
        TYPE    76              ;'>'

;MAINTAIN OPENED LOCATION, RE-INIT INPUT

NEWC:   CLRB    SMFD            ;CLEAR SEMI-COLON FLAG/COUNT
        CLR     R3              ;ZERO SECONDARY ARGUMENT FLAG
        CLR     R5              ;AND ARGUMENT

;NEW SUB-EXPRESSION ENTRY

NEWE:   CLRB    OP              ;CLEAR OPERATOR FOUND
        CLR     EXP             ;SET ZERO IN EXPRESSION SO FAR LOCATION

;GET NUMBER AND THEN SCAN FOR COMMAND

NEWN:   JSR     PC,GETNUM       ;GET AN OCTAL NUMBER AND TERMINATOR

;NON-OCTAL CHAR TYPED WHAT ARE WE TO DO?

CLGL:   JSR     R5,LOOKUP       ;GO SEE IF IT IS REAL
         +      COMTAB          ;THIS DEFINES REAL
        BCS     ERR             ;EASY ENOUGH IF NOT REAL
        TST     R2              ;IF NOTHING TYPE BOTHER NOT
        BEQ     CL01            ;WITH THE EXPRESSION
        JSR     PC,EXPCOM       ;COMPUTE EXPRESSION
CL01:   JMP     @COMDIS(R1)     ;GO TO PROPER ROUTINE

;FOR THE BENEFIT ALL REGISTERS ARE AS FOLLOWS

;R0     LAST CHARACTER TYPED, THE COMMAND ITSELF!
;R1     TABLE INDEX TO COMMAND ADDRESSES, IT IS USED.
;R2,R4  FIRST ARGUMENT, IF R2<>0 THEN R4 IS DATA
;R3,R5  SECOND ARGUMENT, IF R3<>0 THEN R5 IS DATA

;
; SET OUTPUT DEVICE TO CONSOLE TERMINAL
;

SETCN:  MOV     #TPB,OUTB       ;SET OUTPUT BUFFER ADDRESS
        MOV     #TPS,OUTS       ;SET OUTPUT STATUS ADDRESS
        RETURN                  ;

        .SBTTL  EXPRESSION SETUP COMMANDS ( ; + - * , )

;SEMI-COLON PROCESSOR

SEMI:   INCB    SMFD            ;COUNT SEMI-COLON
        CMPB    #2,SMFD         ;PUSH CONTENTS INTO MULTI
        BNE     SEM1            ;SEMI COLON ARG LIST
        MOV     R5,D.ARGS
SEM1:   MOV     R2,R3           ;PUSH R2 AND R4 INTO
        MOV     R4,R5           ;R3 AND R5 (FLAG AND CONTENTS)
        BR      NEWE            ;CONTINUE SCANNER

;ADDITION SETUP

PLUS:   CLRB    OP              ;OP IS 0 FOR +
        BR      CO00

;SUBTRACT SET UP

MINS:   MOVB    #2,OP
        BR      CO00

;MULTIPLY BY 50 AND ADD

STAR:   MOVB    #-2,OP          ;OP IS -2 FOR *
CO00:   CLR     R4              ;R4 IS RESET
        BR      NEWN

;MEMORY RELOCATION CHECK

COMM:   ASL     R4              ;ALL NEED IT X 2
        CMP     R4,#RLR         ;SEE IF REGISTER IS OUT OF RANGE
        BGT     ERR
        MOV     RELT(R4),EXP    ;COMPUTE REAL CORE ADDRESS
        BR      PLUS

        .SBTTL  OPEN AND CLOSE PROCESSORS

.SBTTL "\-/-'-"-%-:" PROCESSOR - OPEN AND TYPE CONTENT COMMANDS

;SYNTAX--
;NC                             OPEN LOC N IN MODE C, SET MODE FOR NEXT
;C                              TYPE LAST OPENED LOC IN MODE C

OCWORD:         ;OCTAL WORD -           R1=2
ANWORD:         ;ANSII WORD -           R1=6
MODULO:         ;RADIX 50 WORD -        R1=10

;OPEN WORD MODE ENTRY, R1 CONTAINS FORMAT INDEX

        MOV     #2,R0           ;SET BYTE FLAG TO WORD FLAG
        BR      OPE004          ;GO TO IT ACE HOLE

OCBYTE:         ;OCTAL BYTE -           R1=0
ANBYTE:         ;ANSII BYTE -           R1=4

OPE001: MOV     #1,R0           ;SET WORD FLAG TO BYTE FLAG

OPE004: TST     R2              ;IF NO VALUE TYPED NO MODE SET
        BEQ     10$
        MOV     R0,BW           ;SET MODE AND FORMAT FLAGS
        MOVB    R0,OBW          ;SET THE LATER USE MODE
        MOVB    R1,FM           ;SET THE MODE FLAG FOR SOOTH
        MOV     R4,CAD          ;SET ADDRESS FOR EXPLICIT OPEN
        MOV     R4,DOT          ;RESET RETURN PTR.
10$:    CMP     #1,R0           ;CHECK ON BYTE MODE
        BEQ     15$             ;NOT BYTE MODE
        BIT     #1,CAD          ;SEE IF ADDRESS IS ODD
        BEQ     15$             ;ALL IS GOOD
        CLR     R1              ;THEY GET BYTE MODE ONLY
        BR      OPE001
15$:    MOV     R1,-(SP)        ;SAVE FORMAT MAINLY
        JSR     PC,GETCAD       ;GET THE DATA
        MOV     (SP)+,R1        ;GET FORMAT
        JSR     PC,@TYFORM(R1)  ;PRINT DATA IN PROPER FORMAT
        BR      NEWC            ;GO GETTA NEW COMMAND TO DO

.SBTTL "<CR>-<LF>->-<-^-_-@" PROCESSOR - CLOSE AND OPEN REGISTERS

;CARRIAGE RETURN

CLCRET: JSR     PC,PUTCAD       ;CLOSE LOCATION
        BR      DCD             ;RETURN TO DECODER

;LESS THAN, BACK TO MAIN STREAM

CLLSTH: INCB    SEQ             ;SET FLAG TO LATER RESTORE CAD

;LINE FEED, NEXT ONE DOWN

CLLNFD: JSR     PC,PUTCAD       ;CLOSE PRESENT CELL
        TSTB    SEQ             ;SHOULD CAD BE RESTORED?
        BEQ     OP5             ;BRANCH IF NOT
        MOV     DOT,CAD         ;RESTORE PREVIOUS SEQUENCE
        CLRB    SEQ             ;RESET FLAG; NO LONGER NEEDED
        BR      OP2A            ;
OP5:    ADD     BW,CAD          ;GENERATE NEW ADDRESS
OP2:    MOV     CAD,DOT         ;INITIALIZE DOT
OP2A:   TYPE    CRLF            ;PLACE CARRIAGE IN PROPER POSITION
        MOV     CAD,R0          ;NUMBER TO TYPE
        JSR     PC,RORA         ; CHECK FORMAT
        MOVB    FM,R0           ;SET FORMAT
        ASR     R0              ;SPLIT R0 IN HALF
        MOVB    COMTAB(R0),R0   ;SET SUFFIX CHARACTER
        TYPE    R0              ;PRINT CHARACTER
        MOV     CAD,R4          ;SET UP THE DATA
        CLR     R2              ; SET TO USE CAD ADDRESS
        CLRB    OP              ;THIS IS BECUZE
        CLR     EXP
        JMP     CLGL            ;R0 HAS TERMIN, R4- DATA, R2= FLAG

;UP ARROW, NEXT ONE UP

CLUPAR: JSR     PC,PUTCAD
        SUB     BW,CAD          ;GENERATE NEW ADDRESS
        BR      OP2             ;GO DO THE REST

;BACK ARROW, PC RELATIVE COMPUTE

CLBACK: JSR     PC,TCLS         ;TEST WORD MODE AND CLOSE
        ADD     @R2,R2          ;COMPUTE
        CMPB    (R2)+,(R2)+     ;NEW ADDRESS
PCS:    MOV     R2,CAD          ;UPDATE CAD
        BR      OP2A            ;GO FINISH UP

;AT SIGN, ABSOLUTE OR INDIRECT CHAIN

CLATSG: JSR     PC,TCLS         ;TEST WORD MODE AND CLOSE
        MOV     @R2,R2          ;GET ABSOLUTE ADDRESS
        BR      PCS

;GREATER THAN, PC OFFSET BRANCH ADDRESS

CLGRTH: JSR     PC,TCLS         ;TEST AND CLOSE
        MOVB    @R2,R1          ;COMPUTE NEW ADDRESS, EXTEND SIGN
        ASL     R1              ;R2=2@R2)
        ADD     #2,R1           ;+2
        ADD     R1,R2           ;   +PC
        BR      PCS

;HANDY DANDY TO DO SOME LEG WORK

TCLS:   JSR     PC,PUTCAD       ;CLOSE CURRENT CELL
        CMP     #2,BW           ;ONLY WORD MODE ALLOWED
        BNE     ERR1            ;BRANCH IF ERROR
        MOV     CAD,R2          ;CURRENT ADDRESS IN R2
        RTS     PC

        .SBTTL  COMMAND PROCESSORS, SECTION TWO ( O = G S P )

.SBTTL "O" PROCESSOR - COMPUTE AND PRINT OFFSETS

;SYNTAX--
;AO                             TYPE OFFSETS FROM . TO A
;L;AO                           TYPE OFFSETS FROM L TO A

;TYPES  _PPPPPP >DDDDDD                 WHERE P-P IS PC RELATIVE
;                                       AND D-D IS BRANCH OFFSET

OFST:   TST     R3              ;HOW ABOUT A VALUE OTHER
        BNE     10$             ;THAN CAD
        MOV     CAD,R5          ;RELUCTANTLY
10$:    SUB     R5,R4
        SUB     #2,R4           ;NO TRICKS, ODD AND NON-EXIST THINGS
        TYPE    '_              ;TYPE PC RELATIVE CUE
        TYPE    40              ;
        MOV     R4,R0
        MOV     R4,-(SP)        ;GOOD IDEA TO SAVE THIS
        JSR     PC,CADW         ;TYPE VALUE + BLANK
        TYPE    76              ;TYPE OFFSET BRANCH CUE
        MOV     (SP)+,R0
        ASR     R0              ;DIVIDE
OF09:   JSR     PC,CADW         ;16 BITS SO YOU CAN SEE HOW FAR OFF
        JMP     DCD             ; GET NEXT COMMAND

.SBTTL "=" PROCESSOR - PRINT LEFT SIDE EXPRESSION ON RIGHT SIDE

EQUALS: MOV     R4,R0           ;PROPER PRIOR PLANNING PREVENTS
        BR      OF09            ;POOR PERFORMANCE

;JUST ANOTHER ERROR CALL

ERR1:   ERROR

.SBTTL  SST INTERRUPT VECTOR ENTRY POINTS


        .IF DF  M$$MGE

;
; SEGMENT FAULT                 - V1 - "MP" - NO PROCEED
;

SGMT:   TESTM   $SGFLT          ;TEST IF IN EXEC MODE
        BIC     #160000,SR0     ;UNFREEZE SEGMENT UNIT
        MOV     #"MP,EXP        ;ENTRY PREFIX
        BR      NIXP            ;

        .ENDC


;
; STACK OVERFLOW                -    - "SO" - NO PROCEED
; ODD ADDRESS                   - V0 - "OD" - NO PROCEED
; BPT                           - V2 - "BE" - SPECIAL CASES
; T-BIT                         - V2 - "TE" - PROCEED
; IOT                           - V3 - "IO" - PROCEED
; RESERVED OR ILLEGAL           - V4 - "IL" - NO PROCEED
;

ODDA:   MOV     #"SO,EXP        ;ASSUME STACK OVERFLOW
        CMP     SP,#V$$CTR+4    ;STACK OVERFLOW?
        BLO     NIXP            ;IF LO YES
        TESTM   $TRP04          ;TEST IF IN EXEC MODE
        MOV     #"OD,EXP        ;"OD:" FOR ODD ONE
        BR      NIXP            ;NIX ON PROCEED
BPTI:   TESTM   $TRACE          ;TEST IF IN EXEC MODE
        MOV     #"BE,EXP        ;"BE:" FOR MAYBE A BAD ENTRY
        CLRB    P               ;ALLOW PROCEED DEAL
        BR      INTR            ;SPECIAL NUMBER FOR THIS ONE
IOTX:   TESTM   $IOTRP          ;TEST IF IN EXEC MODE
        MOV     #"IO,EXP        ;"IO:" FOR IOTEE
        BR      ALOP            ;ALLOW PROCEED
ILLI:   TESTM   $ILINS          ;TEST IF IN EXEC MODE
        MOV     #"IL,EXP        ;"IL:" FOR ILL INSTRUCTION
NIXP:   MOVB    #-1,P           ;NO PROCEED
        BR      INTR            ;

;
; EMT                           - V5 - "EM" - PROCEED
; TRAP                          - V6 - "TR" - NO PROCEED
;

NEMT:   TESTM   $EMTRP          ;TEST IF IN EXEC MODE
        MOV     #"EM,EXP        ;"EM:" FOR EMTEE
                                                                                ;**-13

ALOP:   MOVB    #BKP+2,P        ;ALLOW PROCEED

;
; COMMON INTERRUPT SERVICE AND DISPATCHER
;

INTR:   BIT     #TBT,2(SP)      ;T-BIT SET IN STACKED PS WORD?
        BEQ     1$              ;IF EQ NO
        CMP     PPC,(SP)        ;PC CHANGE FROM LAST TRAP?
        BNE     1$              ;IF NE YES
        JMP     RTN             ;RTT MUST HAVE BEEN CHANGED TO AN RTI
1$:     MOV     (SP)+,UPC       ;SET THE USER PC VALUE
        MOV     (SP)+,UST       ;AND HIS ENTRY STATUS
        MOV     R0,UR0          ;SAVE EXEC REGISTERS
        MOV     #UR0+2,R0       ;POINT TO REGISTER SAVE AREA
        MOV     R1,(R0)+        ;SAVE REGISTERS R1 THRU SP
        MOV     R2,(R0)+        ;
        MOV     R3,(R0)+        ;
        MOV     R4,(R0)+        ;
        MOV     R5,(R0)+        ;
        MOV     SP,(R0)+        ;
        MOV     #XDTSTK,SP      ;SET XDT STACK POINTER
        MOV     #SSTADR,R0      ;POINT TO TRAP VECTOR ADDRESS TABLE
        MOV     #SSTXDT,R1      ;POINT TO XDT TRAP VECTOR TABLE
5$:     MOV     (R1)+,@(R0)+    ;SET XDT TRAP VECTOR ADDRESSES
        CMP     R1,#SSTADR      ;ANY MORE TO SET?
        BLO     5$              ;IF LO YES

;TRY AND FIND OUT WHAT TO DO

        TSTB    P               ;SEE IF CONTROLLED BREAKPOINT
        BNE     10$             ;NOT DUE TO A PLANNED INTERRUPT
        TSTB    T               ;IS A BPT OR T-BIT, SEE IF A PROCEED
        BNE     TBIT            ;COMMAND IS BEING DONE, GO FINISH IT
        TSTB    S               ;NO REMOVAL OF BREAKS ON S.I. MODE
        BNE     12$             ;SKIP NEXT TWO WORDS

;
; REMOVE EXEC BREAKPOINTS
;

10$:    MOV     #ADR1,R4        ;POINT TO BREAKPOINT VECTOR
11$:    MOV     UIN-ADR1(R4),@(R4)+ ;REINSERT CORRECT CONTENTS
        CMP     #ADR1+BKP,R4    ;ANY LEFT TO RESTORE?
        BHIS    11$             ;IF HIS YES
12$:    MOV     UPC,R5          ;GET A COPY OF THE PC AT INTERRUPT
        TSTB    P               ;BREAKPOINT OR T-BIT CHECK
        BNE     30$             ;DEFINITELY NOT A BREAKPOINT
        MOVB    S,R4            ;SEE IF SINGLE STEPPING
        BNE     22$             ;AND PRETEND

;AT THIS POINT IT MAY BE DUE TO T-BIT OR A BPT

        MOVB    #BKP+2,P        ;SET ALLOW TO THE 8'TH ONE
        CMP     -(R5),TRTC      ;BACK-UP R5 AND SEE WHAT'S UP
        BEQ     30$             ;IT WAS A NON-BREAK BPT
        MOV     #BKP,R4         ;SET ADDRESS OF LEGIT BREAKS
15$:    CMP     R5,ADR1(R4)     ;LOOK IT UP IN THE TABLE
        BEQ     20$             ;FOUND THE NASTY LITTLE BUGGER
        SUB     #2,R4           ;KEEP AT IT
        BGE     15$             ;UNLESS NO MORE
        MOV     #"TE,R4         ;NOT THERE, MUST BE T-BIT ERROR
        TST     (R5)+           ;RESET PC TO MAKE IT RIGHT
        BR      26$             ;LABOR
20$:    MOV     R5,UPC          ;BACK-UP PC FOR BREAKPOINT
22$:    MOVB    R4,P            ;BREAKPOINT IS A REAL ONE
        DEC     CT(R4)          ;CHECK OUT THE PROCEED COUNT
        BNE     C990            ;LABOR ON A MIS-CONCEPTION
        INC     CT(R4)          ;RESET PROCEED COUNT
        ASR     R4              ;OCTAL TO UN-BIASED ASCII
        ADD     #"0B,R4         ;BIAS TO ASCII
26$:    MOV     R4,EXP          ;SET THE PREFIX UP

;COMMON TYPE ROUTINE FOR SST VECTORS USED UP

30$:    TYPE    CRLF            ;PLACE CARRIAGE IN PROPER POSITION
        MOV     EXP,R0          ;THE PREFIX
        TYPE    R0+R0           ;
        TYPE    ':              ;
        MOV     R5,R0           ;TYPE ADDRESS OF INTERRUPT
        JSR     PC,RORA         ;AND THE REST OF THE ENTRY
        DECODE

;
; TRAPS ARE ALWAYS HANDLED BY EXEC
;

TRPI:   JMP     $TRTRP          ;

;
; "G" PROCESSOR - GO TO PROGRAM
;SYNTAX--
;LG                     START PROGRAM AT LOCATION L
;G                      START PROGRAM AT CURRENT PC

GOTO:   TST     R2              ;SEE IF SPECIFIC ADDRESS
        BEQ     10$             ;NO
        MOV     R4,UPC          ;SET THE PC
10$:    CLRB    S               ;NO SINGLE INSTRUCTIONS
TBIT:   CLRB    T               ;CLEAR T-BIT FLAGS
        BIS     #TBT,UST        ;BOTH
        TSTB    S               ;SEE IF WE NEED A T-BIT BIT
        BNE     GRTT            ;NO GO ON
        BIC     #TBT,UST        ;SET THE TEE BIT

;
; SET EXEC BREAKPOINTS
;

10$:    MOV     #ADR1,R4        ;POINT TO BREAKPOINT VECTOR
20$:    MOV     @(R4),UIN-ADR1(R4) ;SAVE CONTENTS OF LOCATION
        MOV     TRTC,@(R4)+     ;SET BREAKPOINT
        CMP     #ADR1+BKP,R4    ;ANY MORE TO INSERT?
        BHIS    20$             ;IF HIS YES
GRTT:   MOV     #PR7,-(SP)      ;SET RTT PS WORD
        MOV     #20$,-(SP)      ;SET RTT PC WORD
        MOV     #10$,@#10       ;PLUG ILLEGAL INSTRUCTION TRAP
        MOV     (PC),R0         ;GET RTT INSTRUCTION CODE
        RTT                     ;EXECUTE RTT INSTRUCTION
10$:    ADD     #4,SP           ;CLEAN STACK
        MOV     (PC)+,R0        ;GET RTI INSTRUCTION CODE
        RTI                     ;
20$:    MOV     R0,RTN          ;SET PROPER RETURN INSTRUCTION
        MOV     #SSTADR,R0      ;POINT TO TRAP VECTOR ADDRESS TABLE
        MOV     #SSTVEC,R1      ;POINT TO EXEC TRAP VECTOR TABLE
30$:    MOV     (R1)+,@(R0)+    ;SET EXEC TRAP VECTORS
        CMP     R0,#SSTADR+<SSTADR-SSTXDT> ;ANY MORE TO SET?
        BLO     30$             ;IF LO YES
        MOV     #UR0+2,R0       ;POINT TO SAVED R1
        MOV     (R0)+,R1        ;RESTORE REGISTERS R1 THRU SP THEN R0
        MOV     (R0)+,R2        ;
        MOV     (R0)+,R3        ;
        MOV     (R0)+,R4        ;
        MOV     (R0)+,R5        ;
        MOV     (R0)+,SP        ;
        MOV     UR0,R0          ;
        MOV     UST,-(SP)       ;SET EXEC PS WORD
        MOV     UPC,-(SP)       ;SET EXEC PC WORD
        MOV     (SP),PPC        ;SET PREVIOUS PC WORD
RTN:    RTI                     ;RETURN TO EXEC (MAY BE CHANGED TO RTT)

;
; "S" PROCESSOR - SINGLE STEP PROCEED
;SYNTAX--
;NS                             EXECUTE N INSTRUCTIONS AND THEN STOP
;S                              EXECUTE ONE INSTRUCTION

SNGL:   MOVB    #BKP+2,R0       ;FAKE THE BREAK
        MOVB    R0,S            ;SET THE FLAG FOR S.I. MODE
        BR      PR01            ;FAKE A PROCEED IN S.I. MOOD

;
; "P" PROCESSOR - PROCEED FROM BREAKPOINT
;SYNTAX--
;NP                             PROCEED THRU THIS BREAKPOINT N TIMES
;P                              ASSUME N=1

PROC:   CLRB    S               ;SET FAST MODE
        MOVB    P,R0            ;GET NUMBER OF BREAK
        BMI     PR02            ;THERE WASN'T ONE SO FAR ?
PR01:   TST     R2              ;SEE IF VALUE IN R4 VIA R2
        BNE     10$             ;SEE IF AND WHAT SETTING FOR COUNT
        MOV     #1,R4           ;INIT IT TO ONE FOR A START
10$:    MOV     R4,CT(R0)       ;SET USER'S COUNT
C990:   CMPB    P,#BKP          ;SEE IF A REAL ONE OR A FAKE
        BGT     TBIT            ;BRANCH IF FAKE
        TSTB    S               ;SEE IF SINGLE INSTRUCTION MODE
        BNE     TBIT            ;IF SO EXIT NOW
        INCB    T               ;SET T-BIT FLAG
        BIS     #TBT,UST        ;SET T-BIT
        BR      GRTT
PR02:   ERROR                   ;ANNOUNCE ERROR


;
; TEST IF IN EXEC MODE
;

TESTM:  MOV     (R5)+,-(SP)     ;PICK UP EXEC TRAP ROUTINE ADDRESS


        .IF DF  M$$MGE

        TST     $STKDP          ;ALLOW EXEC TO HANDLE TRAP?
        BGT     20$             ;IF GT YES, TRAP WAS IN USER MODE
        BLT     10$             ;IF LT NO, BAD STACK DEPTH
        CMP     4(SP),#$DRLM1   ;TRAP OCCUR IN DIRECTIVE DISPATCHER?
        BLO     5$              ;IF LO NO
        CMP     4(SP),#$DRLM2   ;TRAP OCCUR IN DIRECTIVE DISPATCHER?
        BLOS    20$             ;IF LO YES, PASS TRAP TO EXEC
5$:     CMP     4(SP),#$DQLM1   ;TRAP OCCUR IN QIO DIRECTIVE?
        BLO     6$              ;IF LO NO
        CMP     4(SP),#$DQLM2   ;TRAP OCCUR IN QIO DIRECTIVE?
        BLOS    20$             ;IF LOS YES, ALLOW EXEC TO HANDLE TRAP
6$:                             ;REF LABEL


        .IF DF  P$$LAS

        CMP     4(SP),#$DPLM1   ;FAULT OCCUR RETRIEVING DEF BLOCK ADDR?
        BLO     10$             ;IF LO NO
        CMP     4(SP),#$DPLM2   ;FAULT OCCUR RETRIEVING DEF BLOCK ADDR?
        BLOS    20$             ;IF LOS YES, ALLOW EXEC TO HANDLE TRAP

        .ENDC


        .IFF

        TST     $STKDP          ;TRAP IN EXEC?
        BLE     10$             ;IF LE YES
        CMP     4(SP),$EXSIZ    ;TRAP OCCUR IN EXEC CODE?
        BHIS    20$             ;IF HIS NO
        BIT     #PR7,6(SP)      ;EXECUTING AT PRIORITY OTHER THAN ZERO?
        BEQ     20$             ;IF EQ NO

        .ENDC


10$:    MOV     R5,(SP)         ;SET TO XDT ADDRESS
20$:    MOV     (SP)+,R5        ;SET RETURN ADDRESS
        RTS     R5              ;PROCESS TRAP

        .SBTTL  COMMAND PROCESSORS, SECTION THREE ( L V X W N E F )

.SBTTL "L" PROCESSOR - LIST MEMORY ON THE SPECIFIED DEVICE

;SYNTAX--
; D;S;FL                WHERE   D IS DEV, <> OR 0 = CONSOLE, 1 = LPT
;                               S IS START ADDRESS, SETS $L IF THERE
;                               F IS STOP ADDRESS, SETS $H IF THERE

LIST:   TST     R2              ;SET UPPER AND LOWER LIMITS
        BEQ     10$             ;IF SPECIFIED TO DO SO
        MOV     R4,HI
10$:    TST     R3              ;DO THE LOW ONE
        BEQ     15$
        MOV     R5,LOW
15$:    CMPB    #2,SMFD         ;SEE IF AN EXTRA ARGUMENT
        BNE     17$             ;USE THE CONSOLE
        TST     D.ARGS          ;LOOK AT THE ARGUMENT
        BEQ     17$             ;DO NOT ARGUE
        MOV     #LPS,OUTS       ;SET OUTPUT STATUS REGISTER TO LINE PRINTER
        MOV     #LPB,OUTB       ;
        TYPE    14              ;OUTPUT A FORM FEED
17$:    MOV     LOW,R5          ;GET STARTING DUMP ADDRESS
        MOVB    OBW,R0          ;GET ADDRESS INCREMENT
        SUB     R0,R5           ;BIAS ADDRESS BY ADDRESS INCREMENT
        MOV     R5,CAD          ;SET CURRENT ADDRESS
        TST     -(SP)           ;MAKE A HOLE IN THE STACK
20$:    CLR     (SP)            ;NEW LINE UP
        JSR     PC,SNAGIT       ;ACCESS DEVICE FOR DATA
        JSR     PC,SPRINT       ;PRINT ADDRESS AND FIRST ITEM
25$:    JSR     PC,SNAGIT       ;GET MORE DATA
        JSR     PC,DPRINT       ;JUST PRINT THE DATA
        INC     (SP)            ;COUNT THE DATA
        CMP     #7,(SP)         ;CHECK THE COUNT
        BNE     25$             ;JUST LIKE THEY TOLD YOU AT THE
        BR      20$             ;FAMOUS PROGRAMMERS SCHOOL

;
; EXIT COMMAND
;
; SYNTAX X
;
; THE EXIT COMMAND IN XDT EFFECTS A JUMP TO THE EXECUTIVE $CRASH ROUTINE.
;

EXIT:   MOV     #UR0+2,R0       ;POINT TO SAVED R1
        MOV     (R0)+,R1        ;RESTORE REGISTERS R1 THRU SP THEN R0
        MOV     (R0)+,R2        ;
        MOV     (R0)+,R3        ;
        MOV     (R0)+,R4        ;
        MOV     (R0)+,R5        ;
        MOV     (R0)+,SP        ;
        MOV     UR0,R0          ;


        .IF DF  C$$RSH

        MOV     UST,$CRUST      ; MOVE USER PS FOR THE CRASH MODULE
        MOV     UPC,$CRUPC      ; MOVE USER PC FOR THE CRASH MODULE
        JMP     $CRALT          ; ALTERNATE ENTRY POINT TO THE CRASH MODULE

        .IFF

        JMP     $CRASH          ;IF NO CRASH SUPPORT, JUST CRASH

        .ENDC


        .SBTTL  UTILITIES - COMMAND SUPPORT ROUTINES

;TEST FOR VALID RELOCATION REGISTER IN R4

RTST:   CMP     #RLR/2,R4       ;GET A GOOD NUMBER FOR A REGISTER
        BLO     10$             ;NOT TOO GOOD, QUESTION IT
        ASL     R4
10$:    RETURN                  ;

;SNAG MEMORY LOCATION   JSR PC,SNAGIT

;NEEDS--
;CAD            POINTS TO MEMORY WORD (APPROXIMATELY THAT IS)
;R0,R5          CONTAINS REAL WORD UPON EXIT TO "SRCHEK"

SNAGIT: MOVB    OBW,R0          ;SET THE INCREMENT
        ADD     R0,CAD          ;INCREMENT AND NOW
        CMP     CAD,HI          ;SEE IF MORE TO DO
        BLOS    10$             ;IF NOT DO NOT
        DECODE                  ;GO RESET STACK AND NO NEXT COMMAND
10$:    JSR     PC,GETCAD       ;ACCESS METHOD
        MOV     R0,R5           ;MAKE A COPY FOR LATER
        RETURN                  ;

;SEARCH HIT PRINT                       JSR PC,SPRINT

;CAD POINTS TO THE LOC TO BE PRINTED
;R5 CONTAINS THE CONTENTS OF THE LOCATION TO BE PRINTED

SPRINT: TYPE    CRLF            ;PLACE CARRIAGE IN PROPER POSITION
        MOV     CAD,R0          ;THE LOCATION
        JSR     PC,RORA         ;THE MODE
        MOVB    FM,R0           ;PICK UP OLD CURENT MODE
        ASR     R0              ;HALVES
        MOVB    COMTAB(R0),R0   ;AH HA
        TYPE    R0              ;TYPE THE MODE REGISTER

;DATA PRINT ROUTINE                     JSR PC,DPRINT

;PRINTS DATA IN R5 IN CURRENT MODE

DPRINT: MOVB    FM,R1           ;SET THE MODE
        MOV     R5,R0           ;THIS IS THE POOR DATA
        MOV     R5,-(SP)        ;SAVE THE DATA
        JSR     PC,@TYFORM(R1)  ;DO THAT __ TO THE POOR DATA
        MOV     (SP)+,R5        ;RESTORE THE DATA
        RTS     PC              ;RESTORE THE PC

;EXPRESSION COMPUTATION ROUTINE         JSR PC,EXPCOM

;NEEDS--
;OP                     THE OPERATION (-2=*, 0=+, *=2)
;EXP                    THE LEFT SIDE
;R4                     THE RIGHT SIDE

;SETS UP--
;OP                     BACK TO 0 FOR ADD
;EXP,R4         ALL SO FAR

EXPCOM: TSTB    OP              ;SEE WHAT'S UP CHUCK
        BMI     20$
        BEQ     10$
        NEG     R4              ;MINUS, OP=2
10$:    ADD     EXP,R4          ;PLUS, OP=0
15$:    MOV     R4,EXP          ;COMMON OUT, SET EXP TO WHATEVER
        CLRB    OP              ;IS IN R4 TOO
        INC     R2              ;SET R2 SO THAT R4 IS, OP=0
        RTS     PC
20$:    MOV     EXP,-(SP)       ;GET THE LEFT SIDE OF EXPRESSION
        ASL     (SP)            ; MULTIPLY BY 10
        ASL     (SP)            ;
        ASL     (SP)            ;
        ADD     (SP),R4         ; ADD IT
        ASL     (SP)            ; MULTIPLY BY 40
        ASL     (SP)            ; WHICH IS LIKE MULTIPLYING BY 50
        ADD     (SP)+,R4        ;AND ADD IT TO THE RIGHT
        BR      15$             ;COMMON OUT

;BUILD AN OCTAL NUMBER          JSR PC,GETNUM

;NEEDS AND RETURNS--
;R0     NON-OCTAL TERMINATING CHARACTER
;R2     OCTAL CHARACTER COUNT
;R4     OCTAL NUMBER THAT I GOT, YOU GET

GETNUM: CLR     R2              ;NEW R2 AND R4
        CLR     R4
10$:    JSR     PC,GET          ;GET 1 CHARACTER
        CMPB    #'0,R0          ;NON-OCTAL, LESS THAN "0"
        BHI     GETC99
        CMPB    #'7,R0          ;NON-OCTAL, LESS THAN "7"
        BLO     GETC99
        BIC     #177770,R0      ;MAKE INTO ACCEPTABLE RANGE
        ASL     R4              ; SHIFT LEFT
        ASL     R4              ; 3 BITS
        ASL     R4              ;
        ADD     R0,R4           ;PLANT LO PLACE
        INC     R2              ;ACCOUNT FOR NEW ONE
        BR      10$             ;NEXT ONE OR OTHER

;SCAN A LIST OF CHARACTERS      JSR R5,LOOKUP

;CALL--
;               R0      HAS THE CHARACTER
;       JSR     R5,LOOKUP       ;THAT IS IT
;        +      LIST TO USE, 00 BYTE IS END OF LIST

;RETURNS AT CALL + 2 WITH--
;R0     STILL HAS CHARACTER
;R1     HAS INDEX X2 OF FOUND CHARACTER IF C=0
;C=1    CHARACTER WAS NOT FOUND

LOOKUP: MOV     (R5),R1         ;GET LIST START
10$:    CMPB    R0,(R1)         ;IS THIS THE ONE
        BNE     20$             ;RIGHT IT WASN'T
        SUB     (R5)+,R1        ;COMPUTE INDEX AND RETURN
        ASL     R1              ;DO THIS FOR EVERBODY, C=0
        BR      30$
20$:    TSTB    (R1)+           ;CHECK FOR END OF LIST
        BNE     10$             ;IF NOT LOOK AT NEXT ITEM
        TST     (R5)+           ;END, AVOID ILLEGAL INSTRUCTION
        SEC                     ;SECURITY EXCHANGE COMMISION
30$:    RTS     R5              ;SECURITY ELSEWHERE

;GET CONTENTS OF ADDRESS IN THE MODE            JSR PC,GETCAD

;NEEDS--
;R0             THE MODE 1=BYTE, 2=WORD
;CAD            THE ADDRESS
;DEVI           THE DEVICE CODE

;RETURNS--
;R0             HAS THE DATA YOU ASKED FOR

GETCAD: MOV     CAD,R3          ; GET CORE ADDRESS
        MOV     SP,OPN          ; SET LOCATION OPEN
        ASR     R0              ;PUSH BW FLAG INTO CARRY BIT
        BCC     10$             ;2 WON'T FIT SO IS WORD
        MOVB    (R3),R0         ;ACCESS BYTE
        BR      GETC99
10$:    MOV     (R3),R0         ;ACCESS WORD
GETC99: RTS     PC              ;STACK ACCESS

;PUT R4 INTO ADDRESS IN THE MODE                JSR PC,PUTCAD

;NEEDS--
;R2             CONTENT FLAG, 0 FOR NONE, ELSE R4 IS GOLD
;R4             THE DATA
;BW             THE MODE FLAG, IF 0 THEN NO LOCATION OPEN

PUTCAD: TST     R2              ;CHECK FOR TYPED VALUE
        BEQ     12$             ;NO DATA NO DODO
        MOV     BW,R0           ;PICK UP MODE AN CC'S
        TST     OPN             ; IS A LOCATION OPEN AT PRESENT?
        BEQ     12$             ;NOT OPEN NOT STORED
        MOV     CAD,R3          ; GET CORE ADDRESS
        BIT     #177776,R0      ;CHECK MODE
        BNE     10$             ;WORD MODE
        MOVB    R4,(R3)         ;BYTE MODE
        BR      12$             ;BRANCH MODE
10$:    MOV     R4,(R3)         ;WORD MODE
12$:    RTS     PC




;
; GET CHARACTER FROM CONSOLE TERMINAL
;

GET:    TSTB    TKS             ;CHARACTER READY?
        BPL     GET             ;IF PL NO
        MOVB    TKB,R0          ;READ INPUT BYTE
        BIC     #177600,R0      ;CLEAR EXCESS BITS
        CMPB    R0,#12          ;BRANCH IF <LF>
        BEQ     40$             ;NO ECHO <LF>'S
        JSR     R5,LOOKUP       ;CHECK IF ALTMODE
        +       ALTTAB
        BCS     20$             ;
        MOVB    #'$,R0          ;CHANGE TO $ IF SO
20$:    MOV     R0,-(SP)        ;SAVE INPUT CHARACTER
        TYPE    R0              ;ECHO CHARACTER
        MOV     (SP)+,R0        ;RESTORE INPUT CHARACTER
        CMP     #141,R0         ;LOWER CASE CHARACTER?
        BHI     30$             ;IF HI NO
        CMP     #172,R0         ;LOWER CASE CHARACTER?
        BLO     30$             ;IF LO NO
        SUB     #40,R0          ;CONVERT TO UPPER CASE CHARACTER
30$:    CMPB    #' ,R0          ;CVT BLANK
        BNE     40$
        MOVB    #'+,R0          ;INTO +
40$:    RETURN                  ;

;
; TYPE CHARACTER ON OUTPUT DEVICE
;

TYPE:   MOV     (SP),-(SP)      ;DUPLICATE RETURN ADDRESS
        SUB     #2,(SP)         ;POINT TO TRAP INSTRUCTION
        MOVB    @(SP)+,-(SP)    ;GET LOW BYTE OF INSTRUCTION
        BMI     10$             ;IF MI CONTROL BYTE
        MOV     (SP)+,R0        ;SET BYTE TO OUTPUT
        BR      30$             ;
10$:    BIT     #40,(SP)        ;OUTPUT CONTENTS OF R0?
        BEQ     20$             ;IF EQ YES
        MOV     (PC)+,R0        ;SET TO OUTPUT <CR><LF>
        .BYTE   15,12           ;
20$:    ASLB    (SP)+           ;OUTPUT TWO BYTES?
        BPL     30$             ;IF PL NO
        TYPE    R0              ;TYPE OUT FIRST BYTE
        SWAB    R0              ;SET UP HIGH BYTE
30$:    TSTB    @OUTS           ;OUTPUT DEVICE READY?
        BPL     30$             ;IF PL NO
        MOVB    R0,@OUTB        ;OUTPUT BYTE
35$:    TSTB    @OUTS           ;OUTPUT DEVICE READY?
        BPL     35$             ;IF PL YES
        CMPB    #15,R0          ;WAS OUTPUT BYTE A CARRIAGE RETURN?
        BNE     50$             ;IF NE NO
        CMP     #LPS,OUTS       ;OUTPUT DEVICE LINE PRINTER?
        BEQ     50$             ;IF EQ YES
        MOV     #5,-(SP)        ;SET FILL COUNT TO 5
        CLRB    R0              ;SET OUTPUT NULLS
40$:    TYPE    R0              ;OUTPUT A NULL
        DEC     (SP)            ;ANY MORE TO OUTPUT?
        BGT     40$             ;IF GT YES
        TST     (SP)+           ;CLEAN STACK
50$:    RTI                     ;

        .SBTTL  UTILITIES - PRETTY PRINTERS

;PRINT ADDRESS- RELOC, SYMBOLIC, OR ABSL        JSR PC.RORA

;R0     ADDRESS TO BE PRINTED
;FORM   CORE ADDRESS FORMAT (0-RELOC  1-ABSOL)

;REGISTER       '$R ' OR '$DR '
;CORE           'D,XXXXXX ' OR 'XXXXXX '

RORA:   MOV     R0,-(SP)        ;CALLING VALUE ONA TOPPA SATCK
        CMP     #INTBEG,(SP)
        BHI     50$             ;BELOW FIRST NON-INDEXED
        CMP     #INTEND,(SP)
        BLO     50$             ;ABOVE LAST NON-INDEXED
        TYPE    '$              ;ANNOUNCE INTENSIONS
        CMP     #INTINX,(SP)
        BLOS    20$             ;GO TO DO INDEXED
        MOV     (SP)+,R0        ;NON-INDEXED REGISTER ----- "$R "
        SUB     #INTBEG,R0      ;CLEANED UP STACK, GET OFFSET
        ASR     R0              ;BYTE THAT WORD, WORD THAT BYTE
        MOVB    NIXMAP(R0),R0   ;MAGIC CHARACTER FROM TABLE
15$:    BIS     (PC)+,R0
        .BYTE   000,'           ;CHARACTER PLUSSA BLANK
        TYPE    R0+R0           ;NAME PLUS BLANK AND SPLIT
        RETURN                  ;
20$:    CLR     R1              ;SEE WHICH SET OF TABLES WE GOT
22$:    CMP     INXTBL+2(R1),(SP) ;LOOK ON AHEAD TO FIND BEHIND
        BHI     24$             ;R1 POINTS TO BASE OF SET
        TST     (R1)+           ;THINK ABOUT THOSE DUMMY ENTRIES DUMMY
        BR      22$
24$:    MOV     (SP)+,R0        ;INDEXED REGISTER ---- "$DR "
        SUB     INXTBL(R1),R0   ;GET ADDRESS AND COMPUTE OFFSET IN WORDS
        ASR     R0              ;AND FINALLY IN PLAIN TALK
        ADD     #'0,R0          ;CONVERT TO ASCII
        TYPE    R0              ;TYPE OUT REGISTER NUMBER
        ASR     R1
        MOVB    INXREG(R1),R0   ;PICK UP THE REAL CHARACTER
        BR      15$             ;GO PRINT REST OF IT
50$:    TST     FORM            ;CORE ADDRESS SEE WHAT USER WANTS
        BNE     80$             ;TYPE AS ABSOLUTE.
        MOV     (SP),R4         ;RELOCATE ---- "R,XXXXXX "
        JSR     PC,LOCA         ;WE ALWAYS PICK, XDT KNOWS BEST
        BMI     80$             ;BUT NOT ALL THE TIME
        MOV     R1,(SP)         ;SET THE DISPLACEMENT
        ADD     #"0,,R0         ;PRINT REGISTER AND COMMA
        TYPE    R0+R0           ;DISK AND CORE
80$:    MOV     (SP)+,R0        ;PRINT R0 AS A WORD

;TYPE R0 AS BYTE OR WORD, TWO ENTRIES
;       FOR A WORD                              JSR PC,CADW
;       FOR A BITE                              JSR PC,CADB

CADW:   MOV     R0,QUAN         ;SET THE FAMOUS QUANTITY VALUE
        MOV     #6,R3           ;# OF DIGITS
        MOV     #-2,R4          ;# OF BITS FIRST-3
        BR      CA01            ;DO THE COMMON THING
CADB:   CLR     QUAN            ;SET FOR ALL OF QUAN A BYTE
        MOVB    R0,QUAN         ;SET THE QUANTITY THING AGAIN
        MOV     #3,R3           ;THERE ARE THREE DIGITS
        MOV     #-1,R4          ;AND ONLY TWO BITS
        SWAB    R0              ;SWITCH ENDS
CA01:   MOV     R0,-(SP)        ;SAVE R0
10$:    ADD     #3,R4           ;COMPUTE THE NUMBER OF BITS TO DO
        CLR     R0
15$:    ROL     (SP)            ;GET A BIT
        ROL     R0              ;STORE IT AWAY
        DEC     R4              ;DECREMENT COUNTER
        BGT     15$             ;LOOP IF MORE BITS NEEDED
        ADD     #'0,R0          ;CONVERT TO ASCII
        TYPE    R0              ;TYPE IT
        DEC     R3              ;SEE IF MORE DIGITS TO DO
        BGT     10$             ;LOOP IF SO
        MOVB    #' ,R0          ;SET UP FOR TRAILING SPACE
        TST     (SP)+           ;GET RID OF JUNK
FT01:   TYPE    R0              ;
        RETURN                  ;

;TYPE CONTENTS OF WORD IN FORMAT        JSR PC,@TYFORM(R1)

;R0             WORD OR BYTE TO BE TYPED, RHJ
;R1     CODE-   ENTRY PT,       FORMAT, CODE

TYFORM: +       CADB            ;BYTE OCTAL - 0
        +       CADW            ;WORD OCTAL - 2
        +       30$             ;BYTE ANSII - 4
        +       20$             ;WORD ANSII - 6
        +       10$             ;RADIX 50  - 10

10$:    JSR     PC,TYRADX       ;R0 GETS THE RADIX 50 TREATMENT
        BR      35$             ;APPEND A BLANK TO 3 CHAR'S

20$:    TYPE    R0              ;TYPE BYTE IN R0
        SWAB    R0              ;SWAP EM AND TYPE IT
30$:    TYPE    R0              ;TYPE BYTE IN R0
35$:    TYPE    40              ;TYPE A SPACE
        RETURN                  ;

;TYPE CONTENTS OF R0 IN RADIX 50                JSR PC,TYRADX

TYRADX: MOV     #3,R5           ;COUNT OF CHARACTERS
        MOV     #50$,R2         ;POINTER TO COEFFICENT TABLE
        MOV     R0,R1           ;COPY OF RADIX 50 WORD
10$:    MOV     R1,R0           ; GET DIVIDEND
        MOV     (R2)+,R1        ; GET DIVISOR
        JSR     PC,$DIV         ; DIVIDE, R0=QUOTIENT, R1 =REMAINDER
        TST     R0              ; IS QUOTIENT ZERO? (SP)?
        BEQ     12$             ;"SP" = 040
        CMPB    R0,#33          ;RAD50-$ =33
        BEQ     16$             ;"$" = 044
        BGT     14$             ;"." OR "0-9" = 056 OR 060-071
        ADD     #40,R0          ;RAD50-A = 1, "A" = 101
12$:    ADD     #16,R0          ;40+16+11+11 = 100 + (A-Z)
14$:    ADD     #11,R0          ;16+11+11 = 40 + (SP)
16$:    ADD     #11,R0          ;11+11 = 22 + (.,0-9)
        TYPE    R0              ;TYPE CHARACTER IN R0
        DEC     R5              ;COUNT THE CHARACTERS
        BNE     10$             ; LOOP
        RTS     PC

;COEFFICENT TABLE, RADIX 50 CONVERT

50$:    .WORD   +1600.,+40.,+1. ;40.^2, 40.^1, 40.^0

;SELECT RELOCATION REGISTER                     JSR PC,LOC

;CAD            ADDRESS TO USE IN SELECTION

;RETURNS--
;R0                             REGISTER NUMBER FOUND, -1 IF NONE FOUND
;R1                             DISTANCE, RELOCATION FACTOR

;SUBROUTINE TO LOCATE RELOCATION REGISTER NEAREST BUT STILL
;BELOW THE ADDRESS IN CAD.  RETURNS WITH THE REGISTER
;NUMBER IN R0, AND WITH THE DISTANCE BETWEEN THE REGISTER
;AND (CAD) IN R1
;IF NO GOOD RELOC. REG. FOUND, R0 WILL = -1

LOC:    MOV     CAD,R4  ;SET UP CAD DATA
LOCA:   CLR     R0
        MOV     #-1,-(SP)       ;INITIALIZE RELOC. REG. INDEX
        MOV     (SP),R1         ;INITIALIZE DISTANCE TO A HIGH VALUE
10$:    CMP     R0,#RLR         ;ARE WE DONE COMPARING?
        BHI     20$             ;BRANCH IF DONE
        CMP     RELT(R0),R4     ;IS CURR. RELOC. BIAS > (R4)?
        BHI     15$             ;IF SO, BRANCH -- DON'T SUBTRACT, GET NEXT
        MOV     R4,R2           ;OTHERWISE TAKE THE DIFFERENCE
        SUB     RELT(R0),R2     ;OF CURR. RELOC. REG. AND CAD
        CMP     R1,R2           ;IS THE RESULT THE SMALLEST SO FAR?
        BHI     25$             ;BRANCH IF YES (UNSIGNED CONDITIONAL)
15$:    TST     (R0)+           ;OTHERWISE, BUMP R0 FOR NEXT RELOC. REG.
        BR      10$             ;LOOP BACK FOR NEXT COMPARISON
20$:    MOV     (SP)+,R0        ;PUT REG.# IN R0
        RTS     PC              ;JOB OVER, RETURN
25$:    MOV     R2,R1           ;REMEMBER SMALLEST DIFFERENCE IN XXY
        ASR     R0              ;AND ASSOCIATED REGISTER NUMBER
        MOV     R0,(SP)         ; IN (SP)
        ASL     R0              ;RESTORE R0 TO ORIGINAL VALUE
        BR      15$             ;GO FO NEXT COMPARISON.

        .END    $XDT

        .TITLE  GRDRV
        .IDENT  /03.02/
 
;
; COPYRIGHT (C) 1976, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VT11/VS60 DISPLAY PROCESSOR DRIVER
;
; VERSION 01
;
; NOTE: THIS IS A SINGLE CONTROLLER DRIVER
;
; WRITTEN  BY HANK MAURER 13-JUL-75
;
; PREVIOUSLY MODIFIED BY:
;
;       E. L. BAATZ
;       H. MAURER
;
; MODIFIED BY:
;
;       HANK MAURER 11-JUN-78
;       HM002 -- CORRECT DPUERR MACRO
;
;       HANK MAURER 11-JUN-78
;       HM003 -- MOVE TRACKING CROSS ONLY WHEN TIP SWITCH IS ON
;
;       ERIC BAATZ 20-JAN-79
;       EB189 -- SET PS.NSF WHEN CONNECTING
;
; EQUATED SYMBOLS
;

        DNR=20                  ;DPU NAME REGISTER
        DOS=36                  ;DPU OFFSET SIGN REGISTER
        BFHDR=52.               ;DISPLAY BUFFER HEADER SIZE
        NAMSIZ=18.              ;NAME LIST SIZE
        DPC=172000              ;DPU PROGRAM COUNTER ADDRESS
        DSR=2                   ;DPU STATUS REGISTER
        DRB=10                  ;DPU RELOCATION REGISTER
        DSRX=12                 ;DPU EXTENDED STATUS REGISTER
        DST=26                  ;DPU STACK READ REGISTER
        DSP=32                  ;DPU STACK POINTER
        DCS=22                  ;DPU CONSOLE STATUS REGISTER
        DJSR=173400             ;DPU JSR INSTRUCTION
        DJMPA=160000            ;DPU JMP INSTRUCTION
        DJMP=173500             ;DPU JMP RELATIVE INSTRUCTION
        DHALT=173400            ;DPU HALT AND INTERRUPT
        LSRA=170000             ;DPU LOAD STATUS REGISTER A
        LPINT=200               ;DPU INTENSIFY LP HITS
        NOITAL=40               ;DPU NON-ITALICS
        LINE0=4                 ;DPU SOLID LINE TYPE
        EXTSTP=200              ;DPU EXTERNAL STOP BIT (VS60)
        LVECT=110000            ;DPU LONG VECTOR INSTRUCTION
        NBLINK=20               ;DPU BLINK OFF
        MINUS=20000             ;DPU LONG VECTOR SIGN BIT
        POINT=114000            ;DPU ABSOLUTE POINT INSTRUCTION
        LPOFF=100               ;DPU LIGHT PEN INTERRUPT OFF
        BLINK=30                ;DPU BLINK ON
        INT3=2600               ;DPU INTENSITY LEVEL 3
        CHAR=100000             ;DPU CHARACTER MODE
        NOMENU=2                ;DPU MENU OFF
        OFFSET=10000            ;DPU SET OFFSET MODE BIT
        S1=164000               ;DPU SELECT SCOPE 1
        S2=164400               ;DPU SELECT SCOPE 2
        SON=300                 ;DPU TURN SCOPE ON (INTENSIFY)
        SOFF=200                ;DPU TYURN SCOPE OFF
        TIPION=14               ;DPU TURN ON TIP SWITCH INTERRUPTS
        LPIOFF=40               ;DPU TURN LIGHT PEN INTERRUPTS OFF
        LSRC=154000             ;DPU LOAD STATUS REGISTER C
        CROFF=1000              ;DPU TURN CHARACTER ROTATE OFF
        CSNORM=240              ;DPU CHARACTER SCALE NORMAL
        VSNORM=24               ;DPU VECTOR SCALE NORMAL
        SRESET=40               ;DPU STACK POINTER RESET
        LP0=40000               ;DPU LIGHT PEN INTERRUPT FOR SCOPE 1
        TON0=20000              ;DPU TIP SWITCH ON FOR SCOPE 1
        TOFF0=10000             ;DPU TIP SWITCH OFF FOR SCOPE 1
        LP1=400                 ;DPU LIGHT PEN INTERRUPT FOR SCOPE 2
        TON1=200                ;DPU TIP SWITCH ON FOR SCOPE 2
        TOFF1=100               ;DPU TIP SWITCH OFF FOR SCOPE 2

;
; LOCAL DATA  *** WARNING *** THE ORDER OF THE LOCAL DATA IS FIXED
;


        .IF DF  V$$S60

GR.PC:  .WORD   0               ;DPU PROGRAM COUNTER ADDRESS
LOCAL:                          ;REFERENCE TAG
BUFST:  .WORD   0               ;DISPLAY BUFFER

        .IF DF  M$$MGE

BUFRB:  .WORD   0               ;DISPLAY BUFFER RELOCATION BIAS
BUFDB:  .WORD   0               ;DISPLAY BUFFER DIB
TASRB:  .WORD   0               ;EQUIVALENT TASK RELOCATION BIAS
DPCFIX: .WORD   0               ;LOW 16 BITS OF PHYSICAL TASK ORIGIN
                                ; (FOR FUDGING DPC ON LP)

        .ENDC

        .IFF

GRSTK:  .BLKW   16.             ;DPU JSR STACK

        .IF DF  M$$MGE

TASK0:  .WORD   0               ;PHYSICAL ADDRESS OF USER VIRTUAL 0
                                ; (FOR RELOCATION)

        .IFTF

GR.PC:  .WORD   0               ;DPU PROGRAM COUNTER
GR.SP:  .WORD   GRSTK           ;DPU STACK POINTER
LOCAL:                          ;REFERENCE TAG

        .IFT

BUFRB:  .WORD   0               ;RELOCATION BIAS FOR DISPLAY BUFFER

        .IFTF

BUFST:  .WORD   0               ;PHYSICAL ADDRESS OF DISPLAY BUFFER
BUFSZ:  .WORD   0               ;SIZE OF DISPLAY BUFFER IN BYTES

        .IFT

BUFDB:  .WORD   0               ;DISPLAY BUFFER DIB (FOR SAR6)

        .ENDC

        .IFTF                   ; DF V$$S60


        .IF DF  A$$TRP

LPAST:  .WORD   0               ;LIGHT PEN AST VIRTUAL ADDRESS

        .ENDC

EFNAD:  .WORD   0               ;EVENT FLAG ADDRESS WORD
EFNMK:  .WORD   0               ;EVENT FLAG MASK WORD (FOR LP HITS)
CONTK:  .WORD   0               ;TCB ADDRESS OF CONNECTED TASK
FRKIP:  .WORD   0               ;LP FORK IN PROGRESS
TIP1:   .WORD   0               ;TIP SWITCH 1 STATUS

        .IF DF  V$$S2S

TIP2:   .WORD   0               ;TIP SWITCH 2 STATUS
LPFLAG: .WORD   0               ;SCOPE 1 OR 2 FLAG ON LP HIT

        .ENDC

HLTFLG: .WORD   100001          ;LEAVE DPU HALTED FLAG

;
; DELAY IN CASE THE USER'S DISPLAY LIST IS VERY SHORT
;

DELAY:  .WORD   POINT+LPOFF+NBLINK+INT3+LINE0

        .IFT                    ; DF V$$S60

        .WORD   OFFSET,0

        .IFTF

        .WORD   1023.,1023.
        .WORD   LVECT
        .WORD   MINUS+1023.,MINUS+1023.

        .IFT

        .WORD   1023.,1023.,MINUS+1023.,MINUS+1023.
        .WORD   1023.,1023.,MINUS+1023.,MINUS+1023.
        .WORD   1023.,1023.,MINUS+1023.,MINUS+1023.

        .IFTF

        .WORD   CHAR
        .BYTE   17,17
        .WORD   LSRA+LPINT+NOITAL+NOMENU

        .IFT

        .WORD   S1+SON+LPIOFF+TIPION
        .WORD   S2+SOFF+LPIOFF+TIPION
        .WORD   LSRC+CROFF+CSNORM+VSNORM

        .IF DF  M$$MGE

DSTART: .WORD   DHALT,0

        .IFF

DSTART: DJMPA,0

        .ENDC

        .IFF

DSTART: .WORD   DJMPA,0

        .ENDC                   ; DF V$$S60

;
; COUNT LIGHT PEN INTERRUPTS THAT ARE NOT LIGHT PEN INTERRUPTS
;

LPERRS: .WORD   0               ;

;
; DRIVER DISPATCH TABLE
;

$GRTBL::.WORD   GRCHK           ;DEVICE INITIATOR ENTRY POINT
        .WORD   GRCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   GROUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   GRPWF           ;POWERFAIL ENTRY POINT


;
; MACRO DEFINITIONS
;

        .MACRO  DPUERR  TEXT,?X
        MOV     #X,DSTART+2                                                     ; HM002
        BR      90$                                                             ;**-1
X:      .WORD   CHAR
        .ASCII  "TEXT"
        .EVEN
        .WORD   DJMPA,DELAY
        .ENDM

;+
; **-GRCHK-VT11/VS60 DISPLAY PROCESSOR PARAMETER CHECKING
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O
; REQUEST IS RECEIVED FOR THE VT11/VS60 DISPLAY PROCESSOR.
; VT11/VS60 I/O REQUESTS CONTAIN DEVICE DEPENDENT INFORMA-
; ATION THAT MUST BE CHECKED IN THE CONTEXT OF THE ISSUING TASK.
; THEREFORE THE I/O REQUEST IS NOT QUEUED BEFORE CALLING THE DRIVER.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       DEPENDENT UPON FUNCTION TO BE PERFORMED.
;
; VT11/VS60 FUNCTION INDEPENDENT I/O PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE .
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;-

GRCHK:  MOV     R1,-(SP)        ;SAVE I/O PACKET ADDRESS
        MOV     I.FCN(R1),R2    ;GET I/O FUNCTION CODE
        MOV     I.PRM(R1),R0    ;GET VIRTUAL BUFFER ADDRESS (IF IO.CON)
        MOV     I.TCB(R1),R1    ;GET REQUESTING TASK'S TCB ADDRESS
        CMP     R2,#IO.CON      ;CONNECT ?
        BEQ     GRCON           ;YES
        CMP     R1,CONTK        ;IS THE REQUESTING TASK CONNECTED ?
        BNE     GRNCN           ;NO, IT CAN'T REQUEST THINGS
        CMP     R2,#IO.STP      ;STOP ?
        BEQ     GRSTP           ;YES
        CMP     R2,#IO.DIS      ;DISCONNECT ?
        BEQ     GRDIS           ;YES
        BR      GRCNT           ;NO, CONTINUE

;+
; **-GRSTP-STOP VT11/VS60 (SO USER CAN MODIFY HIS DISPLAY BUFFER)
;
; FUNCTION DEPENDENT IO PACKET FORMAT:
;
;       WD. 12 -- NOT USED
;       WD. 13 -- NOT USED
;       WD. 14 -- NOT USED
;       WD. 15 -- NOT USED
;       WD. 16 -- NOT USED
;       WD. 17 -- NOT USED
;       WD. 20 -- NOT USED
;-

GRSTP:  CALL    GRHLT           ;HALT DPU
        BR      GRSUC           ;TAKE COMMON SUCCESS EXIT

;+
; **-GRCON-CONNECT DISPLAY BUFFER TO DRIVER
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- USER VIRTUAL ADDRESS OF DISPLAY BUFFER.
;       WD. 13 -- SIZE OF DISPLAY BUFFER IN BYTES.
;       WD. 14 -- LIGHT PEN HIT TRIGGER EVENT FLAG.
;       WD. 15 -- LIGHT PEN AST ADDRESS.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;-

GRCON:  TST     CONTK           ;ANOTHER TASK ALREADY CONNECTED?
        BNE     GRNCN           ;IF NE YES
        MOV     #LOCAL,R3       ;SET UP POINTER TO LOCAL DATA BASE
        BIT     #1,R0           ;IS VIRTUAL BUFFER ADDRESS ODD ?
        BNE     GRSPC           ;YES, ILLEGAL

        .IF DF  V$$S60

        MOV     R0,(R3)+        ;SAVE BUFFER ADDRESS

        .IF DF  M$$MGE

        CALL    $RELOC          ;MAP BUFFER ADDRESS
        MOV     R1,(R3)+        ;SAVE RELOCATION BIAS
        MOV     R2,(R3)+        ;AND DIB
        ASR     R0              ;GET RB OF BUFFER VIRTUAL ADDRESS
        ASR     R0
        ASR     R0
        ASR     R0
        ASR     R0
        ASR     R0
        BIC     #176000,R0      ;CLEAN IT OFF
        SUB     R0,R1           ;GET EQUIVALENT RB OF TASK 0
        MOV     R1,(R3)+        ;AND SAVE IT
        ASL     R1              ;GET LOW 16 BITS OF PHYSICAL
        ASL     R1              ; START OF TASK ADDRESS
        ASL     R1
        ASL     R1
        ASL     R1
        ASL     R1
        MOV     R1,(R3)+        ;SAVE IT

        .IFF

        MOV     R0,DSTART+2     ;PUT BUFFER ADDRESS INTO STARTER
        ADD     #BFHDR,DSTART+2 ;SKIPPING HEADER

        .ENDC

        MOV     (SP),R1         ;RESTORE PACKET POINTER
        ADD     #I.PRM+4,R1     ;POINT TO LIGHT PEN EFN PARAMETER

        .IFF

        .IF DF  M$$MGE

        CALL    $RELOC          ;MAP BUFFER ADDRESS
        MOV     R1,(R3)+        ;SAVE RELOCATION BIAS
        MOV     R2,R4           ;SAVE DIB FOR BUFFER
        CALL    $MPPHY          ;MAP INTO PHYSICAL ADDRESS (2 WORDS)
        MOV     R2,(R3)         ;SAVE LOW 16 BITS OF PHYSICAL ADDRESS
        MOV     (R3)+,DSTART+2  ;PHYSICAL BUFFER ADDRESS TO STARTER
        ADD     #BFHDR,DSTART+2 ;SKIPPING HEADER
        SUB     R2,R0           ;VIRTUAL-PHYSICAL BUFFER ADDRESS
        NEG     R0              ;PHYSICAL-VIRTUAL (TO RELOCATE DJSR, DJMP)
        MOV     R0,TASK0        ;SAVE IT
        TST     R1              ;ANY HIGH ORDER PHYSICAL ADDR. BITS ?
        BNE     GRSPC           ;YES, BUFFER OUT OF 32K

        .IFF

        MOV     R0,(R3)+        ;SAVE BUFFER ADDRESS
        MOV     R0,DSTART+2     ;PHYSICAL ADDRESS TO STARTER
        ADD     #BFHDR,DSTART+2 ;SKIPPING HEADER

        .IFTF

        MOV     (SP),R1         ;RESTORE PACKET POINTER
        ADD     #I.PRM+2,R1     ;POINT TO BUFFER SIZE PARAMETER

        .IFT

        MOV     (R1)+,(R3)      ;SAVE SIZE
        ADD     (R3)+,R2        ;GET ADDRESS OF BUFFER END
        BCS     GRSPC           ;END IS OUT OF 32K
        CMP     R2,#160000      ;ABOVE 28K ?
        BHIS    GRSPC           ;YES, ERROR
        MOV     R4,(R3)+        ;SAVE DIB FOR BUFFER START (SAR6)

        .IFF

        MOV     (R1)+,(R3)+     ;SAVE SIZE

        .ENDC

        .ENDC                   ; DF V$$S60

        MOV     (R1)+,R0        ;GET LP TRIGGER EFN
        BEQ     GRIEF           ;ZERO IS ILLEGAL
        CMP     R0,#64.         ;CHECK AGAINST MAX
        BGT     GRIEF           ;>64 IS ILLEGAL
        MOV     R5,-(SP)        ;SAVE UCB ADDRESS

        .IF DF  A$$TRP

        MOV     (R1),(R3)+      ;SAVE AST ADDRESS

        .ENDC

        MOV     I.TCB-I.PRM-6(R1),R5 ;GET CONNECTING TASK'S TCB ADDRESS
        CALL    $CEFI           ;CONVERT EFN TO MASK AND POINTER
        MOV     R1,(R3)+        ;SAVE EFN ADDRESS
        MOV     R0,(R3)+        ;SAVE EFN MASK
        BIC     R0,(R1)         ;CLEAR THE USER'S EVENT FLAG
        INCB    T.IOC(R5)       ;INCREMENT IO PENDING COUNT
        MOV     R5,(R3)         ;CONNECT TASK TO DRIVER
        MOV     T.PCB(R5),R5    ;GET TASK'S PCB ADDRESS                         ; EB189
        BIS     #PS.NSF,P.STAT(R5) ;DISABLE SHUFFLING                           ; EB189
        MOV     (SP)+,R5        ;RESTORE UCB ADDRESS

;+
; **-GRCNT-CONTINUE AFTER STOP
;
; FUNCTION DEPENDENT IO PACKET FORMAT:
;
;       WD. 12 -- NOT USED.
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;-

GRCNT:  TST     HLTFLG          ;IS DISPLAY RUNNING ?
        BEQ     GRSUC           ;YES

        .IF DF  V$$S60

        MOV     GR.PC,R0        ;GET DPU PC ADDRESS
        MOV     #SRESET,DSP(R0) ;RESET DPU STACK

        .IF DF  M$$MGE

        CLR     DRB(R0)         ;CLEAR RELOCATION BIAS

        .ENDC

        CLR     HLTFLG          ;CLEAR HALT FLAG
        MOV     #DELAY,(R0)     ;START UP THE DISPLAY

        .IFF

        MOV     #GRSTK,GR.SP    ;RESET DPU STACK
        CLR     HLTFLG          ;CLEAR HALT FLAG
        MOV     #DELAY,@GR.PC   ;START UP THE DISPLAY

        .ENDC


        BR      GRSUC           ;TAKE COMMON EXIT

;+
; **-GRDIS-DISCONNECT TASK FROM DRIVER
;
; FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- NOT USED.
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;-

GRDIS:  CALL    GRCAN           ;DISCONNECT TASK FROM DRIVER
        BR      GRSUC           ;TAKE COMMON EXIT

;
; EXITS FROM VT11/VS60 DRIVER
;
;
; ILLEGAL CONNECT/DISCONNECT TO/FROM DRIVER
;

GRNCN:  MOV     #IE.CNR&377,R0  ;SET CONNECT REFUSED STATUS
        BR      GRCMN           ;BUT DON'T DISTURB THE DISPLAY

;
; ILLEGAL EVENT FLAG NUMBER
;

GRIEF:  MOV     #IE.IEF&377,R0  ;SET ILLEGAL EVENT FLAG STATUS
        BR      GRCMN           ;

;
; ILLEGAL BUFFER SPECIFICATION
;

GRSPC:  MOV     #IE.SPC&377,R0  ;SET ILLEGAL BUFFER STATUS
        BR      GRCMN           ;TAKE COMMON EXIT

;
; SUCCESSFUL COMPLETION
;

GRSUC:  MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS

;
; COMMON FUNCTION EXIT
;

GRCMN:  CLR     R1              ;CLEAR SECOND I/O STATUS WORD
        MOV     (SP)+,R3        ;RETRIEVE I/O PACKET ADDRESS
        CALLR   $IOFIN          ;FINISH I/O OPERATION

;
; CANCEL I/O OPERATION
;
; THIS ROUTINE IS CALLED TO CANCEL ALL I/O IN PROGRESS FOR THE CURRENT
; TASK. IF THE TASK IS CONNECTED TO THE DRIVER, IT WILL BE
; DISCONNECTED AND THE DPU WILL BE SET TO THE IDLE DISPLAY.
;
; INPUTS:
;
;       R1=ADDRESS OF TCB OF CURRENT TASK
;       R4=ADDRESS OF SCB
;       R5=ADDRESS OF UCB
;

GRCAN:  MOV     #CONTK,R2       ;;;POINT AT LOCAL DATA
        CMP     R1,(R2)         ;;;IS THIS THE CONNECTED TASK ?
        BNE     GROUT           ;;;NO, DON'T DO ANYTHING
        CLR     (R2)            ;;;YES, DISCONNECT IT
        CLR     -(R2)           ;;;CLEAR EFN MASK
        CLR     -(R2)           ;;;AND ADDRESS IN CASE FORK ALREADY QUEUED

        .IF DF  A$$TRP

        CLR     -(R2)           ;;;AND AST ADDRESS

        .ENDC

        DECB    T.IOC(R1)       ;;;DECREMENT OUTSTANDING I/O COUNT
        MOV     T.PCB(R1),R3    ;;;GET TASK'S PCB ADDRESS                       ; EB189
        BIC     #PS.NSF,P.STAT(R3) ;;;ENABLE SHUFFLING                          ; EB189
        MTPS    #0              ;;;ALLOW DEVICE INTERRUPTS

;
; SUBROUTINE TO HALT DPU
;
; INPUTS:
;
;       R4=ADDRESS OF SCB
;       R5=ADDRESS OF UCB
;

GRHLT:  MOV     #HLTFLG,R3      ;;;OFT USED
        TST     (R3)            ;;;ALREADY HALTED ?
        BNE     30$             ;;;YES
        MOV     #1,(R3)         ;;;SET THE 'PLEASE HALT' INDICATOR
5$:     MOV     #1000.,-(SP)    ;;;PUSH DELAY COUNTER
        MOV     (SP),-(SP)      ;;;TWICE
10$:    TST     (R3)            ;;;HALTED YET ?
        BMI     20$             ;;;YES, EXIT
        DEC     (SP)            ;;;INNER COUNTER
        BGT     10$             ;;;INNER LOOP
        MOV     2(SP),(SP)      ;;;RESTORE INNER COUNTER
        DEC     2(SP)           ;;;OUTER COUNTER
        BGT     10$             ;;;OUTER LOOP
        CMP     (SP)+,(SP)+     ;;;PURGE DEPLETED COUNTERS

        .IF DF  V$$S60

        MOV     GR.PC,R2        ;;;GET DPC ADDRESS
        BIS     #EXTSTP,DSRX(R2);;;DO AN EXTERNAL STOP

        .IFF

        MOV     #DELAY,@GR.PC   ;;;FORCE DPC AND TRY AGAIN

        .ENDC

        BR      5$              ;;;TRY AGAIN
20$:    CMP     (SP)+,(SP)+     ;;;PURGE COUNTERS
30$:    RETURN

;
; POWERFAILURE
;
;
; POWERFAILURE MERELY CAUSES THE DPU TO BE RESTARTED AT THE START OF
; THE DISPLAY BUFFER WITH THE DPU STACK RESET.
;
; INPUTS:
;
;       R3=ADDRESS OF CONTROLLER INDEX (ALWAYS ZERO)
;       R4=ADDRESS OF SCB
;       R5=ADDRESS OF UCB
;


GRPWF:  MOV     S.CSR(R4),R2    ;;;GET VT11/VS60 DPC ADDRESS
        MOV     R2,GR.PC        ;;;SAVE DPC ADDRESS

        .IF DF  V$$S60

        MOV     #SRESET,DSP(R2) ;;;RESET THE DPU STACK
        CLR     DRB(R2)         ;;;CLEAR THE DPU RB

        .IFF

        MOV     #GRSTK,GR.SP    ;;;SET UP THE STACK POINTER

        .ENDC

        TST     HLTFLG          ;;;SHOULD DISPLAY REMAIN HALTED ?
        BNE     GROUT           ;;;YES
        MOV     #DELAY,(R2)     ;;;NO, START IT UP

;
; DEVICE TIMEOUT
;
; DEVICE TIMEOUT CANNOT OCCUR SINCE THE TIMEOUT COUNT IS NEVER SET.
;

GROUT:  RETURN                  ;;;

;
; BUS-ERROR / SHIFT-OUT INTERRUPT
;
; A BUS ERROR OCCURS WHEN THE DPU ATTEMPTS TO EXECUTE DISPLAY
; INSTRUCTIONS FROM NON-EXISTENT MEMORY.  A SHIFT OUT INTERRUPT OCCURS
; WHEN A CHARACTER >40(8) IS ENCOUNTERED WHILE IN THE SHIFT OUT MODE.
; IN EITHER CASE, MERELY RESTART THE DPU AT THE BEGINNING OF THE BUFFER
;

        .IF DF  V$$S60
$GRBSE::
        .ENDC

;
; DPU STOP INTERRUPT
;
; THE DPU STOP INTERRUPT OCCURS IN THE VT11 ON EITHER A DJSR, DJMP,
; OR DRET PSEUDO INSTRUCTION.  IN EACH CASE THE INTERRUPT HANDLER
; PERFORMS THE NECESSARY FUNCTIONS.  FOR THE VS60, IT OCCURS ONLY
; AT THE END OF THE DELAY LIST AND AT THE END OF THE DISPLAY LIST
;

$GRSTP::CALL    $INTSV,PR4      ;;;START INTERRUPT ROUTINE

        .IF DF  V$$S60

        MOV     GR.PC,R4        ;;;GET THE DPC ADDRESS

        .IF DF  M$$MGE

        TST     DRB(R4)         ;;;END OF DELAY OR LIST ?
        BNE     10$             ;;;END OF MAIN LIST
        MOV     #SRESET,DSP(R4) ;;;RESET DPU STACK
        MOV     TASRB,DRB(R4)   ;;;GET EQUIVALENT RB FOR MAIN LIST
        MOV     BUFST,R5        ;;;ADDRESS OF USER'S SPACE
        ADD     #BFHDR,R5       ;;;PLUS HEADER SIZE
        MOV     R5,(R4)         ;;;START IN USER'S LIST
        RETURN                  ;;;EXIT FROM INTERRUPT
10$:    CLR     DRB(R4)         ;;;CLEAR DPU RB
        TST     HLTFLG          ;;;SHOULD WE REMAIN HALTED ?
        BEQ     20$             ;;;NO
        BIS     #100000,HLTFLG  ;;;YES, SET INDICATOR THAT WE SUCCEEDED
        RETURN                  ;;;EXIT FROM INTERRUPT
20$:    MOV     #DELAY,(R4)     ;;;START DPU IN DELAY LIST
        RETURN                  ;;;EXIT FROM INTERRUPT

        .IFF

        MOV     #SRESET,DSP(R4) ;;;RESET DPU STACK
        TST     HLTFLG          ;;;REMAIN HALTED ?
        BEQ     20$             ;;;NO
        BIS     #100000,HLTFLG  ;;;YES, SET SUCCESS BIT
        RETURN                  ;;;EXIT FROM INTERRUPT
20$:    MOV     #DELAY,(R4)     ;;;RESTART IN DELAY LIST
        RETURN                  ;;;EXIT FROM INTERRUPT

        .ENDC

        .IFF                    ;;; DF V$$S60

        MOV     R2,-(SP)        ;;;SAVE ADDITIONAL REGISTERS
        MOV     R3,-(SP)
        MOV     #GR.PC,R4       ;;;POINT AT LOCAL DATA BASE
        MOV     (R4)+,R2        ;;;GET DPC ADDRESS
        MOV     (R4)+,R3        ;;;GET DPU STACK POINTER

        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;;;SAVE SAR6
        MOV     (R4)+,KISAR6    ;;;AND SET UP FOR USER'S BUFFER

        .IFTF

        MOV     (R2),R5         ;;;GET PHYSICAL ADDRESS OF DHALT +2
        SUB     (R4)+,R5        ;;;SUBTRACT PHYSICAL START OF BUFFER
        BCS     70$             ;;;UNDER BUFFER
        CMP     (R4)+,R5        ;;;COMPARE WITH MAX BUFFER SIZE
        BLO     70$             ;;;ABOVE BUFFER

        .IFT

        ADD     (R4)+,R5        ;;;ADD DIB
10$:    CMP     R5,#157700      ;;;AT THE END OF THE SAR ?
        BLOS    15$             ;;;NO, WE'RE IN RANGE
        SUB     #17700,R5       ;;;MOVE IT UP BY ABOUT 4000. WDS
        ADD     #177,KISAR6     ;;;AND ALSO FIX THE RB
        BR      10$             ;;;TEST AGAIN
15$:

        .IFF

        MOV     (R2),R5         ;;;RESTORE ADDRESS OF DHALT+2

        .IFTF

        MOV     -2(R5),R4       ;;;GET PSEUDO INSTRUCTION
        BIC     #13,R4          ;;;IGNORE SPARE BITS
        CMP     R4,#DJSR        ;;;DJSR ?
        BNE     80$             ;;;NO
        MOV     (R5)+,R4        ;;;GET RETURN ADDRESS
        BEQ     40$             ;;;0 MEANS DRET
        CMP     #GRSTK+32.,R3   ;;;FULL STACK ?
        BLOS    50$             ;;;YES
        MOV     (R2),(R3)+      ;;;PUSH PHYSICAL ADDR OF DHALT+2
                                ;;; FOR LP STUFF
        MOV     R4,(R3)+        ;;;PUSH VIRTUAL RETURN ADDRESS
        MOV     (R5)+,R4        ;;;GET SUBPICTURE VIRTUAL ADDRESS
17$:

        .IFT

        ADD     TASK0,R4        ;;;MAKE ADDRESS PHYSICAL

        .IFTF

        MOV     R4,(R2)         ;;;JUMP TO ADDRESS AND RESTART DPU
20$:

        .IFT

        MOV     (SP)+,KISAR6    ;;;RESTORE MAPPING

        .ENDC                   ;;; DF M$$MGE

        MOV     R3,GR.SP        ;;;SAVE DPU STACK POINTER
        MOV     (SP)+,R3        ;;;RESTORE REGS
        MOV     (SP)+,R2        ;;;
        RETURN                  ;;;EXIT FROM INTERRUPT

40$:    CMP     R3,#GRSTK       ;;;STACK EMPTY ?
        BLOS    90$             ;;;YES, RESTART AT THE TOP
        MOV     -(R3),R4        ;;;GET VIRTUAL RETURN ADDRESS
        TST     -(R3)           ;;;WASTE PHYSICAL ADDR OF DHALT+2
        BR      17$             ;;;GO RELOCATE IT AND RESTART THERE

50$:    DPUERR  <DPU STACK OVERFLOW>

70$:    DPUERR  <DPC OUT OF DISPLAY BUFFER>

80$:    CMP     R4,#DJMP        ;;;IS IT A RELATIVE DJMP ?
        BNE     90$             ;;;NO, UNKNOWN DHALT
        MOV     (R5),R4         ;;;GET ADDRESS
        BR      17$             ;;;GO RELOCATE IT AND RESTART THERE

90$:    MOV     #GRSTK,R3       ;;;UNRECOGNIZED DHALT, RESET STACK
        TST     HLTFLG          ;;;REMAIN HALTED ?
        BEQ     100$            ;;;NO
        BIS     #100000,HLTFLG  ;;;SET SUCCESS BIT
        BR      20$             ;;;EXIT
100$:   MOV     #DELAY,(R2)     ;;;RESTART DISPLAY AT THE BEGINNING
        BR      20$

        .ENDC                   ;;; DF V$$S60

        .ENABL  LSB

60$:                            ;;;REF LABEL

        .IF DF  M$$MGE

        MOV     (SP)+,KISAR6    ;;;RESTORE MAPPING

        .ENDC

65$:    INC     (R5)            ;;;RESTART DPU
66$:    RETURN                  ;;;EXIT
67$:    INC     LPERRS          ;;;COUNT UNKNOWN INTERRUPTS
        BR      65$             ;;;

;
; LIGHT PEN INTERRUPT
;
; THE LIGHT PEN SERVICE ROUTINE STORES THE STATUS OF THE DPU AT THE
; LIGHT PEN HIT INTO THE USER'S DISPLAY BUFFER HEADER, SETS THE LIGHT
; PEN TRIGGER EVENT FLAG, AND INITIATES THE AST.
;

$GRLPI::CALL    $INTSV,PR4      ;;;START INTERRUPT CODE
        MOV     GR.PC,R5        ;;;GET DPC ADDRESS
                                                                                ;**-2
        .IF DF  V$$S60

        MOV     DCS(R5),R4      ;;;GET THE CONSOLE STATUS REG
        BIT     #TON0,R4        ;;;TIP SWITCH FOR SCOPE 1 ON ?
        BEQ     10$             ;;;NO
        INC     TIP1            ;;;YES, SET FLAG
        BR      65$             ;;;EXIT
10$:    BIT     #TOFF0,R4       ;;;TIP SWITCH FOR SCOPE 1 OFF ?
        BEQ     15$             ;;;NO
        CLR     TIP1            ;;;YES, CLEAR FLAG
        BR      65$             ;;;EXIT
15$:

        .IF DF  V$$S2S

        BIT     #TON1,R4        ;;;TIP SWITCH FOR SCOPE 2 ON ?
        BEQ     20$             ;;;NO
        INC     TIP2            ;;;YES SET FLAG
        BR      65$             ;;;EXIT
20$:    BIT     #TOFF1,R4       ;;;TIP SWITCH FOR SCOPE 2 OFF ?
        BEQ     25$             ;;;NO
        CLR     TIP2            ;;;YES, CLEAR FLAG
        BR      65$             ;;;EXIT
25$:    BIT     #LP0+LP1,R4     ;;;LIGHT PEN INTERRUPT ?
        BEQ     67$             ;;;NO, WHAT INTERRUPT ?
        MOV     #1,LPFLAG       ;;;YES, SET FLAG
        BIT     #LP1,R4         ;;;WAS IT SCOPE 2
        BEQ     30$             ;;;NO, MUST HAVE BEEN 1
        INC     LPFLAG          ;;;YES, SET FLAG TO 2
30$:

        .IFF

        BIT     #LP0,R4         ;;;LP INTERRUPT ?
        BEQ     67$             ;;;NO, WHAT INTERRUPT ?

        .ENDC

        .ENDC                   ;;; DF V$$S60
                                                                                ; HM003
        TST     FRKIP           ;;;FORK CURRENTLY IN PROGRESS ?                 ; HM003
        BNE     65$             ;;;YES, FORGET INTERRUPT                        ; HM003

        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;;;SAVE SAR6
        MOV     BUFRB,KISAR6    ;;;SETUP SAR FOR BUFFER
        MOV     BUFDB,R4        ;;;ALSO DIB

        .IFF

        MOV     BUFST,R4        ;;;GET ADDRESS OF LP STUFF

        .IFTF

        TST     (R4)+           ;;;IS THE LOCK SET ?
        BNE     60$             ;;;YES, DON'T CHANGE INFO WHILE ITS BEING READ
        MOV     R4,-(SP)        ;;;SAVE NAME LIST  ADDRESS
        ADD     #NAMSIZ,R4      ;;;SKIP OVER IT FOR NOW

        .IF DF  V$$S60


        .IF DF  M$$MGE

        MOV     (R5)+,(R4)      ;;;PUT IN DPC AT HIT
        SUB     DPCFIX,(R4)+    ;;;SUBTRACT LOW BITS OF RELOCATION VALUE

        .IFF


        MOV     (R5)+,(R4)+     ;;;PUT IN DPC AT HIT

        .ENDC

        MOV     (R5)+,(R4)+     ;;;PUT IN CSR AT HIT
        MOV     (R5)+,(R4)+     ;;;PUT IN X POS AT HIT
        MOV     (R5)+,(R4)+     ;;;PUT IN Y POS AT HIT
        TST     (R5)+           ;;;SKIP DPU RB
        MOV     (R5)+,(R4)+     ;;;COPY EXTENDED STATUS
        MOV     (R5)+,(R4)+     ;;;X OFFSET
        MOV     (R5)+,(R4)+     ;;;Y OFFSET
        MOV     DOS-DNR(R5),(R4)+ ;;;OFFSET SIGNS

        .IFF

        .IF DF  M$$MGE

        MOV     (R5)+,(R4)      ;;;RETRIEVE DPC AT HIT
        SUB     TASK0,(R4)+     ;;;CONVERT TO PHYSICAL AND STORE

        .IFF

        MOV     (R5)+,(R4)+     ;;;PUT IN DPC AT HIT

        .ENDC

        MOV     (R5)+,(R4)+     ;;;PUT IN CSR AT HIT
        MOV     (R5)+,(R4)+     ;;;PUT IN X POS AT HIT
        MOV     (R5)+,(R4)+     ;;;PUT IN Y POS AT HIT
        CLR     (R4)+           ;;;NO EXTENDED STATUS FOR VT11
        CLR     (R4)+           ;;;ALSO NO X OFFSET
        CLR     (R4)+           ;;;ALSO NO Y OFFSET
        CLR     (R4)+           ;;;ALSO NO XY OFFSET SIGNS

        .IFTF

        MOV     TIP1,(R4)+      ;;;COPY TIP SWITCH 1 STATUS

        .IF NDF V$$S2S

        CLR     (R4)+           ;;;NO TIP SWITCH 2
        MOV     #1,(R4)         ;;;SET LP FLAG

        .IFF

        MOV     TIP2,(R4)+      ;;;COPY TIP SWITCH 2
        MOV     LPFLAG,(R4)     ;;;COPY IN LP FLAG

        .ENDC

        MOV     (SP),R4         ;;;RESTORE NAME LIST ADDRESS
        MOV     R3,(SP)         ;;;SAVE R3

        .IFT                    ;;; DF V$$S60

        MOV     DSP-DNR(R5),R3  ;;;GET CURRENT STACK POINTER
        BIC     #177703,R3      ;;;ISOLATE WORD SELECT BITS
        MOV     R3,-(SP)        ;;;SAVE 'EM
40$:    CMP     R3,#SRESET      ;;;TOP OF STACK ?
        BHIS    45$             ;;;YES
        MOV     R3,DSP-DNR(R5)  ;;;NO, SELECT THIS LEVEL
        MOV     DST-DNR(R5),(R4)+ ;;;COPY DPC FOR THIS LEVEL
        ADD     #4,R3           ;;;MOVE UP ONE LEVEL
        BR      40$             ;;;LOOP
45$:    MOV     (SP)+,DSP-DNR(R5) ;;;RESTORE ORIGINAL LEVEL

        .IFF

        MOV     GR.SP,R3        ;;;GET DPU STACK POINTER
40$:    CMP     R3,#GRSTK       ;;;AT TOP YET ?
        BLOS    45$             ;;;YES
        TST     -(R3)           ;;;SKIP VIRTUAL RETURN ADDRESS

        .IF NDF M$$MGE

        MOV     -(R3),(R4)+     ;;;POINT TO VIRTUAL RETURN ADDR

        .IFF

        MOV     -(R3),(R4)      ;;;PHYSICAL POINTER TO VRA
        SUB     TASK0,(R4)+     ;;;VIRTUAL POINTER TO VRA

        .ENDC

        BR      40$             ;;;LOOP
45$:

        .ENDC                   ;;; DF V$$S60

        .ENDC                   ;;; DF M$$MGE

        MOV     (SP)+,R3        ;;;RESTORE R3
        MOV     #-2,(R4)        ;;;INSERT TERMINATOR

        .IF DF  M$$MGE

        MOV     (SP)+,KISAR6    ;;;RESTORE MAPPING

        .IFTF

        MOV     #$GRFRK+6,R4    ;;;SET ADDRESS OF FORK BLOCK
        MOV     #FRKIP,R5       ;;;POINT AT LOCAL DATA
        INC     (R5)            ;;;SET FORK IN PROGRESS FLAG
        INC     @GR.PC          ;;;RESTART DPU
        CALL    $FORK1          ;;;FORK


        CLR     (R5)            ;CLEAR FORK IN PROGRESS FLAG
        MOV     -(R5),R4        ;GET TCB ADDRESS OF CONNECTED TASK
        BIT     #T2.ABO,T.ST2(R4) ;TASK CURRENTLY BEING ABORTED ?
        BNE     66$             ;YES, DON'T MEDDLE
        BIS     -(R5),@-(R5)    ;SET LIGHT PEN TRIGGER EVENT FLAG

        .IF DF  A$$TRP

        TST     -(R5)           ;AST DEFINED ?
        BEQ     50$             ;NO, COOL IT
        BIT     #T2.AST!T2.DST,T.ST2(R4) ;AST IN PROGRESS OR DISABLED ?
        BNE     50$             ;YES, DON'T START ANOTHER (Q MIGHT GET FULL)
        TST     T.ASTL(R4)      ;AST QUEUED ALREADY ?
        BNE     50$             ;YES, ASSUME ITS OURS AND COOL IT
        MOV     #5*2,R1         ;SIZE OF AST CONTROL BLOCK
        CALL    $ALOCB          ;ALLOCATE SOME CORE
        BCS     50$             ;NONE AVAILABLE, FORGET IT
        MOV     R0,R1           ;COPY ADDRESS OF BLOCK
        CLR     (R0)+           ;SKIP LINK WORD
        MOV     #5*2,(R0)+      ;SAVE BLOCK SIZE
        MOV     #7*2,(R0)+      ;SPACE TO ALLOCATE ON USER STACK
        MOV     (R5),(R0)+      ;AST ADDRESS
        CLR     (R0)            ;NO PARAMETERS
        MOV     R4,R0           ;GET TCB ADDRESS
        ADD     #T.ASTL,R0      ;MAKE IT POINTER TO AST LISTHEAD
        CALL    $QINSF          ;INSERT AST IN Q

        .ENDC

50$:    MOV     R4,R0           ;COPY TCB ADDRESS
        CALLR   $SETCR          ;REQUEST USER'S TASK

        .ENDC                   ; DF M$$MGE

        .DSABL  LSB

;
; BUS-ERROR / SHIFT-OUT INTERRUPT
;
; A BUS ERROR OCCURS WHEN THE DPU ATTEMPTS TO EXECUTE DISPLAY
; INSTRUCTIONS FROM NON-EXISTENT MEMORY.  A SHIFT OUT INTERRUPT OCCURS
; WHEN A CHARACTER >40(8) IS ENCOUNTERED WHILE IN SHIFT OUT MODE.
; IN EITHER CASE, MERELY RESTART THE DPU AT THE BEGINNING OF THE BUFFER
;

        .IF DF  V$$T11

$GRBSE::

        MOV     #GRSTK,GR.SP    ;;;RESET DPU STACK POINTER
        MOV     #DELAY,@GR.PC   ;;;RESTART DISPLAY AT THE BEGINNING
        RTI                     ;;;INTERRUPT FINISHED

        .ENDC

        .END
        .TITLE  ICDRV
        .IDENT  /02.02/
 
;
; COPYRIGHT (C) 1975, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 02
;
; C. MONIA 05-APR-75
;
; PREVIOUSLY MODIFIED BY:
;
;       T. J. MILLER
;       C. A. MONIA
;
; MODIFIED BY:
;
;       G. H. KUENNING 09-AUG-77
;
;               GK001 -- CHECK FOR EXISTENCE OF CIRCULAR BUFFER
;                       BEFORE USING IT.  (SPR # 11-12905).
;
;       G. H. KUENNING 13-OCT-77
;
;               GK002 -- WHEN UNLINKING INTERRUPTS FROM TASKS, DON'T
;                       RESTORE REGISTERS THAT WEREN'T SAVED.
;
;       G. H. KUENNING 17-JAN-78
;
;               GK004 -- MOVE A MISPLACED LABEL THAT CAUSES A SYSTEM
;                       CRASH WHEN AN I/O CANCEL IS DONE ON AN ICS/ICR.
;
;       G. H. KUENNING 30-JAN-79
;
;               GK005 -- ON STARTUP, READ THE CURRENT STATE OF THE
;                       DIGITAL INTERRUPT POINTS RATHER THAN SETTING THE
;                       CURRENT STATE TO ZERO.
;
; ICR/ICS-11 INDUSTRIAL CONTROL SUBSYSTEM DRIVER
;
; EQUATED SYMBOLS
;
; A/D CONVERTER TABLE OFFSETS
;

        .ASECT

.=0
ADMXC:  .BLKW   1               ; MAXIMUM A/D CHANNEL NUMBER
ADFR:   .BLKB   1               ; FORK REQUEST FLAG
ADIP:   .BLKB   1               ; I/O CONVERSIONS IN-PROGRESS COUNT
ADNXT:  .BLKW   1               ; TABLE ADDRESS OF NEXT ADU02
ADNXA:  .BLKW   2               ; USER BUFFER ADDRESS DOUBLEWORD OF NEXT
ADNXB:  .BLKW   1               ; BYTE COUNT FOR NEXT TRANSFER
ADNXC:  .BLKW   1               ; CONTROL WORD FOR NEXT TRANSFER
ADFBC:  .BLKW   1               ; FINAL BYTE COUNT
ADSTS:  .BLKW   1               ; I/O COMPLETION STATUS

;
; A/D CONVERTER TABLE ENTRY OFFSETS
;

.=0
ADHCH:  .BLKB   1               ; HIGHEST CHANNEL NUMBER ON THIS MODULE
ADBSY:  .BLKB   1               ; ADU02 BUSY FLAG
ADUAD:  .BLKW   2               ; ADDRESS DOUBLEWORD
ADBTC:  .BLKW   1               ; BYTE COUNT FOR THIS CONVERSION
ADMBA:  .BLKW   1               ; ADU02 BUS ADDRESS
ADLGH:  .BLKW   0               ; LENGTH OF A/D MODULE ENTRY

;
; CIRCULAR BUFFER HEADER OFFSETS
;

.=0
CBSY:   .BLKW   1               ; BUSY COUNT
COUT:   .BLKW   1               ; OUTPUT POINTER
CIN:    .BLKW   1               ; INPUT POINTER
CMAX:   .BLKW   1               ; ADDRESS OF END OF BUFFER
CDAT:   .BLKW   16.             ; DATA AREA
CLGH:   .BLKW   0               ; LENGTH OF CIRCULAR BUFFER

;
; ICR DEVICE TABLE OFFSETS
;

.=0
ICMAX:  .BLKW   1               ; MAXIMUM PHYSICAL UNIT NUMBER
ICRES:  .BLKW   1               ; ERROR RESOURCE MASK
ICELH:  .BLKW   2               ; ERROR INTERRUPT LISTHEAD
ICLTL:  .BLKW   2               ; LINKED TASK LISTHEAD

;
; INTERRUPT LINKAGE ENTRY OFFSETS
;

.=0
ILNXT:  .BLKW   1               ; LINK TO NEXT
ILMSK:  .BLKW   1               ; RESOURCE MASK WORD
ILTE:   .BLKW   1               ; ADDRESS OF LINKED TASK ENTRY
ILEVM:  .BLKW   1               ; EVENT FLAG MASK WORD
ILEVA:  .BLKW   1               ; EVENT FLAG MASK ADDRESS
ILRUN:  .BLKW   1               ; RUN FLAG
ILGH:   .BLKW   0               ; LENGTH OF ENTRY

;
; UNSOLICITED INTERRUPTING MODULE OFFSETS
;

.=0
IMAX:   .BLKW   1               ; HIGHEST POINT OR CHANNEL
IMBPE:  .BLKB   1               ; BYTES PER CIRCULAR BUFFER ENTRY
IMFIP:  .BLKB   1               ; FORK-IN-PROGRESS FLAG
IMSBF:  .BLKW   1               ; STARTING BUFFER RELOCATION BIAS
IMCBF:  .BLKW   1               ; CURRENT BUFFER RELOCATION BIAS
IMSAD:  .BLKW   1               ; ADDRESS OF START OF BUFFER
IMSDA:  .BLKW   1               ; ADDRESS OF START OF DATA
IMCUR:  .BLKW   1               ; ADDRESS OF CURRENT ENTRY
IMFIL:  .BLKW   1               ; CURRENT FORTRAN FILL INDEX
IMLGH:  .BLKW   1               ; LENGTH OF CIRCULAR BUFFER IN WORDS
IMEVM:  .BLKW   1               ; EVENT FLAG MASK WORD
IMEVA:  .BLKW   1               ; EVENT FLAG MASK ADDRESS
IMLST:  .BLKW   1               ; LOST DATA COUNT
IMTCB:  .BLKW   1               ; TCB ADDRESS OF CONNECTED TASK
IMFRK:  .BLKW   3               ; INTERRUPT FORK BLOCK
IMSCB:  .BLKW   1               ; SCB BACKPOINTER

IMDAT:  .BLKW   0               ; OFFSET TO MODULE DATA

;
; INTERRUPT MODULE ENTRY OFFSETS
;

.=0
IMRES:  .BLKW   1               ; DIGITAL INTERRUPT RESOURCE MASK
IMLH:   .BLKW   2               ; INTERRUPT LINK LISTHEAD
IMPRV:  .BLKW   1               ; PREVIOUS STATE OF MODULE
RTLGH:  .BLKW   0               ; LENGTH OF REMOTE TERMINAL ENTRY       ;**-1
IMBA:   .BLKW   1               ; BUS ADDRESS OF MODULE
CILGH:  .BLKW   0               ; LENGTH OF DIGITAL INTERRUPT ENTRY     ; GK005
CTLGH:  .BLKW   0               ; LENGTH OF COUNTER MODULE ENTRY

;
; LINKED TASK ENTRY OFFSETS
;

.=0
LNEXT:  .BLKW   1               ; LINK TO NEXT (0=NONE)
LUSE:   .BLKW   1               ; NUMBER OF LINKAGES IN USE
LTCB:   .BLKW   1               ; TASK TCB ADDRESS
LACT:   .BLKW   1               ; ACTIVITY COUNT
LPHY:   .BLKW   1               ; PHYSICAL UNIT NUMBER
LGEN:   .BLKW   1               ; GENERIC CODE
LREL:   .BLKW   1               ; RELATIVE MODULE NUMBER
LHWR:   .BLKW   2               ; HARDWARE DEPENDANT DATA
LPAD:   .BLKW   1               ; PAD ENTRY TO MULTIPLE OF ALLOCATION INCREMENT
LLGH:   .BLKW   0               ; LENGTH OF ENTRY

;
; QIO ADDRESS CHECKING FLAGS
;

CHADR=000001                    ; BUFFER ADDRESS MUST BE ON WORD BOUNDARY (1=YES)
CHBYT=000002                    ; BYTE COUNT MUST BE EVEN(1=YES)

;
; SCB FLAGS WORD BIT DEFINITIONS
;

UFL=000001                      ; UNIT OFFLINE (1=YES)
UNR=000002                      ; UNIT NOT-READY (1=YES)
TUND=000004                     ; TERMINAL OUTPUT UNDERWAY (1=YES)
TUSE=000010                     ; TERMINAL IN USE (1=YES)
NORSP=000020                    ; NO RESPONSE FROM CONTROLLER (1=YES)
TABO=000040                     ; ABORT TERMINAL OUTPUT (1=YES)

;
; ICS/ICR INTERRUPT TIMEOUT COUNT
;

TMOUT=50.                       ;

;
; FIRST EXTERNAL PAGE ADDRESS
;

ICMD=171000                     ;

        .PSECT

;
; LOCAL DATA
;
; DRIVER DISPATCH TABLE
;

$ICTBL::.WORD   ICHK            ; DEVICE INITIATOR ENTRY POINT
        .WORD   ICAN            ; CANCEL I/O OPERATION ENTRY POINT
        .WORD   ICOUT           ; DEVICE TIMEOUT ENTRY POINT
        .WORD   ICPWF           ; POWER RECOVERY ENTRY POINT

;
; UCB ADDRESSES
;

        .IF DF  I$$CAD!I$$CIM!I$$CTI!I$$CR


CNTBL:  .BLKW   I$$C11          ;

;
; ADDRESS OF CURRENT CSR
;

CSR:    .BLKW   1               ;

;
; ICR DEVICE TABLE
;

        .IF DF  I$$CLK

ICDVT:  .WORD   I$$C11-1        ; MAXIMUM PHYSICAL UNIT NUMBER
        .WORD   0               ; ERROR INTERRUPT RESOURCE MASK
        .WORD   0               ; ERROR INTERRUPT LISTHEAD
        .WORD   .-2             ; LAST POINTS TO FIRST INITIALLY
        .WORD   0               ; LINKED TASK LISTHEAD
        .WORD   .-2             ; LAST POINTS TO FIRST INITIALLY

        .ENDC

        .ENDC

;
; LEGAL FUNCTION CODES AND DISPATCH TABLE
;
; EACH ENTRY CONSISTS OF TWO WORDS CONTAINING THE FOLLOWING
; INFORMATION:
;
;       WD. 00 -- QIO FUNCTION CODE.
;       WD. 01 -- ADDRESS OF PROCESSOR/2 ! CONTROL FUNCTION FLAG (MSB).
;
; IF MSB .EQ. 1 THEN THE FUNCTION REQUIRES THE TRANSMISSION OF DATA
; TO OR FROM THE DEVICE.
;

ICDIS:                          ;

        .IF DF  I$$CDA

        .WORD   IO.SAO,100000!<AOUT/2&77777> ; ANALOG OUTPUT

        .ENDC

        .IF DF  I$$CSS

        .WORD   IO.MSO,100000!<SSOUT/2&77777> ; MOMENTARY DIGITAL OUTPUTS

        .ENDC

        .IF DF  I$$CLT

        .WORD   IO.MLO,100000!<LTOUT/2&77777> ; LATCHING OUTPUTS

        .ENDC

        .IF DF  I$$CAD

        .WORD   IO.RBC!CHADR!CHBYT,100000!<ADINI/2&77777> ; READ MULTIPLE A/D CHANNELS

        .ENDC

        .IF DF  I$$CIM

        .WORD   IO.CCI!CHADR!CHBYT,CICNT/2&77777 ; CONTACT INTERRUPT CONNECT
        .WORD   IO.DCI,CIDCT/2&77777 ; CONTACT INTERRUPT DISCONNECT

        .IF DF  I$$CLK

        .WORD   IO.LDI,CILNK/2&77777 ; LINK TO DIGITAL INTERRUPTS
        .WORD   IO.UDI,CIUNL/2&77777 ; UNLINK DIGITIAL INTERRUPTS

        .ENDC


        .ENDC

        .IF DF  I$$CTI

        .WORD   IO.CTI!CHADR!CHBYT,100000!<CTCNT/2&77777> ; COUNTER MODULE CONNECT
        .WORD   IO.DTI,CTDCT/2&77777 ; COUNTER MODULE DISCONNECT

        .IF DF  I$$CLK

        .WORD   IO.LTI,CTLNK/2&77777 ; LINK TO COUNTER MODULE INTERRUPTS
        .WORD   IO.UTI,CTUNL/2&77777 ; UNLINK FROM COUNTER INTERRUPTS

        .ENDC

        .WORD   IO.ITI,100000!<CTINI/2&77777> ; INITIALIZE COUNTER

        .ENDC

        .IF DF  I$$CR

        .WORD   IO.WLB,100000!<RTINI/2&77777> ; OUTPUT TO REMOTE TERMINAL
        .WORD   IO.CTY!CHADR!CHBYT,RTCNT/2&77777 ; REMOTE TERMINAL CONNECT
        .WORD   IO.DTY,RTDCT/2&77777 ; REMOTE TERMINAL DISCONNECT

        .IF DF  I$$CLK

        .WORD   IO.LTY,RTLNK/2&77777 ; LINK TO REMOTE TERMINAL INTERRUPTS
        .WORD   IO.UTY,RTUNL/2&77777 ; UNLINK REMOTE TERMINAL INTERRUPTS
        .WORD   IO.LKE,ERLNK/2&77777 ; LINK TO ERROR INTERRUPTS
        .WORD   IO.UER,ERUNL/2&77777 ; UNLINK ERROR INTERRUPTS

        .ENDC


        .ENDC

        .IF DF  I$$CIM!I$$CTI!I$$CR&I$$CLK

        .WORD   IO.NLK,UNLNK/2&77777 ; UNLINK FROM ALL INTERRUPTS

        .IFTF

        .WORD   IO.ONL,ICONL/2&77777 ; UNIT TO ONLINE
        .WORD   IO.FLN,ICFLN/2&77777 ; UNIT TO OFFLINE

        .IFT

        .WORD   IO.RAD,RDACT/2&77777 ; READ ACTIVATING DATA

        .ENDC

        .IF DF  I$$CDB

        .WORD   IO.ATT,ICDON/2&77777 ; NO-OP THE ATTACH FUNCTION
        .WORD   IO.DET,ICDON/2&77777 ; NO-OP THE DETACH FUNCTION

        .ENDC

        .WORD   0               ; END OF TABLE

;
; ADDRESS OF CURRENT UCB
;

        .IF DF  I$$CAD!I$$CIM!I$$CR!I$$CTI

        .IF GT  I$$C11-1

ICUCB:  .BLKW   1               ;

        .ENDC

;
; FLAG TO INTIATE FORK PROCESSING FOR UNSOLICITED INTERRUPTS
;

RUN:    .BLKW   1               ;

;
; NAME OF TASK BEING UNLINKED
;

        .IF DF  I$$CLK

TASK:   .BLKW   2               ;

        .ENDC



;
; TEMPORARY INTERRUPT PSW STORAGE
;

TMP:    .WORD   0               ;

;
; WATCHDOG TIMER FLAG
;

        .IF DF  I$$CR

WDFLG:  .WORD   0               ; IF NE 0 THEN TIMER SCHEDULED
        .BLKW   5               ; CLOCK QUEUE ENTRY
        .WORD   ICWDT           ; ADDRESS OF INTERNAL SUBROUTINE

        .IF DF  L$$DRV&M$$MGE

        .WORD   0               ;

        .ENDC

        .ENDC

        .ENDC

;+
;
; **-ICHK-ICS/ICR-11 INDUSTRIAL CONTROL SUBSYSTEM PARAMETER CHECKING
;
; THIS ROUTINE IS ENTERED FROM QIO DIRECTIVE PROCESSING WHEN AN
; I/O REQUEST IS RECIEVED FOR THE ICS/ICR-11 INDUSTRIAL CONTROL
; SUBSYSTEMS DEVICES. ICS/ICR-11 REQUESTS CONTAIN PARAMETERS THAT
; MUST BE CHECKED IN THE CONTEXT OF THE ISSUING TASK. THEREFORE
; THE I/O REQUEST IS NOT QUEUED BEFORE CALLING THE DRIVER.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK
;
; OUTPUTS:
;
;       DEPENDANT UPON FUNCTION TO BE PERFORMED
;
; ICS/ICR-11 FUNCTION INDEPENDANT I/O PACKET
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF REQUESTER TASK TCB.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE.
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;
;-

ICHK:                           ;
        MOV     R1,-(SP)        ; SAVE I/O PACKET ADDRESS
        MOV     I.FCN(R1),R2    ; GET FUNCTION CODE
        BIC     #7,R2           ; CLEAR UNRECOGNIZED FLAGS
        ADD     #I.PRM,R1       ; POINT TO PARAMETER BLOCK
        MOV     #ICDIS-2,R3     ; POINT TO DISPATCH TABLE
10$:                            ;
        TST     (R3)+           ; STEP TO NEXT ENTRY
        TST     (R3)            ; AT END OF LIST?
        BEQ     ICIF            ; IF EQ YES - ILLEGAL FUNCTION
        MOV     (R3)+,-(SP)     ; PUSH FUNCTION CODE
        BIC     #7,(SP)         ; CLEAR FLAGS
        CMP     (SP)+,R2        ; TEST FUNCTION CODE
        BNE     10$             ; IF NE TRY NEXT FUNCTION
        MOV     R1,R0           ; COPY PARAMETER BLOCK ADDRESS
        MOV     -2(R3),R2       ; GET FUNCTION CODE AGAIN
12$:                            ;
        BIC     #^C<7>,R2       ; CLEAR ALL BUT ALIGNMENT FLAGS
        BEQ     15$             ; IF EQ NO MORE TESTS TO MAKE
        TST     (R0)+           ; STEP TO NEXT PARAMETER
        ROR     R2              ; ROTATE ALIGNMENT FLAGS
        BCC     12$             ; IF C/C BYPASS CHECK
        BIT     #1,(R0)         ; PARAMETER WORD ALIGNED?
        BNE     ICBY            ; IF NE NO
        BR      12$             ; GO AGAIN
15$:                            ;
        MOV     (R3),R3         ; GET ADDRESS OF PROCESSOR
        ASL     R3              ; CONVERT TO WORD ADDRESS, PUT CONTROL FLAG IN C
        MOV     I.TCB-I.PRM(R1),R0 ; GET TCB ADDRESS
        BCC     20$             ; IF C/C NOT A CONTROLLER FUNCTION
        BIT     #UFL,S.FLG(R4)  ; UNIT OFFLINE?

        .IF DF  I$$CR

        BNE     17$             ; IF NE YES
        BIT     #UNR,S.FLG(R4)  ; UNIT NOT READY?
        BNE     ICDN            ; IF NE YES
        BR      20$             ; ALLOW I/O

        .IFF

        BEQ     20$             ; IF EQ NOT OFFLINE

        .ENDC

17$:                            ;
        BIT     #T3.PRV,T.ST3(R0) ; TASK PRIVILEGED?
        BEQ     ICPR            ; IF EQ NO, PRIVELEGE VIOLATION
20$:                            ;
        JMP     (R3)            ; TRANSFER CONTROL TO PROCESSOR


;+
;
; **-ICFLN-PUT CONTROLLER OFFLINE
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- UNUSED
;       WD. 13 -- UNUSED
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

ICFLN:                          ;
        BIT     #T3.PRV,T.ST3(R0) ; TASK PRIVILEGED?
        BEQ     ICPR            ; IF EQ NO
        BIT     #UFL,S.FLG(R4)  ; UNIT ALREADY OFFLINE?
        BNE     ICFLE           ; IF NE YES
        MOVB    #PR6,PS         ;;; INHIBIT DEVICE INTERRUPTS
        BIC     #22,@S.CSR(R4)  ;;; DISABLE ERROR INTERRUPTS
        BIS     #UFL,S.FLG(R4)  ;;; SET UNIT OFFLINE
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        BR      ICD             ;

;+
;
; **-ICONL-PLACE CONTROLLER ONLINE
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- UNUSED
;       WD. 13 -- UNUSED
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

ICONL:                          ;
        BIT     #T3.PRV,T.ST3(R0) ; TASK PRIVILEGED?
        BEQ     ICPR            ; IF EQ NO
        MOVB    #PR6,PS         ;;; INHIBIT DEVICE INTERRUPTS
        BIS     #26,@S.CSR(R4)  ;;; ENABLE INTERRUPTS
        BIC     #UFL!UNR,S.FLG(R4) ;;; CLEAR NOT-READY, OFFLINE BITS
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS

;
; INTERMEDIATE BRANCH POINTS TO ERROR EXITS
;

ICD:    JMP     ICDON           ; SUCCESSFUL COMPLETION
ICBY:   JMP     ICBYT           ; BUFFER BYTE ALIGNED
ICIF:   JMP     ICIFC           ; ILLEGAL FUNCTION CODE
ICDN:   JMP     ICDNR           ; DEVICE NOT READY
ICPR:   JMP     ICPRI           ; PRIVELEGE VIOLATION
ICMO:   JMP     ICMOD           ; ILLEGAL MODULE NUMBER

        .IF DF  I$$CLK

ICIE:   JMP     ICIEF           ; ILLEGAL EVENT FLAG

        .ENDC

;
; REQUEST HAS BAD PARAMETERS
;

ICBAD:                          ;
        MOV     #IE.BAD&377,R0  ;
        BR      ICFLE1          ;

;
; RESOURCE IN USE
;

        .IF DF  I$$CIM!I$$CR!I$$CTI&I$$CLK

ICRSU:                          ;
        MOV     #IE.RSU&377,R0  ;
        BR      ICFLE1          ;

        .ENDC

;
; DEVICE ALREADY OFFLINE
;

ICFLE:                          ;
        MOV     #IE.FLN&377,R0  ;
ICFLE1:                         ;
        JMP     ICOMN           ;

;+
;
; **-CILNK-LINK TO CONTACT INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 NAME
;       WD. 13 -- WORD 1 OF RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- EVENT FLAG NUMBER
;       WD. 16 -- POINT NUMBER
;       WD. 17 -- CHANGE OF STATE MASK
;
;-

        .ENABL  LSB

        .IF DF  I$$CLK


        .IF DF  I$$CIM

CILNK:                          ;
        MOV     S.DI(R4),R0     ; GET ADDRESS OF CONTACT INTERRUPT TABLE
        MOV     10(R1),R2       ; GET POINT NUMBER
        BIT     #17,R2          ; POINT ON MODULE BOUNDARY?
        BNE     ICMO            ; IF NE NO
        ASR     R2              ; COMPUTE TABLE INDEX
        ASR     R2              ; ...                                   ; GK005
        ADD     10(R1),R2       ; ...                                   ; GK005
        ASR     R2              ; ...                                   ; GK005
        MOV     12(R1),4(R1)    ; SET RESOURCE MASK
        BEQ     ICBAD           ; IF EQ BAD PARAMETERS
        CLR     12(R1)          ; CLEAR COUNTER FLAG
        BR      20$             ;

        .ENDC

;+
;
; **-CTLNK-LINK TO COUNTER MODULE INTERRUPTS:
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 TASK NAME
;       WD. 13 -- WORD 1 OF RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- EVENT FLAG NUMBER
;       WD. 16 -- RELATIVE COUNTER NUMBER
;       WD. 17 -- COUNTER INITIAL VALUE
;
;-

        .IF DF  I$$CTI

CTLNK:                          ;
        MOV     S.CT(R4),R0     ; GET ADDRESS OF COUNTER TABLES
        MOV     10(R1),R2       ; GET COUNTER NUMBER
        ASL     R2              ; COMPUTE TABLE INDEX
        ASL     R2              ; ...
        ADD     10(R1),R2       ; ...
        ASL     R2              ; ...
        BR      10$             ;

        .ENDC

;+
;
; **-ERLNK-LINK TO ERROR INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 TASK NAME
;       WD. 13 -- WORD 1 OF RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- EVENT FLAG NUMBER
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CR

ERLNK:                          ;
        MOV     #ICDVT+ICRES,R2 ; POINT TO RESOURCE MASK
        MOV     #-1,4(R1)       ; SET RESOURCE MASK FOR REQUEST
        CLR     12(R1)          ; CLEAR COUNTER FLAG
        BR      30$             ;

;+
;
; **-RTLNK-LINK TO REMOTE TERMINAL INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 TASK NAME
;       WD. 13 __ WORD 1 OF RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- EVENT FLAG NUMBER
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

RTLNK:                          ;
        MOV     S.RTI(R4),R0    ; GET REMOTE TERMINAL TABLE ADDRESS
        CLR     R2              ; CLEAR OFFSET TO MODULE ENTRY
        CLR     10(R1)          ; CLEAR MODULE NUMBER
        CLR     12(R1)          ; CLEAR COUNTER FLAG

        .ENDC

        .IF DF  I$$CIM!I$$CR!I$$CTI

10$:                            ;
        MOV     #-1,4(R1)       ; SET RESOURCE MASK
20$:                            ;
        TST     R0              ; MODULE EXIST
        BEQ     ICMO            ; IF EQ NO
        CMP     10(R1),(R0)     ; LEGAL POINT NUMBER
        BHI     ICMO            ; IF HI NO
        ADD     R0,R2           ; COMPUTE MODULE ENTRY ADDRESS
        ADD     #IMDAT+IMRES,R2 ; POINT TO RESOURCE MASK
30$:                            ;
        BIT     4(R1),(R2)+     ; RESOURCE IN USE?
        BNE     ICRSU           ; IF NE YES
        MOV     R1,R3           ; COPY ADDRESS OF TASK NAME
        CALL    $SRSTD          ; SEARCH TCB LIST FOR TASK
        BCS     ICNST           ; IF C/S TASK NOT INSTALLED
        CMP     6(R1),#64.      ; LEGAL EVENT FLAG SPECIFIED?
        BHI     ICIE            ; IF HI NO
        MOV     R2,(R1)+        ; SAVE LISTHEAD ADDRESS
        MOV     R5,-(SP)        ; SAVE R5
        MOV     R1,-(SP)        ; SAVE ADDRESS OF PARAMETER BLOCK
        MOV     R0,R5           ; COPY TCB ADDRESS
        MOV     4(R1),R0        ; GET EVENT FLAG NUMBER
        CALL    $CEFI           ; CONVERT TO MASK AND ADDRESS
        MOV     (SP),R3         ; COPY PARAMETER BLOCK ADDRESS
        MOV     R0,(R3)+        ; SAVE MASK
        MOV     (R3)+,(R3)      ; MOVE RESOURCE MASK OUT OF THE WAY
        MOV     R1,-(R3)        ; SAVE ADDRESS
        MOV     #LLGH+ILGH,R1   ; GET LENGTH OF LINKED TASK+INTERRUPT LINK ENTRIES
        MOV     #ICDVT+ICLTL,R3 ; POINT TO INTERRUPT LINK LISTHEAD
40$:                            ;
        MOV     (R3),R3         ; GET ADDRESS OF NEXT ENTRY
        BEQ     50$             ; IF EQ REACHED END OF LIST
        CMP     R5,LTCB(R3)     ; THIS TASK LINKED ONCE?
        BEQ     60$             ; IF EQ YES
        BR      40$             ; GO AGAIN
50$:                            ;
        CALL    $ALOCB          ; ALLOCATE BLOCK
        BCS     ICNOD           ; IF C/S NO MORE STORAGE
        CLR     (R0)            ; CLEAR LINK TO NEXT
        MOV     R0,@ICDVT+ICLTL+2 ; LINK TO LAST ENTRY
        MOV     R0,ICDVT+ICLTL+2 ; SET NEW LAST
        MOV     R5,LTCB(R0)     ; SET TCB ADDRESS
        CLR     LUSE(R0)        ; CLEAR USE COUNT
        CLR     LACT(R0)        ; CLEAR ACTIVITY COUNT
        MOV     R0,R5           ; COPY LINKED TASK ENTRY ADDRESS
        ADD     #LLGH,R0        ; POINT TO INTERRUPT LINK ENTRY
        BR      70$             ;
60$:                            ;
        MOV     R3,R5           ; COPY LINKED TASK ENTRY
        MOV     #ILGH,R1        ; SET LENGTH OF INTERRUPT LINK ENTRY
        CALL    $ALOCB          ; ALLOCATE BLOCK
        BCS     ICNOD           ; IF C/S NO STORAGE AVAILABLE
70$:                            ;
        INC     LUSE(R5)        ; INCREMENT USE COUNT
        MOV     R5,ILTE(R0)     ; SET POINTER TO LINKED ENTRY
        MOV     (SP)+,R1        ; RESTORE R1
        MOV     (SP)+,R5        ; RESTORE R5
        MOV     -2(R1),R2       ; RETRIEVE INTERRUPT LINK LISTHEAD
        MOV     R0,R3           ; COPY ADDRESS OF INTERRUPT LINK ENTRY
        CLR     (R3)+           ; CLEAR LINK TO NEXT
        CMP     (R3)+,(R3)+     ; POINT TO EVENT FLAG MASK
        MOV     (R1)+,(R3)+     ; SAVE EVENT FLAG MASK
        MOV     (R1)+,(R3)+     ; SAVE EVENT FLAG ADDRESS
        CLR     (R3)            ; CLEAR RUN FLAG
        MOVB    #PR6,PS         ;;; INHIBIT DEVICE INTERRUPTS
        MOV     R0,@2(R2)       ;;; LINK THIS ENTRY AS LAST
        MOV     R0,2(R2)        ;;; SET NEW LAST
        BIS     (R1),-(R2)      ;;; SET RESOURCE MASK
        MOV     (R1)+,ILMSK(R0) ;;; SET INTERRUPT MASK
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS

        .IF DF  I$$CTI

        MOV     IMBA(R2),(R1)   ; COPY BUS ADDRESS
        MOV     2(R1),-(R1)     ; COPY COUNTER VALUE
        BEQ     80$             ; IF EQ COUNTER NOT TO BE SET
        MOV     (R1),IMPRV(R2)  ; RESET PREVIOUS STATE
        MOV     R1,R3           ; SET ADDRESS OF MODULE ENTRY
        CALL    SETCT           ; INITIALIZE COUNTER
80$:                            ;

        .ENDC

        BR      ICDO            ;

        .ENDC



        .ENDC

        .DSABL  LSB

;
; TASK NOT INSTALLED
;

        .IF DF  I$$CIM!I$$CR!I$$CTI&I$$CLK

ICNST:                          ;
        MOV     #IE.NST&377,R0  ;
        BR      ICOM            ;

        .ENDC


;+
;
; **-RDACT-READ ACTIVATING DATA
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- ADDRESS OF BUFFER TO RECEIVE ACTIVATING INFORMATION
;       WD. 13 -- UNUSED
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CIM!I$$CR!I$$CTI&I$$CLK

RDACT:                          ;
        BIT     #1,(R1)         ; BUFFER WORD ALIGNED?
        BNE     ICBYT           ; IF NE NO
        MOV     #ICDVT+ICLTL,R4 ; GET ADDRESS OF LINKED TASK LISTHEAD
10$:                            ;
        MOV     (R4),R4         ; GET ADDRESS OF NEXT ENTRY
        BEQ     ICNLK           ; IF EQ TASK NOT LINKED TO INTERRUPTS
        CMP     LTCB(R4),R0     ; THIS ENTRY BELONG TO TASK?
        BNE     10$             ; IF NE NO
        MOV     (R1),R0         ; GET ADDRESS OF BUFFER TO RECEIVE DATA
        MOV     #LPAD-LACT,R3   ; SET BYTE COUNT

        .IF DF  A$$CHK!M$$MGE

        MOV     R3,R1           ; COPY BYTE COUNT
        CALL    $ACHCK          ; ADDRESS CHECK BUFFER
        BCS     ICSP            ; IF C/S BUFFER NOT IN REQUESTORS SPACE

        .ENDC

        .IF DF  M$$MGE

        CALL    $RELOM          ; RELOCATE AND MAP BUFFER

        .ENDC

        ADD     #LACT,R4        ; POINT TO ACTIVITY COUNT
        ASR     R3              ; SHIFT BYTE COUNT TO WORD COUNT
        MOVB    #PR6,PS         ;;; INHIBIT INTERRUPTS
20$:                            ;;;
        MOV     (R4),(R0)+      ;;; COPY ENTRY
        CLR     (R4)+           ;;; CLEAR ENTRY
        DEC     R3              ;;; DECREMENT COUNT
        BNE     20$             ;;; IF NE GO AGAIN
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        BR      ICDO            ;

        .ENDC

;
; TASK NOT LINKED TO INTERRUPTS
;

        .IF DF  I$$CIM!I$$CR!I$$CTI&I$$CLK

ICNLK:                          ;
        MOV     #IE.NLK&377,R0  ;
        BR      ICOM            ;


;
; BUFFER IS BYTE ALIGNED
;

        .IFTF

ICBYT:                          ;
        MOV     #IE.BYT&377,R0  ;

        .IFT

        BR      ICOM            ;

;
; INSUFFICIENT DYNAMIC STORAGE AVAILABLE TO ALLOCATE SECODARY CONTROL BLOCK
;
;       NOTE: AT THIS POINT THE STACK CONTAINS:
;
;               (SP)+00 - PREVIOUS CONTENTS OF R1 (MAY BE DISCARDED),
;               (SP)+02 - PREVIOUS CONTENTS OF R5 (MUST BE RESTORED).
;
;

ICNOD:                          ;
        MOV     (SP)+,R1        ; RESTORE R1
        MOV     (SP)+,R5        ; RESTORE UCB ADDRESS
        MOV     #IE.NOD&377,R0  ;

;
; INTERMEDIATE BRANCH POINTS TO ERROR EXITS
;

        .IFTF

ICOM:   JMP     ICOMN           ; COMMON ERROR EXIT

        .IFT

ICDO:   JMP     ICDON           ; SUCCESFUL COMPLETION
ICSP:   JMP     ICSPC           ; BUFFER OUT OF REQUESTORS ADDRESSS SPACE

        .ENDC

;+
;
; **-UNLNK-UNLINK A TASK FROM ALL INTERRUPTS ON UNIT
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 TASK NAME
;       WD. 13 -- WORD 1 OF RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CIM!I$$CR!I$$CTI&I$$CLK

UNLNK:                          ;
        CLR     -(SP)           ; RESET SUCCESS FLAG

        .IF DF  I$$CIM

        CALL    CIUNL1          ; UNLINK FROM CONTACT INTERRUPTS
        BCS     40$             ; IF C/S NOT LINKED TO ANY INTERRUPTS
        BMI     10$             ; IF MI NOT LINKED TO THIS TYPE
        INC     (SP)            ; SET SUCCESS FLAG
10$:                            ;

        .ENDC

        .IF DF  I$$CTI

        CALL    CTUNL1          ; UNLINK FROM COUNTER MODULE INTERRUPTS
        BCS     40$             ; IF C/S NOT LINKED TO ANY INTERRUPTS
        BMI     20$             ; IF MI NOT LINKED TO THIS TYPE
        INC     (SP)            ; SET SUCCESS
20$:                            ;

        .ENDC

        .IF DF  I$$CR

        CALL    RTUNL1          ; UNLINK FROM REMOTE TERMINAL INTERRUPTS
        BCS     40$             ; IF C/S NOT LINKED TO ANY INTERRUPTS
        BMI     30$             ; IF MI NOT LINKED TO THIS TYPE
        INC     (SP)            ; SET SUCCESS
30$:                            ;
        CALL    ERUNL1          ; UNLINK FROM ERRORS
        BMI     40$             ; IF MI NOT LINKED TO ERRORS
        INC     (SP)            ; SET SUCCESS

        .ENDC

40$:                            ;
        MOV     #IE.NLK&377,R0  ; ASSUME NOT LINKED TO ANY INTERRUPTS
        TST     (SP)+           ; TEST SUCCESS FLAG
        BEQ     ICOM            ; IF EQ NOT LINKED TO ANY INTERRUPTS
        BR      ICDO            ; SUCCESFUL EXIT

;+
;
; **-CIUNL-UNLINK TASK FROM CONTACT INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 TASK NAME
;       WD. 13 -- WORD 1 OF RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .ENABL LSB

        .IF DF  I$$CIM

CIUNL:                          ;
        MOV     #ICOMN,-(SP)    ; SET TRANSFER ADDRESS
CIUNL1:                         ;
        MOV     #IE.MOD&377,-(SP) ; ASSUME NON-EXISTENT MODULE TYPE
        MOV     S.DI(R4),R4     ; GET TABLE ADDRESS
        BEQ     80$             ; IF EQ MODULE NOT INSTALLED
        MOV     (R4),R2         ; GET POINT COUNT-15.
        ASR     R2              ; CONVERT TO NUMBER OF MODULES
        ASR     R2              ; ...
        ASR     R2              ; ...
        ASR     R2              ; ...
        MOV     R2,6(R1)        ; SAVE MODULE-1 COUNT
        MOV     #CILGH,4(R1)    ; SAVE ENTRY SIZE
        BR      UNL             ; TO COMMON UNLINK CODE

        .ENDC

;+
;
; **-CTUNL-UNLINK TASK FROM COUNTER INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 TASK NAME
;       WD. 13 -- WORD 1 O F RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CTI

CTUNL:                          ;
        MOV     #ICOMN,-(SP)    ; PUSH TRANSFER ADDRESS
CTUNL1:                         ;
        MOV     #IE.MOD&377,-(SP) ; ASSUME NON-EXISTENT MODULE TYPE
        MOV     S.CT(R4),R4     ; GET ADDRESS OF TABLES
        BEQ     80$             ; IF EQ NONE
        MOV     (R4),6(R1)      ; SET NUMBER OF HIGHEST MODULE
        MOV     #CTLGH,4(R1)    ; SET ENTRY SIZE
        BR      UNL             ;

        .ENDC

;+
;
; **-RTUNL-UNLINK TASK FROM REMOTE TERMINAL
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 TASK NAME
;       WD. 13 -- WORD 1 OF RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CR

RTUNL:                          ;
        MOV     #ICOMN,-(SP)    ; PUSH TRANSFER ADDRESS
RTUNL1:                         ;
        MOV     #IE.MOD&377,-(SP) ; ASSUME NONEXISTENT MODULE TYPE
        MOV     S.RTI(R4),R4    ; GET MODULE TABLE ADDRESS
        BEQ     80$             ; IF EQ NON-EXISTENT MODULE
        BR      ERUNL2          ;

;+
;
; **-ERUNL-UNLINK FROM ERROR INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- WORD 0 OF RADIX-50 TASK NAME
;       WD. 13 -- WORD 1 OF RADIX-50 TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

ERUNL:                          ;
        MOV     #ICOMN,-(SP)    ; PUSH TRANSFER ADDRESS
ERUNL1:                         ;
        MOV     #ICDVT+ICRES-IMDAT,R4 ; POINT TO ERROR RESOURCE MASK MINUS OFFSET
        CLR     -(SP)           ; RESERVE A WORD ON THE STACK
ERUNL2:                         ;
        CLR     6(R1)           ; SET MODULE-1 COUNT TO ZERO

        .ENDC

UNL:                            ;
        MOV     #TASK,R2        ; POINT TO TASK NAME STORAGE
        MOV     R1,R3           ; COPY ADDRESS OF PARAMETER BLOCK
        MOV     (R1)+,(R2)+     ; SAVE TASK NAME
        MOV     (R1)+,(R2)+     ; ...
        MOV     R3,U.CW2(R5)    ; SAVE ADDRESS OF PARAMETER LIST
        ADD     #IMDAT,R4       ; POINT TO MODULE ENTRIES
        MOV     #IE.NST&377,(SP) ; ASSUME TASK NOT INSTALLED
        CALL    $SRSTD          ; SEARCH TCB LIST FOR TASK
        BCS     60$             ; IF C/S TASK NOT INSTALLED
        MOV     R3,R1           ; RESTORE ADDRESS OF PARAMETER LIST
        MOV     #IE.NLK&377,(SP) ; ASSUME TASK NOT LINKED
        MOV     #ICDVT+ICLTL,R2 ; POINT TO LINKED TASK LISTHEAD
10$:                            ;
        MOV     R2,10(R1)       ; SAVE LINK TO PREVIOUS
        MOV     (R2),R2         ; GET LINK TO NEXT
        SEC                     ; ASSUME TASK NOT LINKED ANYWHERE
        BEQ     60$             ; IF EQ TASK NOT LINKED ANYWHERE
        CMP     LTCB(R2),R0     ; THIS ENTRY BELONG TO TASK?
        BNE     10$             ; IF NE NO
        MOV     R2,(R1)+        ; SAVE ADDRESS OF LINKED TASK ENTRY
        MOV     R4,(R1)         ; SAVE ADDRESS OF FIRST ENTRY
        MOV     R1,R4           ; SAVE PARAMETER LIST ADDRESS
20$:                            ;
        MOV     (R4),R0         ; GET ADDRESS OF CURRENT ENTRY
        TST     (R0)+           ; POINT TO INTERRUPT LINKAGE LISTHEAD
        MOV     -(R4),R1        ; GET ADDRESS OF LINKED TASK ENTRY
        MOVB    #PR6,PS         ;;; INHIBIT DEVICE INTERRUPTS
        CALL    $QRMVT          ;;; ATTEMPT TO REMOVE AN ENTRY FROM LIST
        BCS     40$             ;;; IF C/S NO ENTRY IN LIST THIS TIME
        BIC     ILMSK(R1),-(R0) ;;; CLEAR RESOURCE MASK BITS
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        MOV     #IS.SUC&377,(SP) ; SET SUCCESS
        MOV     R1,R0           ; COPY ADDRESS OF NODE
        MOV     #ILGH,R1        ; SET LENGTH OF NODE
        CALL    $DEACB          ; DEALLOCATE BLOCK
        MOV     (R4)+,R0        ; GET ADDRESS OF LINKED TASK ENTRY
        DEC     LUSE(R0)        ; DECREMENT USE COUNT
        BNE     20$             ; IF NE GO AGAIN
        MOV     10-2(R4),R1     ; GET ADDRESS OF PREVIOUS
        MOV     (R0),(R1)       ; RELINK REMAINING ENTRIES
        BNE     30$             ; IF NE NO NEW LAST
        MOV     R1,ICDVT+ICLTL+2 ; SET NEW LAST
30$:                            ;
        MOV     #LLGH,R1        ; SET LENGTH OF ENTRY
        CALL    $DEACB          ; DEALLOCATE BLOCK
        BR      50$             ; EXIT
40$:                            ;
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        CMP     (R4)+,(R4)+     ; POINT TO ENTRY SIZE
        ADD     (R4),-(R4)      ; OFFSET TO NEXT ENTRY
        DEC     4(R4)           ; DECREMENT ENTRY COUNT
        BPL     20$             ; IF PL GO AGAIN
50$:                            ;
        CLC                     ; SET SUCCESS
60$:                            ;
        MOV     U.CW2(R5),R1    ; RESTORE ADDRESS OF PARAMETER LIST
        MOV     TASK,(R1)       ; RESTORE TASK NAME
        MOV     TASK+2,2(R1)    ; ...
70$:                            ;                                       ; GK004
        MOV     U.SCB(R5),R4    ; RESTORE ADDRESS OF SCB
        MOV     (SP)+,R0        ; RETRIEVE STATUS                       ;**-1
        BISB    R0,R0           ; SET CONDITION CODES
        RETURN                  ;
80$:
        CLC                     ; SET SUCCESS
        BR      70$             ; GO GET STATUS AND EXIT

        .DSABL  LSB

        .ENDC


;+
;
; **-CICNT-CONNECT TO CONTACT INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF CIRCULAR BUFFER
;       WD. 13 -- ADDRESS OF CIRCULAR BUFFER
;       WD. 14 -- LENGTH OF BUFFER
;       WD. 15 -- EVENT FLAG NUMBER
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .ENABL  LSB

        .IF DF  I$$CIM

CICNT:                          ;
        MOV     S.DI(R4),R3     ; GET ADDRESS OF DIGITAL INTERRUPT TABLES
        BR      CNCT            ;

        .ENDC

;+
;
;**-CTCNT-CONNECT TO COUNTER MODULE INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF CIRCULAR BUFFER
;       WD. 13 -- ADDRESS OF CIRCULAR BUFFER
;       WD. 14 -- LENGTH OF CIRCULAR BUFFER
;       WD. 15 -- EVENT FLAG NUMBER
;       WD. 16 -- ADDRESS OF COUNTER INITIAL VALUE TABLE
;       WD. 17 -- UNUSED
;
;+

        .IF DF  I$$CTI

CTCNT:                          ;
        MOV     S.CT(R4),R3     ; GET ADDRESS OF COUNTER TABLES
        BR      CNCT            ;

        .ENDC

;+
;
; **-RTCNT-CONNECT REMOTE TERMINAL INPUTS TO CIRCULAR BUFFER
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF CIRCULAR BUFFER
;       WD. 13 -- ADDRESS OF CIRCULAR BUFFER
;       WD. 14 -- LENGTH OF CIRCULAR BUFFER
;       WD. 15 -- EVENT FLAG NUMBER
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CR

RTCNT:                          ;
        MOV     S.RTI(R4),R3    ; GET ADDRESS OF REMOTE TERMINAL TABLE

        .ENDC

        .IF DF  I$$CIM!I$$CR!I$$CTI

CNCT:                           ;
        BEQ     ICM             ; IF EQ MODULE DOESN'T EXIST
        BIT     #T2.CHK!T2.FXD,T.ST2(R0) ; TASK NOT CHKPOINTABLE OR FXD?
        BEQ     ICPRI           ; IF EQ NO
        TST     IMTCB(R3)       ; OTHER TASK CONNECTED?
        BNE     ICON            ; IF NE YES
        CMP     (R1)+,(R1)+     ; POINT TO DATA BUFFER SIZE
        MOVB    IMBPE(R3),R0    ; GET SIZE OF ENTRY
        CMP     (R0)+,(R0)+     ; ADJUST FOR BUFFER HEADER
        CMP     (R1)+,R0        ; BUFFER BIG ENOUGH
        BLO     ICSPC           ; IF LO NO
        MOV     (R1)+,R0        ; GET EVENT FLAG NUMBER
        BEQ     ICIEF           ; IF EQ ILLEGAL EFN
        CMP     R0,#64.         ; LEGAL EFN?
        BHI     ICIEF           ; IF HI NO

        .IF DF  I$$CTI

        CLR     2(R1)           ; CLEAR COUNTER FLAG
        CMP     R3,S.CT(R4)     ; PROCESSING COUNTERS?
        BNE     20$             ; IF NE NO
        MOV     (R1)+,R0        ; GET ADDRESS OF COUNTER INITIAL VALUE TABLE
        MOV     R3,(R1)         ; SET COUNTER FLAG
        MOV     (R3),R4         ; GET NUMBER OF HIGHEST COUNTER
        INC     R4              ; CONVERT TO NUMBER OF COUNTERS

        .IF DF  A$$CHK!M$$MGE

        MOV     R4,R1           ; COPY NUMBER OF COUNTERS
        ASL     R1              ; CONVERT TO BYTE COUNT
        CALL    $ACHCK          ; ADDRESS CHECK TABLE
        BCS     ICSPC           ; IF C/S OUT OF REQUESTOR'S TASK SPACE

        .ENDC

        .IF DF  M$$MGE

        CALL    $RELOM          ; RELOCATE AND MAP TO INITIAL VALUE TABLE

        .ENDC

        MOV     R3,R1           ; COPY MODULE TABLE ADDRESS
        ADD     #IMDAT+IMPRV,R1 ; POINT TO INITIAL VALUE CELL
10$:                            ;
        MOV     (R0)+,(R1)      ; SET INITIAL VALUE
        ADD     #CTLGH,R1       ; POINT TO NEXT ENTRY
        DEC     R4              ; DECREMENT COUNT
        BNE     10$             ; IF NE GO AGAIN

        .ENDC

20$:                            ;
        MOV     (SP),R4         ; RETRIEVE I/O PACKET ADDRESS
        MOV     R5,-(SP)        ; SAVE ADDRESS OF UCB
        MOV     I.TCB(R4),R5    ; GET REQUESTER TASK TCB ADDRESS
        ADD     #I.PRM,R4       ; POINT TO I/O PACKET ADDRESS
        TST     (R3)+           ; POINT TO BYTES OF INTERRUPT DATA
        MOVB    (R3)+,(R3)      ; SET FORK NOT IN PROGRESS
        MOVB    (R3)+,-(SP)     ; SAVE BYTES PER ENTRY
        MOV     (R4)+,(R3)      ; INSERT STARTING BUFFER RELOCATION BIAS
        MOV     (R3)+,(R3)+     ; INSERT CURRENT BUFFER RELOCATION BIAS
        MOV     (R4)+,(R3)      ; INSERT STARTING ADDRESS OF BUFFER
        MOV     (R3)+,(R3)      ; COPY STARTING ADDRESS OF BUFFER
        ADD     #4,(R3)         ; COMPUTE STARTING ADDRESS OF DATA
        MOV     (R3)+,(R3)+     ; SET CURRENT BUFFER ADDRESS
        MOV     #3,(R3)+        ; SET CURRENT FORTRAN FILL INDEX
        MOV     (R4)+,(R3)      ; SET LENGTH OF BUFFER IN BYTES
        ROR     (R3)+           ; CONVERT TO LENGTH IN WORDS
        MOV     (R4)+,R0        ; GET EVENT FLAG NUMBER
        CALL    $CEFI           ; CONVERT TO MASK AND ADDRESS
        MOV     R0,(R3)+        ; INSERT EVENT FLAG MASK
        MOV     R1,(R3)+        ; INSERT EVENT FLAG ADDRESS
        CLR     (R3)+           ; CLEAR LOST DATA COUNT
        MOV     R5,(R3)         ; CONNECT TASK TO INTERRUPTS
        INCB    T.IOC(R5)       ; BIAS TASK'S OUTSTANDING I/O COUNT

        .IF DF  D$$SHF

        MOV     T.PCB(R5),R0    ; GET ADDRESS OF PCB
        BIS     #PS.NSF,P.STAT(R0) ; DISABLE TASK SHUFFLING

        .ENDC

        MOVB    (SP)+,R0        ; RETRIEVE BYTES PASSED PER INTERRUPT
        MOV     (SP)+,R5        ; RETRIEVE ADDRESS OF UCB

        .IF DF  I$$CTI

        MOV     2(R4),R3        ; GET COUNTER FLAG
        BEQ     30$             ; IF EQ NOT CONNECTING TO COUNTERS
        CALL    RSETC           ; INITIALIZE ALL COUNTERS
30$:                            ;

        .ENDC

        ASR     R0              ; CONVERT BYTES TO WORD COUNT
        DEC     R0              ; ADJUST FOR EXISTENCE INDICATOR
        BIS     #3*256.,R0      ; INCLUDE INITIAL FORTRAN INDEX
        MOV     R0,R1           ; COPY RESULT
        BR      ICDON1          ; COMPLETE REQUEST

;
; INTERMEDIATE ERROR BRANCH POINTS
;

ICB:    JMP     ICBYT           ; BUFFER BYTE ALIGNED
ICM:    JMP     ICMOD           ; ILLEGAL MODULE NUMBER SPECIFIED

        .ENDC

        .DSABL  LSB

;+
;
; **-DISCONNECT CIRCULAR BUFFER FROM CONTACT INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- UNUSED
;       WD. 13 -- UNUSED
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .ENABL  LSB

        .IF DF  I$$CIM

CIDCT:                          ;
        MOV     S.DI(R4),R3     ; GET ADDRESS OF CONTACT INTERRUPT TABLES
        BR      10$             ;

        .ENDC

;+
;
; **-CTDCT-DISCONNECT CIRCULAR BUFFER FROM COUNTER INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- UNUSED
;       WD. 13 -- UNUSED
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CTI

CTDCT:                          ;
        MOV     S.CT(R4),R3     ; GET ADDRESS OF COUNTER TABLES
        BR      10$             ;

        .ENDC

;+
;
; **-RTDCT-DISCONNECT REMOTE TERMINAL FROM CIRCULAR BUFFER
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- UNUSED
;       WD. 13 -- UNUSED
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CR


RTDCT:                          ;
        MOV     S.RTI(R4),R3    ; GET ADDRESS OF REMOTE TERMINAL TABLES

        .ENDC

        .IF DF  I$$CIM!I$$CR!I$$CTI

10$:                            ;
        CALL    ICAN1           ; DISCONNECT TASK FROM INTERRUPTS
        BCC     ICDON           ; IF C/C DISCONNECT SUCCEEDED
        BEQ     ICMOD           ; IF EQ MODULE DOESN'T EXIST

;
; TASK NOT CONNECTED OR OTHER TASK CONNECTED
;

ICON:                           ;
        MOV     #IE.CON&377,R0  ;
        BR      ICOMN           ;

        .ENDC

;
; ILLEGAL OR NONEXISTENT EVENT FLAG SPECIFIED
;

        .IF DF  I$$CLK!I$$CIM!I$$CR!I$$CTI

ICIEF:                          ;
        MOV     #IE.IEF&377,R0  ;
        BR      ICOMN           ;

        .ENDC

;
; PRIVELEGE VIOLATION - TASK REQUESTING CONNECTION WAS
; CHECKPOINTABLE BUT NOT FIXED
;

ICPRI:                          ;
        MOV     #IE.PRI&377,R0  ;
        BR      ICOMN           ;

;
; INVALID FUNCTION CODE ISSUED OR NONEXISTENT MODULE
; TYPE REFERENCED
;

ICIFC:                          ;
        MOV     #IE.IFC&377,R0  ;
        BR      ICOMN           ;

;
; BUFFER OUT OF REQUESTORS ADDRESS SPACE
;

ICSPC:                          ;
        MOV     #IE.SPC&377,R0  ;
        BR      ICOMN           ;

;
; DEVICE NOT READY
;

ICNRD:                          ;
        MOV     #IE.DNR&377,R0  ;
        BR      ICOMN           ;


;+
;
; **-CTINI-INITIALIZE COUNTER MODULE
;
; FUNCTION DEPENDANT I/O PACKET FORMAT
;
;       WD. 12 -- COUNTER NUMBER
;       WD. 13 -- COUNTER INITIAL VALUE
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-

        .IF DF  I$$CTI

CTINI:                          ;
        MOV     S.CT(R4),R3     ; GET ADDRESS OF COUNTER TABLES
        BEQ     ICMOD           ; IF EQ MODULE DOES NOT EXIST
        CMP     (R1),(R3)       ; LEGAL COUNTER NUMBER?
        BHI     ICMOD           ; IF HI NO
        MOV     (R1),R2         ; GET COUNTER NUMBER
        ASL     R2              ; CONVERT TO TABLE INDEX
        ASL     R2              ; ...
        ADD     (R1)+,R2        ; ...
        ASL     R2              ; ...
        ADD     R2,R3           ; POINT TO MODULE ENTRY
        ADD     #IMDAT+IMPRV,R3 ; ...
        MOV     (R1),(R3)       ; SET NEW INITIAL VALUE
        CALL    SETCT           ; RE-INITIALIZE COUNTERS
        BR      ICDON           ; EXIT

        .ENDC

;+
;
; **-AOUT-SINGLE CHANNEL ANALOG OUTPUT
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- RELATIVE CHANNEL NUMBER
;       WD. 13 -- OUTPUT VOLTAGE REPRESENTATION
;
;-


        .IF DF  I$$CDA

AOUT:                           ;
        MOV     R4,R3           ; COPY ADDRESS OF SCB
        ADD     #S.DAC,R3       ; POINT TO D/A ENTRY
        TST     (R3)+           ; ANY D/A CONVERTER MODULES?
        BEQ     ICMOD           ; IF EQ NO
        MOV     R1,R2           ; COPY PARAMETER BLOCK ADDRESS
        CMP     (R2)+,2(R3)     ; LEGAL CHANNEL?
        BHI     ICMOD           ; IF HI NO
        TST     (R2)+           ; POINT TO PARAMETER WORD 3
        MOV     (R1),(R2)       ; COPY CHANNEL NUMBER
        ASL     (R2)            ; CONVERT TO WORD OFFSET
        ADD     (R3),(R2)       ; COMPUTE CONTEXT SAVE LOCATION
        SWAB    -(R2)           ; SWAP DATA WORD BYTES
        RORB    (R2)            ; LEFT JUSTIFY DATA
        ROR     (R2)            ; ...
        ROR     (R2)            ; ...
        ASR     (R1)            ; INCLUDE CHANNEL NUMBER WITHIN MODULE
        ROR     (R2)            ; ...
        ASR     (R1)            ; ...
        ROR     (R2)            ; ...
        MOV     (R2)+,@(R2)+    ; SAVE CONTROL WORD
        BR      OUTCM           ; TO COMMON OUTPUT CODE

        .ENDC

;+
;
; **-LTOUT-BI-STABLE DIGITAL OUTPUT
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- STARTING RELATIVE POINT NUMBER
;       WD. 13 -- DATA MASK WORD
;       WD. 14 -- DATA VALUE
;
;-

        .IF DF  I$$CLT

LTOUT:                          ;
        MOV     R4,R3           ; COPY SCB ADDRESS
        ADD     #S.LTO,R3       ; POINT TO BI-STABLE SCB ENTRY
        TST     (R3)+           ; ANY BI-STABLE OUTPUTS ON THIS CONTROLLER?
        BEQ     ICMOD           ; IF EQ NO
        CMP     (R1),2(R3)      ; LEGAL POINT NUMBER?
        BHI     ICMOD           ; IF HI NO
        BIT     #17,(R1)        ; POINT ON MODULE BOUNDARY?
        BNE     ICMOD           ; IF EQ NO
        ASR     (R1)            ; CONVERT POINT TO WORD INDEX
        ASR     (R1)            ; ...
        ASR     (R1)            ; ...
        MOV     (R1)+,R2        ; GET INDEX
        ADD     (R3),R2         ; COMPUTE ADDRESS OF PREVIOUS STATE ENTRY
        BIC     (R1),(R2)       ; CLEAR ALL BITS THAT WILL CHANGE STATE
        COM     (R1)            ; COMPLEMENT MASK
        BIC     (R1)+,(R1)      ; CLEAR ALL BITS THAT WILL NOT CHANGE STATE
        BIS     (R1),(R2)       ; ESTABLISH NEW 'CURRENT STATE'
        MOV     (R2),-(R1)      ; COPY NEW STATE
        ASR     -(R1)           ; CONVERT WORD OFFSET TO BYTE OFFSET
        BR      OUTCM           ; TO COMMON CODE

        .ENDC

;+
;
; **-SSOUT-MOMENTARY DIGITAL OUTPUTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- STARTING RELATIVE POINT NUMBER
;       WD. 13 -- DATA VALUE
;
;-

        .IF DF  I$$CSS

SSOUT:                          ;
        MOV     R4,R3           ; COPY SCB ADDRESS
        ADD     #S.SSO,R3       ; POINT TO 'MOMENTARY' ENTRY
        TST     (R3)+           ; ANY MOMENTARY OUTPUTS?
        BEQ     ICMOD           ; IF EQ NO
        CMP     (R1),2(R3)      ; LEGAL POINT NUMBER?
        BHI     ICMOD           ; IF HI NO
        BIT     #17,(R1)        ; POINT ON MODULE BOUNDARY?
        BNE     ICMOD           ; IF NE NO
        ASR     (R1)            ; CONVERT TO MODULE NUMBER
        ASR     (R1)            ; ...
        ASR     (R1)            ; ...
        ASR     (R1)            ; ...

        .ENDC

;
; COMMON CODE TO PERFORM OUTPUT FOR NON-
; INTERRUPTING FUNCTIONS
;

        .IF DF  I$$CDA!I$$CLT!I$$CSS

OUTCM:                          ;
        ADD     -(R3),(R1)+     ; COMPUTE MODULE MAPPING TABLE ENTRY ADDRESS
        MOVB    @-(R1),(R1)+    ; CONVERT LOGICAL TO PHYSICAL SLOT NUMBER
        CLRB    (R1)+           ; CLEAR HIGH BYTE
        ADD     #ICMD/2&77777,-(R1) ; COMPUTE BUS ADDRESS/2
        CALL    CBINS           ; ATTEMPT TO INSERT IN CIRCULAR BUFFER

        .IF DF  I$$CR

        BCS     ICDNR           ; IF C/S UNIT NOT READY

        .ENDC

        BR      ICDON           ; SET SUCCESFUL COMPLETION STATUS

        .ENDC

;
; ILLEGAL OR NONEXISTENT MODULE SPECIFIED
;

ICMOD:                          ;
        MOV     #IE.MOD&377,R0  ;
        BR      ICOMN                   ;

;
; RETURN SUCCESS STATUS, SET WORD 2 OF I/O STATUS BLOCK
; TO ZERO
;

ICDON:                          ;
        CLR     R1              ; CLEAR SECOND WORD OF I/O STATUS
ICDON1:                         ;
        MOV     #IS.SUC&377,R0  ; SET STATUS
        BR      ICOMN1          ;

;
; DEVICE NOT READY
;

ICDNR:                          ;
        MOV     #IE.DNR&377,R0          ;

;
; COMMON EXIT FROM ALL FUNCTION CODE PROCESSING
;

ICOMN:                          ;
        CLR     R1              ; CLEAR SECOND WORD OF I/O STATUS
ICOMN1:                         ;
        MOV     (SP)+,R3        ; RESTORE ADDRESS OF I/O PACKET
        CALLR   $IOFIN          ; TERMINATE REQUEST


;+
;
; **-ADINI-INITIATE BUFFERED A/D CONVERSION
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER
;       WD. 13 -- DATA BUFFER ADDRESS
;       WD. 14 -- NUMBER OF BYTES IN DATA BUFFER
;       WD. 15 -- CONTROL BUFFER ADDRESS
;
;-

        .ENABL  LSB

        .IF DF  I$$CAD

ADINI:                          ;
        TST     S.ADC(R4)       ; ANY A/D CONVERTERS ON THIS CONTROLLER?
        BEQ     ICMOD           ; IF EQ NO
        MOV     6(R1),R0        ; GET VIRTUAL ADDRESS OF CONTROL BUFFER

        .IF DF  A$$CHK!M$$MGE

        MOV     4(R1),R1        ; GET LENGTH OF BUFFER TO CHECK
        CALL    $ACHCK          ; ADDRESS CHECK CONTROL BUFFER
        BCS     ICSPC           ; IF C/S ADDRESS CHECK FAILURE

        .ENDC

        MOV     (SP),R3         ; GET ADDRESS OF I/O PACKET
        CALL    $RELOC          ; RELOCATE AND MAP BUFFER
        ADD     #I.PRM+4,R3     ; POINT TO BYTE COUNT (C/CLEAR)
        ROR     (R3)+           ; CONVERT TO NUMBER OF CHANNELS
        MOV     R1,(R3)+        ; SAVE CONTROL BUFFER ADDRESS BIAS
        MOV     R2,(R3)         ; SAVE CONTROL BUFFER ADDRESS

        .ENDC

;+
;
; **-RTINI-INITIATE REMOTE TERMINAL I/O
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF CONTROL BUFFER
;       WD. 13 -- DATA BUFFER ADDRESS
;       WD. 14 -- NUMBER OF BYTES IN DATA BUFFER
;
;-

        .IF DF  I$$CAD!I$$CR

RTINI:                          ;
        MOV     (SP)+,R1        ; RETRIEVE I/O PACKET ADDRESS
        MOV     R4,R0           ; SET ADDRESS OF I/O LISTHEAD
        CALL    $QINSP          ; INSERT I/O PACKET IN REQUEST QUEUE

        .ENDC

        .DSABL  LSB

;+
;
; **-IMRQ-ICS/ICR-11 INTERRUPT MODULE REQUEST PROCESSING
;
; THIS ROUTINE IS ENTERED FROM QIO DIRECTIVE PROCESSING
; WHEN AN I/O REQUEST IS QUEUED AND AT THE END OF A PRE-
; VIOUS I/O REQUEST TO CONTINUE REQUEST PROCESSING. IF
; THE SPECIFIED CONTROLLER IS NOT BUSY THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT REQUEST. OTHERWISE A RE-
; TURN TO THE CALLER IS EXECUTED. IF THE DEQUEUE ATTEMPT
; IS SUCCESFUL THE NEXT I/O OPERATION IS INITIATED, A  RE-
; TURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK
;
; OUTPUTS:
;
;       IF THE CONTROLLER IS NOT BUSY AND AN I/O REQUEST
;       IS WAITING TO BE PROCESSED, THEN THE REQUEST IS DE-
;       QUEUED AND THE I/O OPERATION IS INITIATED.
;
;-

        .ENABL  LSB

        .IF DF  I$$CAD!I$$CR

IMRQ:                           ;
        CALL    $GTPKT          ; DEQUEUE AN I/O PACKET


        .IF DF  I$$CR

        BCS     20$             ; IF C/S NO WORK OR CONTROLLER BUSY

        .IFF

        BCC     ADRQ            ; IF C/CLEAR HAVE PACKET TO PROCESS

        .ENDC

        .ENDC

;+
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=I/O REQUEST PACKET ADDRESS
;       R2=REQUEST UCB PHYSICAL UNIT NUMBER
;       R3=CONTROLLER INDEX
;       R4=STATUS CONTROL BLOCK ADDRESS
;       R5=UNIT CONTROL BLOCK ADDRESS
;
; ICR/ICS-11 INTERRUPT MODULE REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER
;       WD. 02 -- ADDRESS OF REQUESTING TASK TCB
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB)
;       WD. 05 -- I/O FUNCTION CODE (IO.RBC OR IO.WLB)
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT+140000)
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER
;       WD. 13 -- DATA BUFFER ADDRESS
;       WD. 14 -- NUMBER OF BYTES IN DATA BUFFER
;       WD. 15 -- RELOCATION BIAS OF CONTROL BUFFER (ADU02 INPUT ONLY)
;       WD. 16 -- CONTROL BUFFER ADDRESS (ADU02 ONLY)
;       WD. 17 -- NOT USED
;       WD. 20 -- NOT USED
;
;-

        .IF DF  I$$CAD&I$$CR

        CMPB    #IO.WLB/256.,I.FCN+1(R1) ; REMOTE TERMINAL OUTPUT?
        BNE     ADRQ            ; IF NE A/D CONVERSION REQUEST

        .ENDC

        .IF DF  I$$CR

        MOV     #IE.MOD&377,R0  ; ASSUME DEVICE IS ICS11
        TST     S.RTI(R4)       ; DEVICE ICS11 CONTROLLER?
        BEQ     27$             ; IF EQ YES
10$:                            ;
        MOV     #IE.ABO&377,R0  ; ASSUME I/O CANCEL IS ASSERTED
        BIT     #TABO,S.FLG(R4) ; ABORT TRANSFER?
        BNE     25$             ; IF NE YES
        CALL    $GTBYT          ; GET AN OUTPUT BYTE
        MOV     #ICMD/2,-(SP)   ; PUSH BUS ADDRESS/2!TERMINAL FLAG
        BISB    S.CON(R4),(SP)  ; MERGE WITH CONTROLLER INDEX
        ASLB    (SP)            ; MULTIPLY CONTROLLER INDEX BY 8
        ASLB    (SP)            ; ...
        ASLB    (SP)            ; ...
        MOV     SP,R1           ; COPY STACK ADDRESS
        BIS     #TUND!TUSE,S.FLG(R4) ; SET TERMINAL BUSY AND IN USE
        MOVB    S.ITM(R4),S.CTM(R4) ; ENABLE DEVICE TIME-OUTS
        CALL    CBINS           ; INSERT IN CIRCULAR BUFFER
        MOV     (SP)+,(SP)+     ; CLEAN STACK

        .IFTF

        .IF DF  I$$CAD!I$$CR

20$:                            ;
        RETURN                  ;

        .ENDC

;+
;
; **-RTINT-REMOTE TERMINAL INTERRUPT PROCESSING
;
;-

        .IFT

RTINT:                          ;;;
        BIC     #1000,@S.CSR(R4) ;;; DISABLE TERMINAL OUTPUT INTERRUPTS
        ADD     #6,SP           ;;; REMOVE DATA, MOD. NO., GENERIC CODE FROM STACK
        TSTB    R2              ;;; TERMINAL BUFFER EMPTY?
        BPL     30$             ;;; IF PL NO, ERROR

        .IF GT  I$$C11-1

        MOV     ICUCB,R5        ;;; GET UCB ADDRESS


        .IFF

        MOV     CNTBL,R5        ;;; GET UCB ADDRESS

        .ENDC

        BIT     #TUND,S.FLG(R4) ;;; TERMINAL INTERRUPTS EXPECTED?
        BEQ     30$             ;;; IF EQ NO
        BIC     #TUND,S.FLG(R4) ;;; CLEAR UNDERWAY FLAG
        CLRB    S.CTM(R4)       ;;; DISABLE DEVICE TIMEOUTS
        CALL    $FORK           ;;; CREATE A SYSTEM PROCESS
        DEC     U.CNT(R5)       ; DECREMENT BYTE COUNT
        BGT     10$             ; IF GT MORE TO OUTPUT
        MOV     #IS.SUC&377,R0  ; SET SUCCESFUL COMPLETION STATUS
25$:                            ;
        BIC     #TABO!TUSE,S.FLG(R4) ; CLEAR TERMINAL IN USE FLAG, ABORT FLAG
27$:                            ;
        JMP     IMFIN           ; COMPLETE REQUEST PROCESSING
30$:                            ;
        RETURN                  ;;; EXIT ISR

        .ENDC

        .DSABL  LSB

;+
;
; **-ADRQ-INITIATE BUFFERED, PARALLEL A/D CONVERSION
;
; THIS ROUTINE IS INVOKED TO INITIATE BUFFERED, PARALLEL A/D
; CONVERSION ON THE ICS/ICR-11 INDUSTRIAL CONTROL SUBSYSTEM
; CONVERSIONS ARE INITIATED UNTIL A BUSY CHANNEL IS ENCOUNTERED
; WHEREUPON PROCESSING IS SUSPENDED UNTIL THE CHANNEL BECOMES
; IDLE. SCANNING IS THEN RESUMED AND TERMINATES WHEN ALL TRANS-
; FERS HAVE BEEN COMPLETED OR UPON DETECTION OF AN ERROR.
;
; INPUTS:
;
;       R1=I/O REQUEST PACKET ADDRESS
;       R2=REQUEST UCB PHYSICAL UNIT NUMBER
;       R3=CONTROLLER INDEX
;       R4=ADDRESS OF STATUS CONTROL BLOCK
;       R5=ADDRESS OF UNIT CONTROL BLOCK
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER
;       WD. 13 -- DATA BUFFER ADDRESS
;       WD. 14 -- BYTE COUNT
;       WD. 15 -- RELOCATION BIAS OF CONTROL BUFFER
;       WD. 16 -- CONTROL BUFFER ADDRESS
;
; THE DATA BUFFER RECEIVES VALUES THAT ARE CONVERTED IN
; ACCORDANCE WITH THE GAIN AND CHANNEL SPECIFIED IN THE
; CORRESPONDING CONTROL WORD. EACH WORD IN THE CONTROL BUFF-
; ER CONSISTS OF CHANNEL AND GAIN IN THE FOLLOWING FORMAT:
;
;       BITS 15 - 12 -- GAIN CODE.
;
;               LEGAL GAIN CODES ARE
;
;               0000=GAIN OF 1.
;               0001=GAIN OF 2.
;               0100=GAIN OF 10.
;               0101=GAIN OF 20.
;               1000=GAIN OF 50.
;               1001=GAIN OF 100.
;               1100=GAIN OF 200.
;               1101=GAIN OF 1000.
;
;       BITS 11-0 -- CHANNEL NUMBER.
;
;               EACH ICS/ICR-11 CONTROLLER MAY HAVE UP TO 240
;               PHYSICAL CHANNELS INSTALLED. HOWEVER SINCE EACH
;               ADU02 OCCUPIES A BLOCK OF 120 ADDRESSES THE MAX-
;               IMUM NUMBER OF LOGICAL CHANNELS PER CONTROLLER
;               IS 1920. THE LEGALITY OF A PARTICULAR CHANNEL
;               IS DETERMINED BY THE ENTRIES IN THE A/D MODULE
;               DESCRIPTOR TABLES.
;
;-

        .ENABL  LSB

        .IF DF  I$$CAD

ADRQ:                           ;
        MOV     I.PRM+6(R1),U.CBF(R5) ; SET RELOCATION BIAS OF CONTROL BUFFER
        MOV     I.PRM+10(R1),U.CBF+2(R5) ; SET ADDRESS OF CONTROL BUFFER
        MOV     S.ADC(R4),R3    ; GET ADDRESS OF A/D DESCRIPTOR TABLE
        CLR     ADFBC(R3)       ; CLEAR FINAL BYTE COUNT
10$:                            ;
        CALL    $GTCWD          ; GET CONTROL WORD
        MOV     (SP)+,R0        ; POP CONTROL WORD
        MOV     R0,R2           ; COPY WORD
        BIC     #7777,R2        ; CLEAR ALL BUT GAIN CODE
        BIC     R2,R0           ; CLEAR ALL BUT CHANNEL NUMBER
        CMP     R0,(R3)         ; LEGAL CHANNEL NUMBER?
        BHI     50$             ; IF HIGH NO
        MOV     #120.,R1        ; GET NUMBER OF CHANNELS PER MODULE
        CALL    $DIV            ; GET MODULE NUMBER IN R0, CHANNEL IN R1
        MOV     R0,-(SP)        ; COPY CHANNEL NUMBER
        ASL     R0              ; COMPUTE OFFSET INTO DESCRIPTOR ABLE
        ASL     R0              ; ...
        ADD     (SP)+,R0        ; ...
        ASL     R0              ; ...
        ADD     #ADSTS+2,R0     ; COMPUTE ADDRESS OF DESCRIPTOR ENTRY
        ADD     R3,R0           ; ...
        CMPB    R1,(R0)+        ; LEGAL MODULE NUMBER?
        BHI     50$             ; IF HI NO
        INC     R2              ; SET CONVERT BIT
        SWAB    R2              ; POSITION GAIN CODE TO LOW BYTE
        ASL     R2              ; BIT 15 TO HIGH BYTE
        ASL     R2              ; BIT 14 TO HIGH BYTE
        ASLB    R2              ; DROP BIT 13
        BCS     50$             ; IF C/S ILLEGAL GAIN CODE
        ASL     R2              ; BIT 12 TO HIGH BYTE
        ADD     #8.,R1          ; BIAS CHANNEL NUMBER
        BISB    R1,R2           ; MERGE CHANNEL AND GAIN
        ASL     R2              ; POSITION CONTROL INFORMATION
        ASL     R2              ; ...
        ASL     R2              ; ...
        ASL     R2              ; ...
        MOV     R2,-(SP)        ; PLACE CONTROL WORD ON STACK
        MOV     R0,R1           ; COPY ENTRY ADDRESS
        MOVB    #PR6,PS         ;;; LOCKOUT DEVICE INTERRUPTS
        MOVB    (R1)+,-(SP)     ;;; MODULE BUSY?
        BEQ     20$             ;;; IF EQ NO
        INCB    ADFR(R3)        ;;; REQUEST FORK ON COMPLETION
        MOV     R3,R1           ;;; COPY TABLE ADDRESS
        ADD     #ADNXT,R1       ;;; POINT TO DESCRIPTOR CONTEXT ADDRESS
        MOV     R0,(R1)+        ;;; SAVE ENTRY+1 ADDRESS
20$:                            ;;;
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        MOV     R5,R2           ; COPY UCB ADDRESS
        ADD     #U.BUF,R2       ; POINT TO BUFFER ADDRESS
30$:                            ;
        MOV     (R2)+,(R1)+     ; SAVE BUFFER ADDRESS
        MOV     (R2)+,(R1)+     ; ...
        MOV     (R2),(R1)+      ; SAVE CHANNEL COUNT
        TSTB    (SP)+           ; FIND MODULE BUSY?
        BEQ     40$             ; IF EQ NO
        MOV     (SP)+,(R1)+     ; SAVE CONTROL WORD
        BR      90$             ; EXIT
40$:                            ;
        INCB    (R0)+           ; SET MODULE BUSY
        MOVB    S.ITM(R4),S.CTM(R4) ; ENABLE DEVICE TIMEOUTS
        MOV     ADMBA-2(R0),-(SP) ; PUSH BUS ADDRESS
        MOV     SP,R1           ; SET ADDRESS OF BLOCK
        INCB    ADIP(R3)        ; INCREMENT IN-PROGRESS COUNT
        MOV     R3,R0           ; SAVE TABLE ADDRESS
        CALL    CBINS           ; INSERT IN CIRCULAR BUFFER
        MOV     R0,R3           ; RESTORE TABLE ADDRESS
        MOV     (SP)+,(SP)+     ; CLEAN STACK
        MOV     R5,R2           ; COPY ADDRESS OF UCB
        ADD     #U.BUF+2,R2     ; POINT TO BUFFER ADDRESS
        ADD     #2,(R2)+        ; UPDATE ADDRESS
        DEC     (R2)            ; ANY MORE TO CONVERT?
        BLE     60$             ; IF LE NO

        .IF DF  M$$MGE

        BIT     #20000,-(R2)    ; OVERFLOW 4K BOUNDARY?
        BEQ     10$             ; IF EQ NO
        BIC     #20000,(R2)     ; CLEAR APR 7 OFFSET
        ADD     #200,-(R2)      ; ADJUST ADDRESS BIAS

        .ENDC

        BR      10$             ; PROCESS NEXT REQUEST
50$:                            ;
        MOV     #IE.BAD&377,R0  ; GET ERROR CODE
        BR      70$             ;
60$:                            ;
        MOV     #IS.SUC&377,R0  ; GET STATUS
70$:                            ;
        MOV     U.CNT(R5),R1    ; GET CHANNEL COUNT
        MOVB    #PR6,PS         ;;; INHIBIT DEVICE INTERRUPTS
        MOV     ADFR(R3),R2     ;;; GET FORK REQUEST, IN-PROGRESS COUNT
        BEQ     80$             ;;; IF EQ NO INTERRUPTS PENDING
        INCB    ADFR(R3)        ;;; POST FORK REQUEST
80$:                            ;;;
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        TST     R2              ; INTERRUPTS PENDING?
        BNE     85$             ; IF NE YES, SET STATUS, EXIT
        MOV     #130$,-(SP)     ; SET RETURN ADDRESS
85$:                            ;
        CMP     R1,ADFBC(R3)    ; COMPARE AGAINST CURRENT RETURN COUNT
        BLO     90$             ; IF LO DO NOT OVERRIDE STATUS
        MOV     R1,ADFBC(R3)    ; SET NEW COUNT
        MOV     R0,ADSTS(R3)    ; SET NEW STATUS
90$:                            ;
        RETURN                  ;

;+
;
; **-ADINT-A/D INTERRUPT SERVICE ROUTINE
;
;-

ADINT:                          ;;;
        MOV     (SP)+,R1        ;;; GET CONVERTED DATA
        MOV     S.ADC(R4),R5    ;;; GET ADDRESS OF A/D TABLES
        BEQ     140$            ;;; IF EQ NONE
        TSTB    ADIP(R5)        ;;; A/D IN PROGRESS?
        BEQ     140$            ;;; IF EQ NO, EXIT ISR
        ASL     R3              ;;; COMPUTE MODULE ENTRY OFFSET
        ASL     R3              ;;; ...
        ADD     (SP)+,R3        ;;; ...
        ASL     R3              ;;; ...
        ADD     #ADSTS+ADBSY+2,R3 ;;; COMPUTE OFFSET TO BUSY FLAG
        ADD     R5,R3           ;;; CONVERT TO ADDRESS
        TSTB    (R3)            ;;; MODULE BUSY?
        BEQ     150$            ;;; IF EQ NO
        CLRB    (R3)+           ;;; CLEAR BUSY FLAG

        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;;; SAVE ASR 6 CONTENTS
        MOV     (R3)+,KISAR6    ;;; MAP TO USER BUFFER
        MOV     R1,@(R3)+       ;;; TRANSFER DATA TO USER
        MOV     (SP)+,KISAR6    ;;; RESTORE ASR 6

        .IFF

        MOV     R1,@2(R3)       ;;; TRANSFER DATA TO USER

        .ENDC

        DECB    ADIP(R5)        ;;; DECREMENT IN PROGRESS COUNT
        BNE     150$            ;;; IF NE MORE INTERRUPTS PENDING
        TSTB    ADFR(R5)        ;;; INITIATE FORK ON COMPLETION?
        BEQ     150$            ;;; IF EQ NO
        CLRB    ADFR(R5)        ;;; CLEAR FORK REQUEST FLAG
        CLRB    S.CTM(R4)       ;;; DISABLE DEVICE TIMEOUTS

        .IF GT  I$$C11-1

        MOV     ICUCB,R5        ;;; GET ADDRESS OF UCB

        .IFF

        MOV     CNTBL,R5        ;;; GET ADDRESS OF UCB

        .ENDC

        INC     (SP)+           ;;; CLEAN THE STACK
        CALL    $FORK           ;;; CREATE A SYSTEM PROCESS
        MOV     S.ADC(R4),R3    ; GET ADDRESS OF A/D TABLES
        TST     U.CNT(R5)       ; MORE TO PROCESS?
        BEQ     130$            ; IF EQ NO
        MOV     R3,R2           ; COPY ADDRESS OF A/D TABLES
        ADD     #ADNXT,R2       ; POINT TO ENTRY+1 ADDRESS
        MOV     (R2)+,R0        ; RESTORE ENTRY+1 ADDDRESS
        MOV     R0,R1           ; COPY ADDRESS
        INC     R1              ; POINT TO MODULE CONTEXT
        MOV     ADNXC(R3),-(SP) ; RESTORE CONTROL WORD
        CLR     -(SP)           ; SET 'NOT BUSY' CONDITION
        BR      30$             ; INITIATE DEVICE

;+
;
; **-ICOUT-ICS/ICR-11 DEVICE TIMEOUT PROCESSING
;
; THIS ROUTINE IS CALLED AT DEVICE PRIORITY BY THE EXEC-
; UTIVE WHEN AN INTERRUPT RESPONSE WAS NOT RECEIVED FROM
; THE A/D OR TERMINAL DEVICES WITHIN THE SPECIFIED INTER-
; VAL AFTER INITIATION. TIMEOUT CAUSES THE CURRENT OPERA-
; TION TO BE TERMINATED WITH A FINAL STATUS OF DEVICE NOT
; READY. IF THE CONTROLLER WAS PLACED OFFLINE MANUALLY THE
; REQUEST IS TERMINATED WITH A STATUS OF REQUEST ABORTED. IN
; EITHER CASE A COUNT OF THE NUMBER OF CHANNELS SAMPLED OR
; THE NUMBER OF BYTES TRANSFERRED IS PLACED IN THE SECOND
; STATUS WORD.
;
;-

        .IFTF

ICOUT:                          ;;;

        .IF DF  I$$CR

        MOV     S.FLG(R4),R2    ;;; GET DEVICE FLAGS
        BIC     #TABO!TUND!TUSE,S.FLG(R4) ;;; CLEAR TERMINAL BUSY, IN-USE, ABORT FLAGS

        .ENDC


        .IF DF  I$$CAD!I$$CR

        CLRB    PS              ; ALLOW INTERRUPTS
        MOV     #IE.DNR&377,R0  ; ASSUME DEVICE NOT READY
        BIT     #UFL,R2         ; UNIT OFFLINE?
        BEQ     100$            ; IF EQ NO
        MOV     #IE.ABO&377,R0  ; GET ABORT STATUS
100$:                           ;

        .ENDC

        .IFT

        .IF DF  I$$CR

        BIT     #TUND,R2        ; TERMINAL UNDERWAY?
        BNE     IMFIN           ; IF NE YES, TERMINATE REQUEST

        .ENDC

        CLR     R1              ; CLEAR CHANNEL COUNT
        MOV     S.ADC(R4),R3    ; GET ADDRESS OF A/D TABLES
        MOV     R3,R2           ; COPY A/D TABLE ADDRESS
        MOV     (R2)+,-(SP)     ; PUSH HIGHEST CHANNEL NUMBER
        CLR     (R2)            ; CLEAR IN-PROGRESS, FORK REQUEST FLAGS
        ADD     #ADSTS,R2       ; POINT TO FIRST MODULE ENTRY
110$:                           ;
        TSTB    ADBSY(R2)       ; THIS MODULE BUSY?
        BEQ     120$            ; IF EQ NO
        CLRB    ADBSY(R2)       ; RESET BUSY FLAG
        MOV     ADBTC(R2),R1    ; GET BYTE COUNT
        CALL    85$             ; UPDATE FINAL STATUS
120$:                           ;
        ADD     #ADLGH,R2       ; POINT TO NEXT ENTRY
        SUB     #120.,(SP)      ; DECREMENT CHANNEL COUNT BY ONE BLOCK
        BPL     110$            ; IF PL GO AGAIN
        INC     (SP)+           ; CLEAN THE STACK
130$:                           ;
        MOV     ADSTS(R3),R0    ; SET FINAL STATUS
        MOV     ADFBC(R3),U.CNT(R5) ; SET FINAL BYTE COUNT

        .IFTF

        .IF DF  I$$CAD!I$$CR

IMFIN:                          ;
        MOV     S.PKT(R4),R3    ; GET ADDRESS OF I/O PACKET
        MOV     I.PRM+4(R3),R1  ; GET INITIAL BYTE COUNT
        SUB     U.CNT(R5),R1    ; COMPUTE NUMBER OF BYTES TRANSFERRED
        CALL    $IODON          ; TERMINATE REQUEST
        JMP     IMRQ            ; LOOK FOR MORE WORK

        .ENDC

        .IFT

140$:                           ;;;
        INC     (SP)+           ;;; POP RELATIVE MODULE NUMBER
150$:                           ;;;
        INC     (SP)+           ;;; POP GENERIC CODE

        .ENDC

        RETURN                  ;;; EXIT ISR

        .DSABL  LSB
;+
;
; **-$ICINT-ICS/ICR-11 INTERRUPT SERVICE ROUTINE
;
;-

$ICINT::                        ;;;

        .IF NDF I$$CAD&I$$CIM&I$$CR&I$$CTI

        RTI                     ;;; DISMISS SPURIOUS INTERRUPT

        .IFF


        .ENABL  LSB


        .IF GT  I$$C11-1

        MOVB    PS,TMP          ;;; SAVE CONTROLLER INDEX

        .IFTF

        CALL    $INTSV,PR6      ;;; SAVE R4,R5, SET PRIORITY
        JSR     R3,SAVE         ;;; SAVE R3 - R0

        .IFT

        MOV     TMP,R5          ;;; GET INDEX
        BIC     #^C<17>,R5      ;;; CLEAR ALL BUT INDEX BITS
        MOV     R5,TMP          ;;; SAVE PHYSICAL UNIT NUMBER
        ASL     R5              ;;; CONVERT TO WORD INDEX

        .IFF

        CLR     R5              ;;; SET INDEX TO CONTROLLER 0

        .IFTF

        MOV     CNTBL(R5),R5    ;;; GET UCB ADDRESS

        .IFT

        MOV     R5,ICUCB        ;;; SAVE UCB ADDRESS

        .ENDC

        MOV     U.SCB(R5),R4    ;;; GET SCB ADDRESS
        MOV     S.CSR(R4),R5    ;;; GET ADDRESS OF CSR
        MOV     R5,CSR          ;;; SAVE ADDRESS OF CSR

        .IF DF  I$$CR

        MOV     (R5),R0         ;;; GET CSR CONTENTS
        BIT     #22,R0          ;;; ERROR INTERRUPTS RECOGNIZED?
        BEQ     50$             ;;; IF EQ NO
        BIT     #12000,R0       ;;; ANY ERRORS?
        BEQ     50$             ;;; IF EQ NO
        BIT     #2000,R0        ;;; POWER FAIL?
        BNE     10$             ;;; IF NE YES
        TST     -2(R5)          ;;; CLEAR ERROR FLAGS
        INC     S.ERR(R4)       ;;; INCREMENT ERROR COUNT
        BMI     50$             ;;; IF MI ERROR NOT FATAL
10$:                            ;;;
        BIS     #UNR,S.FLG(R4)  ;;; MARK UNIT NOT READY
        MOV     TMP,R1          ;;; GET CONTROLLER NUMBER
        CALL    STERR           ;;; INITIATE ERROR PROCESSORS

        .IF GT  I$$C11-1

        MOV     ICUCB,R5        ;;; GET ADDRESS OF CURRENT UCB

        .IFF

        MOV     CNTBL,R5        ;;; GET ADDRESS OF UCB

        .ENDC

        TSTB    U.EIP(R5)       ;;; FORK IN PROGRESS?
        BNE     40$             ;;; IF NE YES
        INCB    U.EIP(R5)       ;;; SET FORK UNDERWAY
        MOV     R5,R4           ;;; COPY ADDRESS OF UCB
        ADD     #U.EFB+6,R4     ;;; POINT TO ERROR FORK BLOCK
        CALL    $FORK1          ;;; CREATE A SYSTEM PROCESS
        CLRB    U.EIP(R5)       ; CLEAR IN-PROGRESS FLAG

;+
; **-INIER-INITIATE ERROR PROCESSES
;
; THIS ROUTINE IS CALLED AT FORK LEVEL AFTER A FATAL ERROR
; HAS BEEN DETECTED TO INITIATE ALL TASKS THAT HAVE RECEIVED
; 'ALARM' INFORMATION FOR PROCESSING. SUCH INFORMATION IS CON-
; VEYED TO ALL TASKS THAT ARE CONNECTED TO INTERRUPTS ON THE
; PHYSICAL UNIT AND TO A SINGLE TASK THAT IS LINKED TO ERROR
; INTERRUPTS FROM ALL UNITS
;
; INPUTS:
;
;       R5=UCB ADDRESS OF FAULTY UNIT
;
; OUTPUTS:
;
;       THE UNIT IS PLACED IN THE 'NOT READY' STATE AND
;       ALL SPECIFIED TASKS ARE ACTIVATED.
;
; REGISTERS MODIFIED:
;
; R0 - R5
;
;-

INIER:                          ;
        MOV     U.SCB(R5),R4    ; GET ADDRESS OF SCB

        .IF DF  I$$CLK

        MOV     #ICDVT+ICELH,R3 ; POINT TO ERROR INTERRUPT LISTHEAD
        CALL    ALINK           ; ACTIVATE THE LINKED TASK

        .ENDC

        ADD     #S.DI,R4        ; POINT TO MODULE TABLES
        MOV     #3,-(SP)        ; SET TABLE COUNT
20$:                            ;
        MOV     (R4)+,R5        ; GET TABLE ADDRESS
        BEQ     25$             ; IF EQ NONE
        CALL    ACBUF           ; ACTIVATE CONNECTED TASK
25$:                            ;
        DEC     (SP)            ; DECREMENT TABLE COUNT
        BNE     20$             ; IF NE GO AGAIN
        INC     (SP)+           ; CLEAN STACK
40$:                            ;;; REF. LABEL
        RETURN                  ;;; EXIT INTERRUPT SERVICE ROUTINE
50$:                            ;;;
        TST     R0              ;;; SERIAL LINE BUFFER EMPTY?
        BMI     60$             ;;; IF MI NO
        MOVB    S.ITMC(R4),R2   ;;; SET INITIAL TIMEOUT COUNT
        MOV     S.CBF(R4),R3    ;;; GET ADDRESS OF CIRCULAR BUFFER
        BEQ     60$             ;;; IF EQ, NO CIRCULAR BUFFER
        TST     (R3)            ;;; ANY DATA SENT?
        BMI     60$             ;;; IF MI NO
        BIC     #NORSP,S.FLG(R4) ;;; CLEAR NO-RESPONSE CONDITION
        DEC     (R3)            ;;; ACKNOWLEDGE INTERRUPTS
        BGT     55$             ;;; IF GT MORE THAN ONE OUTPUT QUEUED
        BMI     60$             ;;; IF MI BUFFER NOW EMPTY
        BIC     #10,(R5)        ;;; DISABLE BUFFER EMPTY INTERRUPTS
        CLR     R2              ;;; CLEAR TIMEOUT COUNT
55$:                            ;;;
        MOVB    R2,S.CTMC(R4)   ;;; SET DEVICE TIMEOUT COUNT
        CALL    CBOUT           ;;; OUTPUT DATA TO CONTROLLER
60$:                            ;;;
        TSTB    R0              ;;; MODULE INTERRUPTS?
        BPL     40$             ;;; IF PL NO

        .IFF

        MOV     (R5),R0         ;;; GET CSR CONTENTS
        TSTB    R0              ;;; MODULE INTERRUPTS?
        BMI     60$             ;;; IF MI YES
        RETURN                  ;;; EXIT ISR
60$:                            ;;;

        .ENDC

        MOV     -2(R5),R2       ;;; GET ICAR CONTENTS
        CLR     R1              ;;; SET FOR MOVB WITHOUT SIGN EXTENSION
        BISB    R2,R1           ;;; GET MODULE OFFSET
        CLRB    R2              ;;; CLEAR LOW BYTE OF ICAR COPY
        SWAB    R2              ;;; POSITION GENERIC CODE AND FLAGS TO LOW BYTE

        .IF DF  I$$CAD!I$$CIM!I$$CTI

        MOV     R1,R3           ;;; COPY MODULE OFFSET
        BIC     #^C<17>,R3      ;;; CONVERT TO MODULO 16.
        MOV     R2,-(SP)        ;;; PUSH GENERIC CODE
        BIC     #^C<7>,(SP)     ;;; CLEAR EXTRANEOUS BITS

        .IF DF  I$$CR

        BEQ     70$             ;;; IF EQ REMOTE TERMINAL

        .ENDC

        ADD     S.IM(R4),R3     ;;; COMPUTE MAPPING TABLE ADDRESS
        MOVB    (R3),R3         ;;; GET RELATIVE MODULE NUMBER
        BR      80$             ;;;

        .IFF

        CLR     -(SP)           ;;; CLEAR GENERIC CODE

        .ENDC

        .IF DF  I$$CR

70$:                            ;;;
        CLR     R3              ;;; FORCE RELATIVE MODULE NUMBER OF ZERO
        BIS     #40,(R5)        ;;; SET TERMINAL MODE

        .IFTF

80$:                            ;;;
        MOV     R3,-(SP)        ;;; PUSH RELATIVE MODULE NUMBER
        ASL     R1              ;;; CONVERT MODULE OFFSET TO WORD BIAS
        BIS     #1,(R5)         ;;; SET THE RIF BIT
        MOV     ICMD(R1),-(SP)  ;;; PUSH MODULE DATA

        .IFT

        BIC     #40,(R5)        ;;; CLEAR TERMINAL MODE

        .IF DF  I$$CAD!I$$CIM!I$$CTI

        BIT     #7,R2           ;;; TERMINAL INPUT?
        BNE     83$             ;;; IF NE NO

        .ENDC

        BIT     #20,R2          ;;; TERMINAL DATA AVAILABLE?
        BNE     82$             ;;; IF NE YES
        JMP     RTINT           ;;; PROCESS OUTPUT INTERRUPT
82$:                            ;;;
        BICB    #200,(SP)       ;;; CLEAR PARITY BIT
        MOV     S.RTI(R4),R5    ;;; GET ADDRESS OF REMOTE TERMINAL TABLE
        BR      90$             ;;;
83$:                            ;;;

        .ENDC

        .IF DF  I$$CIM!I$$CTI&I$$CAD

        CMP     #7,4(SP)        ;;; A/D INPUT?
        BNE     85$             ;;; IF NE NO

        .ENDC

        .IF DF  I$$CAD

        JMP     ADINT           ;;; PROCESS A/D INPUT
85$:                            ;;;

        .ENDC

        .IF DF  I$$CIM

        MOV     S.DI(R4),R5     ;;; GET DIGITAL INTERRUPT TABLE ADDRESS

        .ENDC

        .IF DF  I$$CTI&I$$CIM

        BIT     #4,R2           ;;; CONTACT INTERRUPT MODULE?
        BEQ     90$             ;;; IF EQ YES

        .ENDC

        .IF DF  I$$CTI

        MOV     S.CT(R4),R5     ;;; GET COUNTER TABLES

        .ENDC

90$:                            ;;;

        .IF DF  I$$CIM!I$$CR!I$$CTI

        CLR     RUN             ;;; RESET RUN FLAG
        MOV     #6,R1           ;;; SET NUMBER OF BYTES CURRENTLY ON STACK
        TST     R5              ;;; SPURIOUS INTERRUPT?
        BEQ     172$            ;;; IF EQ YES

        .IF DF  I$$CIM!I$$CTI&I$$CR                                     ; GK005
                                                                        ; GK005
        CLR     -(SP)           ;;; CLEAR A WORD                        ; GK005
        CMP     R5,S.RTI(R4)    ;;; PROCESSING TERMINAL INTERRUPTS?     ; GK005
        BEQ     100$            ;;; IF EQ YES                           ; GK005
        MOV     R3,(SP)         ;;; COPY RELATIVE MODULE NUMBER         ; GK005
                                                                        ; GK005
        .IFF                                                            ; GK005
                                                                        ; GK005
        MOV     R3,-(SP)        ;;; COPY RELATIVE MODULE NUMBER         ; GK005
                                                                        ; GK005
        .ENDC                                                           ;**-22

100$:                           ;;;

        .IF DF  I$$CIM!I$$CTI

        ASL     R3              ;;; MULTIPLY BY TABLE ENTRY SIZE
        ASL     R3              ;;; ...
        ADD     (SP)+,R3        ;;;
        ASL     R3              ;;; ...

        .ENDC

        ADD     #IMDAT,R3       ;;; OFFSET TO MODULE DATA ENTRIES
        ADD     R5,R3           ;;;

        .IF DF  I$$CR!I$$CTI&I$$CIM

        CMP     R5,S.DI(R4)     ;;; DIGITAL INTERRUPTS?
        BNE     130$            ;;; IF NE NO

        .ENDC

        .IF DF  I$$CIM

        MOV     (SP),R1         ;;; COPY DATA WORD
        MOV     IMPRV(R3),R0    ;;; COPY PREVIOUS STATE
        MOV     R1,IMPRV(R3)    ;;; SET NEW 'PREVIOUS'
        BIC     R0,R1           ;;; CLEAR ALL NEW BITS THAT DID NOT CHANGE
        BIC     (SP),R0         ;;; CLEAR ALL OLD BITS THAT DID NOT CHANGE
        BIS     R0,R1           ;;; COMBINE ALL THAT CHANGED STATE
        CLR     R0              ;;; ASSUME ALL COS WANTED
        COM     R2              ;;; COMPLEMENT PCL, POP FLAGS
        BIT     #140,R2         ;;; BOTH PCL AND POP WANTED
        BEQ     110$            ;;; IF EQ YES
        MOV     (SP),R0         ;;; GET DATA AGAIN
        BIT     #100,R2         ;;; PCL WANTED?
        BNE     110$            ;;; IF NE NO
        COM     R0              ;;; SET ALL OPEN POINTS
110$:                           ;;;
        BIC     R0,R1           ;;; CLEAR UNWANTED COS BITS
        BNE     120$            ;;; IF NE SOME CHANGED STATE
        ADD     #6,SP           ;;; CLEAN STACK
        BR      175$            ;;; EXIT ISR
120$:                           ;;;
        MOV     R1,-(SP)        ;;; SAVE CHANGE OF STATE
        MOV     R1,-(SP)        ;;; SET RESOURCE MASK

        .IF DF  I$$CLK

        CALL    SLINK           ;;; ACTIVATE ANY LINKED TASKS
        ADC     RUN             ;;; UPDATE RUN FLAG

        .ENDC

        BR      170$            ;;; CONTINUE

        .ENDC

130$:                           ;;;

        .IF DF  I$$CR!I$$CTI

        CLR     -(SP)           ;;; CLEAR SECOND HARDWARE WORD

        .IF DF  I$$CLK

        MOV     #-1,-(SP)       ;;; SET RESOURCE MASK

        .IFTF

        .IF DF  I$$CTI&I$$CR

        CMP     R5,S.CT(R4)     ;;; PROCESSING COUNTERS?
        BNE     140$            ;;; IF NE NO

        .ENDC

        .IF DF  I$$CTI

        TST     IMTCB(R5)       ;;; TASK CONNECTED?
        BEQ     150$            ;;; IF EQ NO
        MOV     4(SP),R1        ;;; COPY COUNTER DATA
        ROL     R1              ;;; TIME TO UPDATE COUNTER?
        BVS     150$            ;;; IF VS NO (INTERRUPTED ON HALF-COUNT)

        .IF DF  I$$CR

        BIS     #100000,IMBA(R3) ;;; SET 'REFRESH' FLAG
        INC     RUN             ;;; FORCE PASS THROUGH FORK PROCESSOR

        .IFF

        MOV     IMBA(R3),R1     ;;; GET BUS ADDRESS/2
        ASL     R1              ;;; CONVERT TO BUS ADDRESS
        MOV     IMPRV(R3),(R1)  ;;; REFRESH COUNTER

        .ENDC

        BR      150$            ;;;

        .ENDC

140$:                           ;;; REF. LABEL

        .IF DF  I$$CR

        CMPB    4(SP),#3        ;;; CONTROL-C?
        BNE     160$            ;;; IF NE NO

        .ENDC

150$:                           ;;; REF. LABEL

        .IFT

        CALL    SLINK           ;;; ACTIVATE LINKED TASKS
        ADC     RUN             ;;; UPDATE RUN FLAG

        .IFTF

160$:                           ;;; REF. LABEL

        .IFT

        MOV     (SP)+,(SP)      ;;; COLLAPSE STACK

        .ENDC

        .ENDC

170$:                           ;;; REF. LABEL
        CLR     R2              ;;; FLAG ENTRY NOT FORCED
        CALL    CENTR           ;;; ENTER DATA IN CIRCULAR BUFFER
        ADC     RUN             ;;; UPDATE RUN FLAG
        MOV     R5,R4           ;;; COPY TABLE ADDRESS
        MOVB    IMBPE(R4),R1    ;;; GET BYTES PER ENTRY
172$:                           ;;;
        ADD     R1,SP           ;;; CLEAN STACK
175$:                           ;;;
        TST     RUN             ;;; FORK PROCESSING REQUIRED?
        BEQ     220$            ;;; IF EQ NO, EXIT ISR
        TSTB    IMFIP(R4)       ;;; FORK NOW IN PROGRESS?
        BEQ     220$            ;;; IF EQ YES
        CLRB    IMFIP(R4)       ;;; SET FORK PENDING
        ADD     #IMFRK+6,R4     ;;; POINT TO FORK BLOCK
        CALL    $FORK1          ;;; CREATE A SYSTEM PROCESS
        INCB    IMFIP(R5)       ; CLEAR FORK-PENDING FLAG

        .IF DF  I$$CLK!I$$CR

        MOV     IMSCB(R5),R4    ; GET SCB ADDRESS

        .ENDC

        .IF DF  I$$CLK

        CMP     -(SP),-(SP)     ; RESERVE TWO WORDS ON THE STACK

        .ENDC

        .IF DF  I$$CIM!I$$CR&I$$CLK

        MOV     #CILGH,2(SP)    ; SET LENGTH OF CONTACT INTERRUPT ENTRY
        MOV     (R5),(SP)       ; PUSH MAX POINT OR CHANNEL

        .ENDC

        .IF DF  I$$CIM&I$$CLK

        ASR     (SP)            ; CONVERT TO NUMBER OF HIGHEST MODULE
        ASR     (SP)            ; ...
        ASR     (SP)            ; ...
        ASR     (SP)            ; ...

        .ENDC

        .IF DF  I$$CLK!I$$CR

        .IF DF  I$$CIM!I$$CR&I$$CTI

        CMP     S.CT(R4),R5     ; PROCESSING COUNTERS?
        BNE     200$            ; IF NE NO

        .ENDC

        .ENDC

        .IF DF  I$$CLK&I$$CTI

        MOV     #CTLGH,2(SP)    ; SET LENGTH OF COUNTER ENTRY
        MOV     (R5),(SP)       ; SET NUMBER OF HIGHEST COUNTER

        .ENDC

        .IF DF  I$$CR&I$$CTI

        MOV     R5,R3           ; SET ADDRESS OF COUNTER TABLES
        TST     IMTCB(R3)       ; ANY TASK CONNECTED?
        BEQ     200$            ; IF EQ NO
        MOV     (R3),R0         ; GET HIGHEST COUNTER NUMBER
        ADD     #IMDAT+IMPRV,R3 ; POINT TO PREVIOUS STATE ENTRY
180$:                           ;
        TST     IMBA-IMPRV(R3)  ; REFRESH BIT SET?
        BPL     190$            ; IF PL NO
        CALL    SETCT           ; REFRESH COUNTER
190$:                           ;
        ADD     #CTLGH,R3       ; STEP TO NEXT MODULE ENTRY
        DEC     R0              ; DECREMENT COUNT
        BPL     180$            ; IF PL GO AGAIN

        .ENDC

200$:                           ; REF. LABEL

        .IF DF  I$$CLK

        MOV     R5,R4           ; COPY TABLE ADDRESS
        ADD     #IMDAT+IMLH,R4  ; POINT TO MODULE ENTRIES
210$:                           ;
        MOV     R4,R3           ; COPY ADDRESS OF ENTRY
        CALL    ALINK           ; ACTIVATE LINKED TASK
        ADD     2(SP),R4        ; POINT TO NEXT ENTRY
        DEC     (SP)            ; DECREMENT MODULE COUNT
        BPL     210$            ; IF PL GO AGAIN
        CMP     (SP)+,(SP)+     ; CLEAN STACK

        .ENDC

;+
; **-ACBUF-ACTIVATE TASK CONNECTED TO CIRCULAR BUFFER
;
; THIS SUBROUTINE IS CALLED TO ACTIVATE A TASK THAT IS
; CONNECTED TO A CIRCULAR BUFFER AND SET THE TRIGGER
; EVENT FLAG.
;
; INPUTS:
;
;       R5=INTERRUPT MODULE TABLE ADDRESS
;
; OUTPUTS:
;
;       IF A TASK IS CONNECTED THE TRIGGER EVENT FLAG IS SET
;       AND THE TASK IS MADE ACTIVE.
;
; REGISTERS MODIFIED:
;
; RO - R3
;
;-

ACBUF:                          ;
        MOV     IMTCB(R5),R0    ; GET TCB ADDRESS
        BEQ     220$            ; IF EQ NONE, EXIT
        BIS     IMEVM(R5),@IMEVA(R5) ; SET EVENT FLAG MASK
        CALL    $SETCR          ; CONDITIONALY SCHEDULE TASK
220$:                           ;;;
        RETURN                  ;;; EXIT INTERRUPT SERVICE ROUTINE

        .ENDC

        .ENDC

        .DSABL  LSB

;+
; **-ICAN-CANCEL I/O OPERATION
;
; THIS ROUTINE IS CALLED BY THE EXECUTIVE TO CANCEL ALL I/O IN
; PROGRESS FOR THE CURRENT TASK. IF THE TASK IS CONNECTED TO
; EITHER CONTACT INTERRUPTS, COUNTERS OR REMOTE TERMINAL
; INTERRUPTS IT IS DISCONNECTED. ALL A/D INPUT IS ALLOWED TO
; COMPLETE SINCE IT WILL DO SO WITHIN A REASONABLE AMOUNT OF TIME.
; ALL TERMINAL OUTPUT IS SET TO TERMINATE ON THE OCCURENCE OF THE
; NEXT OUTPUT INTERRUPT.
;
;-

        .ENABL  LSB

ICAN:                           ;;;

        .IF DF  I$$CIM!I$$CR!I$$CTI

        MOV     R1,R0           ;;; SET TCB ADDRESS OF CURRENT TASK

        .IF DF  I$$CIM

        MOV     S.DI(R4),R3     ;;; GET ADDRESS OF CONTACT INTERRUPT TABLES

        .ENDC

        .IF DF  I$$CR!I$$CTI&I$$CIM

        CALL    ICAN1           ;;; DISCONNECT TASK

        .ENDC

        .IF DF  I$$CTI

        MOV     S.CT(R4),R3     ;;; GET ADDRESS OF COUNTER TABLES

        .ENDC

        .IF DF  I$$CR&I$$CTI

        CALL    ICAN1           ;;; DISCONNECT TASK

        .ENDC

        .IF DF  I$$CR

        BIT     #TUSE,S.FLG(R4) ;;; TERMINAL IN USE?
        BEQ     5$              ;;; IF EQ NO
        MOV     S.PKT(R4),R1    ;;; GET ADDRESS OF I/O PACKET
        CMP     R0,I.TCB(R1)    ;;; TERMINAL IN USE BY THIS TASK?
        BNE     5$              ;;; IF NE NO
        BIS     #TABO,S.FLG(R4) ;;; FORCE I/O COMPLETION ON NEXT TERMINAL INTERRUPT
5$:                             ;;;
        MOV     S.RTI(R4),R3    ;;; GET ADDRESS OF REMOTE TERMINAL TABLES

        .ENDC

;+
;
; **-ICAN1-CONDITIONALLY DISCONNECT A TASK FROM INTERRUPTS
;
; THIS SUBROUTINE IS CALLED TO CONDITIONALLY DISCONNECT A TASK FROM
; ICS/ICR UNSOLICITED INTERRUPTS. IF THE MODULE IS INSTALLED ON THE
; CONTROLLER AND THE TCB ADDRESS MATCHES THAT OF THE CONNECTED TASK THEN
; THE TASK IS DISCONNECTED.
;
; INPUTS:
;
;       Z/CLEAR IF SPECIFIED MODULE TYPE IS INSTALLED ON THIS CONTROLLER
;
;       R0 = TCB ADDRESS OF TASK TO BE DISCONNECTED
;       R3 = MODULE TABLE ADDRESS
;       R4 = SCB ADDRESS
;       R5 = UCB ADDRESS
;
; OUTPUTS:
;
;       C/CLEAR: TASK DISCONNECTED FROM INTERRUPTS
;
;       THE TCB ADDRESS, EVENT FLAG MASK AND ADDRESS IN THE DEVICE TABLE
;       ARE CLEARED.
;
;
;       C/SET: TASK NOT CONNECTED OR NON-EXISTENT MODULE TYPE SPECIFIED.
;       Z/SET: NON EXISTENT MODULE TYPE SPECIFIED.
;
; REGISTERS MODIFIED:
;
; R1
;
;-

ICAN1:                          ;;;
        BEQ     10$             ;;; IF EQ MODULE DOES NOT EXIST
        CMP     R0,IMTCB(R3)    ;;; THIS TASK CONNECTED?
        BNE     10$             ;;; IF NE NO
        CLR     IMTCB(R3)       ;;; DISCONNECT TASK
        CLR     IMEVA(R3)       ;;; CLEAR ADDRESS OF EVENT FLAG MASK
        CLR     IMEVM(R3)       ;;; CLEAR EVENT FLAG MASK
        DECB    T.IOC(R0)       ;;; DECREMENT OUTSTANDING I/O COUNT

        .IF DF  D$$SHF

        MOV     T.PCB(R0),R1    ;;; GET ADDRESS OF PCB
        BIC     #PS.NSF,P.STAT(R1) ;;; ENABLE SHUFFLING

        .ENDC

        BR      20$             ;;;
10$:                            ;;;
        SEC                     ;;; SET NO-CONNECT FLAG
20$:                            ;;;

        .ENDC

        RETURN                  ;;;

        .DSABL  LSB

;+
;
; **-ICPWF-DEVICE DEPENDANT POWER RECOVERY CODE
;
; POWER FAILURE IS HANDLED VIA THE DEVICE TIMEOUT FACILITIES AND
; THEREFORE CAUSES NO IMMEDIATE ACTION. THE ICS/ICR-11 CONTROL BLOCK
; ADDRESS IS STORED, THE STATE OF ALL VOLATILE OUTPUT MODULES IS
; RESTORED AND ALL ICS/ICR-11 INTERRUPTS ARE ENABLED.
;-
        .ENABL  LSB

ICPWF:                          ;

        .IF DF  I$$CAD!I$$CIM!I$$CTI!I$$CR

        MOV     R5,CNTBL(R3)    ; SAVE ADDRESS OF UCB

        .ENDC


        .IF DF  I$$CR

        MOV     #WDFLG,R0       ; GET ADDRESS OF WATCHDOG FLAG
        TST     (R0)            ; WATCHDOG TIMER SCHEDULED?
        BNE     RSTOR           ; IF NE YES
        MOV     PC,(R0)+        ; SET TIMER FLAG
        CALL    SWDT            ; INITIATE WATCHDOG TIMER

        .IFTF

        MOV     U.SCB(R5),R4    ; RESTORE ADDRESS OF SCB

;+
; **-RSTOR-RESTORE THE STATE OF THE ICS/ICR CONTROLLER
;
; THIS SUBROUTINE IS CALLED TO RESTORE THE STATE OF THE ICR CIRCULAR
; OUTPUT BUFFER, ANALOG OUTPUTS, COUNTER MODULES AND LATCHING OUTPUTS
; FOLLOWING A POWER FAIL AT THE PROCESSOR OR A FAULT AT THE REMOTE SITE.
; THE STATE OF EACH COUNTER IS RESTORED PROVIDED THAT:
;
;       (1) A TASK IS CONNECTED OR,
;       (2) A TASK IS LINKED TO RECEIVE COUNTER INTERRUPTS AND
;           A NON-ZERO COUNTER VALUE WAS SPECIFIED.
;
; INPUTS:
;
;       R4=SCB ADDRESS
;       R5=UCB ADDRESS
;
; OUTPUTS:
;
;       THE CIRCULAR OUTPUT BUFFER IS PLACED IN THE EMPTY STATE AND
;       THE STATE OF EACH COUNTER MODULE, ANALOG OUTPUT CHANNEL AND
;       LATCHING OUTPUT MODULE IS RESTORED AS PREVIOUSLY DESCRIBED.
;
; REGISTERS MODIFIED:
;
;  R0 - R3
;
;-

RSTOR:                          ;

        .IFT

        MOV     S.CBF(R4),R3    ; GET ADDRESS OF CIRCULAR BUFFER
        BEQ     5$              ; IF EQ, NO CIRC. BFR (ICS11)
        MOV     #-1,(R3)+       ; SET BUFFER EMPTY
        MOV     R3,(R3)         ; SET ADDRESS OF BUFFER+2
        ADD     #CDAT-2,(R3)    ; COMPUTE ADDRESS OF OUTPUT POINTER
        MOV     (R3)+,(R3)      ; INSERT ADDRESS OF INPUT POINTER
        MOV     (R3)+,(R3)      ; COPY ADDRESS OF INPUT POINTER
        ADD     #CLGH-CDAT-2,(R3) ; COMPUTE END ADDRESS
5$:                             ;
        BIT     #UFL,S.FLG(R4)  ; ERROR INTERRUPTS RECOGNIZED?
        BNE     10$             ; IF NE NO
        BIS     #22,@S.CSR(R4)  ; ENABLE ERROR INTERRUPTS
        BIT     #UNR,S.FLG(R4)  ; UNIT READY?
        BNE     60$             ; IF NE NO

        .ENDC

10$:                            ; REF. LABEL
        BIS     #4,@S.CSR(R4)   ; ENABLE MODULE INTERRUPTS

        .IF DF  I$$CIM!I$$CLT!I$$CDA

        TSTB    U.RST(R5)       ; RESTORE STATE OF THIS CONTROLLER?
        BEQ     60$             ; IF EQ NO

        .ENDC

        .IF DF  I$$CTI

        MOV     S.CT(R4),R3     ; GET ADDRESS OF COUNTER TABLES
        BEQ     20$             ; IF EQ NONE
        CALL    RSETC           ; RESET ALL COUNTERS
20$:                            ;

        .ENDC

        .IF DF  I$$CIM                                                  ; GK005
                                                                        ; GK005
        MOV     S.DI(R4),R3     ; GET ADDRESS OF DIGITAL INTERRUPT TABLE; GK005
        BEQ     25$             ; IF EQ NONE                            ; GK005
        CALL    READDI          ; READ IN CURRENT STATES                ; GK005
25$:                                                                    ; GK005
                                                                        ; GK005
        .ENDC                                                           ; GK005
                                                                        ; GK005
        .IF DF  I$$CDA

        MOV     R4,R0           ; COPY SCB ADDRESS
        ADD     #S.DAC,R0       ; POINT TO D/A TABLES
        MOV     (R0)+,R3        ; GET MAPPING TABLE ADDRESS
        BEQ     40$             ; IF EQ NONE
        MOV     2(R0),-(SP)     ; PUSH NUMBER OF CHANNELS-1
        MOV     (R0),R0         ; POINT TO PREVIOUS STATE TABLE
        CLR     -(SP)           ; RESERVE SPACE ON THE STACK
30$:                            ;
        MOV     (R0)+,R1        ; GET PREVIOUS STATE
        BIC     #140000,R1      ; CLEAR CHANNEL NUMBER
        BIC     #37777,(SP)     ; CLEAR VOLTAGE REPRESENTATION
        BIS     R1,(SP)         ; MERGE CHANNEL AND VOLTAGE
        MOV     #ICMD/2&77777,-(SP) ; PUSH BUS ADDRESS OF ICR/2
        BISB    (R3),(SP)       ; MERGE MODULE OFFSET
        MOV     SP,R1           ; SET ADDRESS OF BLOCK
        CALL    CBINS           ; OUTPUT TO DEVICE
        TST     (SP)+           ; CLEAN STACK
        ADD     #40000,(SP)     ; INCREMENT CHANNEL NUMBER
        ADC     R3              ; STEP TO NEXT MODULE ON OVERFLOW
        DEC     2(SP)           ; DECREMENT COUNT
        BPL     30$             ; IF PL GO AGAIN
        CMP     (SP)+,(SP)+     ; CLEAN STACK
40$:                            ;

        .ENDC

        .IF DF  I$$CLT

        MOV     R4,R0           ; COPY ADDRESS OF SCB
        ADD     #S.LTO,R0       ; POINT TO LATCHING OUTPUT TABLE ADDRESSES
        MOV     (R0)+,R3        ; GET MAPPING TABLE ADDRESS
        BEQ     60$             ; IF EQ NONE
        MOV     2(R0),-(SP)     ; SET POINT COUNT-1
        MOV     (R0),R0         ; GET ADDRESS OF PREVIOUS STATE TABLE
50$:                            ;
        MOV     (R0)+,-(SP)     ; PUSH PREVIOUS STATE
        MOV     #ICMD/2&77777,-(SP) ; PUSH BUS ADDRESS/2
        BISB    (R3)+,(SP)      ; COMBINE WITH MODULE OFFSET BIAS
        MOV     SP,R1           ; COPY ADDRESS OF BLOCK
        CALL    CBINS           ; INSERT IN CIRCULAR BUFFER
        CMP     (SP)+,(SP)+     ; CLEAN STACK
        SUB     #16.,(SP)       ; DECREMENT POINT COUNT
        BPL     50$             ; IF PL GO AGAIN
        INC     (SP)+           ; CLEAN THE STACK

        .ENDC
60$:                            ;
        RETURN

        .DSABL  LSB

;+
; **-ICWDT-WATCHDOG TIMER ROUTINE
;
; THIS ROUTINE IS SCHEDULED BY THE DRIVER TO PERIODICALY RE-
; SET THE SOFTWARE WATCHDOG TIMERS FOR ALL CONTROLLERS AND PER-
; FORM ERROR RECOVERY FOR ANY CONTROLLER THAT IS IN THE NOT-READY
; STATE.
;
;-
        .ENABL  LSB

        .IF DF  I$$CR

ICWDT:                          ;
        MOV     #I$$C11,-(SP)   ; SET COUNT OF CONTROLLERS
10$:                            ;
        MOV     #CNTBL-2,R5     ; GET ADDRESS OF UCB TABLE
        ADD     (SP),R5         ; OFFSET TO CONTROLLER SLOT
        ADD     (SP),R5         ; ...
        MOV     (R5),R5         ; GET UCB ADDRESS
        BEQ     40$             ; IF EQ CONTROLLER OFFLINE
        BITB    #US.OFL,U.ST2(R5) ; CONTROLLER OFFLINE?
        BNE     40$             ; IF NE YES
        MOV     U.SCB(R5),R4    ; GET ADDRESS OF SCB
        MOV     #-I$$CWD,S.ERR(R4) ; RESET WATCHDOG TIMER
        TSTB    S.CTMC(R4)      ; CONTROLLER TIMEOUT ACTIVE?
        BEQ     20$             ; IF EQ NO
        DECB    S.CTMC(R4)      ; DECREMENT TIMEOUT COUNT
        BNE     40$             ; IF NE OK
        CALL    CTOUT           ; INITIATE TIMEOUT PROCESSING
        BR      40$             ;
20$:                            ;
        MOV     S.CSR(R4),R2    ; GET CSR ADDRESS
        BIT     #UNR,S.FLG(R4)  ; DEVICE NOT READY?
        BEQ     40$             ; IF EQ NO
        BIT     #12000,(R2)     ; ERROR CONDITIONS PRESENT?
        BNE     30$             ; IF NE YES
        BIC     #UNR,S.FLG(R4)  ; CLEAR NOT-READY FLAG
        CALL    RSTOR           ; RESTORE CONTROLLER
        BR      40$             ;
30$:                            ;
        MOV     -(R2),R2        ; CLEAR ERROR FLAGS
40$:                            ;
        DEC     (SP)            ; DECREMENT CONTROLLER COUNT
        BGT     10$             ; IF GT MORE TO GO
        INC     (SP)+           ; CLEAN STACK
        MOV     #WDFLG+2,R0     ; GET ADDRESS OF TIMER PACKET
SWDT:                           ;
        CLR     R1              ; CLEAR HIGH ORDER DELTA TIME
        MOV     $TKPS,R2        ; GET TICKS PER SECOND
        MOV     #C.SYST,R4      ; SET REQUEST TYPE
        CALLR   $CLINS          ; INSERT IN CLOCK QUEUE

        .ENDC


        .DSABL  LSB


;+
;
; **-ALINK-ACTIVATE A LINKED TASK
;
; THIS SUBROUTINE IS CALLED TO ACTIVATE ALL TASKS LINKED
; TO A GIVEN INTERRUPT LIST. IF THE SPECIFIED TASK IS AC-
; TIVE THEN THE EVENT FLAG DEFINED THROUGH THE LINK FUNC-
; TION IS SET ELSE THE TASK IS REQUESTED TO RUN.
;
; INPUTS:
;
;       R3=ADDRESS OF INTERRUPT LINK LIST
;
; OUTPUTS:
;
;       IF THE 'RUN' FLAG IS SET IN THE ENTRY, THEN THE
;       TASK IS MADE ACTIVE AS DESCRIBED ABOVE ELSE THE
;       SPECIFIED EVENT FLAG IS SET.
;
; REGISTERS MODIFIED:
;
; R0 - R3
;
;-

        .IF DF  I$$CIM!I$$CR!I$$CTI&I$$CLK

ALINK:                          ;
        MOV     R3,-(SP)        ; SAVE LISTHEAD ADDRESS
10$:                            ;
        MOV     @(SP)+,R3       ; GET LINK TO NEXT
        BEQ     30$             ; IF EQ DONE WITH LIST
        MOV     R3,-(SP)        ; SAVE ADDRESS OF THIS ENTRY
        TST     ILRUN(R3)       ; RUN FLAG SET?
        BEQ     10$             ; IF EQ NO
        CLR     ILRUN(R3)       ; CLEAR RUN FLAG
        MOV     ILTE(R3),R0     ; GET ADDRESS OF LINKED TASK ENTRY
        MOV     LTCB(R0),R0     ; GET ADDRESS OF TCB
        MOV     T.STAT(R0),R1   ; GET TASK STATUS FLAGS
        BIT     #TS.EXE,R1      ; TASK ACTIVE?
        BNE     20$             ; IF NE NO
        BIT     #T2.ABO,T.ST2(R0) ; TASK BEING ABORTED?
        BNE     10$             ; IF NE YES
        BIT     #TS.OUT,R1      ; TASK OUT OF MEMORY?
        BEQ     15$             ; IF EQ NO
        BIT     #TS.CKP,R1      ; TASK CHECKPOINTED?
        BEQ     10$             ; IF EQ NO
15$:                            ;
        MOV     ILEVA(R3),R2    ; GET ADDRESS OF EVENT FLAG MASK
        BEQ     10$             ; IF EQ NONE
        BIS     ILEVM(R3),(R2)  ; SET EVENT FLAG
        CALL    $SETCR          ; ISSUE CONDITIONAL SCHEDULE REQUEST
        BR      10$             ; GO AGAIN
20$:                            ;
        CLR     R1              ; SET DEFAULT UIC
        CALL    $TSKRT          ; REQUEST TASK
        BR      10$             ; GO AGAIN
30$:                            ;
        RETURN                  ;

        .ENDC

;+
;
; **-CBINS-INSERT AN ENTRY IN THE CIRCULAR BUFFER
;
; INPUTS:
;
;       R1=ADDRESS OF TWO-WORD DATA BLOCK CONTAINING THE
;          FOLLOWING:
;
;          WD. 00 -- BUS ADDRESS/2!REMOTE TERMINAL BIT(MSB)
;          WD. 01 -- BUS DATA
;
;       R4=ADDRESS OF STATUS CONTROL BLOCK
;
; OUTPUTS:
;
;       C/CLEAR: ENTRY INSERTED IN BUFFER
;
;       C/SET: CONTROLLER TIME-OUT DETECTED.
;
;
; IF CONTROLLER TIME-OUT IS DETECTED THE APPROPRIATE ERROR
; PROCESSING IS INITIATED.
;
; R1 AND R2 ARE MODIFIED
;
;-

CBINS:                          ;

        .IF DF  I$$CR

        MOV     R3,-(SP)        ; SAVE R3
        MOV     S.CBF(R4),R3    ; GET ADDRESS OF CIRCULAR BUFFER
        BEQ     60$             ; IF EQ 0, NO CBF (THIS IS ICS11)
        MOV     #TMOUT,-(SP)    ; SET DEVICE TIME-OUT COUNT
10$:                            ;
        CMP     #<CLGH-CDAT>/4-1,(R3) ; ROOM IN BUFFER?
        BGT     20$             ; IF GT YES
        DEC     (SP)            ; DECREMENT TIME-OUT COUNT
        BNE     10$             ; IF NE TRY AGAIN
        MOV     R0,(SP)         ; SAVE R0
        CALL    CTOUT           ; INITIATE DEVICE TIME-OUT PROCESSING
        MOV     (SP),R0         ; RESTORE R0
        BR      50$             ; EXIT
20$:                            ;
        CMP     (R3)+,(R3)+     ; POINT TO INPUT POINTER
        MOVB    #PR6,PS         ;;; LOCKOUT DEVICE INTERRUPTS
        MOV     (R3)+,R2        ;;; GET INPUT POINTER
        MOV     2(R1),(R2)+     ;;; SET OUTPUT DATA
        MOV     (R1),(R2)+      ;;; SET BUS ADDRESS
        CMP     R2,(R3)+        ;;; AT END OF BUFFER?
        BLO     30$             ;;; IF LO NO
        MOV     R3,R2           ;;; RESET POINTER TO START OF DATA
30$:                            ;;;
        MOV     R2,CIN-CDAT(R3) ;;; SAVE INPUT POINTER
        INC     CBSY-CDAT(R3)   ;;; INCREMENT BUSY COUNT
        BEQ     35$             ;;; IF EQ NO INTERRUPTS WANTED
        BIS     #10,@S.CSR(R4)  ;;; ENABLE INTERRUPTS
        MOVB    S.ITMC(R4),S.CTMC(R4) ;;; ENABLE CONTROLLER TIMEOUTS
        BR      40$             ;;;
35$:                            ;;;
        CALL    CBOUT           ;;; STARTUP INTERRUPTS
40$:                            ;;;
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
50$:                            ;
        INC     (SP)+           ; CLEAN STACK
        MOV     (SP)+,R3        ; RESTORE R3
        RETURN                  ;
60$:                            ;
        MOV     (SP)+,R3        ; RESTORE R3

        .IFTF

        MOV     (R1)+,R2        ; GET BUS ADDRESS/2
        ASL     R2              ; CONVERT TO BUS ADDRESS
        MOV     (R1),(R2)       ; TRANSFER MODULE DATA
        RETURN                  ;

;+
; **-CBOUT-TRANSMIT CIRCULAR BUFFER DATA TO DEVICE
;
; THIS SUBROUTINE IS CALLED AT DEVICE PRIORITY LEVEL TO TRANS-
; FER DATA FROM THE CIRCULAR BUFFER TO THE SPECIFIED BUS AD-
; DRESS.
;
; INPUTS:
;
;       R4=ADDRESS OF STATUS CONTROL BLOCK
;
; OUTPUTS:
;
;       DATA (IF PRESENT) IS TRANSMITTED TO THE BUS ADDRESS
;       CONTAINED IN THE BUFFER.
;
; R1, R2, AND R3 ARE MODIFIED
;
;-

        .IFT


CBOUT:                          ;;;
        MOV     S.CSR(R4),R1    ;;; GET CSR ADDRESS
        MOV     S.CBF(R4),R3    ;;; GET CIRCULAR BUFFER ADDRESS
        BEQ     40$             ;;; IF EQ, ICS-11 & THUS NO CBF
        TST     (R3)+           ;;; POINT TO OUTPUT POINTER
        MOV     (R3)+,R2        ;;; GET OUTPUT POINTER
        ASL     2(R2)           ;;; SHIFT BUS ADDRESS
        BCC     10$             ;;; IF C/CLEAR NO REMOTE TERMINAL OUTPUT
        BIS     #40,(R1)        ;;; ENABLE REMOTE TERMINAL I/O
10$:                            ;;;
        MOV     (R2)+,@(R2)+    ;;; MOVE DATA TO DEVICE
        BCC     15$             ;;; IF C/C NOT REMOTE TERMINAL I/O
        BIS     #1000,(R1)      ;;; ENABLE REMOTE TERMINAL OUTPUT INTERRUPT
        BIC     #40,(R1)        ;;; DISABLE REMOTE TERMINAL MODE
15$:                            ;;;
        TST     (R3)+           ;;; POINT TO END ADDRESS OF BUFFER
        CMP     R2,(R3)+        ;;; REACHED END OF BUFFER?
        BLO     20$             ;;; IF LO NO
        MOV     R3,R2           ;;; RESET OUTPUT POINTER
20$:                            ;;;
        MOV     R2,COUT-CDAT(R3) ;;; SAVE OUTPUT POINTER
30$:                            ;;;
        RETURN                  ;;;
40$:                            ;
        CRASH                   ;;; CBOUT CALLED ON AN ICS-11

        .ENDC

;+
;
; **-CENTR-CONDITIONALLY ENTER DATA IN A CIRCULAR BUFFER
;
; THIS ROUTINE IS CALLED AT DEVICE PRIORITY LEVEL TO CONDITIONALLY
; INSERT AN ENTRY IN A CIRCULAR BUFFER.
;
; INPUTS:
;
;       R2=FORCE ENTRY FLAG
;
;               R2=0 - INSERT NEW ENTRY ONLY IF BUFFER IS FREE
;               R2=-1 - INSERT NEW ENTRY EVEN IF BUFFER NOT READ BY TASK
;
;       R5=MODULE TABLE ADDRESS
;
;       STACK CONTENTS:
;
;       (SP)+00 -- RETURN TO CALLER
;       (SP)+02 -- UNDEFINED
;       (SP)+04 -- CIRCULAR BUFFER ENTRY WD. 01
;       .               .
;       .               .
;       (SP)+NN -- CIRCULAR BUFFER ENTRY WD. NN
;
; OUTPUTS:
;
;       C/SET: A TASK IS CONNECTED TO INTERRUPTS
;
;       IF R2 WAS NEGATIVE, THE ENTRY IS UNCONDITIONALLY
;       INSERTED IN THE CIRCULAR BUFFER. ELSE THE ENTRY
;       EXISTENCE INDICATOR IS TESTED. IF NON-ZERO THE
;       ENTRY IS DISCARDED AND A COUNT OF OVERRUNS IS
;       INCREMENTED AND PLACED IN THE BUFFER. IF ZERO
;       THE ENTRY IS PLACED IN THE BUFFER AND THE INDI-
;       CATOR IS SET TO +1
;
;
;       C/CLEAR: NO TASK CONNECTED OR OVERRUN EXISTS
;
; REGISTERS MODIFIED:
;
; R0 - R2
;
;-

        .IF DF  I$$CIM!I$$CR!I$$CTI

CENTR:                          ;;;
        MOV     SP,R0           ;;; GET ADDRESS OF STACK
        TST     (R0)+           ;;; POINT TO FIRST WORD OF BUFFER ENTRY
        MOV     #1,(R0)         ;;; ASSUME NO FORCED ENTRY

        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;;; SAVE ASR 6
        MOV     IMCBF(R5),KISAR6 ;;; MAP TO USER'S BUFFER

        .IFTF

        TST     IMTCB(R5)       ;;; TASK CONNECTED?
        BEQ     60$             ;;; IF EQ NO
        MOV     IMCUR(R5),R1    ;;; GET CURRENT BUFFER ADDRESS
        TST     (R1)            ;;; ENTRY FREE
        BEQ     10$             ;;; IF EQ YES
        TST     R2              ;;; FORCED ENTRY?
        BPL     50$             ;;; IF PL NO
10$:                            ;;;
        SUB     R2,(R0)         ;;; INCLUDE FORCED ENTRY CONDITION
        MOVB    IMBPE(R5),R2    ;;; GET BYTES PER ENTRY
        ASR     R2              ;;; CONVERT TO WORD BIAS
        CLR     IMLST(R5)       ;;; CLEAR LOST DATA COUNT
20$:                            ;;;
        MOV     (R0)+,(R1)+     ;;; MOVE A WORD TO USERS'S BUFFER

        .IFT

        BIT     #20000,R1       ;;; CROSS 4K BOUNDARY?
        BEQ     30$             ;;; IF EQ NO
        BIC     #20000,R1       ;;; RESET BUFFER ADDRESS
        ADD     #200,KISAR6     ;;; RESET ADDRESS BIAS
        ADD     #200,IMCBF(R5)  ;;; ...

        .IFTF

30$:                            ;;;
        INC     IMFIL(R5)       ;;; INCREMENT FILL INDEX
        CMP     IMLGH(R5),IMFIL(R5) ;;; REACHED END OF BUFFER?
        BHIS    40$             ;;; IF HIS NO
        MOV     #3,IMFIL(R5)    ;;; RESET FILL INDEX

        .IFT

        MOV     IMSBF(R5),IMCBF(R5) ;;; RESET ADDRESS TO START
        MOV     IMCBF(R5),KISAR6 ;;; ...

        .IFTF

        MOV     IMSDA(R5),R1    ;;; POINT TO START OF DATA
40$:                            ;;;
        DEC     R2              ;;; DECREMENT WORD COUNT
        BGT     20$             ;;; IF GT MORE TO MOVE
        MOV     R1,IMCUR(R5)    ;;; SAVE CURRENT ADDRESS

        .IFT

        MOV     IMSBF(R5),KISAR6 ;;; POINT TO START OF BUFFER

        .IFTF

        MOV     IMFIL(R5),@IMSAD(R5) ;;; RESET FILL INDEX
        SEC                     ;;; SET SUCCESS
        BR      70$             ;;;
50$:                            ;;;
        CMP     IMLST(R5),#100001 ;;; OVERRUN COUNT PEGGED?
        BEQ     55$             ;;; IF EQ YES
        DEC     IMLST(R5)       ;;; 'INCREMENT' LOST DATA COUNT
55$:                            ;;;
        MOV     IMLST(R5),(R1)  ;;; SET OVERRUN COUNT
60$:                            ;;;
        CLC                     ;;; SET FAILURE
70$:                            ;;;

        .IFT

        MOV     (SP)+,KISAR6    ;;; RESTORE ASR 6

        .ENDC

        RETURN                  ;;;

        .ENDC


;+
;
; **-CTOUT-ACTIVATE ERROR PROCESSING ON CONTROLLER TIME-OUT
;
; THIS SUBROUTINE IS CALLED WHENEVER CONTROLLER TIMEOUT IS DE-
; TECTED. IF THE UNIT IS ONLINE ERROR ALARMING IS INITIATED.
;
; INPUTS:
;
;       R4=ADDRESS OF STATUS CONTROL BLOCK
;       R5=ADDRESS OF UNIT CONTROL BLOCK
;
; OUTPUTS:
;
;       C BIT CLEAR: UNIT ONLINE.
;
;       C BIT CLEAR: UNIT OFFLINE OR PREVIOUS NO-RESPONSE CONDITION IN EFFECT.
;
;       IF THE UNIT IS ON-LINE ALL ERROR ALARMING TASKS ARE
;       INITIATED. THE UNIT IS PLACED IN THE NOT READY STATE.
;
; REGISTERS MODIFIED
; R0 - R3
;
;-

        .IF DF  I$$CR

CTOUT:                          ;
        CLC                     ; ASSUME UNIT OFFLINE
        MOV     U.UNIT(R5),R1   ; GET UNIT NUMBER
        MOV     R4,-(SP)        ; SAVE SCB ADDRESS
        MOV     R5,-(SP)        ; SAVE UCB ADDRESS
        MOV     S.CSR(R4),R5    ; GET ADDRESS OF CSR
        MOVB    #PR6,PS         ;;; INHIBIT DEVICE INTERRUPTS
        BIT     #UNR!NORSP,S.FLG(R4) ;;; UNIT NOT READY OR NO RESPONSE?
        BNE     5$              ;;; IF NE YES
        BIS     #UNR!NORSP,S.FLG(R4) ;;; SET NOT-READY, NO RESPONSE CONDITIONS
        MOV     (R5),R0         ;;; GET ICSR CONTENTS
        CALL    STERR           ;;; INITIATE ERROR PROCESSING
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        MOV     (SP),R5         ; SET UCB ADDRESS
        CALL    INIER           ; INITIATE ERROR PROCESSING
5$:                             ;;;
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        MOV     (SP)+,R5        ; RESTORE UCB ADDRESS
        MOV     (SP)+,R4        ; RESTORE SCB ADDRESS
        SEC                     ; FLAG UNIT ONLINE
10$:                            ;
        RETURN                  ;

        .ENDC

;+
;
; **-RSETC-SUBROUTINE TO RESET ALL COUNTER MODULES
;
; THIS ROUTINE IS CALLED WHENEVER IT IS NECESSARY TO UNCONDITIONALLY
; RESET THE STATE OF ALL COUNTERS ON A CONTROLLER.
;
; INPUTS:
;
;       R3=ADDRESS OF COUNTER TABLE
;       R5=ADDRESS OF UNIT CONTROL BLOCK
;
; OUTPUTS:
;
;       R4=ADDRESS OF STATUS CONTROL BLOCK
;       ALL COUNTERS ARE RESET WITH THE CURRENT STATE
;
; REGISTERS MODIFIED:
;
; R1 - R3
;
;-

        .IF DF  I$$CTI

RSETC:                          ;
        MOV     U.SCB(R5),R4    ; GET ADDRESS OF SCB
        MOV     IMTCB(R3),-(SP) ; PUSH TCB ADDRESS OF CONNECTED TASK
        MOV     (R3),-(SP)      ; SET NUMBER OF COUNTERS-1
        ADD     #IMDAT+IMPRV,R3 ; OFFSET TO MODULE DATA
10$:                            ;
        TST     2(SP)           ; TASK CONNECTED?
        BNE     20$             ; IF NE YES
        TST     IMRES-IMPRV(R3) ; TASK LINKED?
        BEQ     30$             ; IF EQ NO
        TST     (R3)            ; PREVIOUS STATE 0
        BEQ     30$             ; IF EQ YES - DON'T RESET COUNTER
20$:                            ;
        CALL    SETCT           ; INITIALIZE THE COUNTER
30$:                            ;
        ADD     #CTLGH,R3       ; POINT TO NEXT ENTRY
        DEC     (SP)            ; DECREMENT COUNT
        BPL     10$             ; IF PL GO AGAIN
        MOV     (SP)+,(SP)+     ; CLEAN STACK
        RETURN                  ;

        .ENDC
                                                                        ; GK005
;+                                                                      ; GK005
;                                                                       ; GK005
; **-READDI-SUBROUTINE TO READ THE CURRENT STATE OF ALL DI MODULES      ; GK005
;                                                                       ; GK005
; THIS ROUTINE IS CALLED WHEN POWER IS APPLIED, IN ORDER TO READ IN THE ; GK005
; CURRENT STATE OF ALL THE DIGITAL INTERRUPT MODULES ON A CONTROLLER.   ; GK005
;                                                                       ; GK005
; INPUTS:                                                               ; GK005
;                                                                       ; GK005
;       R3=ADDRESS OF DIGITAL INTERRUPT TABLE                           ; GK005
;       R4=ADDRESS OF STATUS CONTROL BLOCK                              ; GK005
;       R5=ADDRESS OF UNIT CONTROL BLOCK                                ; GK005
;                                                                       ; GK005
; OUTPUTS:                                                              ; GK005
;                                                                       ; GK005
;       ALL "IMPRV" ENTRIES IN THE MODULE DATA FOR THE CONTROLLER HAVE  ; GK005
;       BEEN FILLED IN.                                                 ; GK005
;                                                                       ; GK005
; REGISTERS MODIFIED:                                                   ; GK005
;                                                                       ; GK005
; R2 - R3                                                               ; GK005
;                                                                       ; GK005
;-                                                                      ; GK005
                                                                        ; GK005
        .IF DF  I$$CIM                                                  ; GK005
                                                                        ; GK005
READDI:                         ;                                       ; GK005
        MOV     R4,-(SP)        ; SAVE R4                               ; GK005
        MOV     (R3),R2         ; GET HIGHEST POINT - 15                ; GK005
        ASR     R2              ; CONVERT TO NO. MODULES - 1            ; GK005
        ASR     R2              ; ...                                   ; GK005
        ASR     R2              ; ...                                   ; GK005
        ASR     R2              ; ...                                   ; GK005
        ADD     #IMDAT,R3       ; POINT AT MODULE DATA                  ; GK005
10$:    MOV     IMBA(R3),R4     ; GET MODULE BUS ADDRESS / 2            ; GK005
        ASL     R4              ; CALCULATE BUS ADDRESS                 ; GK005
        MOV     (R4),IMPRV(R3)  ; READ CURRENT MODULE STATE             ; GK005
        DEC     R2              ; COUNT PASSES                          ; GK005
        BPL     10$             ; ...                                   ; GK005
        RETURN                                                          ; GK005
                                                                        ; GK005
        .ENDC                                                           ; GK005

;+
;
; **-SAVE-SAVE REGISTERS R3 - R0
;
; THIS SUBROUTINE IS CALLED VIA A 'JSR R3,SAVE' TO SAVE
; REGISTERS R3 - R0. A CO-ROUTINE CALL IS THEN MADE TO
; THE CALLER. A SUBSEQUENT RETURN WILL CAUSE THE REGISTERS
; TO BE RESTORED AND THE INTERRUPT ENABLE BITS TO BE TOGGLED
; IN ORDER TO PERMIT THE ASSERTION OF ANY PENDING BUT UNRE-
; COGNIZED INTERRUPTS. EXIT IS VIA A RETURN.
;
;-

        .IF DF  I$$CAD!I$$CIM!I$$CTI!I$$CR


SAVE:                           ;;;
        MOV     R2,-(SP)        ;;; SAVE R2
        MOV     R1,-(SP)        ;;; SAVE R1
        MOV     R0,-(SP)        ;;; SAVE R0
        CALL    (R3)            ;;; CALL THE CALLER
        MOV     CSR,R0          ;;; GET THE CSR ADDRESS
        MOV     (R0),R1         ;;; READ THE CSR CONTENTS
        BIC     #^C<1036>,R1    ;;; CLEAR ALL BUT THE INTERRUPT ENABLE BITS
        BIC     R1,(R0)         ;;; DISABLE ALL ENABLED INTERRUPTS
        BIS     R1,(R0)         ;;; RE-ENABLE APPROPRIATE INTERRUPTS
        MOV     (SP)+,R0        ;;; RESTORE R0
        MOV     (SP)+,R1        ;;; RESTORE R1
        MOV     (SP)+,R2        ;;; RESTORE R2
        MOV     (SP)+,R3        ;;; RESTORE R3
        RETURN                  ;;; EXIT

        .ENDC


;+
;
; **-SETCT-INITIALIZE A COUNTER MODULE
;
; THIS SUBROUTINE IS CALLED TO INITIALIZE A SINGLE COUNTER MODULE.
;
; INPUTS:
;
;       R3=ADDRESS OF COUNTER MODULE ENTRY IN MODULE TABLE
;       R4=ADDRESS OF STATUS CONTROL BLOCK
;
; OUTPUTS:
;
;       THE SPECIFIED COUNTER IS INITIALIZED WITH THE VALUE
;       CONTAINED IN THE INITIAL VALUE CELL WITHIN THE TABLE.
;
; REGISTERS MODIFIED:
;
; R1 - R2
;
;-

        .IF DF  I$$CTI

SETCT:                          ;

        .IF DF  I$$CR

        MOV     (R3)+,-(SP)     ; PUSH MODULE DATA
        MOV     #100000,R1      ; GET REFRESH FLAG
        MOV     (R3),-(SP)      ; PUSH BUS ADDRESS/2
        BIC     R1,(R3)         ; CLEAR POSSIBLE REFRESH FLAG
        BIC     R1,(SP)         ; ...

        .IFF

        MOV     (R3)+,-(SP)     ; PUSH MODULE DATA
        MOV     (R3),-(SP)      ; PUSH BUS ADDRESS

        .IFTF

        MOV     SP,R1           ; COPY ADDRESS OF BLOCK

        .IFT

        TST     S.RTI(R4)       ; ICS-11 CONTROLLER?
        BEQ     10$             ; IF EQ YES
        CALL    CBINS           ; TRANSMIT DATA TO DEVICE
        BR      20$             ; EXIT
10$:                            ;

        .IFTF

        ASL     (R1)+           ; SHIFT BUS ADDRESS
        MOVB    #PR6,PS         ;;; INHIBIT DEVICE INTERRUPTS
        BIS     #1,@S.CSR(R4)   ;;; SET RIF BIT
        MOV     (R1),@-(R1)     ;;; RESET COUNTER
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS

        .ENDC

20$:                            ;
        MOV     (SP)+,(SP)+     ; CLEAN STACK
        TST     -(R3)           ; RESET R3
        RETURN                  ;

        .ENDC
;+
;
; **-SLINK-SCAN LINKED INTERRUPT LIST FOR A MATCH
;
; THIS SUBROUTINE IS CALLED AT DEVICE PRIORITY LEVEL TO
; SCAN A LINKED INTERRUPT LIST FOR A MATCH. IF A MATCH
; IS FOUND THE ENTRY IS FLAGGED FOR SCHEDULING AT FORK
; LEVEL.
;
; INPUTS:
;
;       R3=ADDRESS OF ENTRY IN MODULE TABLE
;       TMP=PHYSICAL UNIT NUMBER
;
;       STACK CONTENTS AS FOLLOWS:
;
;       (SP)+00 -- RETURN TO CALLER
;       (SP)+02 -- RESOURCE MASK
;       (SP)+04 -- HARDWARE DEPENDANT DATA - WD. 01
;       (SP)+06 -- HARDWARE DEPENDANT DATA - WD. 00
;       (SP)+10 -- RELATIVE MODULE NUMBER
;       (SP)+12 -- GENERIC CODE
;
; OUTPUTS:
;
;       C/SET: ONE OR MORE ENTRIES LINKED TO THE RESOURCE WERE
;                FOUND. THE LINKED TASK ENTRY FOR EACH SUCH TASK
;                IS CONDITIONALLY UPDATED AND THE 'SCHEDULE' FLAG
;                 IS SET IN THE INTERRUPT LINKAGE LIST.
;
;       C/CLEAR: NO TASKS ARE LINKED TO THE RESOURCE
;
; REGISTERS MODIFIED:
;
; R0 - R3
;
;-

        .IF DF  I$$CIM!I$$CR!I$$CTI&I$$CLK

SLINK:                          ;;;
        CLR     R0              ;;; ASSUME NO LINKED ENTRIES
        BIT     2(SP),(R3)+     ;;; ANY TASKS LINKED?
        BEQ     30$             ;;; IF EQ NO
10$:                            ;;;
        MOV     (R3),R3         ;;; GET NEXT ENTRY
        BEQ     30$             ;;; IF EQ REACHED END OF LIST
        BIT     2(SP),ILMSK(R3) ;;; THIS TASK LINKED?
        BEQ     10$             ;;; IF EQ NO
        MOV     PC,R0           ;;; ASSUME NO LINKED ENTRIES
        MOV     ILTE(R3),R1     ;;; GET ADDRESS OF LINKED TASK ENTRY
        INC     ILRUN(R3)       ;;; SET RUN FLAG
        ADD     #LACT,R1        ;;; POINT TO ACTIVITY COUNT
        TST     (R1)            ;;; PREVIOUS ENTRY READ BY USER?
        BNE     20$             ;;; IF NE NO
        INC     (R1)+           ;;; SET COUNT TO +1
        MOV     SP,R2           ;;; GET STACK ADDRESS
        ADD     #12,R2          ;;; POINT TO GENERIC CODE
        MOV     TMP,(R1)+       ;;; RECORD PHYSICAL UNIT NUMBER
        MOV     (R2),(R1)+      ;;; RECORD GENERIC CODE
        MOV     -(R2),(R1)+     ;;; RECORD RELATIVE MODULE NUMBER
        MOV     -(R2),(R1)+     ;;; SAVE HARDWARE DEPENDANT DATA
        MOV     -(R2),(R1)+     ;;; ...
        BR      10$             ;;; LOOK FOR ANOTHER LINKED ENTRY
20$:                            ;;;
        DEC     (R1)            ;;; DECREMENT ACTIVATION COUNT
        BMI     10$             ;;; IF MI ALREADY MISSED AT LEAST ONE
        DEC     (R1)            ;;; SET COUNT NEGATIVE
        BR      10$             ;;; GO AGAIN
30$:                            ;;;
        NEG     R0              ;;; SET SUCCESS/FAIL FLAG
        RETURN                  ;;;

        .ENDC


;+
;
; **-STERR-PERFORM ERROR ALARMING FUNCTIONS
;
; THIS SUBROUTINE IS CALLED AT DEVICE PRIORITY TO INITIATE
; PROCESSING FOR ALL TASKS THAT ARE TO BE NOTIFIED WHEN-
; EVER A FATAL CONTROLLER ERROR IS DETECTED.
;
; INPUTS:
;
;       R0=ICSR CONTENTS
;       R1=PHYSICAL UNIT NUMBER
;       R4=ADDRESS OF SCB
;       R5=ADDRESS OF ICSR
;
; OUTPUTS:
;
;       ALL ICS/ICR INTERRUPTS ARE DISABLED. ERROR DATA IS
;       SUPPLIED TO ALL CONNECTED TASKS AND THE ALARMING
;       TASK IS FLAGGED FOR SCHEDULING AT FORK LEVEL.
;
; REGISTERS MODIFIED:
;
; R0, R1, R2, R3, AND R5
;-


        .IF DF  I$$CR

STERR:                          ;;;
        CLRB    S.CTMC(R4)      ;;; DISABLE DEVICE TIME-OUTS
        MOV     R1,TMP          ;;; SET PHYSICAL UNIT NUMBER
        MOV     #177770,-(SP)   ;;; SET GENERIC CODE
        MOV     R1,-(SP)        ;;; SET PHYSICAL UNIT NUMBER
        MOV     R0,-(SP)        ;;; SET ICSR CONTENTS
        BIC     #22,(R5)        ;;; DISABLE ERROR INTERRUPTS
        MOV     -(R5),-(SP)     ;;; SAVE ICAR CONTERNTS
        MOV     #-1,-(SP)       ;;; SET RESOURCE MASK

        .IF DF  I$$CLK

        MOV     #ICDVT+ICRES,R3 ;;; POINT TO RESOURCE MASK FOR ERRORS
        CALL    SLINK           ;;; SET ALARMING TASK FOR SCHEDULING

        .ENDC

        .IF DF  I$$CIM

        MOV     S.DI(R4),R5     ;;; GET ADDRESS OF DIGITAL INTERRUPT TABLES
        BEQ     10$             ;;; IF EQ NONE
        CALL    40$             ;;; ENTER DATA IN CIRCULAR BUFFER

        .ENDC

10$:                            ;;;
        MOV     (SP)+,(SP)      ;;; COLLAPSE STACK

        .IF DF  I$$CTI

        MOV     S.CT(R4),R5     ;;; GET ADDRESS OF COUNTER TABLES
        BEQ     20$             ;;; IF EQ NONE
        CALL    40$             ;;; ENTER DATA IN CIRCULAR BUFFER

        .ENDC

20$:                            ;;;
        MOV     S.RTI(R4),R5    ;;; GET ADDRESS OF REMOTE TERMINAL TABLES
        BEQ     30$             ;;; IF EQ NONE
        CALL    40$             ;;; ENTER DATA IN CIRCULAR BUFFER
30$:                            ;;;
        ADD     #10,SP          ;;; CLEAN STACK
        RETURN                  ;;;
40$:                            ;;;
        MOV     #-1,R2          ;;; SET FORCED ENTRY FLAG
        CALLR   CENTR           ;;; MOVE ENTRY TO CIRCULAR BUFFER

        .ENDC

        .END
        .TITLE  ICOM
        .IDENT  /00/
 
;
; COPYRIGHT (C) 1975, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 00
;
; C. MONIA 05-JUN-75
;
; ICS/ICR-11 DEVICE COMMON BLOCK
;
; EQUATED SYMBOLS
;
; DEFINE NUMBER OF ICS/ICR CONTROLLERS GLOBALLY
;
 
        .IF DF  I$$C11
 
        .GLOBL  I$$C11
 
        .ENDC
 
;+
;
; **-.ICOM-ICS/ICR-11 DEVICE COMMON BLOCK
;
;       THIS COMMON BLOCK MUST BE BUILT WHENEVER ANY ICS/ICR-11
; MODULES ARE REFERENCED DIRECTLY. IN GENERAL SUCH DIRECT REFERENCES
; OCCUR AS THE RESULT OF CALLS TO THE FORTRAN PROCESS CONTROL SUB-
; ROUTINES THAT PERFORM INPUT FROM CONTACT SENSE, CONTACT INTERRUPT
; AND TIMER MODULES. THE EXTENT OF THE BLOCK IS SET TO
; PREVENT ACCESS TO THE DEVICE CONTROL AND STATUS REGISTERS BY THE TASK.
;
; ASSEMBLING THE COMMON BLOCK:
;
;       THE COMMON BLOCK MUST BE ASSEMBLED WITH THE PREFIX FILE [11,10]
; RSXMC.MAC TO DEFINE  CONDITIONALS THAT CONTROL THE SIZE AND COMMON BLOCK
; ATTRIBUTES AS FOLLOWS:
;
;       CONDITIONAL             EFFECT
;       -----------             ------
;
;       I$$C11                  CONTROLS EXTENT OF COMMON BLOCK
;       M$$MGE                  ESTABLISHES RELOCATABILITY OF COMMON BLOCK.
;                               COMMON BLOCK IS RELOCATABLE (PIC) IF DEFINED.
;                               OTHERWISE COMMON BLOCK IS ABSOLUTE.
;
;
; THE USER MAY FORCE THE COMMON BLOCK TO BE PIC BY INCLUDING THE
; CONDITIONAL 'I$$COM' IN RSXMC.MAC BY MEANS OF THE TEXT EDITOR.
;
;-
 
        .IF DF  I$$C11
 
        .IF DF  M$$MGE!I$$COM
 
        .PSECT  ICOM,REL,GBL,OVR,D
 
        .IFF
 
        .ASECT
 
.=171000
 
        .ENDC
.ICMD::                         ;
        .BLKW   I$$C11*16.      ; SET LENGTH OF COMMON BLOCK
 
        .ENDC
 
        .END
        .TITLE  INITL
        .IDENT  /13.2/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 13.2
;
; D. N. CUTLER 23-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       B. SCHREIBER 28-JUL-77
;
;               BS004 -- CHANGE TO V3.1.
;
;       T. J. MILLER 14-SEP-77
;
;               TM103 -- ENHANCE CLOCK SETUP AND ALIGN POOL ON EVEN
;                       BOUNDARY.
;
;               TM104 -- PROPERLY INITIALIZE VECTORS FOR HANDLING
;                       FLOATING POINT PROCESSOR EXCEPTION CONDITIONS.
;
;               TM105 -- ADD SUPPORT FOR ODD CSR'S AND DEVICE UNIT
;                       NUMBERS OVER 127.
;
;       B. SCHREIBER    14-JUL-78
;
;               BS063 -- CHANGE SYSTEM IDENTIFICATION MESSAGE
;
;       C. SPITZ        25-JUL-78
;                CS010 -- CHANGE 11S SYSTEM IDENTIFICATION
;
;       C. SPITZ        19-DEC-78
;               CS024 -- USE $SGFIN IN INITL
;
;       M. S. HARVEY    17-APR-79
;               MSH013 -- INITL MUST BE LAST MODULE IN EXEC
;
;       CHUCK SPITZ     15-MAY-79
;               CS051 -- HANDLE KW11-L FOR LSI-11
;
; SYSTEM START UP AND INITIALIZATION ROUTINE
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS

;
; LOCAL DATA
;
; SYSTEM IDENTIFICATION MESSAGES
;
;                                                                       ;MSH013
; MAKE SURE THAT INITL TASK BUILDS AS THE LAST MODULE IN THE EXEC       ;MSH013
;                                                                       ;MSH013
        .PSECT  ......                                                  ;MSH013
                                                                        ;MSH013

$POOL::                         ;START OF POOL


        .IF NDF R$$11S

SYSMG:  .ASCII  <15><12>/RSX11M V3.2 BL/                                ;BS063
                                                                        ;**-1
        .IFF

SYSMG:  .ASCII  <15><12>/RSX11S V2.2 BL/                                ; CS010
                                                                        ;**-1
        .ENDC


SYSID:  .ASCIZ  /XXXX/<15><12><12> ;
DEVMG:  .ASCIZ  <15><177><177><12>/ DEVICE DDUU: NOT IN CONFIGURATION/<15> ;
PROMT:  .ASCIZ  <15><12>/>/     ;
        .EVEN

;+
; **-$INITL-SYSTEM TRANSFER ADDRESS
;
; THIS ROUTINE CONTAINS THE TRANSFER POINT OF THE RESIDENT EXECUTIVE. WHEN
; THE SYSTEM IS BOOTED, CONTROL IS TRANSFERED HERE TO INITIALIZE AND START
; UP THE SYSTEM
;-

$INITL::RESET                   ;RESET PROCESSOR
        MOV     #$SYSIZ+2,R0    ;POINT TO SYSTEM CONFIGURATION VECTOR
        MOVB    R3,(R0)+        ;SAVE UNIT NUMBER
        MOVB    R1,(R0)+        ;SAVE LBN OF LOAD IMAGE
        MOV     R2,(R0)+        ;
        MOV     R4,(R0)+        ;SAVE DEVICE NAME
        MOV     R5,(R0)+        ;SAVE LENGTH OF LOAD FILE


        .IF DF  M$$MGE

        MOV     #PMODE+PR7,PS   ;SET MODE BITS AND LOCK OUT INTERRUPTS
        MOV     #$STACK-20,SP   ;SETUP EXEC STACK POINTER
        MOV     #KISAR0,R0      ;POINT TO KERNEL PAR 0
        MOV     #KISDR0,R1      ;POINT TO KERNEL PDR 0
        MOV     #UISAR0,R2      ;POINT TO USER PAR 0
        MOV     #UISDR0,R3      ;POINT TO USER PDR 0
        MOV     #8.,R4          ;SET LOOP COUNT
        CLR     R5              ;START AT BOTTOM OF MEMORY
10$:    MOV     R5,(R0)+        ;SET KERNEL AND USER RELOCATION BIAS
        MOV     R5,(R2)+        ;
        MOV     #77406,(R1)     ;SET KERNEL AND USER DESCRIPTOR  REGISTERS
        MOV     (R1)+,(R3)+     ;
        ADD     #200,R5         ;ADVANCE TO NEXT 4K BLOCK
        DEC     R4              ;ANY MORE REGISTERS TO LOAD?
        BGT     10$             ;IF GT YES
        MOV     #177600,-(R0)   ;SET KERNEL PAR 7 TO I/O PAGE
        INC     SR0             ;AND AWAY WE GO


        .IF DF  M$$EXT

        MOV     #UBMPR,R0       ;POINT TO FIRST UNIBUS MAPPING REG
        CLR     R1              ;SET INITIAL ADDRESS TO ZERO
        MOV     #5.,R2          ;SET NUMBER OF REGISTER PAIRS TO LOAD
11$:    MOV     R1,(R0)+        ;LOAD LOW 16 BITS OF ADDRESS
        CLR     (R0)+           ;CLEAR HIGH 6 BITS OF ADDRESS
        ADD     #20000,R1       ;ADVANCE 8K BYTES
        DEC     R2              ;ANY MORE TO LOAD?
        BGT     11$             ;IF GT YES
        MOV     #60,SR3         ;ENABLE 22 BIT ADDRESSING AND UB MAP

        .ENDC


        .IFF

        MTPS    #PR7            ;LOCK OUT INTERRUPTS
        MOV     #$STACK-10,SP   ;SETUP EXEC STACK POINTER

        .IFTF

        MOV     #$DIRXT,-(SP)   ;SET UP RETURN FOR $SGFIN               ; CS024
        CALL    $SGFIN          ;TRAP NON-EXISTANT MEMORY               ; CS024
        MOV     #$SYSID,R0      ;POINT TO SYSTEM IDENTIFICATION         ;**-2
        MOV     #SYSID,R1       ;POINT TO IDENTIFICATION MESSAGE
        MOVB    (R0)+,(R1)+     ;MOVE SYSTEM IDENTIFICATION INTO MESSAGE
        MOVB    (R0)+,(R1)+     ;
        MOVB    (R0)+,(R1)+     ;
        MOVB    (R0),(R1)       ;
        JSR     R5,OPMSG        ;TELL EVERYBODY WE'RE ON THE AIR
        .WORD   SYSMG           ;

        .IFT

        MOV     #140000,R0      ;SET INITIAL MEMORY ADDRESS
        CLR     KISAR6          ;SET ZERO RELOCATION BIAS

        .IFF

        CLR     R0              ;SET INITIAL MEMORY ADDRESS

        .IFTF

        CLR     R1              ;ZERO NUMBER OF 32W BLOCKS IN SYSTEM
13$:    TST     (R0)            ;MEMORY EXIST?
        BCS     17$             ;IF CS NO
        ADD     #40,R1          ;UPDATE NUMBER OF 32W BLOCKS

        .IFT

        ADD     #40,KISAR6      ;UPDATE RELOCATION BIAS BY 1K


        .IF DF  M$$EXT

        CMP     KISAR6,#170000  ;END OF MEMORY?

        .IFF

        CMP     KISAR6,#7600    ;END OF MEMORY?

        .ENDC


        BLO     13$             ;IF LO NO

        .IFF

        ADD     #4000,R0        ;UPDATE MEMORY ADDRESS BY 1K
        CMP     R0,#160000      ;END OF MEMORY?
        BLO     13$             ;IF LO NO

        .IFTF

17$:    MOV     R1,$SYSIZ       ;SET SIZE OF MEMORY IN 32W BLOCKS

        .IFT

        MOV     #1400,KISAR6    ;RESET MAPPING RELOCATION BIAS

        .ENDC


        MOV     #$DEVHD,R5      ;GET ADDRESS OF FIRST DCB ADDRESS
20$:    MOV     (R5),R5         ;GET ADDRESS OF NEXT DCB
        BEQ     80$             ;IF EQ NO MORE TO SCAN
        MOV     D.UCB(R5),R4    ;POINT TO FIRST UCB
        BIT     #DV.PSE,U.CW1(R4) ;PSEUDO DEVICE?
        BNE     20$             ;IF NE YES
        MOVB    D.UNIT(R5),-(SP) ;SET STARTING LOGICAL UNIT NUMBER
        MOVB    D.UNIT+1(R5),-(SP) ;CALCULATE NUMBER OF UCB'S TO SCAN
        SUB     D.UNIT(R5),(SP) ;
        INCB    (SP)            ;
        INCB    (SP)            ;
30$:    DECB    (SP)            ;ANY MORE UCB'S TO SCAN?
        BNE     40$             ;IF NE YES
        CMP     (SP)+,(SP)+     ;CLEAN STACK
        BR      20$             ;GO AGAIN
40$:    CMP     $SYSIZ+6,D.NAM(R5) ;DEVICE NAMES MATCH?
        BNE     45$             ;IF NE NO
        CMPB    $SYSIZ+2,2(SP)  ;UNIT NUMBERS MATCH?
        BNE     45$             ;IF NE NO
        MOV     R4,.SY0+2       ;REDIRECT SYSTEM DEVICE
        MOV     R4,.LB0+2       ;REDIRECT LB: AS WELL
45$:    MOV     U.SCB(R4),R2    ;GET ADDRESS OF SCB
        INCB    2(SP)           ;UPDATE LOGICAL UNIT NUMBER
        TSTB    @S.CSR(R2)      ;DEVICE IN SYSTEM?
        BCC     60$             ;IF CC YES
        BISB    #US.OFL,U.ST2(R4) ;SET DEVICE OFFLINE
        MOVB    D.NAM(R5),DEVMG+12. ;INSERT GENERIC DEVICE NAME
        MOVB    D.NAM+1(R5),DEVMG+13. ;
        MOV     R4,R0           ;COPY ADDRESS OF UCB
        SUB     D.UCB(R5),R0    ;CALCULATE ADDRESS OFFSET TO UCB
        MOV     D.UCBL(R5),R1   ;GET LENGTH OF UCB
        CALL    $DIV            ;CALCULATE RELATIVE UNIT NUMBER
        ADD     D.UNIT(R5),R0   ;CALCULATE LOGICAL UNIT NUMBER
        BIC     #177400,R0      ;CLEAR EXTRANEOUS BITS
        MOV     #8.,R1          ;SET DIVISOR
        CALL    $DIV            ;CONVERT UNIT NUMBER TO 2 DIGITS
        ADD     #'0,R0          ;ADD CHARACTER BIAS
        ADD     #'0,R1          ;ADD CHARACTER BIAS
        MOVB    R0,DEVMG+14.    ;INSERT DEVICE UNIT NUMBER
        MOVB    R1,DEVMG+15.    ;
        JSR     R5,OPMSG        ;OUTPUT DEVICE MESSAGE
        .WORD   DEVMG           ;
60$:    ADD     D.UCBL(R5),R4   ;CALCULATE ADDRESS OF NEXT UCB
        BR      30$             ;GO AGAIN
80$:                            ;REF LABEL


        .IF DF  P$$RTY

        MOV     #$PARTB,R0      ;GET ADDRESS OF PARITY CSR ADDRESS TABLE
        MOV     R0,R1           ;COPY ADDRESS OF TABLE
        MOV     #1,(R1)+        ;INSERT A ONE IN FIRST TABLE ENTRY
        MOV     #MPAR-2,R2      ;GET ADDRESS OF FIRST PARITY REGISTER-2
        MOV     #16.,R3         ;SET NUMBER OF PARITY REGISTERS
90$:    ADD     #2,R2           ;ADVANCE TO NEXT PARITY CSR REGISTER
        MOV     R2,(R1)+        ;ASSUME PARITY REGISTER PRESENT
        TST     (R2)            ;PARITY CSR REGISTER PRESENT?
        BCC     100$            ;IF CC YES
        MOV     R0,-2(R1)       ;POINT TO FIRST WORD OF TABLE
100$:   DEC     R3              ;ANY MORE TO SCAN?
        BGT     90$             ;IF GT YES
        MOV     (R1),R1         ;11/70 CACHE PARITY CSR SEARCH DONE?
        BEQ     105$            ;IF EQ YES
        MOV     #MPCSR-10,R2    ;POINT TO FIRST CSR ADDRESS - 2
        MOV     #6,R3           ;SET COUNT OF REGISTERS
        BR      90$             ;SEARCH FOR THEM
105$:                           ;REF LABEL

        .ENDC


        .IF DF  F$$LPP

        TST     PIRQ            ;IS THERE A PIRQ REGISTER?
        BCS     106$            ;IF CS NO
        MOV     #$FPPRQ,@#240   ;SET UP PIRQ VECTOR
        MOV     #$FPPR8,@#244   ;SET UP FLOATING POINT EXCEPTION VECTOR
106$:                           ;REF LABEL

        .ENDC


        JSR     R5,OPMSG        ;OUTPUT INITIAL PROMPT MESSAGE
        .WORD   PROMT           ;


        MOV     $CKCSR,R0       ;GET ADDRESS OF CLOCK CSR               ;**-6
        TST     (R0)            ;IS THE GENERATED CLOCK AVAILABLE?
        BCC     110$            ;IF CC YES
        MOV     #172540,R0      ;GET ADDRESS OF KW11-P CSR
        MOV     R0,$CKCSR       ;SETUP FOR KW11-P
        MOV     #172542,$CKCNT  ;
        MOV     #K$$LDC,$CKLDC  ;SET COUNT REGISTER LOAD COUNT
        MOV     #K$$TPS,$TKPS   ;SET TICKS PER SECOND
        TST     (R0)            ;KW11-P?
        BCC     110$            ;IF CC YES
        MOV     #177546,R0      ;GET ADDRESS OF KW11-L CSR
        MOV     R0,$CKCSR       ;SETUP FOR KW11-L
        MOV     R0,$CKCNT       ;
        CLR     $CKLDC          ;
        MOV     #H$$RTZ,$TKPS   ;SET TICKS PER SECOND TO LINE FREQUENCY
110$:   MOV     #$NONSI,@#100   ;RESET KW11-L INTERRUPT VECTOR
        MOV     #$CKINT,104     ;SETUP KW11-P VECTOR
        CMP     #172540,R0      ;KW11-P?
        BEQ     120$            ;IF EQ YES
        MOV     #$CKINT,100     ;SETUP KW11-L VECTOR
        MOV     #$NONSI,104     ;RESET KW11-P VECTOR
120$:   MOV     $CKCNT,R1       ;GET ADDRESS OF COUNT REGISTER
        MOV     $CKLDC,(R1)     ;SETUP CLOCK COUNT REGISTER
        MOV     #K$$IEN,(R0)    ;START CLOCK
                                                                        ;**-3
        .IF DF  M$$MGE

        MOV     #PMODE+PR7,PS   ;MAKE SURE PS IS SETUP PROPERLY

        .ENDC


        MOV     #SYSMG,R0       ;SET ADDRESS OF BLOCK TO RELEASE
        ADD     $CRAVL-2,R0     ;ROUND TO NEXT BOUNDARY
        BIC     $CRAVL-2,R0     ;
        MOV     #$SYBEG-SYSMG,R1 ;SET LENGTH OF BLOCK TO RELEASE
        CALLR   $DEACB          ;DEALLOCATE INITIALIZATION CODE         ; CS024
                                                                        ;**-3
;
; SUBROUTINE TO OUTPUT A MESSAGE TO THE SYSTEM CONSOLE TERMINAL
;

OPMSG:  MOV     (R5)+,R1        ;GET ADDRESS OF OUTPUT MESSAGE
10$:    MOVB    (R1)+,R0        ;GET NEXT BYTE TO OUTPUT
        BEQ     30$             ;IF EQ DONE
        MOVB    R0,TPS+2        ;LOAD BYTE IN OUTPUT BUFFER
20$:    TSTB    TPS             ;PRINTER BUSY?
        BCS     30$             ;IF CS NO CONSOLE TERMINAL
        BPL     20$             ;IF PL YES
        BR      10$             ;GO AGAIN
30$:    RTS     R5              ;

;
; NONEX MEM TRAP ROUTINE
;

TRPRT:  BIS     #1,2(SP)        ;SET CARRY BIT
        RTI                     ;

;
; END OF DYNAMIC STORAGE REGION
;


        .IF NE  <.-SYSMG>&3

        .BLKB   <.-SYSMG>&3

        .ENDC


;
; BEGINNING OF DYNAMIC STORAGE REGION
;

$SYBEG::.WORD   0               ;LINK TO NEXT BLOCK IN FREE LIST
        .WORD   <<<C$$ORE*2>+3>&177774> ;LENGTH OF FREE BLOCK
        .BLKB   <<<C$$ORE*2>+3>&177774>-4 ;ALLOCATE REMAINING STORAGE
$SYTOP::                        ;LAST ADDRESS IN EXECUTIVE

        .END    $INITL
        .TITLE  IOSUB
        .IDENT  /10.14/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 10.14
;
; D. N. CUTLER 4-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 25-JAN-78
;
;               PB056 -- CORRECTLY RELOCATE UNIBUS PHYSICAL ADDRESSES
;                       ON 22-BIT PROCESSORS.
;
;       P. J.BEZEREDI 15-MAR-78
;
;               PB060 -- PASS RHBAE AND RHCS3 BACK TO DIAGNOSTIC TASK.
;
;       CHUCK SPITZ 15-JUN-78
;               CS013 -- ADD $GSPKT, $QUEBF, $INIBF, AND $TSTBF FOR
;                       NEW TERMINAL DRIVER.
;
;       M. S. HARVEY 19-OCT-78
;
;               MSH012 -- ADD ENTRY CODE ALLOWING USER SPECIFIED
;                         UMR MAPPING ASSIGNMENT BLOCKS
;
;       B. S. MCCARTHY 29-NOV-78
;
;               BM004 -- CORRECT DYNAMIC UMR ALLOCATION FOR ODD
;                        USER BUFFER ADDRESSES
;
;       CHUCK SPITZ 7-DEC-78
;
;               CS020 -- ADD GROUP GLOBAL EF'S
;
;       CHUCK SPITZ 30-JAN-79
;
;               CS029 -- CORRECT BUG IN $INIBF
;
;       CHUCK SPITZ 14-FEB-79
;               CS032 -- CORRECT CONDITIONALS TO INCLUDE $MPUBM
;                       ON SYSTEMS WITHOUT ACP SUPPORT (A$$CPS)
;
;       B. A. O'CONNELL 27-FEB-79
;
;               BO015 -- DIRECT ACP QUEUING & FOREIGN VOLUME SUPPORT
;
;       B. A. O'CONNELL 27-FEB-79
;
;               BO016 -- 2-4 WINDOW SUPPORT - $MPVBN
;
;       M. S. HARVEY    5-MAR-79
;
;               MSH029 -- CORRECT DRIVER CONTEXT SAVING IF NO UMRS AVAILABLE
;
;       CHUCK SPITZ 27-MAR-79
;               CS041 -- ALLOW PRV TASK TO DO ANYTHING TO A TERMINAL
;                       EXCEPT ATTACH, FOR  SCS-11
;
;       M. S. HARVEY    26-MAY-79
;               MSH036 -- DON'T TRY TO CALL UNLOADED UNMAPPED DRIVER
;                         AT ITS CANCEL I/O ENTRY POINT
;
;
; I/O RELATED ROUTINES
;
; MACRO LIBRARY CALLS
;

        .MCALL  F11DF$,HDRDF$,HWDDF$,PCBDF$,PKTDF$,TCBDF$
        F11DF$                  ;DEFINE WINDOW AND LOCK BLOCK OFFSETS
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$ACHKP-ADDRESS CHECK PARAMETER BLOCK
; **-$ACHKW-ADDRESS CHECK PARAMETER BLOCK WORD ALIGNED
; **-$ACHK2-ADDRESS CHECK 2 BYTE DIRECTIVE PARAMETER BLOCK
;
; THESE ROUTINES ARE CALLED TO ADDRESS CHECK A TASK SPECIFIED PARAMETER
; BLOCK TO INSURE IT IS WITHIN THE TASK'S ADDRESS SPACE AND ALIGNED PROPERLY.
; IF EITHER CHECK FAILS, THEN A DIRECTIVE STATUS OF 'D.RS98' IS RETURNED.
;
; INPUTS:
;
;       R0=STARTING ADDRESS OF THE BLOCK TO BE CHECKED.
;       R1=LENGTH OF THE BLOCK TO BE CHECKED IN BYTES.
;
; OUTPUTS:
;
;       THE SPECIFIED BLOCK IS CHECKED FOR PROPER ALIGNMENT AND WHETHER
;       IT IS WITHIN THE TASK'S ADDRESS SPACE. IF EITHER CHECK FAILS,
;       THEN A DIRECTIVE STATUS OF 'D.RS98' IS RETURNED. ELSE A RETURN
;       TO THE CALLER IS EXECUTED.
;
;       R0 AND R3 ARE PRESERVED ACROSS CALL.
;-


        .IF DF  A$$CHK!M$$MGE

        .ENABL  LSB


        .IF NDF M$$MGE

$ACHK2::MOV     #2,R1           ;SET TO CHECK 2 BYTES

        .IFTF

$ACHKP::MOV     R3,R0           ;SET ADDRESS OF BLOCK TO CHECK

        .IFF

        CALL    $ACHCK          ;ADDRESS CHECK WORD ALIGNED
        BCS     10$             ;IF CS CHECK FAILURE
        CALL    $RELOC          ;RELOCATE PARAMETER BLOCK ADDRESS
        MOV     R1,KISAR6       ;MAP TO PARAMETER BLOCK
        MOV     R2,R3           ;REDEFINE PARAMETER BLOCK ADDRESS
        RETURN                  ;

        .ENDC


$ACHKW::CALL    $ACHCK          ;ADDRESS CHECK WORD ALIGNED
        BCC     50$             ;IF CC OKAY
10$:    DRSTS   D.RS98          ;SET DIRECTIVE STATUS

;+
; **-$ACHKB-ADDRESS CHECK BYTE ALIGNED
; **-$ACHCK-ADDRESS CHECK WORD ALIGNED
;
; THIS ROUTINE IS CALLED TO ADDRESS CHECK A BLOCK OF MEMORY TO SEE WHETHER
; IT LIES WITHIN THE ADDRESS SPACE OF THE CURRENT TASK.
;
; INPUTS:
;
;       R0=STARTING ADDRESS OF THE BLOCK TO BE CHECKED.
;       R1=LENGTH OF THE BLOCK TO BE CHECKED IN BYTES.
;
; OUTPUTS:
;
;       C=1 IF ADDRESS CHECK FAILED.
;       C=0 IF ADDRESS CHECK SUCCEEDED.
;
;       R0 AND R3 ARE PRESERVED ACROSS CALL.
;-

$ACHCK::ASR     R0              ;ODD ADDRESS?
        BCS     50$             ;IF CS YES
        ASL     R0              ;REALIGN ADDRESS
$ACHKB::                        ;REFERENCE LABEL


        .IF NDF M$$MGE

        SAVNR                   ;SAVE R4 AND R5

        .IFTF

        MOV     $TKTCB,R2       ;GET TCB ADDRESS OF CURRENT TASK
        CLC                     ;ASSUME TASK IS PRIVILEGED
        BIT     #T3.PRV,T.ST3(R2) ;PRIVILEGED TASK?
        BNE     50$             ;IF NE YES
        DEC     R1              ;CALCULATE HIGHEST ADDRESS OF BLOCK
        ADD     R0,R1           ;
        BCS     50$             ;IF CS ADDRESS WRAP AROUND

        .IFF

        MOV     $HEADR,R2       ;GET ADDRESS OF CURRENT TASK HEADER
        MOV     H.WND(R2),R2    ;POINT TO NUMBER OF WINDOW BLOCKS
        MOV     (R2)+,-(SP)     ;PUSH NUMBER OF WINDOW BLOCKS

        .IFT

        MOV     $HEADR,R4       ;GET ADDRESS OF CURRENT TASK HEADER
        MOV     H.WND(R4),R2    ;POINT TO NUMBER OF WINDOW BLOCKS
        MOV     (R2)+,-(SP)     ;PUSH NUMBER OF WINDOW BLOCKS
        MOV     (R2),R5         ;SAVE PCB ADDRESS OF TASK PARTITION

        .IFTF

15$:    TST     (R2)+           ;IS NEXT WINDOW MAPPED? (W.BPCB)
        BEQ     20$             ;IF EQ NO
        CMP     R0,(R2)         ;COMPARE LOW LIMITS (W.BLVR)
        BLO     20$             ;IF LO NOT IN DESCRIPTOR
        CMP     R1,2(R2)        ;COMPARE HIGH LIMITS (W.BHVR)
        BLOS    25$             ;IF LOS BUFFER IS IN DESCRIPTOR
20$:    ADD     #W.BLGH-2,R2    ;POINT TO NEXT DESCRIPTOR
        DEC     (SP)            ;MORE DESCRIPTORS TO GO?
        BGT     15$             ;IF GT YES
        BR      30$             ;ELSE EXIT WITH CS
25$:                            ;REFERENCE LABEL

        .IFT

        CMP     -(R2),R5        ;TASK PARTITION?
        BNE     40$             ;IF NE NO
        CMP     R0,H.GARD(R4)   ;HEADER VIOLATION?
        BHI     40$             ;IF HI NO

        .IFF

        BIT     #4,W.BLPD-W.BLVR(R2) ;WRITE ACCESS PERMITTED?
        BNE     40$             ;IF NE YES

        .ENDC


30$:    COM     (SP)+           ;CLEAN STACK AND SET CARRY
        RETURN                  ;
40$:    TST     (SP)+           ;CLEAN STACK AND CLEAR CARRY
50$:    RETURN                  ;
        .DSABL  LSB

        .ENDC


;+
; **-$CEFN-CONVERT EVENT FLAG NUMBER FOR DIRECTIVE
; **-$CEFI-CONVERT EVENT FLAG NUMBER FOR I/O
;
; THIS ROUTINE IS CALLED TO CONVERT AN EVENT FLAG NUMBER TO AN
; EVENT FLAG MASK WORD AND EVENT FLAG MASK ADDRESS. IF AN ILLEGAL
; EVENT FLAG IS SPECIFIED, THEN A DIRECTIVE STATUS OF 'D.RS97' IS
; RETURNED. ELSE THE EVENT FLAG NUMBER IS CONVERTED AND THE COM-
; PONENT PARTS ARE RETURNED TO THE CALLER.
;
; INPUTS:
;
;       R0=EVENT FLAG NUMBER TO BE CONVERTED.
;       R5=TCB ADDRESS OF THE TASK THE EFN APPLIES TO.
;
; OUTPUTS:
;
;       C=1 IF NO EVENT FLAG NUMBER WAS SPECIFIED.
;               R0=ZERO.
;               R1=ZERO.
;       C=0 IF AN EVENT FLAG NUMBER WAS SPECIFIED.
;               R0=EVENT FLAG MASK WORD.
;               R1=EVENT FLAG MASK ADDRESS.
;
;       R3 IS PRESERVED ACROSS CALL IF ENTRY AT $CEFI, ELSE R3 IS ADVANCED BY 2.
;-

        .ENABL  LSB
$CEFN:: MOVB    (R3)+,R0        ;GET EVENT FLAG NUMBER
        INC     R3              ;ADVANCE TO NEXT WORD
$CEFI:: MOV     R0,R1           ;COPY EFN
        SEC                     ;ASSUME NONE SPECIFIED
        BEQ     30$             ;IF EQ NO EFN SPECIFIED
        DEC     R0              ;BACK OFF EFN BY ONE
        MOV     #32.,R2         ;SET EFN DIVIDER
        MOV     R5,R1           ;POINT TO FIRST TASK MASK WORD
        ADD     #T.EFLG,R1      ;
        CMP     R0,R2           ;IN TASK EFN SET?
        BLO     10$             ;IF LO YES
        SUB     R2,R0           ;NORMALIZE TO COMMON SET
        CMP     R0,R2           ;LEGAL EFN?
                                                                        ; CS020
        .IF DF G$$EFN                                                   ; CS020
                                                                        ; CS020
        BLO     5$              ;IF LO YES                              ; CS020
        SUB     R2,R0           ;NORMALIZE TO GROUP GLOBAL SET          ; CS020
        CMP     R0,R2           ;LEGAL EFN?                             ; CS020
        BHIS    40$             ;IF HIS NO                              ; CS020
        CALL    $GTGEF          ;GET ADDRESS OF GROUP GLOBAL EF'S       ; CS020
        BR      10$             ;USE GROUP GLOBAL SET                   ; CS020
5$:                             ;REF LABEL                              ; CS020
                                                                        ; CS020
        .ENDC   ;G$$EFN                                                 ; CS020
        MOV     #$COMEF,R1      ;POINT TO FIRST COMMON MASK WORD        ;**-1
10$:    ASR     R2              ;HALVE DIVIDER
        CMP     R0,R2           ;FIRST MASK WORD?
        BLO     20$             ;IF LO YES
        SUB     R2,R0           ;NORMALIZE EFN
        TST     (R1)+           ;POINT TO SECOND MASK WORD
20$:    ASL     R0              ;CONVERT EFN TO WORD INDEX
        MOV     $BTMSK(R0),R0   ;GET PROPER MASK WORD
30$:    RETURN                  ;
40$:    DRSTS   D.RS97          ;SET DIRECTIVE STATUS

;+
; **-$DVMSG-DEVICE MESSAGE OUTPUT
;
; THIS ROUTINE IS CALLED TO SUBMIT A MESSAGE TO THE TASK TERMINATION
; NOTIFICATION TASK. MESSAGES ARE EITHER DEVICE RELATED OR A CHECKPOINT
; WRITE FAILURE FROM THE LOADER.
;
; INPUTS:
;
;       R4=ADDITIONAL PARAMETER
;       R5=ADDRESS OF THE UCB OR TCB THAT THE MESSAGE APPLIES TO.
;
; OUTPUTS:
;
;       A FOUR WORD PACKET IS ALLOCATED, R0 AND R5 ARE STORED IN THE
;       SECOND AND THIRD WORDS RESPECTIVELY, AND THE PACKET IS THREADED
;       INTO THE TASK TERMINATION NOTIFICATION TASK MESSAGE QUEUE.
;
;       NOTE: IF THE TASK TERMINATION NOTIFICATION TASK IS NOT INSTALLED
;               OR NO STORAGE CAN BE OBTAINED, THEN THE MESSAGE REQUEST
;               IS IGNORED.
;-

$DVMSG::                        ;REF LABEL


        .IF DF  T$$KMG

        MOV     R0,R3           ;SAVE MESSAGE NUMBER
        TST     $TKNPT          ;TKTN INSTALLED?
        BEQ     30$             ;IF EQ NO
        MOV     #8.,R1          ;SET LENGTH OF BLOCK NEEDED
        CALL    $ALOCB          ;GET A CORE BLOCK
        BCS     30$             ;IF CS DIDN'T GET ONE
        MOV     R0,R1           ;SET ADDRESS OF MESSAGE BLOCK
        TST     (R0)+           ;POINT TO SECOND WORD IN BLOCK
        MOV     R3,(R0)+        ;INSERT MESSAGE NUMBER
        MOV     R5,(R0)+
;INSERT UCB OR TCB ADDRESS
        MOV     R4,(R0)         ;INSERT ADDITIONAL PARAMETER
        MOV     $TKNPT,R0       ;PICK UP TKTN TCB ADDRESS
        CALLR   $EXRQF          ;REQUEST TKTN AND QUEUE MESSAGE

        .IFF

        RETURN                  ;

        .ENDC


        .DSABL  LSB

;+
; **-$GTPKT-GET I/O PACKET FROM REQUEST QUEUE
; **-$GSPKT-GET SELECTIVE I/O PACKET FROM REQUEST QUEUE                 ; CS013
;
; THIS ROUTINE IS CALLED BY DEVICE DRIVERS TO DEQUEUE THE NEXT I/O REQUEST TO
; PROCESS. IF THE DEVICE CONTROLLER IS BUSY, THEN A CARRY SET INDICATION IS
; RETURNED TO THE CALLER. ELSE AN ATTEMPT IS MADE TO DEQUEUE THE NEXT REQUEST
; FROM THE CONTROLLER QUEUE. IF NO REQUEST CAN BE DEQUEUED, THEN A CARRY
; SET INDICATION IS RETURNED TO THE CALLER. ELSE THE CONTROLLER IS SET BUSY AND
; A CARRY CLEAR INDICATION IS RETURNED TO THE CALLER.
;
; THE ALTERNATE ENTRY POINT $GSPKT IS INTENDED FOR USE BY DRIVERS WHICH ; CS013
; SUPPORT PARALLEL OPERATIONS ON A SINGLE UNIT, A COMMON EXAMPLE BEING  ; CS013
; FULL DUPLEX.  SUCH DRIVERS ARE EXPECTED TO LOOK TO THE SYSTEM AS IF   ; CS013
; THEY ARE ALWAYS FREE, WHILE MAINTAINING THE STATUS OF ALL PARALLEL    ; CS013
; OPERATIONS INTERNALLY WITHIN THEIR OWN DEVICE DATA STRUCTURES.        ; CS013
; PARALLELISM IS ACCOMPLISHED BY HANDLING DRIVER-DEFINED CLASSES OF I/O ; CS013
; FUNCTION CODES IN PARALLEL WITH EACH OTHER.  FOR EXAMPLE A FULL-DUPLEX; CS013
; DRIVER WOULD HANDLE INPUT REQUESTS IN PARALLEL WITH OUTPUT REQUESTS.  ; CS013
; A DRIVER CALLS $GSPKT WHEN IT WANTS TO DEQUEUE A PACKET WHOSE I/O     ; CS013
; FUNCTION CODE BELONGS TO A CERTAIN CLASS.  WHICH FUNCTIONS QUALIFY IS ; CS013
; DETERMINED BY AN ACCEPTANCE ROUTINE IN THE DRIVER WHOSE ADDRESS IS    ; CS013
; PASSED TO $GSPKT IN R2.  THE ACCEPTANCE ROUTINE IS CALLED BY $GSPKT   ; CS013
; EACH TIME A PACKET IS FOUND IN THE QUEUE WHICH IS ELIGIBLE TO BE      ; CS013
; DEQUEUED.  THE ACCEPTANCE ROUTINE IS THEN EXPECTED TO TAKE ONE OF THE ; CS013
; FOLLOWING THREE ACTIONS:                                              ; CS013
;                                                                       ; CS013
;           1.  RETURN WITH CARRY CLEAR IF THE PACKET SHOULD BE         ; CS013
;               DEQUEUED.  IN THIS CASE $GSPKT PROCEEDS AS $GTPKT       ; CS013
;               NORMALLY WOULD ON DEQUEUEING THE PACKET.                ; CS013
;                                                                       ; CS013
;           2.  RETURN WITH CARRY SET IF THE PACKET SHOULD NOT BE       ; CS013
;               DEQUEUED.  IN THIS CASE $GSPKT WILL CONTINUE THE SCAN   ; CS013
;               OF THE I/O QUEUE.                                       ; CS013
;                                                                       ; CS013
;           3.  ADD THE CONSTANT G$$SPSA TO THE STACK POINTER TO ABORT  ; CS013
;               THE SCAN WITH NO FURTHER ACTION.                        ; CS013
;                                                                       ; CS013
; THE ACCEPTANCE ROUTINE MUST SAVE AND RESTORE ANY REGISTERS WHICH IT   ; CS013
; INTENDS TO MODIFY.  WHEN A PACKET IS DEQUEUED VIA $GSPKT, THE         ; CS013
; FOLLOWING NORMAL $GTPKT ACTIONS DO NOT OCCUR:                         ; CS013
;                                                                       ; CS013
;           1.  FILLING IN OF U.BUF, U.BUF+2 AND U.CNT.  THESE FIELDS   ; CS013
;               ARE AVAILABLE FOR DRIVER-SPECIFIC USE.                  ; CS013
;                                                                       ; CS013
;           2.  BUSYING OF UCB AND SCB.                                 ; CS013
;                                                                       ; CS013
;           3.  EXECUTION OF $CFORK TO GET TO PROPER PROCESSOR (MULTI-  ; CS013
;               PROCESSOR SYSTEMS).                                     ; CS013
;                                                                       ; CS013
; INPUTS:                                                               ; CS013
;                                                                       ; CS013
;       R2=ADDRESS OF DRIVER'S ACCEPTANCE ROUTINE (IF CALL AT $GSPKT).  ; CS013
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO GET A PACKET FOR.    ; CS013
;                                                                       ; CS013
; OUTPUTS:                                                              ; CS013
;                                                                       ; CS013
;       C=1 IF CONTROLLER IS BUSY OR NO REQUEST CAN BE DEQUEUED.        ; CS013
;       C=0 IF A REQUEST WAS SUCCESSFULLY DEQUEUED.                     ; CS013
;               R1=ADDRESS OF THE I/O PACKET.                           ; CS013
;               R2=PHYSICAL UNIT NUMBER.                                ; CS013
;               R3=CONTROLLER INDEX.                                    ; CS013
;               R4=ADDRESS OF THE STATUS CONTROL BLOCK.                 ; CS013
;               R5=ADDRESS OF THE UNIT CONTROL BLOCK.                   ; CS013
;                                                                       ; CS013
;       NOTE: R4 AND R5 ARE DESTROYED BY THIS ROUTINE.                  ; CS013
;-                                                                      ; CS013
                                                                        ; CS013
        .ENABL  LSB                                                     ; CS013
                                                                        ; CS013
        .IF DF T$$CPW                                                   ; CS013
                                                                        ; CS013
G$$SPA==4                       ;CONSTANT TO ADD TO SP TO ABORT SCAN    ; CS013
                                                                        ; CS013
$GTPKT::MOV     #128$,R2        ;ACCEPT ALL PACKETS                     ; CS013
$GSPKT::MOV     R2,$TEMP2       ;SAVE ADDRESS OF ACCEPTANCE ROUTINE     ; CS013
5$:     MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB                     ; CS013
                                                                        ; CS013
        .IFF                                                            ; CS013
                                                                        ; CS013
$GTPKT::MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB                     ; CS013
                                                                        ; CS013
        .ENDC   ;T$$CPW                                                 ; CS013
                                                                        ; CS013
        TSTB    S.STS(R4)       ;CONTROLLER BUSY?                       ;**-18
        BNE     70$             ;IF NE CONTROLLER IS BUSY


        .IF DF  E$$DVC

        BICB    #SP.EIP,S.PRI(R4) ;CLEAR ERROR IN PROGRESS

        .ENDC


        MOV     R4,R1           ;SET POINTER TO I/O QUEUE LISTHEAD
10$:    MOV     R1,R0           ;SAVE ADDRESS OF PREVIOUS PACKET
        MOV     (R0),R1         ;GET ADDRESS OF NEXT PACKET
        BEQ     70$             ;IF EQ NO MORE PACKETS TO SCAN
        MOV     I.UCB(R1),R5    ;GET ADDRESS OF UNIT CONTROL BLOCK
        MOV     U.ATT(R5),R3    ;UNIT ATTACHED?
        BEQ     20$             ;IF EQ NO
        MOV     I.TCB(R1),R2    ;GET ADDRESS OF REQUESTOR TASK TCB
        BIT     #T3.PRV,T.ST3(R2) ;TASK PRIVILEGED?
        BEQ     15$             ;IF EQ NO


        .IF DF  D$$ISK

        CMP     R2,$LDRPT       ;REQUESTING TASK THE LOADER?
        BEQ     20$             ;IF EQ YES-ALWAYS BREAK THRU ATTACH

        .ENDC


        BIT     #DV.TTY,U.CW1(R5) ;DEVICE A TERMINAL?
        BEQ     15$             ;IF EQ NO
                                                                        ; CS041
        .IF DF R$$SCS                                                   ; CS041
                                                                        ; CS041
        CMPB    #IO.ATT/256.,I.FCN+1(R1) ;ATTACH FUNCTION?              ; CS041
        BNE     20$             ;IF NE, NO, ALLOW FUNCTION              ; CS041
                                                                        ; CS041
        .IFF                                                            ; CS041
                                                                        ; CS041
        CMPB    #IO.WLB/256.,I.FCN+1(R1) ;WRITE LOGICAL FUNCTION
        BEQ     20$             ;IF EQ YES-BREAK THRU ATTACH
                                                                        ; CS041
        .ENDC   ;R$$SCS                                                 ; CS041
                                                                        ; CS041
15$:    CMP     R2,R3           ;IS THIS THE APPROPRIATE TASK?
        BNE     10$             ;IF NE NO
                                                                        ; CS013
        .IF DF T$$CPW                                                   ; CS013
                                                                        ; CS013
20$:    CALL    @$TEMP2         ;CALL DRIVER ACCEPTANCE ROUTINE         ; CS013
        BCS     10$             ;IF CS PACKET NOT ACCEPTED              ; CS013
        MOV     (R1),(R0)       ;CLOSE UP LIST REMOVING ENTRY           ; CS013
                                                                        ; CS013
        .IFF                                                            ; CS013
                                                                        ; CS013
20$:    MOV     (R1),(R0)       ;CLOSE UP LIST REMOVING ENTRY           ; CS013
                                                                        ; CS013
        .ENDC   ;T$$CPW                                                 ; CS013
                                                                        ; CS013
        BNE     30$             ;IF NE LAST ENTRY WAS NOT REMOVED       ;**-1
        MOV     R0,2(R4)        ;SET ADDRESS OF NEW LAST IN LIST
30$:    MOV     R1,S.PKT(R4)    ;SET ADDRESS OF CURRENT I/O PACKET
        MOVB    I.FCN+1(R1),R2  ;GET I/O FUNCTION CODE
        CMPB    #IO.ATT/256.,R2 ;ATTACH FUNCTION?
        BNE     40$             ;IF NE NO


        .IF DF  A$$CPS

        MOV     #IE.PRI&377,R0  ;ASSUME PRIVILEGE VIOLATION
        TST     U.CW1(R5)       ;MOUNTABLE DEVICE?
        BPL     35$             ;IF PL NO
        BITB    #US.MNT!US.FOR,U.STS(R5) ;NOT MOUNTED OR FOREIGN?
        BEQ     60$             ;IF EQ NO

        .IFTF

35$:    MOV     I.TCB(R1),R0    ;ASSUME SUCCESSFUL ATTACH
        TST     R3              ;UNIT ALREADY ATTACHED?


        .IF DF  D$$IAG

        BEQ     36$             ;IF EQ NO

        .IFF

        BEQ     50$             ;IF EQ NO

        .IFTF

        MOV     #IE.DAA&377,R0  ;SET STATUS OF DEVICE ALREADY ATTACHED
        BR      60$             ;


        .IFT

36$:    BITB    #IQ.UMD,I.FCN(R1) ;IS THIS A DIAGNOSTIC ATTACH?
        BEQ     50$             ;IF EQ NO
        BIT     #DV.UMD,U.CW1(R5) ;USER MODE DIAGNOSTICS SUPPORTED?
        BEQ     37$             ;IF EQ NO
        BISB    #US.UMD,U.ST2(R5) ;INDICATE DIAGNOSTIC ATTACH
        BR      50$             ;
37$:    MOV     #IE.IFC&377,R0  ;SET STATUS OF ILLEGAL FUNCTION
        BR      60$             ;

        .IFTF

40$:    CMPB    #IO.DET/256.,R2 ;DETACH FUNCTION
        BNE     80$             ;IF NE NO
        MOV     #IE.DNA&377,R0  ;ASSUME DEVICE NOT ATTCHED
        TST     R3              ;UNIT ATTACHED?
        BEQ     60$             ;IF EQ NO
        CLR     R0              ;SET TO DETACH UNIT

        .IFT

        BICB    #US.UMD,U.ST2(R5) ;RESET DIAGNOSTIC BIT

        .ENDC


50$:    MOV     R0,U.ATT(R5)    ;ATTACH/DETACH UNIT
        BITB    #UC.ATT,U.CTL(R5) ;DOES DRIVER WANT CONTROL ON ATTACH/DETACH?
        BNE     120$            ;IF NE YES
        MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS
60$:    CALL    $IOALT          ;FINISH I/O OPERATION
                                                                        ; CS013
        .IF DF T$$CPW                                                   ; CS013
                                                                        ; CS013
65$:    BR      5$              ;GO AGAIN                               ; CS013
                                                                        ; CS013
        .IFF                                                            ; CS013
                                                                        ; CS013
65$:    BR      $GTPKT          ;GO AGAIN                               ; CS013
                                                                        ; CS013
        .ENDC   ;T$$CPW                                                 ; CS013
                                                                        ; CS013
70$:    SEC                     ;SET CONTROLLER BUSY OR NO REQUEST      ;**-1
        BR      130$            ;
80$:                            ;REF LABEL

        .IFT

        TST     U.CW1(R5)       ;DEVICE MOUNTABLE?
        BPL     120$            ;IF PL NO


        .IF DF  D$$IAG

        BITB    #IQ.UMD,I.FCN(R1)  ;IS THIS A DIAGNOSTIC FUNCTION?
        BNE     120$            ;IF NE YES, IT CAN'T BE AN ACP FUNCTION

        .ENDC

;                                                                       ; BO015
; DETERMINE IF FUNCTION IS ACP FUNCTION                                 ; BO015
;       APPLICABLE TO ALL MOUNTED DEVICES - NATIVE AND FOREIGN          ; BO015
;       FILES 11 - MAPPING OF VIRTUAL TO LOGICAL NOW DONE BY            ; BO015
;               DRQIO.  ONLY VIRTUAL & ACP FUNCTIONS THAT               ; BO015
;               NEED CORRECT SEQUENCING ARE ROUTED THRU DRIVER.         ; BO015
;                                                                       ; BO015
        MOV     U.ACP(R5),R0    ;GET ADDRESS OF ACP                     ; BO015
        BEQ     120$            ;NO ACP - PASS IT ON TO DRIVER          ; BO015
;                                                                       ; BO015
;       NATIVE REQUESTS ARE ROUTED TO THE ACP IF THE FCTN CODE > 7.     ; BO015
;       THIS IS REQUIRED BECAUSE IO.CLN IS NOT CURRENTLY DEFINED        ; BO015
;       IN DCB BITS.  HOPEFULLY THIS WILL BE FIXED.                     ; BO015
;                                                                       ; BO015
                                                                        ; BO015
        BITB    #US.MNT!US.FOR,U.STS(R5)        ;MOUNTED NATIVE?        ; BO015
        BNE     85$             ;BRANCH IF MOUNTED FOREIGN              ; BO015
        CMP     #7,R2           ;NATIVE-IS IT ACP FCTN?                 ; BO015
        BHI     120$            ;IF HI NO -DRIVER FCTN                  ; BO015
        BR      95$             ;ACP                                    ; BO015
85$:    MOV     (R5),R3         ;GET DCB ADDRESS                        ; BO015
        CMP     R2,#15.         ;NORMALIZE FCTN CODE                    ; BO015
        BLOS    90$             ;                                       ; BO015
        SUB     #15.,R2         ;                                       ; BO015
        ADD     #10,R3          ;ADJUST PTR TO 2ND MASK SET             ; BO015
90$:    ASL     R2              ;CONVERT TO WORD INDEX                  ; BO015
        BIT     $BTMSK(R2),D.MSK+6(R3)  ;IS IT ACP FUNCTION?            ; BO015
        BEQ     120$            ;NO - DRIVER                            ; BO015
95$:                            ;                                       ; BO015
        CALL    $EXRQP          ;INSURE FILE SYSTEM IS ACTIVE           ;**-31
        BR      65$             ;GO AGAIN                               ; CS013
                                                                        ; CS013
                                                                        ;**-1
        .ENDC

                                                                        ; CS013
        .IF DF T$$CPW                                                   ; CS013
                                                                        ; CS013
120$:   CMP     $TEMP2,#128$    ;$GSPKT CALL?                           ; CS013
        BNE     127$            ;IF NE YES, SKIP TO DRIVER CALL         ; CS013
                                                                        ; CS013
        .IFF                                                            ; CS013
                                                                        ; CS013
120$:                                                                   ; CS013
                                                                        ; CS013
        .ENDC   ;T$$CPW                                                 ; CS013
                                                                        ; CS013
        MOV     I.PRM(R1),U.BUF(R5) ;INSERT RELOCATION BIAS IN UCB      ; CS013
        MOV     I.PRM+2(R1),U.BUF+2(R5) ;INSERT BUFFER ADDRESS IN UCB   ; CS013
        MOV     I.PRM+4(R1),U.CNT(R5) ;INSERT BYTE COUNT IN UCB         ; CS013
126$:   INCB    S.STS(R4)       ;SET CONTROLLER BUSY                    ; CS013
        BISB    #US.BSY,U.STS(R5) ;SET UNIT BUSY                        ; CS013
127$:   MOVB    S.CON(R4),R3    ;GET CONTROLLER INDEX                   ; CS013
        MOVB    U.UNIT(R5),R2   ;SET PHYSICAL UNIT NUMBER               ; CS013
128$:   CLC                     ;INDICATE PACKET BEING RETURNED         ; CS013
130$:   RETURN                  ;                                       ;**-9

        .DSABL  LSB                                                     ; CS013
                                                                        ; CS013
                                                                        ; CS013
        .IF DF T$$CPW                                                   ; CS013
                                                                        ; CS013
;+                                                                      ; CS013
; **-$TSTBF-TEST IF I/O BUFFERING CAN BE INITIATED                      ; CS013
;                                                                       ; CS013
; THIS ROUTINE DETERMINES IF A GIVEN I/O REQUEST IS ELIGIBLE FOR I/O    ; CS013
; BUFFERING, AND IF SO IT STORES THE PCB ADDRESS OF THE REGION INTO     ; CS013
; WHICH THE TRANSFER IS TO OCCUR IN I.PRM+16 OF THE I/O PACKET.         ; CS013
;                                                                       ; CS013
; INPUTS:                                                               ; CS013
;                                                                       ; CS013
;       R3=ADDRESS OF I/O PACKET FOR I/O REQUEST                        ; CS013
;                                                                       ; CS013
; OUTPUTS:                                                              ; CS013
;                                                                       ; CS013
;       R3 IS PRESERVED.                                                ; CS013
;                                                                       ; CS013
;       C=0 IF I/O BUFFERING CAN BE INITIATED.                          ; CS013
;                                                                       ; CS013
;       C=1 IF I/O BUFFERING CAN NOT BE INITIATED.                      ; CS013
;-                                                                      ; CS013
                                                                        ; CS013
$TSTBF::MOV     I.TCB(R3),R0    ;GET ADDRESS OF REQUESTOR TCB           ; CS013
        SEC                     ;ASSUME TASK CANNOT BE STOPPED?         ; CS013
        BIT     #T2.AST!T2.DST!T2.CHK!T2.CKD!T2.STP,T.ST2(R0) ;STOP IT? ; CS013
        BNE     20$             ;IF NE NO                               ; CS013
        SAVNR                   ;SAVE R4 AND R5                         ; CS013
        MOV     T.PCB(R0),R1    ;GET ADDRESS OF REQUESTER HEADER        ; CS013
        MOV     P.HDR(R1),R1    ;                                       ; CS013
        MOV     H.WND(R1),R1    ;POINT TO NUMBER OF WINDOW BLOCKS       ; CS013
        MOV     (R1)+,R2        ;GET COUNT OF WINDOWS                   ; CS013
10$:    SEC                     ;ASSUME NO MORE WINDOWS                 ; CS013
        DEC     R2              ;ANY MORE WINDOWS TO EXAMINE?           ; CS013
        BLT     20$             ;IF LT NO, DON'T CHECKPOINT             ; CS013
        MOV     (R1)+,R4        ;GET ADDRESS OF DESCRIPTOR PCB          ; CS013
        BEQ     30$             ;IF EQ WINDOW NOT MAPPED                ; CS013
        MOV     (R1)+,-(SP)     ;GET LOW VIRTUAL ADDRESS                ; CS013
        MOV     (R1)+,R5        ;GET HIGH VIRTUAL ADDRESS               ; CS013
        SUB     (SP),R5         ;CALCULATE NUMBER OF BYTES MINUS 1      ; CS013
        SUB     #77,R5          ;REDUCE TO ACTUAL NUMBER OF BYTES - 64B ; CS013
        ASL     R5              ;CONVERT TO 32W BLOCKS                  ; CS013
        ROL     R5              ;                                       ; CS013
        ROLB    R5              ;                                       ; CS013
        SWAB    R5              ;                                       ; CS013
        MOV     P.REL(R4),(SP)  ;GET RELOCATION BIAS OF PCB             ; CS013
                                                                        ; CS013
                                                                        ; CS013
        .IF DF  P$$LAS                                                  ; CS013
                                                                        ; CS013
        ADD     W.BOFF-W.BATT(R1),(SP) ;ADD IN OFFSET IN PARTITION      ; CS013
                                                                        ; CS013
        .ENDC                                                           ; CS013
                                                                        ; CS013
                                                                        ; CS013
        ADD     (SP),R5         ;CALCULATE HIGHEST 32W BLOCK            ; CS013
        ADD     #W.BLGH-W.BATT,R1 ;POINT TO NEXT DESCRIPTOR             ; CS013
        CMP     I.PRM(R3),(SP)+ ;TRANSFER IN THIS PARTITION?            ; CS013
        BLO     10$             ;IF LO NO                               ; CS013
        CMP     R5,I.PRM(R3)    ;TRANSFER IN THIS PARTITION?            ; CS013
        BLO     10$             ;IF LO NO                               ; CS013
        MOV     R4,I.PRM+16(R3) ;STORE PCB ADDRESS IN I/O PACKET        ; CS013
20$:    RETURN                  ;                                       ; CS013
30$:    ADD     #W.BLGH-W.BLVR,R1 ;POINT TO NEXT WINDOW BLOCK           ; CS013
        BR      10$             ;                                       ; CS013
                                                                        ; CS013
                                                                        ; CS013
;+                                                                      ; CS013
; **-$INIBF-INITIATE I/O BUFFERING                                      ; CS013
;                                                                       ; CS013
; THIS ROUTINE INITIATES I/O BUFFERING BY DOING THE FOLLOWING:          ; CS013
;                                                                       ; CS013
;           1.  DECREMENT THE TASK'S I/O COUNT.                         ; CS013
;                                                                       ; CS013
;           2.  SET THE TASK'S T2.TIO BIT TO SIGNIFY A BUFFERED I/O     ; CS013
;               REQUEST IS IN PROGRESS.                                 ; CS013
;                                                                       ; CS013
;           3.  STOPS THE TASK, HANDLING A PENDING CHECKPOINT REQUEST IF; CS013
;               NECESSARY.                                              ; CS013
;                                                                       ; CS013
; INPUTS:                                                               ; CS013
;                                                                       ; CS013
;       R3=ADDRESS OF I/O PACKET FOR I/O REQUEST.                       ; CS013
;                                                                       ; CS013
; OUTPUTS:                                                              ; CS013
;                                                                       ; CS013
;       R3 IS PRESERVED.                                                ; CS013
;-                                                                      ; CS013
                                                                        ; CS013
$INIBF::MOV     R3,-(SP)        ;SAVE PACKET ADDRESS                    ; CS013
        MOV     I.TCB(R3),R0    ;POINT TO ISSUING TASK'S TCB            ; CS013
        BIS     #T2.TIO,T.ST2(R0) ;SHOW DOING TERMINAL I/O              ; CS013
        DECB    T.IOC(R0)       ;ADJUST OUTSTANDING I/O REQUEST COUNT   ; CS013
        MOV     I.PRM+16(R3),R1 ;GET PCB                                ; CS013
        SUB     P.REL(R1),I.PRM(R3) ;CONVERT TO RELATIVE RELOCATION BIAS; CS013
10$:                                                                    ; CS013
                                                                        ; CS013
        .IF DF  D$$ISK                                                  ; CS013
                                                                        ; CS013
        BIT     #TS.CKR,T.STAT(R0) ;CHECKPOINT REQUEST PENDING?         ; CS029
        BEQ     20$             ;IF EQ NO                               ; CS029
        BIC     #TS.CKR,T.STAT(R0) ;CLEAR CHECKPOINT REQUEST            ; CS029
        MOV     R0,-(SP)        ;SAVE TCB ADDRESS                       ; CS029
        MOV     R0,R1           ;COPY TCB ADDRESS                       ; CS029
        CALL    $ICHKP          ;INITIATE CHECKPOINT OF PCB             ; CS013
        MOV     (SP)+,R0        ;RESTORE TCB ADDRESS                    ; CS013
                                                                        ; CS013
        .ENDC                                                           ; CS013
                                                                        ; CS013
20$:    CALL    $STPTK          ;STOP TASK AND REALLOCATE PARTITION     ; CS013
        MOV     (SP)+,R3        ;RESTORE PACKET ADDRESS IN R3           ; CS013
        RETURN                  ;                                       ; CS013
                                                                        ; CS013
;+                                                                      ; CS013
; **-$QUEBF-QUEUE BUFFERED I/O FOR COMPLETION                           ; CS013
;                                                                       ; CS013
; THIS ROUTINE QUEUES A SPECIAL ENTRY TO A TASK'S AST QUEUE TO COMPLETE ; CS013
; A BUFFERED I/O REQUEST THE NEXT TIME THE TASK IS SCHEDULED.  IT ALSO  ; CS013
; CLEARS THE TASK'S T2.TIO BIT (BUFFERED I/O) AND UNSTOPS THE TASK.     ; CS013
;                                                                       ; CS013
; NOTE: THIS ROUTINE IS EQUIVALENT TO CALLING $IOFIN AND IT DOES NOT    ; CS013
;       UNBUSY THE DEVICE.                                              ; CS013
;                                                                       ; CS013
; INPUTS:                                                               ; CS013
;                                                                       ; CS013
;       R0=FIRST WORD OF I/O STATUS                                     ; CS013
;       R1=SECOND WORD OF I/O STATUS                                    ; CS013
;       R3=ADDRESS OF I/O PACKET                                        ; CS013
;                                                                       ; CS013
; OUTPUTS:                                                              ; CS013
;                                                                       ; CS013
;       NONE                                                            ; CS013
;-                                                                      ; CS013
                                                                        ; CS013
$QUEBF::MOV     R0,I.PRM+6(R3)  ;STORE OFFSPRING I/O RETURN STATUS      ; CS013
        MOV     R1,I.PRM+10(R3) ;                                       ; CS013
        MOV     I.TCB(R3),R0    ;PICK UP OFFSPRING TCB ADDRESS          ; CS013
        BIC     #TS.RDN,T.STAT(R0) ;CLEAR RUNDOWN IN PROG               ; CS013
        MOV     R0,R2           ;COPY TCB ADDRESS                       ; CS013
        ADD     #T.ASTL,R2      ;POINT TO AST LISTHEAD                  ; CS013
        MOV     (R2),(R3)       ;LINK PACKET TO FRONT OF LIST           ; CS013
        BNE     10$             ;                                       ; CS013
        MOV     R3,2(R2)        ;                                       ; CS013
10$:    MOV     R3,(R2)         ;                                       ; CS013
        MOVB    #200,A.CBL(R3)  ;SET BUFFERED I/O FLAG                  ; CS013
        BIC     #T2.TIO,T.ST2(R0) ;CLEAR "TERMINAL I/O" FLAG IN TCB     ; CS013
        CALLR   $EXRQN          ;UNSTOP TASK AND RETURN                 ; CS013
                                                                        ; CS013
        .ENDC   ;T$$CPW                                                 ; CS013
                                                                        ; CS013
;+
; **-$BLKCK-LOGICAL BLOCK CHECK ROUTINE
; **-$BLKC1-LOGICAL BLOCK CHECK ROUTINE (ALTERNATE ENTRY)
;
; THIS ROUTINE IS CALLED BY I/O DEVICE DRIVERS TO CHECK THE STARTING
; AND ENDING LOGICAL BLOCK NUMBERS OF AN I/O TRANSFER TO A FILE
; STRUCTURED DEVICE. IF THE RANGE OF BLOCKS IS NOT LEGAL, THEN $IODON
; IS ENTERED WITH A FINAL STATUS OF "IE.BLK" AND A RETURN TO THE
; DRIVER'S INITIATOR ENTRY POINT IS EXECUTED. ELSE A RETURN TO THE
; DRIVER IS EXECUTED.
;
; INPUTS:
;
;       R1=ADDRESS OF I/O PACKET.
;       R5=ADDRESS OF THE UCB.
;
; OUTPUTS:
;
;       IF THE CHECK FAILS, THEN $IODON IS ENTERED WITH A FINAL STATUS
;       OF "IE.BLK" AND A RETURN TO THE DRIVER'S INITIATOR ENTRY POINT
;       IS EXECUTED.
;
;       IF THE CHECK SUCCEEDS, THEN THE FOLLOWING REGISTERS ARE RETURNED
;               R0=LOW PART OF LOGICAL BLOCK NUMBER.
;               R1=POINTS TO I.PRM+12 (LOW PART OF USER LBN)
;               R2=HIGH PART OF LOGICAL BLOCK NUMBER.
;               R3=ADDRESS OF I/O PACKET.
;-


.IF DF  R$$JP1!R$$K11!R$$L11!R$$M11!R$$P11!R$$JS1!R$$611!T$$C11

$BLKCK::MOV     R1,R3           ;SAVE ADDRESS OF I/O PACKET
        ADD     #I.PRM+11,R1    ;POINT PAST HIGH PART OF LBN
        CLRB    (R1)+           ;CLEAR EXCESS BYTE
$BLKC1::                        ;ALTERNATE ENTRY POINT
        MOV     (R1),R0         ;GET LOW PART OF LBN
        MOV     -(R1),R2        ;GET HIGH PART OF LBN
        MOV     I.PRM+4(R3),-(SP) ;GET NUMBER OF BYTES TO TRANSFER
        ADD     #777,(SP)       ;ROUND TO NEXT BLOCK
        ROR     (SP)            ;CALCULATE NUMBER OF BLOCKS IN HIGH BYTE
        CLRB    (SP)            ;CLEAR EXCESS BYTE
        SWAB    (SP)            ;CALCULATE NUMBER OF BLOCK IN TRANSFER
        ADD     (SP)+,R0        ;CALCULATE HIGHEST BLOCK NUMBER + 1
        ADCB    R2              ;
        BCS     20$             ;IF CS ILLEGAL BLOCK NUMBER
        CMPB    R2,U.CW2(R5)    ;HIGH PART OF LBN LEGAL?
        BHI     20$             ;IF HI NO
        BLO     10$             ;IF LO YES
        CMP     R0,U.CW3(R5)    ;LOW PART OF LBN LEGAL?
        BHI     20$             ;IF HI NO
10$:    MOV     (R1)+,R2        ;RETRIEVE HIGH PART OF LBN
        MOV     (R1),R0         ;RETRIEVE LOW PART OF LBN
        RETURN                  ;
20$:    MOV     (R5),R0         ;GET ADDRESS OF DEVICE DCB
        MOV     @D.DSP(R0),(SP) ;REPLACE RETURN ADDRESS TO INITIATOR
        MOV     #IE.BLK&377,R0  ;SET FINAL I/O STATUS

        .ENDC


;+
; **-$IOALT-I/O DONE (ALTERNATE ENTRY)
; **-$IODON-I/O DONE
;
; THIS ROUTINE IS CALLED BY DEVICE DRIVERS AT THE COMPLETION OF AN I/O REQUEST
; TO DO FINAL PROCESSING. THE UNIT AND CONTROLLER ARE SET IDLE AND $IOFIN IS
; ENTERED TO FINISH THE PROCESSING.
;
; INPUTS:
;
;       R0=FIRST I/O STATUS WORD.
;       R1=SECOND I/O STATUS WORD.
;       R2=STARTING AND FINAL ERROR RETRY COUNTS IF ERROR LOGGING
;               DEVICE.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK OF THE UNIT BEING COMPLETED.
;       (SP)=RETURN ADDRESS TO DRIVER'S CALLER.
;
;       NOTE: IF ENTRY IS AT $IOALT, THEN R1 IS CLEAR TO SIGNIFY THAT THE
;               SECOND STATUS WORD IS ZERO.
;
; OUTPUTS:
;
;       THE UNIT AND CONTROLLER ARE SET IDLE.
;
;       R3=ADDRESS OF THE CURRENT I/O PACKET.
;-

$IOALT::CLR     R1              ;ZERO SECOND I/O STATUS WORD
$IODON::MOV     U.SCB(R5),R4    ;GET ADDRESS OF STATUS CONTROL BLOCK
        BICB    #US.BSY,U.STS(R5) ;CLEAR UNIT BUSY
        CLRB    S.STS(R4)       ;CLEAR CONTROLLER BUSY


        .IF DF  E$$DVC

        BITB    #SP.EIP,S.PRI(R4) ;ERROR IN PROGRESS?
        BEQ     15$             ;IF EQ NO
        MOV     R1,-(SP)        ;SAVE SECOND I/O STATUS WORD
        MOV     S.BMSV(R4),R1   ;GET ADDRESS OF EMB
        BEQ     10$             ;IF EQ NONE
        MOV     R0,-(SP)        ;SAVE FIRST I/O STATUS WORD
        TSTB    R0              ;SUCCESSFUL FUNCTION?
        BPL     5$              ;IF PL YES
        NEG     R2              ;SIGNAL UNSUCCESSFUL FUNCTION
5$:     MOV     R2,E.RTRY+2(R1) ;SAVE FINAL ERROR RETRY COUNT
        CALL    $QEMB           ;QUEUE ERROR MESSAGE BLOCK
        MOV     (SP)+,R0        ;RESTORE I/O STATUS WORDS
10$:    MOV     (SP)+,R1        ;
15$:                            ;REF LABEL

        .ENDC


        .IF DF  M$$EXT

        BITB    #UC.NPR,U.CTL(R5) ;IS IT AN NPR DEVICE?
        BEQ     20$             ;IF EQ NO, DOES NOT USE UMR'S
        BIT     #DV.MBC,U.CW1(R5)  ;IS IT A MASSBUS DEVICE?             ; PB056
        BNE     20$             ;IF NE YES                              ; PB056
        MOV     R4,R2           ;COPY SCB POINTER                       ;**-2
        ADD     #S.MPR,R2       ;POINT TO MAPPING ASSIGNMENT BLOCK
        CALL    $DEUMR          ;DEASSIGN ANY UMR'S
        MOV     #$DQUMR,-(SP)   ;PUSH ADDRESS TO CHECK FOR UMR WAIT

        .ENDC


20$:    MOV     S.PKT(R4),R3    ;RETRIEVE ADDRESS OF I/O PACKET


        .IF DF  Q$$OPT

        TST     (R4)            ;ANY OTHER I/O REQUESTS TO INITIATE?
        BEQ     $IOFIN          ;IF EQ NO
        MOV     R3,R4           ;COPY I/O PACKET POINTER
        ADD     #I.PRM+14,R4    ;POINT TO LAST WORD FOR FORK BLOCK
        MOV     R0,(R4)         ;STORE I/O STATUS BLOCK CONTENTS
        MOV     R1,-(R4)        ;
        CALL    $FORK0          ;FORK HERE TO ALLOW NEXT I/O INITIATION
        MOV     R4,R0           ;RESTORE I/O STATUS BLOCK CONTENTS
        MOV     R5,R1           ;
        SUB     #I.PRM+10,R3    ;POINT TO BEGINNING OF FORK BLOCK

        .ENDC


;+
; **-$IOFIN-I/O FINISH
;
; THIS ROUTINE IS CALLED TO FINISH I/O PROCESSING IN CASES WHERE THE UNIT AND
; CONTROLLER ARE NOT TO BE DECLARED IDLE.
;
; INPUTS:
;
;       R0=FIRST I/O STATUS WORD.
;       R1=SECOND I/O STATUS WORD.
;       R3=ADDRESS OF THE I/O REQUEST PACKET.
;
; OUTPUTS:
;
;       THE FOLLOWING ACTIONS ARE PERFORMED
;
;       1-THE FINAL I/O STATUS VALUES ARE STORED IN THE I/O STATUS BLOCK IF
;               ONE WAS SPECIFIED.
;
;       2-THE I/O COUNT IS DECREMENTED AND TS.RDN IS CLEARED IN CASE
;               THE TASK WAS BLOCKED FOR I/O RUNDOWN.
;
;       3-IF 'TS.CKR' IS SET, THEN IT IS CLEARED AND CHECKPOINTING OF
;               THE TASK IS INITIATED.
;
;       4-IF AN AST SERVICE ROUTINE WAS SPECIFIED, THEN AN AST IS QUEUED
;               FOR THE TASK. ELSE THE I/O PACKET IS DEALLOCATED.
;
;       5-A SIGNIFICANT EVENT OR EQUIVALENT IS DECLARED.
;
;       NOTE: R4 IS DESTROYED BY THIS ROUTINE.
;-

$IOFIN::MOV     I.IOSB+4(R3),R2 ;GET ADDRESS OF I/O STATUS BLOCK
        BEQ     10$             ;IF EQ NO I/O STATUS BLOCK SPECIFIED


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;SAVE CURRENT MAPPING
        MOV     I.IOSB+2(R3),KISAR6 ;MAP TO I/O STATUS BLOCK

        .IFTF

        MOV     R0,(R2)+        ;SET FINAL I/O STATUS VALUES
        MOV     R1,(R2)         ;

        .IFT

        MOV     (SP)+,KISAR6    ;RESTORE CURRENT MAPPING

        .ENDC


10$:    MOV     I.TCB(R3),R1    ;GET ADDRESS OF TASK CONTROL BLOCK
        MOV     R1,R2           ;POINT TO FIRST TASK STATUS WORD
        ADD     #T.STAT,R2      ;
        DECB    T.IOC(R1)       ;DECREMENT I/O REQUEST COUNT
        BIC     #TS.RDN,(R2)    ;FREE TASK IF I/O RUNDOWN IS IN PROGRESS


        .IF DF  R$$LKL

        MOV     I.PRM+16(R3),R0 ;PICK UP LOCK BLOCK ADDRESS
        BEQ     20$             ;IF EQ THERE IS NONE
        CMP     R0,#140000      ;IS IT A RELOCATED USER ADDRESS?
        BHIS    20$             ;IF HIS YES
        DEC     (R0)            ;FREE LOCK FOR UNLOCKING
20$:                            ;REF LABEL

        .ENDC


        .IF DF  C$$CKP&D$$ISK

        MOV     R3,R4           ;SAVE PACKET ADDRESS
        BIT     #TS.CKR,(R2)    ;CHECKPOINT REQUESTED?
        BEQ     30$             ;IF EQ NO
        BIC     #TS.CKR,(R2)    ;CLEAR CHECKPOINT REQUEST FLAG
        CALL    $ICHKP          ;INITIATE TASK CHECKPOINTING
30$:                            ;REF LABEL


        .IF DF  D$$YNM&D$$SHF

        MOV     I.TCB(R4),R1    ;PICK UP ISSUING TASK'S TCB ADDRESS
        MOV     T.PCB(R1),R0    ;POINT TO TASK PCB
        BIT     #PS.LIO,P.STAT(R0) ;DID SHUFFLER DETECT A LONG I/O?
        BEQ     35$             ;IF EQ NO
        TSTB    T.IOC(R1)       ;IS I/O COUNT NOW ZERO?
        BNE     35$             ;IF NE NO
        BIC     #PS.LIO,P.STAT(R0) ;CLEAR LONG I/O BIT
        CALL    $NXTSK          ;REALLOCATE PARTITION
35$:                            ;REF LABEL

        .ENDC


        MOV     R4,R3           ;RESTORE PACKET ADDRESS

        .ENDC


        MOV     R5,-(SP)        ;SAVE UCB ADDRESS
        MOV     I.TCB(R3),R5    ;SET TCB ADDRESS
        MOVB    I.EFN(R3),R0    ;GET EVENT FLAG NUMBER
        CALL    $SETF           ;SET THE EVENT FLAG
        MOV     R3,R0           ;COPY I/O PACKET ADDRESS


        .IF DF  A$$TRP

        TST     (R3)+           ;POINT TO SECOND WORD
        MOV     #I.LGTH,(R3)+   ;INSERT LENGTH OF BLOCK IN BYTES
        MOV     #8.*2,(R3)+     ;SET NUMBER OF BYTES TO ALLOCATE ON USER STACK
        MOV     I.AST(R0),(R3)+ ;INSERT AST ADDRESS
        BEQ     70$             ;IF EQ NONE SPECIFIED
        MOV     #1,(R3)+        ;INSERT NUMBER OF AST PARAMETERS
        MOV     I.IOSB(R0),(R3) ;INSERT VIRTUAL ADDRESS OF I/O STATUS BLOCK
        MOV     R0,R1           ;COPY ADDRESS OF I/O PACKET
        MOV     R5,R0           ;CALCULATE ADDRESS OF AST LISTHEAD
        ADD     #T.ASTL,R0      ;
        CALL    $QINSF          ;INSERT AST IN QUEUE
        MOV     R5,R0           ;COPY TCB ADDRESS
        CALL    $SETCR          ;SET A SCHEDULE REQUEST FOR THE TASK
        BR      80$             ;

        .ENDC


70$:    CALL    $DEPKT          ;DEALLOCATE I/O PACKET
80$:    MOV     (SP)+,R5        ;RESTORE UCB ADDRESS
        RETURN                  ;

;+
; **-$IOKIL-I/O KILL
;
; THIS ROUTINE IS CALLED TO FLUSH ALL I/O REQUESTS FOR THE CURRENT TASK FROM
; A DEVICE QUEUE AND TO CANCEL THE CURRENT I/O OPERATION IN PROGRESS IF IT
; IS ALSO FOR THE CURRENT TASK.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE DEVICE TO FLUSH REQUESTS FOR.
;
; OUTPUTS:
;
;       IF THE SPECIFIED DEVICE IS NOT FILE STRUCTURED, THEN THE I/O RE-
;       REQUEST QUEUE IS FLUSHED AND THE CURRENT I/O OPERATION IN PROGRESS
;       IS CANCELLED.
;
;       NOTE: R4 IS DESTROYED BY THIS ROUTINE.
;-

$IOKIL::MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOV     $TKTCB,R1       ;GET TCB ADDRESS OF CURRENT TASK
        TST     U.CW1(R5)       ;DEVICE-UNIT MOUNTABLE?
        BPL     10$             ;IF PL NO
        BITB    #US.MNT,U.STS(R5) ;DEVICE-UNIT MOUNTED?
        BEQ     40$             ;IF EQ YES
10$:    MOV     R4,R3           ;COPY ADDRESS OF I/O QUEUE LISTHEAD
20$:    MOV     R3,R2           ;SAVE ADDRESS OF CURRENT ENTRY
        MOV     (R2),R3         ;GET ADDRESS OF NEXT ENTRY
        BEQ     40$             ;IF EQ END OF LIST
        CMP     R1,I.TCB(R3)    ;REQUEST FOR CURRENT TASK?
        BNE     20$             ;IF NE NO
        CMP     R5,I.UCB(R3)    ;REQUEST FOR SPECIFIED UCB?
        BNE     20$             ;IF NE NO
        MOV     (R3),(R2)       ;CLOSE UP LIST
        BNE     30$             ;IF NE NO NEW LAST
        MOV     R2,2(R4)        ;SET ADDRESS OF NEW LAST
30$:    MOV     #IE.ABO&377,R0  ;SET FINAL STATUS TO ABORT
        CLR     I.AST(R3)       ;MAKE SURE THERE IS NO AST DECLARED
        CALL    $IOFIN          ;FINISH I/O REQUEST
        BR      $IOKIL          ;GO AGAIN
40$:    BITB    #UC.KIL,U.CTL(R5) ;CALL DRIVER REGARDLESS OF ACTIVITY?
        BNE     45$             ;IF NE YES
        TSTB    U.STS(R5)       ;UNIT BUSY?
        BPL     50$             ;IF PL NO
45$:    MOV     S.PKT(R4),R0    ;GET ADDRESS OF CURRENT I/O PACKET
        MOV     (R5),R2         ;RETRIEVE ADDRESS OF DEVICE CONTROL BLOCK


        .IF DF  L$$DRV&M$$MGE

        MOV     KISAR5,-(SP)    ;SAVE APR5
        MOV     D.PCB(R2),R3    ;GET DRIVER PCB ADDRESS
        BEQ     47$             ;IF EQ DRIVER IS PART OF EXEC
        MOV     P.REL(R3),KISAR5  ;MAP THE DRIVER
47$:                            ;

        .ENDC                                                           ;MSH036
                                                                        ;**-1
        MOV     D.DSP(R2),R2    ;GET ADDRESS OF DRIVER DISPATCH TABLE

        .IF DF  L$$DRV                                                  ;MSH036
                                                                        ;**-1
        BEQ     49$             ;IF EQ DRIVER IS UNLOADED

        .ENDC   ;L$$DRV                                                 ;MSH036
                                                                        ;**-1
        MOVB    S.CON(R4),R3    ;GET CONTROLLER INDEX

;
; CALL DRIVER AT CANCEL I/O OPERATION ENTRY POINT WITH THE ARGUMENTS:
;
;       R0=ADDRESS OF THE CURRENT I/O PACKET.
;       R1=ADDRESS OF THE TCB OF THE CURRENT TASK.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;

        MTPS    S.PRI(R4)       ;;;LOCK OUT DEVICE INTERRUPTS
        CALL    @D.VCAN(R2)     ;;;CANCEL CURRENT REQUEST
        MTPS    #0              ;;;ALLOW DEVICE INTERRUPTS
49$:                                                                    ;MSH036
        .IF DF  L$$DRV&M$$MGE                                           ;MSH036
                                                                        ;**-2
        MOV     (SP)+,KISAR5    ;RESTORE APR5                           ;MSH036
                                                                        ;**-1
        .ENDC


50$:    RETURN                  ;

;+
; **-$MPLNE-MAP LOGICAL UNIT NUMBER FOR EXIT
; **-$MPLUN-MAP LOGICAL UNIT NUMBER
;
; THIS ROUTINE IS CALLED TO VALIDATE A LOGICAL UNIT NUMBER (LUN) AND TO MAP
; THE LUN INTO A UCB POINTER. IF AN ILLEGAL LUN IS SPECIFIED, THEN A
; DIRECTIVE STATUS OF 'D.RS96' IS RETURNED. ELSE THE LUN IS MAPPED AND A
; POINTER TO THE LUN AND UCB ARE RETURNED TO THE CALLER.
;
; INPUTS:
;
;       R3=ADDRESS OF THE LUN.
;       R4=ADDRESS OF THE HEADER OF THE CURRENT TASK.
;       R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;
; OUTPUTS:
;
;       C=1 IF NO DEVICE IS ASSIGNED TO THE SPECIFIED LUN.
;               R0=0.
;       C=0 IF A DEVICE IS ASSIGNED TO THE SPECIFIED LUN.
;               R0=ADDRESS OF THE UCB OF THE ASSIGNED DEVICE.
;
;       IN EITHER CASE R1 IS RETURNED AS THE ADDRESS OF THE SECOND LUN
;       WORD IN THE TASK HEADER AND R3 IS ADVANCED BY 2.
;-

        .ENABL  LSB
$MPLUN::CLR     R1              ;GET LOGICAL UNIT NUMBER
        BISB    (R3)+,R1        ;
        INC     R3              ;POINT TO NEXT WORD
        DEC     R1              ;BACK OFF LUN BY 1
        CMP     R1,H.NLUN(R4)   ;LEGAL LUN?
        BHIS    40$             ;IF HIS NO
$MPLNE::ASL     R1              ;MULTIPLY LUN-1 BY 4
        ASL     R1              ;
        ADD     R4,R1           ;CALCULATE ADDRESS OF FIRST LUN WORD
        ADD     #H.NLUN+2,R1    ;IN TASK HEADER
        SEC                     ;ASSUME LUN NOT ASSIGNED
        MOV     (R1)+,R0        ;GET POINTER TO DEVICE UCB
        BEQ     30$             ;IF EQ NO DEVICE ASSIGNED
$MPLND::CMP     R0,U.RED(R0)    ;IS DEVICE REDIRECTED?
        BEQ     10$             ;IF EQ NO
        MOV     U.RED(R0),R0    ;GET POINTER TO REDIRECT UCB
        BR      $MPLND          ;TRY AGAIN
10$:    MOV     (R0),R2         ;GET ADDRESS OF DEVICE DCB
        CMP     #"TI,D.NAM(R2)  ;TERMINAL INPUT PSEUDO DEVICE?
        BNE     20$             ;IF NE NO
        MOV     T.UCB(R5),R0    ;GET ADDRESS OF "TI" UCB
        BR      $MPLND          ;
20$:    CLC                     ;INDICATE DEVICE ASSIGNED
30$:    RETURN                  ;
40$:    DRSTS   D.RS96          ;SET DIRECTIVE STATUS
        .DSABL  LSB

;+
; **-$MPPHY-MAP TO PHYSICAL ADDRESS
;
; THIS ROUTINE IS CALLED TO MAP A RELOCATION BIAS AND DISPLACEMENT ADDRESS TO AN
; 18 BIT PHYSICAL ADDRESS. IF THE INDICATED DEVICE IS NOT AN NPR AN DEVICE,
; THEN THE RELOCATION BIAS AND DISPLACEMENT ADDRESS ARE RETURNED TO THE CALLER.
; ELSE THE RELOCATION BIAS AND DISPLACEMENT ADDRESS ARE CONVERTED TO AN 18 BIT
; PHYSICAL ADDRESS WHICH IS RETURNED TO THE CALLER.
;
; INPUTS:
;
;       R1=RELOCATION BIAS.
;       R2=DISPLACEMENT ADDRESS.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       IF DEVICE IS AN NPR DEVICE ON AN 18-BIT MACHINE, THEN
;               R1=HIGH ORDER 2 BITS OF PHYSICAL ADDRESS IN BITS 4 AND 5.
;               R2=LOW ORDER 16 BITS OF PHYSICAL ADDRESS.
;       IF DEVICE IS AN NPR DEVICE ON AN 11/70, THEN
;               R1=HIGH ORDER 6 BITS OF PHYSICAL ADDRESS IN HIGH BYTE.
;               R2=LOW ORDER 16 BITS OF PHYSICAL ADDRESS.
;       IF DEVICE IS NOT AN NPR DEVICE, THEN
;               R1=RELOCATION BIAS.
;               R2=DISPLACEMENT ADDRESS.
;
;       R0 AND R3 ARE PRESERVED ACROSS CALL.
;-


        .IF DF  M$$MGE

$MPPHY::BITB    #UC.NPR,U.CTL(R5) ;NPR DEVICE?
        BEQ     10$             ;IF EQ NO
        ASL     R2              ;REMOVE APR6 BIAS FROM DISPLACEMENT
        ASL     R2              ;
        CLC                     ;GET 2 BITS OF RELOCATION BIAS
        ROR     R1              ;
        RORB    R2              ;TO FILL 8 LOW ORDER BITS OF ADDRESS
        ASR     R1              ;
        RORB    R2              ;
        SWAB    R2              ;SWAP TO COLLECT 8 MORE BITS
        BISB    R1,R2           ;INSERT UPPER 8 BITS OF ADDRESS
        SWAB    R2              ;SWAP BACK TO REAL ADDRESS
        CLRB    R1              ;CLEAR LOW BYTE OF UPPER BITS


        .IF NDF M$$EXT

        ASR     R1              ;SHIFT BITS 17 AND 18 OF ADDRESS
        ASR     R1              ;INTO BITS 4 AND 5
        ASR     R1              ;
        ASR     R1              ;

        .ENDC


10$:    RETURN                  ;

        .ENDC


;+
; **-$MPPKT-MAP I/O PACKET FUNCTION
;
; THIS ROUTINE IS CALLED TO MAP A READ/WRITE VIRTUAL FUNCTION IN AN I/O PACKET
; TO A READ/WRITE LOGICAL FUNCTION. IF THE CURRENT WINDOW DOES NOT MAP THE VIRTU
; FUNCTION, THEN A FAILURE INDICATION IS RETURNED. ELSE IF THE WINDOW COMPLETELY
; MAPS THE VIRTUAL FUNCTION, THEN THE LOGICAL BLOCK NUMBER IS STORED IN THE I/O
; PACKET AND THE READ/WRITE VIRTUAL FUNCTION IS CONVERTED TO ITS LOGICAL COUNTER
; PART. ELSE THE PARTIAL MAPPING RESULTS ARE RETURNED TO THE CALLER.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O PACKET.
;
; OUTPUTS:
;
;       C=1 IF MAPPING FAILURE.
;       C=0 IF MAPPING WAS SUCCESSFUL.
;               IF R0 EQ 0, THEN
;                       I.FCN+1(R1)=IO.WLB/IO.RLB.
;                       I.PRM+10(R1)=HIGH PART OF MAPPED LBN.
;                       I.PRM+12(R1)=LOW PART OF MAPPED LBN..
;               ELSE
;                       R0=NUMBER OF BLOCKS NOT MAPPED.
;                       R2=HIGH PART OF MAPPED LBN.
;                       R3=LOW PART OF MAPPED LBN.
;
;       R1 IS PRESERVED ACROSS CALL.
;-


        .IF DF  A$$CPS

$MPPKT::MOV     I.PRM+12(R1),R3 ;PICKUP LOW PART OF VBN
        MOV     I.PRM+10(R1),R2 ;PICKUP HIGH PART OF VBN
        MOV     R1,-(SP)        ;SAVE I/O PACKET ADDRESS
        MOV     I.PRM+4(R1),R0  ;GET LENGTH OF TRANSFER IN BYTES
        MOV     @I.LN2(R1),R1   ;GET ADDRESS OF WINDOW BLOCK
        BIC     #1,R1           ;MAKE SURE LOW BIT OF ADDRESS IS ZERO
        CALL    $MPVBN          ;MAP VIRTUAL BLOCK NUMBER
        MOV     (SP)+,R1        ;RETRIEVE I/O PACKET ADDRESS
        BCS     20$             ;IF CS MAPPING FAILURE
        TST     R0              ;REQUEST COMPLETELY MAPPED?
        BNE     20$             ;IF NE NO
        MOVB    R2,I.PRM+10(R1) ;SET HIGH PART OF LBN
        MOV     R3,I.PRM+12(R1) ;SET LOW PART OF LBN
        MOV     #IO.WLB,-(SP)   ;ASSUME WRITE LOGICAL FUNCTION
        CMPB    #IO.WVB/256.,I.FCN+1(R1) ;WRITE VIRTUAL FUNCTION?
        BEQ     10$             ;IF EQ YES
        INCB    1(SP)           ;CONVERT TO READ LOGICAL FUNCTION
10$:    MOV     (SP)+,I.FCN(R1) ;SET NEW FUNCTION CODE


        .IF DF  M$$MGE

        MOV     R1,R3           ;SAVE I/O PACKET ADDRESS
        MOV     I.PRM(R3),R1    ;GET RELOCATION BIAS
        MOV     I.PRM+2(R3),R2  ;GET DISPLACEMENT ADDRESS
        CALL    $MPPHY          ;MAP TO 18 BIT PHYSICAL ADDRESS
        MOV     R1,I.PRM(R3)    ;INSERT 18 BIT PHYSICAL ADDRESS BACK
        MOV     R2,I.PRM+2(R3)  ;INTO I/O PACKET
        MOV     R3,R1           ;RESTORE I/O PACKET ADDRESS
        CLC                     ;MAKE SURE CARRY IS CLEAR

        .ENDC


20$:    RETURN                  ;
                                                                        ; CS032
        .ENDC   ;A$$CPS                                                 ; CS032
                                                                        ; CS032

;+                                                                      ;MSH012
; **-$MPUB1-MAP UNIBUS TO MEMORY (ALTERNATE ENTRY)                      ;MSH012
;                                                                       ;MSH012
; THIS ROUTINE IS CALLED BY UNIBUS NPR DEVICE DRIVERS TO LOAD THE       ;MSH012
; NECESSARY UNIBUS MAP REGISTERS TO EFFECT A TRANSFER TO MAIN           ;MSH012
; MEMORY ON AN 11/70 PROCESSOR WITH EXTENDED MEMORY. THIS ALTERNATE     ;MSH012
; ENTRY POINT ALLOWS THE DRIVER TO SPECIFY A NON-STANDARD UMR MAPPING   ;MSH012
; ASSIGNMENT BLOCK.                                                     ;MSH012
;                                                                       ;MSH012
; INPUTS:                                                               ;MSH012
;                                                                       ;MSH012
;       R0=ADDRESS OF A UMR MAPPING ASSIGNMENT BLOCK                    ;MSH012
;                                                                       ;MSH012
; OUTPUTS:                                                              ;MSH012
;                                                                       ;MSH012
;       THE UNIBUS MAP REGISTERS NECESSARY TO EFFECT THE                ;MSH012
;       TRANSFER ARE LOADED                                             ;MSH012
;                                                                       ;MSH012
; NOTE: REGISTER R3 IS PRESERVED ACROSS CALL.                           ;MSH012
;-                                                                      ;MSH012
                                                                        ;MSH012
                                                                        ;MSH012
        .IF DF M$$EXT&M$$MGE                                            ;MSH012
                                                                        ;MSH012
$MPUB1::MOV     M.UMRN(R0),-(SP) ;SET COUNT OF REGISTERS TO LOAD        ;MSH012
        MOVB    M.BFVH(R0),R1   ;GET HIGH 6 BITS OF ADDRESS             ;MSH012
        MOV     M.BFVL(R0),R2   ;GET LOW 16 BITS OF ADDRESS             ;MSH012
        MOV     M.UMRA(R0),R0   ;GET ADDRESS OF FIRST MAP REGISTER      ;MSH012
        BR      $MPUB2          ;GO LOAD THE UMR'S                      ;MSH012
                                                                        ;MSH012
        .ENDC                                                           ;MSH012
                                                                        ;MSH012
                                                                        ;MSH012
                                                                        ;MSH012
;+
; **-$MPUBM-MAP UNIBUS TO MEMORY
;
; THIS ROUTINE IS CALLED BY UNIBUS NPR DEVICE DRIVERS TO LOAD THE
; NECESSARY UNIBUS MAP REGISTERS TO EFFECT A TRANSFER TO MAIN MEM-
; ORY ON AN 11/70 PROCESSOR WITH EXTENDED MEMORY.
;
; INPUTS:
;
;       R4=ADDRESS OF DEVICE SCB.
;       R5=ADDRESS OF DEVICE UCB.
;
; OUTPUTS:
;
;       THE UNIBUS MAP REGISTERS NECESSARY TO EFFECT THE  TRANSFER
;       ARE LOADED.
;
; NOTE: REGISTER R3 IS PRESERVED ACROSS CALL.
;-


        .IF DF  M$$EXT&M$$MGE

$MPUBM::MOV     S.MPR+M.UMRA(R4),R0 ;GET ADDRESS OF FIRST MAP REGISTER
        MOV     S.MPR+M.UMRN(R4),-(SP) ;SET COUNT OF REGISTERS TO LOAD
        MOVB    S.MPR+M.BFVH(R4),R1 ;GET HIGH 6 BITS OF ADDRESS
        MOV     S.MPR+M.BFVL(R4),R2 ;GET LOW 16 BITS OF ADDRESS
$MPUB2: MOV     R2,(R0)+        ;LOAD LOW 16 BITS OF ADDRESS            ;MSH012
        MOV     R1,(R0)+        ;LOAD HIGH 6 BITS OF ADDRESS            ;**-1
        ADD     #20000,R2       ;ADVANCE 8K BYTES
        ADC     R1              ;
        SUB     #4,(SP)         ;ALL REGISTERS LOADED?
        BGT     $MPUB2          ;IF GT NO                               ;MSH012
        TST     (SP)+           ;CLEAN STACK                            ;**-1
        RETURN

        .ENDC

                                                                        ; CS032
        .IF DF A$$CPS                                                   ; CS032
                                                                        ; CS032

;+
; **-$MPVBN-MAP VIRTUAL BLOCK NUMBER
;
; THIS ROUTINE IS CALLED TO MAP A VIRTUAL BLOCK NUMBER (VBN) TO A LOGICAL BLOCK
; NUMBER (LBN) VIA A WINDOW BLOCK THAT CONTAINS A SET OF MAPPING POINTERS.
;
; INPUTS:
;
;       R0=NUMBER OF CONSECUTIVE BYTES THAT MUST BE MAPPED.
;       R1=ADDRESS OF THE WINDOW BLOCK.
;       R2=HIGH PART OF VBN.
;       R3=LOW PART OF VBN.
;
; OUTPUTS:
;
;       C=1 IF VBN CANNOT BE MAPPED VIA WINDOW BLOCK.
;       C=0 IF VBN SUCCESSFULLY MAPPED TO LBN.
;               PARTIAL MAPPING IS A SUCCESS                            ; BO016
;               R0=NUMBER OF UNMAPPED BLOCKS.
;               R2=HIGH PART OF LBN.
;               R3=LOW PART OF LBN.
;-

$MPVBN::SAVNR                   ;SAVE NONVOLATILE REGISTERS
        MOVB    (R1),R5         ;GET THE NUMBER OF ACTIVE PTRS          ; BO016
        BEQ     20$             ;IF EQ NO MAP POSSIBLE                  ;**-1
        ADD     #777,R0         ;ROUND BYTES TO NEXT 256. WORD BLOCK
        ROR     R0              ;CONVERT TO WORDS
        CLRB    R0              ;CLEAR RESIDUAL BITS
        SWAB    R0              ;SWAP NUMBER OF BLOCKS TO LOW BYTE
        MOVB    W.VBN(R1),R4    ;GET 7 BITS OF HI VBN                   ; BO016
        SUB     R4,R2           ;NORMALIZE HIGH PART OF VBN             ;**-4
        SUB     W.VBN+2(R1),R3  ;NORMALIZE LOW VBN                      ; BO016
        SBC     R2              ;                                       ;**-2
        BLO     20$             ;BRANCH ON MAPPING FAILURE              ; BO016
        ADD     #W.RTRV,R1      ;POINT R1 TO WINDOW MAPPING POINTERS    ; BO016
10$:    SUB     (R1)+,R3        ;SUBTRACT EXTENT SIZE FROM VBN          ; BO016
        SBC     R2              ; ALSO HIGH VBN                         ; BO016
        BLO     30$             ;BRANCH IF VBN IS IN THIS EXTENT        ; BO016
        CMP     (R1)+,(R1)+     ;SKIP OVER THE LBN                      ; BO016
        DEC     R5              ;DECREMENT ACTIVE POINTER COUNT         ; BO016
        BGT     10$             ;IF GT YES                              ;**-12
20$:    SEC                     ;INDICATE MAPPING FAILURE
        BR      70$             ;
;                                                                       ; BO016
30$:    ADD     R3,R0           ;TEST FOR ALL BLOCKS IN EXTENT          ; BO016
        BGT     40$             ;BRANCH IF NOT - ONLY PARTIAL MAP       ; BO016
        CLR     R0              ;ZERO R0 FOR FULL MAPPING               ; BO016
40$:    ADD     -2(R1),R3       ;R3=OFFSET WITHIN EXTENT                ; BO016
        ADC     R2              ;R2=HIGH OFFSET (=0)                    ; BO016
        ADD     (R1)+,R2        ;ADD THE EXTENTS BEGINNING              ; BO016
        ADD     (R1)+,R3        ; LBN TO THE OFFSET                     ; BO016
        ADC     R2              ;  TO GET DESIRED LBN                   ; BO016
; NOTE: AT THIS POINT THE CARRY IS CLEAR                                ; BO016
70$:                            ;                                       ; BO016
        RETURN                  ;                                       ;**-22

        .ENDC


;+
; **-$LCKPR-LOCK PROCESSING ROUTINE
;
; THIS ROUTINE FIRST DETERMINES IF A FILE I/O REQUEST IS TO A SHARED
; FILE.  IF SO, IT DETERMINES IF THE REQUEST IS AN UNLOCK QIO OR A
; VIRTUAL BLOCK I/O REQUEST.  IT THEN EITHER PERFORMS THE UNLOCK QIO
; OR THE LOCK PROCESSING RESPECTIVELY.
;
; INPUTS:
;
;       R1=I/O PACKET ADDRESS OF THE REQUEST
;
; OUTPUTS:
;
;       C=0 IF NO LOCK PROCESSING WAS REQUIRED.
;
;       C=1 IF AN UNLOCK WAS PERFORMED OR AN ERROR CONDITION OCCURED
;               DURING THE LOCK PROCESSING.
;               R0=I/O STATUS
;
;       R1 IS PRESERVED.
;-


        .IF DF  R$$LKL

$LCKPR::MOV     @I.LN2(R1),R3   ;POINT TO WINDOW BLOCK
        BIC     #1,R3           ;CLEAR INTERLOCK BIT
        MOV     #IE.ULK&377,R0  ;SET FOR UNLOCK ERROR STATUS
        MOV     W.LKL(R3),R2    ;POINT TO FIRST ENTRY IN LOCK LIST
        BEQ     50$             ;IF EQ THERE IS NONE
        SAVNR                   ;SAVE R4 AND R5
        MOV     I.PRM+4(R1),R4  ;PICK UP BYTE COUNT FOR REQUEST
        ADD     #777,R4         ;ROUND TO NEXT DISK BLOCK
        ROR     R4              ;CONVERT TO SIZE IN BLOCKS
        CLRB    R4              ;
        SWAB    R4              ;
        CMPB    I.FCN+1(R1),#IO.ULK/256. ;IS THIS AN UNLOCK REQUEST?
        BNE     100$            ;IF NE NO

;
; UNLOCK PROCESSING
;
; THIS SECTION OF THE ROUTINE PERFORMS THE UNLOCK PROCESSING.  RELEVANT
; REGISTER CONTENTS AT THIS POINT ARE:
;
;       R0=UNLOCK ERROR STATUS
;       R1=I/O PACKET ADDRESS
;       R2=ADDRESS OF THE FIRST LOCK BLOCK IN THE LOCK LIST
;       R3=POINTER TO CURRENT WINDOW
;       R4=BYTE COUNT OF CURRENT UNLOCK REQUEST
;

        MOV     I.PRM+12(R1),R5 ;CREATE BLOCK NUMBER SPECIFIED FLAG
        BISB    I.PRM+10(R1),R5 ;
10$:    TSTB    L.CNT(R2)       ;THIS LOCK BLOCK IN USE?
        BEQ     40$             ;IF EQ NO
        TST     R5              ;BLOCK NUMBER SPECIFIED?
        BEQ     20$             ;IF EQ NO
        CALL    180$            ;EXACT VBN AND COUNT MATCH?
        BNE     40$             ;IF NE NO
20$:    CMP     L.WI1(R2),R3    ;SAME OWNER?
        BNE     40$             ;IF NE NO
        CLRB    L.CNT(R2)       ;UNLOCK THE LOCK
        MOV     #IS.SUC&377,R0  ;SET FOR SUCCESSFUL RETURN
        TST     R5              ;WAS THIS FOR AN EXPLICIT BLOCK NUMBER?
        BNE     50$             ;IF NE YES
40$:    MOV     (R2),R2         ;POINT TO NEXT LOCK BLOCK
        BNE     10$             ;IF NE THERE IS ONE

;
; NO LOCK LIST EXISTS
;
; IF THE FUNCTION IS NOT AN UNLOCK FUNCTION, A SIMPLE RETURN OCCURS
; WITH CARRY CLEAR.  AN UNLOCK IN THIS CASE IS AN ERROR.  (NOTE THAT
; ALL UNLOCK REQUESTS FALL THROUGH HERE AS WELL.)
;

50$:    CMPB    I.FCN+1(R1),#<IO.ULK/256.>+1 ;SET CARRY IF UNLOCK
        RETURN                  ;

;
; LOCK PROCESSING
;
; THIS ROUTINE CHECKS FOR ATTEMPTED LOCK OVERLAPS, ATTEMPTS TO SET THE
; NEW LOCK, AND PERFORMS THE IMPLIED UNLOCK.  IF A NEW LOCK REQUEST
; FOR AN EXPLICIT UNLOCKER IS DETECTED WHICH EXACTLY MATCHES AN EXISTING
; LOCK FOR THAT WINDOW IN BOTH STARTING VBN AND SIZE, THE LOCK BLOCK IS
; SIMPLY REUSED.  RELEVANT REGISTER CONTENTS AT THIS POINT ARE:
;
;       R1=I/O PACKET ADDRESS
;       R2=ADDRESS OF FIRST LOCK BLOCK IN LOCK LIST
;       R3=ADDRESS OF FILE WINDOW
;       R4=BLOCK COUNT FOR CURRENT REQUEST
;

100$:   CLR     R5              ;INIT FREE NODE POINTER
        MOV     #IE.LCK&377,-(SP) ;PUSH LOCK ERROR STATUS
110$:   TSTB    L.CNT(R2)       ;IS LOCK BLOCK IN USE?
        BNE     120$            ;IF NE YES
        TST     R5              ;ALREADY HAVE FREE BLOCK?
        BNE     150$            ;IF NE YES, LOOK AT NEXT LOCK BLOCK
        BR      130$            ;ELSE CLAIM THIS BLOCK
120$:   MOV     L.WI1(R2),R0    ;PICK UP OWNER WORD
        BIC     #1,R0           ;CLEAR BIT FOR NO UNLOCK FLAG
        CMP     R0,R3           ;LOCK BELONG TO THIS WINDOW?
        BNE     140$            ;IF NE NO, CHECK FOR OVERLAPS
        BIT     #WI.EXL,(R3)    ;EXPLICIT UNLOCKER?
        BEQ     125$            ;IF EQ NO, SAVE BLOCK FOR IMPLIED UNLOCK
        CALL    180$            ;EXACT VBN AND COUNT?
        BNE     150$            ;IF NE NO
125$:   MOV     L.WI1(R2),R0    ;RETRIEVE OWNER WORD
        ROR     R0              ;CAN LOCK BLOCK BE REUSED?
        BCS     170$            ;IF CS NO
130$:   MOV     R2,R5           ;SET TO REUSE THIS LOCK BLOCK
        BR      150$            ;LOOK AT NEXT LOCK BLOCK
140$:   CLR     R0              ;PICK UP LOCK BLOCK COUNT
        BISB    L.CNT(R2),R0    ;
        ADD     L.VB1+2(R2),R0  ;CALCULATE NUMBER OF HIGHEST BLOCK +1
        MOVB    L.VB1(R2),-(SP) ;PUSH HIGH ORDER BYTE
        ADCB    (SP)            ;PROPAGATE CARRY
        CMPB    I.PRM+10(R1),(SP)+ ;OVERLAP?
        BNE     145$            ;IF NE USE BRANCH BELOW
        CMP     I.PRM+12(R1),R0 ;OVERLAP?
145$:   BHIS    150$            ;IF HIS NO
        MOV     R4,R0           ;COPY SIZE OF CURRENT REQUEST
        ADD     I.PRM+12(R1),R0 ;CALCULATE NUMBER OF HIGHEST BLOCK +1
        MOVB    I.PRM+10(R1),-(SP) ;PUSH HIGH ORDER BYTE
        ADCB    (SP)            ;PROPAGATE CARRY
        CMPB    L.VB1(R2),(SP)+ ;OVERLAP?
        BNE     146$            ;IF NE USE BRANCH BELOW
        CMP     L.VB1+2(R2),R0  ;OVERLAP?
146$:   BLO     170$            ;IF LO YES
150$:   MOV     (R2),R2         ;POINT TO NEXT LOCK BLOCK
        BNE     110$            ;IF NE THERE IS ONE
        CLC                     ;ASSUME SUCCESS ON READ VALIDATION
        BIT     #WI.WRV,(R3)    ;IS THIS A WRITER?
        BEQ     170$            ;IF EQ NO, SUCCESSFUL VALIDATION
        MOV     R5,R0           ;COPY POINTER TO SAVED LOCK BLOCK
        BNE     160$            ;IF NE ONE WAS IN FACT SAVED
        MOV     #IE.NOD&377,(SP) ;SET FOR ALLOCATION FAILURE STATUS
        MOV     R1,-(SP)        ;SAVE I/O PACKET ADDRESS
        MOV     #L.LGTH,R1      ;PICK UP SIZE OF LOCK BLOCK
        CALL    $ALOCB          ;ALLOCATE LOCK BLOCK
        MOV     (SP)+,R1        ;RESTORE I/O PACKET ADDRESS
        BCS     170$            ;IF CS ALLOCATION FAILURE
        MOV     @W.LKL(R3),(R0) ;POINT NEW BLOCK TO SECOND ONE IN LIST
        MOV     R0,@W.LKL(R3)   ;POINT FIRST BLOCK IN LIST TO NEW ONE
160$:   TST     (R0)+           ;ADVANCE TO OWNER WORD
        MOV     R0,I.PRM+16(R1) ;SAVE POINTER TO OWNER WORD
        MOV     R3,(R0)         ;SET OWNER WORD
        INC     (R0)+           ;SET NO UNLOCK FLAG
        MOVB    I.PRM+10(R1),(R0)+ ;SET HIGH PART OF VBN
        MOVB    R4,(R0)+        ;SET BLOCK COUNT
        MOV     I.PRM+12(R1),(R0) ;SET LOW PART OF VBN
170$:   MOV     (SP)+,R0        ;PICK UP ERROR STATUS
        RETURN                  ;

;
; ROUTINE TO CHECK FOR EXACT VBN AND BLOCK COUNT MATCH
;
; INPUTS:
;
;       R1=I/O PACKET ADDRESS
;       R2=LOCK BLOCK ADDRESS
;       R4=BYTE COUNT
;
; OUTPUTS:
;
;       ALL REGISTERS PRESERVED.
;
;       Z=1 IF EXACT MATCH.
;
;       Z=0 IT NO MATCH.
;

180$:   CMP     L.VB1+2(R2),I.PRM+12(R1) ;MATCH ON LOW ORDER?
        BNE     190$            ;IF NE NO
        CMPB    L.VB1(R2),I.PRM+10(R1) ;MATCH ON HIGH ORDER?
        BNE     190$            ;IF NE NO
        TST     R4              ;COUNT SPECIFIED?
        BEQ     190$            ;IF EQ NO
        CMPB    L.CNT(R2),R4    ;MATCH ON COUNT?
190$:   RETURN                  ;

        .ENDC


;+
; **-$RELOC-RELOCATE USER VIRTUAL ADDRESS
;
; THIS ROUTINE IS CALLED TO TRANSFORM A 16 BIT USER VIRTUAL ADDRESS
; INTO A RELOCATION BIAS AND DISPLACEMENT IN BLOCK RELATIVE TO APR6.
;
; INPUTS:
;
;       R0=USER VIRTUAL ADDRESS TO RELOCATE.
;
; OUTPUTS:
;
;       R1=RELOCATION BIAS TO BE LOADED INTO PAR6.
;       R2=DISPLACEMENT IN BLOCK PLUS 140000 (PAR6 BIAS).
;
;       R0 AND R3 ARE PRESERVED ACROSS CALL.
;-

$RELOC::                        ;REF LABEL


        .IF NDF M$$MGE

        MOV     R0,R2           ;COPY PHYSICAL ADDRESS
        CLR     R1              ;CLEAR RELOCATION BIAS

        .IFF

        MOV     R0,R1           ;COPY VIRTUAL ADDRESS
        CLR     R2              ;ZERO APR NUMBER ACCUMULATOR
        ASL     R1              ;COLLECT APR NUMBER
        ROL     R2              ;
        ASL     R1              ;
        ROL     R2              ;
        ASL     R1              ;
        ROL     R2              ;
        ASL     R2              ;CONVERT TO APR INDEX
        CLRB    R1              ;CLEAR EXTRANEOUS BITS
        SWAB    R1              ;COLLECT BLOCK NUMBER IN LOW BYTE
        ROR     R1              ;
        ADD     UISAR0(R2),R1   ;CALCULATE RELOCATION BIAS
        MOV     R0,R2           ;COPY VIRTUAL ADDRESS
        BIC     #177700,R2      ;CLEAR ALL BUT DISPLACEMENT IN BLOCK
        BIS     #140000,R2      ;SET APR 6 BIAS

        .ENDC


        RETURN                  ;

;+
; **-$RELOM-RELOCATE AND MAP ADDRESS
;
; THIS ROUTINE IS CALLED TO TRANSFORM A 16 BIT USER VIRTUAL ADDRESS
; INTO A RELOCATION BIAS AND DISPLACEMENT IN BLOCK RELATIVE TO APR6
; AND LOAD THESE VALUES FOR ACCESS BY THE CALLER.
;
; INPUTS:
;
;       R0=USER VIRTUAL ADDRESS TO RELOCATE.
;
; OUTPUTS:
;
;       R0=DISPLACEMENT IN BLOCK.
;       KISAR6 IS LOADED WITH THE RELOCATION BIAS.
;
;       R3 IS PRESERVED ACROSS CALL.
;-


        .IF DF  M$$MGE

$RELOM::CALL    $RELOC          ;RELOCATE USER VIRTUAL ADDRESS
        MOV     R1,KISAR6       ;SET KERNEL MAPPING REGISTER
        MOV     R2,R0           ;SET DISPLACEMENT IN BLOCK ADDRESS
        RETURN                  ;

        .ENDC


;+
; **-$RLCH-RELEASE CHANNEL
;
; THIS ROUTINE IS CALLED TO RELEASE A CHANNEL. THE CHANNEL STATUS IS SET TO
; IDLE AND AN ATTEMPT IS MADE TO DEQUEUE THE NEXT DRIVER WAITING TO USE THE
; CHANNEL. IF NO DRIVER IS WAITING, THEN A RETURN TO THE CALLER IS EXECUTED.
; ELSE THE DRIVER IS DEQUEUED, THE CHANNEL STATUS IS SET TO BUSY, THE DRIVER
; IS CALLED, AND THEN A RETURN TO THE CALLER IS EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       THE CHANNEL STATUS IS SET TO IDLE AND AN ATTEMPT IS MADE TO DEQUEUE
;       THE NEXT DRIVER WAITING TO USE THE CHANNEL.
;
;       R0, R1, AND R2 ARE PRESERVED ACROSS CALL.
;
;       NOTE: R4 IS DESTROYED BY THIS ROUTINE.
;-


        .IF DF M$$IXD

        .ENABL  LSB
$RLCH:: MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOV     S.CCB(R4),R4    ;GET ADDRESS OF CHANNEL CONTROL BLOCK
        CLR     4(R4)           ;SET CHANNEL IDLE
        TST     (R4)            ;ANY DRIVER IN WAIT QUEUE?
        BEQ     10$             ;IF EQ NO
        MOV     R0,-(SP)        ;SAVE R0, R1, R2, AND R5
        MOV     R1,-(SP)        ;
        MOV     R2,-(SP)        ;
        MOV     R5,-(SP)        ;


        .IF DF  L$$DRV&M$$MGE

        MOV     KISAR5,-(SP)    ;SAVE APR5

        .IFTF

        MOV     R4,R0           ;SET ADDRESS OF WAIT QUEUE LISTHEAD
        CALL    $QRMVF          ;REMOVE DRIVER FROM QUEUE
        ADD     #10,R1          ;POINT PAST SAVED R1

        .IFT

        MOV     (R1),KISAR5     ;MAP THE DRIVER

        .IFTF

        MOV     -(R1),R4        ;RETRIEVE ADDRESS OF SCB
        MOV     -(R1),R5        ;RETRIEVE ADDRESS OF UCB
        CALL    20$             ;SET CHANNEL BUSY
        CALL    @-(R1)          ;CALL DRIVER

        .IFT

        MOV     (SP)+,KISAR5    ;RESTORE APR5

        .ENDC


        MOV     (SP)+,R5        ;RESTORE R5, R2, R1, AND R0
        MOV     (SP)+,R2        ;
        MOV     (SP)+,R1        ;
        MOV     (SP)+,R0        ;
10$:    RETURN                  ;

;+
; **-$RQCH-REQUEST CHANNEL
;
; THIS ROUTINE IS CALLED TO REQUEST EXCLUSIVE USE OF A CHANNEL. IF THE
; CHANNEL IS CURRENTLY BUSY, THEN THE CALLING DRIVER IS THREADED INTO THE
; CHANNEL WAIT QUEUE AND A RETURN TO THE CALLER OF THE DRIVER IS EXECUTED.
; ELSE THE CHANNEL STATUS IS SET TO BUSY AND A RETURN TO THE CALLING DRIVER
; IS EXECUTED.
;
; INPUTS:
;
;       R4=ADDRESS OF STATUS CONTROL BLOCK.
;       R5=ADDRESS OF UNIT CONTROL BLOCK.
;       (SP)=RETURN ADDRESS OF CALLER.
;       2(SP)=RETURN ADDRESS OF CALLER OF CALLER.
;
; OUTPUTS:
;
;       IF THE CHANNEL IS IDLE, THEN IT IS SET BUSY AND A RETURN TO THE
;       CALLER IS EXECUTED. ELSE THE CALLER IS THREADED INTO THE CHANNEL
;       WAIT QUEUE AND A RETURN TO THE CALLER'S CALLER IS EXECUTED.
;-

$RQCH:: MOV     S.CCB(R4),R0    ;GET ADDRESS OF CHANNEL CONTROL BLOCK
        TST     4(R0)           ;CHANNEL BUSY?
        BEQ     20$             ;IF EQ NO
        MOV     R4,R1           ;CALCULATE ADDRESS OF LAST WORD IN FORK BLOCK
        ADD     #S.FRK+6,R1     ;
        MOV     R4,(R1)         ;SAVE ADDRESS OF SCB
        MOV     R5,-(R1)        ;SAVE ADDRESS OF UCB
        MOV     (SP)+,-(R1)     ;SAVE DRIVER RETURN ADDRESS
        TST     -(R1)           ;POINT TO START OF BLOCK
        CALLR   $QINSF          ;INSERT BLOCK IN CHANNEL WAIT QUEUE
20$:    MOV     R5,4(R0)        ;SET CHANNEL BUSY
        CLR     R0              ;PICKUP VECTOR ADDRESS
        BISB    S.VCT(R4),R0    ;
        ASL     R0              ;CALCULATE ACTUAL VECTOR ADDRESS
        ASL     R0              ;
        MOV     S.CCB+2(R4),(R0)+ ;INSERT INTERRUPT ROUTINE ADDRESS
        MOV     S.CCB+4(R4),(R0) ;INSERT INTERRUPT PS WORD
        RETURN                  ;
        .DSABL  LSB

        .ENDC


;+
; **-$SCDVT-SCAN DEVICE TABLES
; **-$SCDV1-SCAN DEVICE TABLES (ALTERNATE ENTRY)
;
; THIS ROUTINE IS A CO-ROUTINE THAT IS CALLED TO SCAN THE DEVICE TABLES. FOR EAC
; UNIT CONTROL BLOCK THE CALLER IS RECALLED.
;
; INPUTS:
;
;       R3=LIST POINTER (IF ENTRY AT $SCDV1)
;
; OUTPUTS:
;
;       C=1 IF NO MORE ENTRIES EXIST IN THE DEVICE TABLES.
;       C=0 IF THE NEXT DEVICE TABLE ENTRY IS BEING RETURNED.
;               R3=ADDRESS OF THE DEVICE CONTROL BLOCK.
;               R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;               R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;-

S$$SPA==10                      ;SYMBOL TO ADD TO SP TO ABORT SCAN      ; CS013
S$$SPC==6                       ;OFFSET ON SP TO SET TO 1 TO SKIP CURREN; CS013
                                                                        ; CS013
$SCDVT::MOV     #$DEVHD,R3      ;GET ADDRESS OF FIRST DCB ADDRESS
$SCDV1::MOV     (SP)+,R4        ;REMOVE RETURN ADDRESS FROM STACK
10$:    MOV     (R3),R3         ;GET ADDRESS OF NEXT DCB
        BEQ     30$             ;IF EQ NO MORE
        MOV     D.UCB(R3),R5    ;POINT TO FIRST UCB
        BIT     #DV.PSE,U.CW1(R5) ;PSEUDO DEVICE?
        BNE     10$             ;IF NE YES
        MOVB    D.UNIT+1(R3),-(SP) ;CALCULATE NUMBER OF UCB'S TO SCAN
        SUB     D.UNIT(R3),(SP) ;
        INCB    (SP)            ;
20$:    MOV     R3,-(SP)        ;SAVE DCB ADDRESS
        MOV     R5,-(SP)        ;SAVE UCB ADDRESS
        MOV     R4,-(SP)        ;SET RETURN ADDRESS
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF STATUS CONTROL BLOCK
        CLC                     ;INDICATE ENTRY
        CALL    @(SP)+          ;CALL THE CALLER
        MOV     (SP)+,R4        ;REMOVE RETURN ADDRESS
        MOV     (SP)+,R5        ;RESTORE UCB ADDRESS
        MOV     (SP)+,R3        ;RESTORE DCB ADDRESS
        ADD     D.UCBL(R3),R5   ;POINT TO NEXT UCB
        DECB    (SP)            ;ANY MORE UCB'S TO SCAN?
        BNE     20$             ;IF NE YES
        TST     (SP)+           ;CLEAN STACK
        BR      10$             ;GO AGAIN
30$:    SEC                     ;INDICATE NO ENTRY
        JMP     (R4)            ;RETURN TO CALLER

;+
; **-$ASUMR-ASSIGN UNIBUS MAPPING REGISTERS
;
; THIS ROUTINE IS CALLED TO ASSIGN A CONTIGUOUS SET OF UMR'S.  NOTE THAT
; FOR THE SAKE OF SPEED, THE LINK WORD OF EACH MAPPING ASSIGNMENT BLOCK
; POINTS TO THE UMR ADDRESS (2ND) WORD OF THE BLOCK, NOT THE FIRST WORD.
; THE CURRENT STATE OF UMR ASSIGNMENT IS REPRESENTED BY A LINKED LIST OF
; MAPPING ASSIGNMENT BLOCKS, EACH BLOCK CONTAINING THE ADDRESS OF THE
; FIRST UMR ASSIGNED AND THE NUMBER OF UMR'S ASSIGNED TIMES 4.  THE
; BLOCKS ARE LINKED IN THE ORDER OF INCREASING FIRST UMR ADDRESS.
;
; INPUTS:
;
;       R0=POINTER TO A MAPPING REGISTER ASSIGNMENT BLOCK.
;       M.UMRN(R0)=NUMBER OF UMR'S REQUIRED * 4.
;
; OUTPUTS:
;
;       ALL REGISTERS ARE PRESERVED.
;
;       C=0 IF THE UMR'S WERE SUCCESSFULLY ASSIGNED.
;               ALL FIELDS OF THE MAPPING REGISTER ASSIGNMENT BLOCK
;                       ARE INITIALIZED AND THE BLOCK IS LINKED INTO
;                       THE ASSIGNMENT LIST.
;       C=1 IF THE UMR'S COULD NOT BE ASSIGNED.
;-


        .IF DF  M$$EXT

$ASUMR::SAVNR                   ;SAVE R4 AND R5
        TST     (R0)+           ;SKIP OVER LINK WORD (M.LNK)
        MOV     #$UMRHD+2,R5    ;POINT TO UMR ASSIGNMENT LISTHEAD + 2
10$:    MOV     R5,R4           ;SAVE POINTER TO PREVIOUS
        BEQ     30$             ;IF EQ ASSIGNMENT FAILURE
        MOV     (R5),(R0)       ;POINT TO NEXT FREE UMR (M.UMRA)(M.UMRA)
        ADD     M.UMRN-M.UMRA(R5),(R0) ;(M.UMRA)
        MOV     #UBMPR+<31.*4>,-(SP) ;PUSH POINTER PAST LAST UMR
        MOV     -(R5),R5        ;POINT TO NEXT ASSIGNMENT BLOCK (M.LNK)
        BEQ     20$             ;IF EQ THERE IS NONE
        MOV     (R5),(SP)       ;SET NEXT ALLOCATED UMR ADDRESS (M.UMRA)
20$:    SUB     (R0),(SP)       ;CALCULATE # OF FREE UMR'S * 4 (M.UMRA)
        CMP     (SP)+,M.UMRN-M.UMRA(R0) ;ENOUGH UMR'S AVAILABLE?
        BLO     10$             ;IF LO NO
        MOV     R0,-(R4)        ;LINK NEW BLOCK TO PREVIOUS (M.LNK)
        MOV     (R0),R4         ;SAVE FIRST UMR ADDRESS (M.UMRA)
        MOV     R5,-2(R0)       ;POINT NEW BLOCK TO NEXT IN LIST (M.LNK)
        MOV     R4,R5           ;DUPLICATE FIRST UMR ADDRESS
        BICB    #UBMPR!34,R5    ;MASK OUT ALL BUT HI 2 BITS IN LOW BYTE
        BIC     R5,R4           ;CLEAR OUT HIGH BYTE AND HIGH 2 BITS
        ASR     R5              ;SHIFT HIGH 2 BITS TO BITS 4 & 5
        ASLB    R4              ;CALCULATE HIGH BYTE OF LOW 16 BITS
        ASL     R4              ;   (LOSING BIT 200 FIRST)
        ASL     R4              ;
        SWAB    R4              ;FORM LOW SIXTEEN BITS OF ADDRESS
        MOV     M.BFVL-2(R0),M.UMVL-2(R0) ; GET ORIGINAL BUFFER ADDRESS ; BM004
        BIC     #^C<1>,M.UMVL-2(R0) ; WAS IT ODD ?                      ; BM004
        ADD     R4,M.UMVL-2(R0) ; IF IT WAS, THEN M.UMVL SHOULD BE      ; BM004
        MOVB    R5,M.UMVH-2(R0) ;SET BITS 4 & 5                         ;**-1
30$:    DEC     R0              ;PNT BACK TO LINK WORD PRESERVING CARRY
        DEC     R0              ;
        RETURN                  ;

;+
; **-$DEUMR-DEASSIGN UNIBUS MAPPING REGISTERS
;
; THIS ROUTINE IS CALLED TO DEASSIGN A CONTIGUOUS BLOCK OF UMR'S. IF
; THE MAPPING ASSIGNMENT BLOCK IS NOT IN THE LIST, NO ACTION IS TAKEN.
; NOTE THAT FOR THE SAKE OF ASSIGNMENT SPEED, THE LINK WORD POINTS TO
; THE UMR ADDRESS (2ND) WORD OF THE ASSIGNMENT BLOCK.
;
; INPUTS:
;
;       R2=POINTER TO ASSIGNMENT BLOCK.
;
; OUTPUTS:
;
;       R0 AND R1 ARE PRESERVED.
;-

$DEUMR::TST     (R2)+           ;SKIP OVER LINK WORD (M.LNK)
        MOV     #$UMRHD+2,R3    ;POINT TO ASSIGNMENT LISTHEAD + 2
10$:    CMP     -(R3),R2        ;IS IT THE NEXT ONE? (M.LNK)
        BEQ     20$             ;IF EQ YES
        MOV     (R3),R3         ;ELSE POINT TO NEXT IN LIST (M.LNK)
        BNE     10$             ;IF NE THERE IS ONE
        BR      30$             ;ELSE MAPPING ASSIGNMENT BLK NOT IN LIST
20$:    MOV     -(R2),(R3)      ;UNLINK THE BLOCK (M.LNK)(M.LNK)
30$:    RETURN                  ;

;+                                                                      ;MSH012
; **-$STMP1-SET UP UNIBUS MAPPING ADDRESS (ALTERNATE ENTRY)             ;MSH012
;                                                                       ;MSH012
; THIS ENTRY CODE SETS UP AN ALTERNATE DATA STRUCTURE USED AS           ;MSH012
; A UMR MAPPING ASSIGNMENT BLOCK AND CONTEXT STORAGE BLOCK, IN          ;MSH012
; THE SAME MANNER AS $STMAP USES THE FORK BLOCK AND MAPPING             ;MSH012
; BLOCK IN THE SCB. THE FORMAT OF THE STRUCTURE IS AS FOLLOWS:          ;MSH012
;                                                                       ;MSH012
;       ---------------------                                           ;MSH012
;       !                   !           4 WORDS USED FOR SAVING         ;MSH012
;       !                   !           DRIVER'S CONTEXT IN CASE        ;MSH012
;       !                   !           UMR'S CAN'T BE MAPPED           ;MSH012
;       !                   !           IMMEDIATELY.                    ;MSH012
;       ---------------------                                           ;MSH012
;       !                   !                                           ;MSH012
;       !                   !           6 WORDS USED AS A UMR           ;MSH012
;       !                   !           MAPPING ASSIGNMENT BLOCK.       ;MSH012
;       !                   !                                           ;MSH012
;       !                   !                                           ;MSH012
;       !                   !                                           ;MSH012
;       ---------------------                                           ;MSH012
;                                                                       ;MSH012
;                                                                       ;MSH012
; INPUTS:                                                               ;MSH012
;                                                                       ;MSH012
;       R0=ADDRESS OF THE DATA STRUCTURE DEPICTED ABOVE                 ;MSH012
;       R4=ADDRESS OF DEVICE SCB                                        ;MSH012
;       R5=ADDRESS OF DEVICE UCB                                        ;MSH012
;                                                                       ;MSH012
; OUTPUTS:                                                              ;MSH012
;                                                                       ;MSH012
;       DATA STRUCTURE POINTERS SET UP FOR ENTRY TO $STMP2 IN $STMAP    ;MSH012
;                                                                       ;MSH012
;-                                                                      ;MSH012
                                                                        ;MSH012
                                                                        ;MSH012
$STMP1::MOV     S.FRK+10(R4),6(R0) ;SAVE DRIVER'S MAPPING               ;MSH012
        MOV     R0,R4           ;COPY BLOCK POINTER                     ;MSH012
        ADD     #M.LGTH+10,R0   ;POINT PAST MAPPING BLOCK               ;MSH012
        ADD     #4,R4           ;POINT TO CONTEXT SAVE BLOCK            ;MSH012
        BR      $STMP2          ;SET UP THE UMR ADRESS                  ;MSH012
                                                                        ;MSH012
;+
; **-$STMAP-SET UP UNIBUS MAPPING ADDRESS
;
; THIS ROUTINE IS CALLED BY UNIBUS NPR DEVICE DRIVERS TO SET UP THE
; UNIBUS MAPPING ADDRESS, FIRST ASSIGNING THE UMR'S.  IF THE UMR'S
; CANNOT BE ALLOCATED, THE DRIVER'S MAPPING ASSIGNMENT BLOCK IS PLACED
; IN A WAIT QUEUE AND A RETURN TO THE DRIVER'S CALLER IS EXECUTED.  THE
; ASSIGNMENT BLOCK WILL EVENTUALLY BE DEQUEUED WHEN THE UMR'S ARE
; AVAILABLE AND THE DRIVER WILL BE REMAPPED AND RETURNED TO WITH R1-R5
; PRESERVED AND THE NORMAL OUTPUTS OF THIS ROUTINE.  THE DRIVER'S
; CONTEXT IS STORED IN THE ASSIGNMENT BLOCK AND FORK BLOCK WHILE IT IS
; BLOCKED AND IN THE WAIT QUEUE.  ONCE A DRIVER'S MAPPING ASSIGNMENT
; BLOCK IS PLACED IN THE UMR WAIT QUEUE, IT IS NOT REMOVED FROM THE
; QUEUE UNTIL THE UMR'S ARE SUCCESSFULLY ASSIGNED.  THIS STRATEGY
; ASSURES THAT WAITING DRIVERS WILL BE SERVICED FIFO AND THAT DRIVER'S
; WITH LARGE REQUESTS FOR UMR'S WILL NOT WAIT INDEFINATELY.
;
; INPUTS:
;
;       R4=ADDRESS OF DEVICE SCB.
;       R5=ADDRESS OF DEVICE UCB.
;       (SP)=RETURN TO DRIVER'S CALLER.
;
; OUTPUTS:
;
;       UNIBUS MAP ADDRESSES ARE SET UP IN THE DEVICE UCB AND THE
;       ACTUAL PHYSICAL ADDRESS IS MOVED TO THE SCB.
;
; NOTE: REGISTERS R1, R2, AND R3 ARE PRESERVED ACROSS CALL.
;-

$STMAP::MOV     R4,R0           ;COPY SCB POINTER
        ADD     #S.MPR+M.LGTH,R0 ;POINT PAST MAPPING ASSIGNMENT BLOCK
        ADD     #S.FRK+6,R4     ;POINT INTO FORK BLOCK                  ;MSH012
$STMP2: MOV     U.BUF+2(R5),-(R0) ;SAVE LOW 16 BITS OF ADDRESS (M.BFVL) ;MSH012
        MOVB    U.BUF+1(R5),-(R0) ;SAVE HIGH 6 BITS OF ADDRESS (M.BFVH) ;**-1
        DEC     R0              ;POINT BACK TO NEXT WORD
        MOV     U.CNT(R5),-(R0) ;TEMORARILY STORE BYTE COUNT (M.UMVL)
        CLR     -(R0)           ;INITIALIZE UMR COUNT (M.UMRN)
        BIT     #1,M.BFVL-M.UMRN(R0) ; BUFFER ADDRESS ODD ?             ; BM004
        BEQ     10$             ; IF EQ NO, ALL IS NORMAL               ; BM004
        INC     2(R0)           ; IT'S ODD, WE MUST MAP ONE EXTRA BYTE  ; BM004
10$:    ADD     #4,(R0)         ;INCREASE COUNT FOR ONE UMR (M.UMRN)
        SUB     #20000,2(R0)    ;REDUCE BYTE COUNT BY 8K BYTES (M.UMVL)
        BCC     10$             ;IF CC MORE BYTES TO GO
        TST     -(R0)           ;(M.UMRA)
        MOV     -(R0),-(SP)     ;SAVE POSSIBLE WAIT QUEUE LINK (M.LNK)
        CALL    $ASUMR          ;ATTEMPT TO ASSIGN REQUIRED UMR'S
        BCC     20$             ;IF CC SUCCESSFUL, CHECK FOR UMR WAIT
        TST     (SP)+           ;CLEAR STACK
        MOV     R5,(R4)         ;SAVE R5 IN FORK BLOCK (S.FRK+6)        ;**-1
        MOV     (SP)+,-(R4)     ;SAVE DRIVER'S RETURN ADDRESS (S.FRK+4)
        MOV     R0,-(R4)        ;SAVE MAPPING BLOCK POINTER (S.FRK+2)   ;MSH012
        CALL    $WTUMR          ;WAIT FOR CHANGE IN UMR ASSIGNMENT
        MOV     (R4)+,R0        ;RESTORE MAPPING BLOCK POINTER (S.FRK+2);MSH012
        ADD     #M.LGTH,R0      ;POINT PAST MAPPING BLOCK               ;MSH012
        MOV     (R4)+,-(SP)     ;RESTORE DRIVER'S RETURN ADDR (S.FRK+4)
        MOV     (R4),R5         ;RESTORE R5 (S.FRK+6)                   ;MSH012
        MOV     2(R4),KISAR5    ;REMAP DRIVER (S.FRK+10)                ;MSH012
        BR      $STMP2          ;TRY AGAIN                              ;MSH012
20$:    MOV     U.SCB(R5),R4    ;RESTORE R4                             ;MSH012
        MOV     M.UMVL(R0),U.BUF+2(R5) ;STORE LOW WORD OF UMR VIRT ADDR ;MSH012
        MOVB    M.UMVH(R0),U.BUF(R5) ;STORE HIGH SIX BITS               ;**-5
        CLRB    U.BUF+1(R5)     ;CLEAR HIGH-ORDER BYTE
        CMP     $UMRWT,R0       ;WAS THIS CALLER WAITING?
        BNE     30$             ;IF NE NO
        MOV     (SP),$UMRWT     ;DEQUEUE CURRENT CALLER'S BLOCK
        BNE     30$             ;IF NE NOT END OF LIST
        MOV     #$UMRWT,$UMRWT+2 ;UPDATE LAST IN LIST POINTER
30$:    TST     (SP)+           ;CLEAR STACK

;+
; **-$DQUMR-DEQUEUE FROM UMR WAIT
;
; CONTROL IS TRANSFERRED HERE TO SEE IF A DRIVER IS WAITING FOR UMR
; ASSIGNMENT.  FIRST THE CALLING DRIVER IS CALLED BACK AS A COROUTINE.
; WHEN THE CALLING DRIVER ISSUES A RETURN BACK TO THIS ROUTINE, A CHECK
; IS MADE TO SEE IF ANY DRIVERS ARE WAITING FOR UMR'S.  IF SO THE WAIT-
; ING DRIVER'S CONTEXT IS RESTORED WITHOUT ACTUALLY DEQUEUEING THE
; MAPPING ASSIGNMENT BLOCK AND CONTROL IS PASSED BACK TO THE ORIGINAL
; UMR ASSIGNMENT ROUTINE.
;
; INPUTS:
;
;       (SP)=RETURN ADDRESS TO DRIVER'S CALLER..
;
; OUTPUTS:
;
;       IF ANYONE IS WAITING THEIR CONTEXT IS RESTORED AND THE ALLOCA-
;       TION ROUTINE IS CALLED BACK.
;-

        .ENABL  LSB
$DQUMR::CALL    @(SP)+          ;CALL THE CALLER AS COROUTINE
        MOV     $UMRWT,R0       ;ANYONE WAITING FOR UMR ASSIGNMENT?
        BEQ     10$             ;IF EQ HE HAS SINCE GONE AWAY
        TST     (R0)+           ;POINT TO SAVED R1
        MOV     (R0)+,R1        ;RESTORE SAVED REGISTERS
        MOV     (R0)+,R2        ;
        MOV     (R0)+,R3        ;
        MOV     (R0)+,R4        ;
        JMP     @(R0)+          ;JUMP BACK TO ALLOCATION ROUTINE

;+
; **-$WTUMR-WAIT FOR CHANGE IN UMR STATE
;
; THIS ROUTINE STORES R1-R4 AND THE RETURN PC IN THE MAPPING ASSIGNMENT
; AND QUEUES THE BLOCK IN THE UMR WAIT QUEUE FOR A SUBSEQUENT RECALL TO
; THE CALLER WHEN THE STATE OF UMR ASSIGNMENT CHANGES.  NOTE THAT IT IS
; POSSIBLE FOR THE MAPPING ASSIGNMENT BLOCK TO ALREADY BE IN THE WAIT
; QUEUE, BUT IF IT IS IT CAN ONLY BE AT THE HEAD OF THE QUEUE.
;
; INPUTS:
;
;       R0=POINTER TO UMR ASSIGNMENT BLOCK
;
; OUTPUTS:
;
;       THE ASSIGNMENT BLOCK IS QUEUED IN THE UMR WAIT QUEUE.
;       THE CALLER IS EVENTUALLY RETURNED TO AT SYSTEM STATE WITH R1-R4
;               PRESERVED.
;-

$WTUMR::MOV     (SP)+,12(R0)    ;STORE RETURN ADDR TO ALLOCATE ROUTINE
        CMP     R0,$UMRWT       ;MAPPING ASSIGNMENT BLK ALREADY IN LIST?
        BEQ     5$              ;IF EQ YES                              ;MSH029
        MOV     R0,@$UMRWT+2    ;LINK BLOCK TO LAST IN QUEUE            ;**-1
        MOV     R0,$UMRWT+2     ;UPDATE LAST IN LIST POINTER
        CLR     (R0)            ;ZERO LINK WORD                         ;MSH029
5$:     TST     (R0)+           ;POINT PAST LINK WORD                   ;MSH029
        MOV     R1,(R0)+        ;SAVE CALLER'S REGISTERS                ;**-1
        MOV     R2,(R0)+        ;
        MOV     R3,(R0)+        ;
        MOV     R4,(R0)+        ;
10$:    RETURN                  ;RETURN TO CALLER'S CALLER
        .DSABL  LSB

        .ENDC


;+
; **-$ECCOR-COMMON ECC CORRECTION CODE FOR RP04/RK06.
;
; THIS ROUTINE APPLIES THE ECC CORRECTION ALGORITHM AND DETERMINES
; IF OFFSET RECOVERY IS REQUIRED (IF SUPPORTED).
;
; INPUTS:
;
;       R1=CONTENTS OF ERROR REGISTER
;       R2=CSR ADDRESS
;       R3=ADDRESS OF FIRST ECC REGISTER
;       R5=UCB ADDRESS
;
; OUTPUTS:
;
;       R3=CONTROLLER INDEX
;       C=0 IF OFFSET RECOVERY IS NOT REQUIRED
;               R0=IS.SUC&377
;               R1=BYTES ACTUALLY TRANSFERRED
;               R2, R4, R5 ARE UNMODIFIED
;               U.BUF AND U.BUF+2 ARE UPDATED (VIA $RELOP)
;
;       OR C=1 IF OFFSET RECOVERY IS REQUIRED
;               R0=NUMBER OF GOOD BYTES TRANSFERED
;               R1-R5 ARE UNMODIFIED
;
; FIRST CALCULATE THE BYTE OFFSET TO THE START OF BLOCK TRANSFERRED
;-


        .IF DF  S$$ECC

$ECCOR::MOV     2(R2),R0        ;GET NEGATIVE NUMBER OF WORDS REMAINING
        ASL     R0              ;CONVERT TO NEGATIVE BYTES REMAINING
        ADD     U.CNT(R5),R0    ;CALCULATE NUMBER OF BYTES TRANSFERED
        MOV     R0,-(SP)        ;SAVE NUMBER OF BYTES TRANSFERRED

        .IF DF  R$$JPO!R$$6OF!R$$MOF

        SEC                     ;ASSUME OFFSET RECOVERY IS REQUIRED
        BEQ     40$             ;IF EQ NO BYTES TRANSFERED
        BIT     #600,R1         ;HEADER COMPARE OR CRC ERROR?
        BNE     10$             ;IF NE YES

        .IFTF

        DEC     R0              ;CALCULATE OFFSET TO START OF BLOCK
10$:    BIC     #777,R0         ;CLEAR RESIDUE

        .IFT

        BIT     #10700,R1       ;ECC HARD ERROR?
        BNE     40$             ;IF NE YES

        .ENDC


;
; SECOND CALCULATE BYTE OFFSET IN BLOCK AND POSITION PATTERN SHIFT COUNT
;

        MOV     (R3)+,R1        ;GET STARTING BIT NUMBER
        DEC     R1              ;CONVERT TO RELATIVE BIT NUMBER
        MOV     R1,-(SP)        ;SAVE STARTING RELATIVE BIT NUMBER
        BIC     #^C<17>,R1      ;ISOLATE SHIFT COUNT
        BIC     R1,(SP)         ;CLEAR SHIFT COUNT IN RELATIVE BIT NUMBE
        CLC                     ;CALCULATE OFFSET TO FIRST BYTE IN BLOCK
        ROR     (SP)            ;
        ASR     (SP)            ;
        ASR     (SP)            ;
        ADD     (SP),R0         ;CALCULATE OFFSET TO FIRST BYTE IN TRANS

;
; THIRD SHIFT CORRECTION PATTERN INTO PLACE
;

        MOV     (R3),R3         ;GET CORRECTION PATTERN WORD
        CLR     (SP)            ;CLEAR SECOND WORD
20$:    DEC     R1              ;ANY MORE SHIFTS TO PERFORM?
        BLT     30$             ;IF LT NO
        ASL     R3              ;DOUBLE LEFT SHIFT
        ROL     (SP)            ;
        BR      20$             ;

;
; FOURTH APPLY FIRST CORRECTION
;

30$:    CALL    50$             ;APPLY ECC CORRECTION

;
; FIFTH APPLY SECOND CORRECTION
;

        MOV     (SP)+,R3        ;RETRIEVE SECOND PATTERN WORD
        ADD     #2,R0           ;UPDATE COUNT
        CALL    50$             ;APPLY ECC CORRECTION

;
; SIXTH FINISH OR CONTINUE PREVIOUS FUNCTION
;

        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        CLC                     ;OFFSET RECOVERY NOT REQUIRED
        MOV     (SP),R1         ;RETRIEVE BYTES TRANSFERRED
40$:    INC     (SP)+           ;CLEAN STACK
        MOVB    S.CON(R4),R3    ;SET CONTROLLER INDEX
        RETURN                  ;

;
; ECC CORRECTION ROUTINE
;

50$:    CMP     R0,U.CNT(R5)    ;BYTE OFFSET WITHIN RANGE?
        BHIS    60$             ;IF HIS NO
        CALL    $RELOP          ;RELOCATE PHYSICAL ADDRESS
        MOV     (R1),-(SP)      ;COPY CURRENT DATA WORD
        BIC     R3,(R1)         ;.NOT.PATTERN.AND.DATA WORD
        BIC     (SP)+,R3        ;.NOT.DATA WORD.AND.PATTERN
        BIS     R3,(R1)         ;PATTERN.OR.DATA WORD
60$:    RETURN                  ;

        .ENDC


;+
; **-$RELOP-RELOCATE UNIBUS PHYSICAL ADDRESS
;
; THIS ROUTINE RELOCATES A UNIBUS PHYSICAL ADDRESS TO A KISAR6
; BIAS AND DISPLACEMENT.
;
; INPUTS:
;
;       R0=BYTE OFFSET FROM ADDRESS IN U.BUF+1 AND U.BUF+2
;       R5=UCB ADDRESS
;               U.BUF+1(R5)=HIGH ORDER BITS OF PHYSICAL ADDRESS
;               U.BUF+2(R5)=LOW ORDER BITS OF PHYSICAL ADDRESS
;
; OUTPUTS:
;
;       KISAR6=CALCULATED BIAS (MAPPED SYSTEM)
;       R1=REAL ADDRESS OR DISPLACEMENT
;-


        .IF DF  D$$IAG!S$$ECC

$RELOP::                        ;


        .IF DF  M$$MGE

        MOV     U.BUF(R5),-(SP) ;RETRIEVE ORIGINAL MEMORY EXTENSION BITS
        CLRB    (SP)            ;ZERO FUNCTION CODE LEAVING EXMEM BITS  ; PB056
                                                                        ;**-1
        .IFTF

        MOV     U.BUF+2(R5),R1  ;RETRIEVE STARTING BUFFER ADDRESS
        ADD     R0,R1           ;CALCULATE ADDRESS OF WORD TO BE CORRECT

        .IFT

        ADCB    1(SP)           ;PROPAGATE ADDRESS CARRY
        SWAB    R1              ;SWAP STARTING BUFFER ADDRESS
        BISB    R1,(SP)         ;MERGE 8 BITS OF UPPER ADDRESS BIAS
        ASL     R1              ;COLLECT REMAINING TWO BITS
        ROL     (SP)            ;
        ASL     R1              ;
        ROL     (SP)            ;
                                                                        ; PB056
                                                                        ; PB056
        .IF DF  M$$EXT                                                  ; PB056
                                                                        ; PB056
        BIT     #DV.MBC,U.CW1(R5)  ;IS THIS A MASSBUS DEVICE?           ; PB056
        BNE     10$             ;IF NE YES, ADDRESS OK AS IS            ; PB056
        ADD     #170000,(SP)    ;FORCE UNIBUS MAP TO ACCESS MAIN MEMORY ; PB056
                                                                        ; PB056
        .ENDC                                                           ; PB056
                                                                        ; PB056
                                                                        ; PB056
10$:    MOV     (SP)+,KISAR6    ;SET BUFFER RELOCATION BIAS             ; PB056
        CLRB    R1              ;CLEAR LOW BYTE OF STARTING ADDRESS     ;**-1
        SWAB    R1              ;SWAP ADDRESS BACK
        ASR     R1              ;SETUP APR6 ADDRESS
        ASR     R1              ;
        BIS     #140000,R1      ;

        .ENDC


        RETURN                  ;

        .ENDC


;+
; **-$CRPAS - COMMON REGISTER PASS ROUTINE
;
; THIS SUBROUTINE IS USED TO PASS THE CONTENTS OF THE DEVICE REGISTERS
; BACK TO THE DIAGNOSTIC TASK.  ALL REGISTERS ARE PASSED IN THE ORDER
; IN WHICH THEY APPEAR ON THE UNIBUS.
;
; NOTE: THIS ROUTINE MAKES USE OF THE ERROR LOGGING ENTRIES S.ROFF AND
;       S.RCNT IN THE SCB.  THEREFORE ERROR LOGGING MUST BE ENABLED IN
;       ORDER TO USE THIS ROUTINE.
;
; INPUTS:
;
;       R1=I/O PACKET ADDRESS
;       R2=CSR ADDRESS
;       R4=SCB ADDRESS
;       R5=UCB ADDRESS                                                  ; PB060
;
; OUTPUTS:
;
;       R1=DESTROYED                                                    ; PB060
;       R0,R2 ARE PRESERVED
;-


        .IF DF  D$$IAG

$CRPAS::MOV     R0,-(SP)        ;SAVE R0


        .IF DF  M$$MGE

        MOV     I.PRM+14(R1),KISAR6 ;SET RELOCATION BIAS

        .ENDC


        MOV     I.PRM+16(R1),R0 ;GET REGISTER BUFFER ADDRESS
        MOV     R2,-(SP)        ;PRESERVE INITIAL CSR ADDRESS
        MOVB    S.ROFF(R4),R2   ;GET OFFSET TO FIRST REGISTER
        ADD     (SP),R2         ;ADD CSR ADDRESS
        MOVB    S.RCNT(R4),R1   ;GET NUMBER OF REGISTERS TO XFER
10$:    MOV     (R2)+,(R0)+     ;TRANSFER A REGISTER
        DEC     R1              ;DONE YET?
        BNE     10$             ;IF NE NO
                                                                        ; PB060
                                                                        ; PB060
        .IF DF  M$$EXT                                                  ; PB060
                                                                        ; PB060
        BIT     #DV.MBC,U.CW1(R5)  ;IS THIS A MASSBUS DEVICE?           ; PB060
        BEQ     20$             ;IF EQ NO                               ; PB060
                                                                        ; PB060
                                                                        ; PB060
        .IF DF  M$$IXD                                                  ; PB060
                                                                        ; PB060
        MOV     (SP),R2         ;RESTORE CSR ADDRESS                    ; PB060
        MOV     74(R2),(R0)+    ;TRANSFER RHBAE                         ; PB060
        MOV     76(R2),(R0)     ;TRANSFER RHCS3                         ; PB060
                                                                        ; PB060
        .IFF                                                            ; PB060
                                                                        ; PB060
        MOV     (R2)+,(R0)+     ;TRANSFER RHBAE                         ; PB060
        MOV     (R2),(R0)       ;TRANSFER RHCS3                         ; PB060
                                                                        ; PB060
        .ENDC                                                           ; PB060
                                                                        ; PB060
                                                                        ; PB060
        .ENDC                                                           ; PB060
                                                                        ; PB060
                                                                        ; PB060
20$:    MOV     (SP)+,R2        ;RESTORE CSR ADDRESS                    ; PB060
        MOV     (SP)+,R0        ;RESTORE R0                             ;**-1
        RETURN

        .ENDC


;+
; **-$MUL-INTEGER MULTIPLY MAGNITUDE NUMBERS
;
; INPUTS:
;
;       R0=MULTIPLIER.
;       R1=MULTIPLICAND.
;
; OUTPUTS:
;
;       DOUBLE WORD RESULT IS RETURNED WITH THE
;       HIGH PART IN R0 AND THE LOW PART IN R1.
;
;       REGISTERS R2, R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-

        .ENABL  LSB
$MUL::  MOV     R0,-(SP)        ;SAVE R0 FOR ADDS
        MOV     #21,-(SP)       ;SET REPEAT COUNT
        CLR     R0              ;CLEAR HIGH PART
10$:    ROR     R0              ;DOUBLE RIGHT SHIFT
        ROR     R1              ;
        BCC     20$             ;IF CC DO NOT ADD
        ADD     2(SP),R0        ;
20$:    DEC     (SP)            ;DECREMENT REPEAT COUNT
        BGT     10$             ;IF GT MORE TO GO
        BR      50$             ;EXIT TO CALLER

;+
; **-$DIV-INTEGER DIVIDE MAGNITUDE NUMBERS
;
; INPUTS:
;
;       R0=DIVIDEND.
;       R1=DIVISOR.
;
; OUTPUTS:
;
;       QUOTIENT IS RETURNED IN R0 AND REMAINDER IN R1.
;
;       REGISTERS R2, R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-

$DIV::  MOV     #20,-(SP)       ;SET LOOP COUNT
        MOV     R1,-(SP)        ;SAVE DIVISOR FOR SUBTRACTS
        CLR     R1              ;CLEAR REMAINDER
30$:    ASL     R0              ;DOUBLE LEFT SHIFT
        ROL     R1              ;
        CMP     R1,(SP)         ;SUBTRACT OUT DIVISOR?
        BLO     40$             ;IF LO NO
        SUB     (SP),R1         ;SUBTRACT OUT DIVISOR
        INC     R0              ;ADD IN LOW BIT
40$:    DEC     2(SP)           ;DECREMENT REPEAT COUNT
        BGT     30$             ;IF GT MORE TO GO
50$:    CMP     (SP)+,(SP)+     ;CLEAN STACK
        RETURN                  ;
        .DSABL  LSB

        .END
        .TITLE  PCSCOM
        .IDENT  /00/
;               COPYRIGHT (C) 1977 BY
;       DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;
.IF DF  N$$PCS

        .GLOBL  N$$PCS

.IF DF  M$$MGE!I$$POM

        .PSECT  PCSCOM,REL,GBL,OVR,D

.IFF

        .ASECT

.=I$$PB0

.ENDC

.PCSAD:: .BLKW  255.

.ENDC
.END
        .TITLE  IPDRV - IP-11/IP-300 DRIVER
        .IDENT  /V01.05/
        .ENABL  LC

;
; COPYRIGHT (C) 1977, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED  UNDER A LICENSE FOR USE ONLY ON A SINGLE
; COMPUTER  SYSTEM AND  MAY BE  COPIED ONLY WITH  THE INCLUSION OF THE
; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
; MAY NOT BE PROVIDED OR  OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
; TERMS.  TITLE TO AND  OWNERSHIP OF THE  SOFTWARE  SHALL AT ALL TIMES
; REMAIN IN DEC.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
; AND SHOULD  NOT BE CONSTRUED  AS A COMMITMENT  BY DIGITAL  EQUIPMENT
; CORPORATION.
;
; DEC ASSUMES  NO  RESPONSIBILITY  FOR  THE USE OR  RELIABILITY OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;

;++
; FACILITY:     RSX-11M I/O DRIVERS
;
; ABSTRACT:
;
;       THE IP-11 PROCESS CONTROL SUBSYSTEM IS A LOW-COST EXPANDABLE
;       PROCESS-CONTROL DEVICE SUITABLE FOR INDUSTRIAL APPLICATIONS.
;       THIS DRIVER PROVIDES USER-LEVEL TASKS WITH THE ABILITY TO
;       PERFORM ANALOG AND DIGITAL INPUT AND OUTPUT IN A (SOMEWHAT)
;       DEVICE-INDEPENDENT MANNER.
;
;
; ENVIRONMENT:  KERNEL MODE, MAPPED TO RSX-11M EXECUTIVE
;
; AUTHOR: PAUL BECK, CREATION DATE: 14-MAR-77
;
; VERSION V01.05
;
; MODIFIED BY:
;
;       GEOFF KUENNING, 24-JAN-78:  VERSION 1.0
; 01-15 - ADD CODE TO SUPPORT A/D CONVERTERS.
; 16-20 - REMOVE ASSEMBLY ERRORS.
; 21-34 - FIX VARIOUS BUGS FOUND IN DEBUGGING, ADD CODE TO DEALLOCATE
;         OLD A/D MAPPING TABLES ON POWERUP, AND ADD FUNCTION IO.RAM
;         TO THE DRIVER.
; 35    - FIX BUGS FOUND IN DEBUGGING.  ADD GENERIC CODES FOR THE
;         M6010-YA AND M5012-YA TTL-COMPATIBLE DIGITAL INPUT MODULES
;         TO THE GENERIC CODE TABLE, THUS ADDING SUPPORT FOR SAID
;         MODULES.
; 36-37 - FIX BUGS FOUND IN DEBUGGING.
; 40    - FIX 14-BIT ADDRESS SEARCH LOOP TO RUN AT PR6 SO AS TO AVOID
;         AVOID CONFLICT WITH SHUFFLE LOOP IN INTERRUPT CODE.  FIX
;         12-BIT SUPPORT TO RETURN DATA IN TWO'S COMPLEMENT FORM.  FIX
;         A/D MAPPING TO LIMIT CONVERTERS TO A MAXIMUM OF 16 PER
;         CONTROLLER.  REMOVE PATCH SPACE RESERVED DURING DEBUGGING.
; 41    - FIX ASSEMBLY ERROR IF UNSOLICITED-INTERRUPT SUPPORT IS NOT
;         SELECTED AND A/D SUPPORT IS.
; 42    - FIX SOME MINOR LISTING UNCLEANLINESSES.
; 43    - ON AN UNMAPPED SYSTEM WITHOUT ADDRESS CHECKING, PICK UP THE
;         CORRECT VALUE FOR THE USER'S CONTROL-BUFFER ADDRESS (BUG).
; 44    - CHANGE SYMBOL EXPR0 TO XITPR0.
; 45    - REMOVE SYMBOL BOOT AND ALL REFERENCES, REPLACING BY A SIMPLE
;         UNCONDITIONAL SETTING OF THE CLEAR BIT.  ADD A TIMEOUT LOOP
;         IMMEDIATELY AFTER THIS TO ENFORCE THE 20-MICROSECOND
;         TIMING RESTRICTION.
; 46    - REMOVE .DSABL GBL AND ALL .GLOBL STATEMENTS TO PREVENT
;         PROBLEMS WITH UNDEFINED SYMBOLS.
; 47    - DON'T CREATE TABLE IPSERV IF IT ISN'T NEEDED.
;       J. CLEARY        1-FEB-79
;
;               JC031 -- ADD COUNTER MODULE SUPPORT
;
;       M. S. HARVEY    21-FEB-79
;               MSH026  ADD LOADABLE DRIVER SUPPORT
;                       ADD RSX-11M, RSX-11M+ COMPATIBILITY
;
;       J. CLEARY       4-APR-79
;
;               JC037 -- RENAME GLOBAL SYMBOLS WHICH CONFLICT WITH ICS
;
;--
        .PAGE
        .SBTTL  SYSTEM SYMBOL DECLARATIONS
;
; SYSTEM SYMBOL DEFINITIONS
;
        .MCALL  HWDDF$,PCBDF$,PKTDF$,QIOSY$,SCBDF$,TCBDF$,UCBDF$

        .DSABL  CRF
        HWDDF$
        PCBDF$
        PKTDF$
        QIOSY$
        SCBDF$
        TCBDF$
        UCBDF$
        .ENABL  CRF
        .PAGE
        .SBTTL  EQUATED SYMBOLS
        .ASECT
;
; UNSOLICITED DIGITAL INTERRUPTING MODULE OFFSETS
;       ..ONE TABLE PER MODULE TYPE (COS,DSI,CTR) PER UNIT
;       ..ACCESSED VIA SCB (S.SI, S.CI, S.TI)
;
.=0
IMAX:   .BLKW 1         ; HIGHEST POINT NUMBER
IMBPE:  .BLKB 1         ; BYTES PER CIRCULAR BUFFER ENTRY
IMFIP:  .BLKB 1         ; FORK-IN-PROGRESS FLAG
IMSBF:  .BLKW 1         ; STARTING BUFFER RELOCATION BIAS
IMCBF:  .BLKW 1         ; CURRENT BUFFER RELOCATION BIAS
IMSAD:  .BLKW 1         ; ADDRESS OF START OF BUFFER
IMSDA:  .BLKW 1         ; ADDRESS OF START OF DATA
IMCUR:  .BLKW 1         ; ADDRESS OF CURRENT ENTRY
IMFIL:  .BLKW 1         ; CURRENT FORTRAN FILL INDEX
IMLGH:  .BLKW 1         ; LENGTH OF CIRCULAR BUFFER IN WORDS
IMEVM:  .BLKW 1         ; EVENT FLAG MASK WORD
IMEVA:  .BLKW 1         ; EVENT FLAG MASK ADDRESS
IMLST:  .BLKW 1         ; LOST DATA COUNT
IMTCB:  .BLKW 1         ; TCB ADDRESS OF CONNECTED TASK
IMTYP:  .BLKW 1         ;COUNTER MASK AND FLAG WORD                     ;JC031
IMFRK:  .BLKW 3         ; FORK BLOCK
IMSCB:  .BLKW 1         ; SCB BACKPOINTER
        .IF DF  LD$IP                                                   ;MSH026
IMPCB:  .BLKW 1         ; BASE ADDRESS OF DRIVER PCB                    ;MSH026
        .ENDC                                                           ;MSH026
IMLH:   .BLKW 2         ; RESOURCE LINKAGE LISTHEAD
                        ; (ONE LISTHEAD PER CONTROLLER IF I$$PUN DEFINED)
;
; RESOURCE LINKAGE OFFSETS
;       ..ONE ENTRY PER TASK OR EVENT FLAG LINKAGE
;       ..ACCESSED AS QUEUE FROM UNSOLICITED MODULE TABLE FOR
;       THE APPROPRIATE MODULE TYPE.
;
.=0
ILNXT:  .BLKW 1         ; LINK TO NEXT
ILPBA:  .BLKB 1         ; PHYSICAL BYTE OFFSET FOR MODULE LINKED TO
ILRES:  .BLKB 1         ; RESOURCE MASK FOR THIS LINKAGE
ILTE:   .BLKW 1         ; TASK LINKAGE (( EF*2 + 1 ))
ILEVM:  .BLKW 1         ; EVENT FLAG MASK (( EVENT FLAG ))
ILEVA:  .BLKW 1         ; EVENT FLAG ADDRESS (( TCB ADDRESS ))
ILRUN:  .BLKB 1         ; RUN FLAG FOR FORK PROCESS
ILCOS:  .BLKB 1         ; RESOURCE INTERRUPTED MASK
ILREL:  .BLKW 1         ; RELATIVE ENTRY NUMBER OF THIS LINKAGE
ILPAD:  .BLKW 1         ; PAD LENGTH FOR ALLOCATION
ILGH:   .BLKW 0         ; LENGTH
;
; ITEMS ABOVE IN DOUBLE PAREN (( )) ARE ALTERNATE MEANINGS FOR
; EVENT FLAG LINKAGES
;
;
; TASK LINKAGE OFFSETS
;       ..ONE ENTRY/LINKED TASK, QUEUED IN A SINGLE LIST COMMON TO
;       ALL PCS CONTROLLERS
;
.=0
LNEXT:  .BLKW 1         ; LINK
LUSE:   .BLKW 1         ; NUMBER OF RESOURCE LINKAGES FOR THIS TASK
LTCB:   .BLKW 1         ; TASK TCB ADDRESS
LACT:   .BLKW 1         ; ACTIVITY COUNT (START OF IO.RAD BLOCK)
LPHY:   .BLKW 1         ; UNIT NUMBER
LGEN:   .BLKW 1         ; MODULE TYPE
LREL:   .BLKW 1         ; RELATIVE ENTRY NUMBER
LHWR:   .BLKW 3         ; HARDWARE DEPENDANT DATA
LLGH:   .BLKW 0         ; LENGTH
;
; GENERIC CODE DEFINITION TABLE
;       ..ONE ENTRY PER SUPPORTED MODULE
;
.=0
GCODE:  .BLKB 1         ; GENERIC CODE
GCNBM:  .BLKB 1         ; NUMBER OF BYTES OF ADDR SPACE USED BY MODULE
GCMOD:  .BLKB 1         ; MODULE TYPE
GCLEM:  .BLKB 1         ; NUMBER OF LOGICAL ENTRIES PER MODULE
GCLGH:  .BLKW 0         ; LENGTH
;
; GENERIC CODE TABLE FOR MULTIPLEXERS ADDED ON TO THE A014 A/D
;       ..ONE ENTRY PER SUPPORTED MULTIPLEXER
;
.=0
MGCODE: .BLKB 1         ; GENERIC CODE OF MULTIPLEXER
MCHANS: .BLKB 1         ; NUMBER OF CHANNELS IT PROVIDES
;
; MODULE MAPPING TABLE
;       ..ONE ENTRY PER DENSE SET OF MODULES OF THE SAME MODULE TYPE
;       ..ENTRIES OF THE SAME MODULE TYPE IN DIFFERENT CONTROLLERS ARE
;       LINKED TOGETHER.
;       ..ACCESSED FROM SCB VIA S.IPM+(MODULE TYPE - 1)*2
;
.=0
IPMNEX: .BLKW 1         ; LINK
IPMMIN: .BLKW 1         ; MINIMUM RELATIVE ENTRY, THIS DENSE SET
IPMMAX: .BLKW 1         ; MAXIMUM RELATIVE ENTRY
IPMMOD: .BLKB 1         ; MODULE TYPE
        .BLKB 1         ; SPARE
IPMLOW: .BLKB 1         ; RELATIVE BYTE ADDRESS OF FIRST ENTRY IN SET
IPMCON: .BLKB 1         ; CONTROLLER INDEX
LGMAP:  .BLKW 0         ; LENGTH
;
; A/D CONVERTER CONTROL TABLE
;       ..ONE ENTRY PER LOGICAL UNIT, COVERING A MAXIMUM OF 16 ADC'S
;       ON THAT UNIT
;       ..ACCESSED FROM SCB VIA S.ADC
;
.=0
ADMXC:  .BLKW 1         ; MAXIMUM CHANNEL NUMBER ON THIS PCS
ADFR:   .BLKB 1         ; FORK REQUEST FLAG, *MUST* PRECEDE ADIP!
ADIP:   .BLKB 1         ; CONVERSIONS IN PROGRESS COUNT
ADNXT:  .BLKW 1         ; ADDR OF ADC ENTRY FOR BLOCKED CONVERSION
ADNXC:  .BLKW 1         ; CONTROL WORD FOR BLOCKED CONVERSION
ADFBC:  .BLKW 1         ; COUNTER OF SUCCESSFUL CONVERSIONS
ADSTS:  .BLKW 1         ; I/O COMPLETION STATUS
ADCONV: .BLKW 16.       ; ADDRESSES OF ADC ENTRIES (0 IF NONE)
ADLG:   .BLKW 0
;
; A/D CONVERTER ENTRIES
;       ..ONE PER A/D CONVERTER, COVERING UP TO 8 MUXES
;       ..BLOCK IS ALLOCATED ON POWER-UP
;       ..ACCESSED FROM A/D CONTROL TABLE (ABOVE) BY CONVERTER INDEX
;
.=0
ADBUS:  .BLKW 1         ; BUS ADDRESS OF ADC
                        ; LOW BIT OF ABOVE IS SET IF CNVTR IS BUSY
ADTYP:  .BLKB 1         ; CONVERTER TYPE (ADI12 OR ADI14)
;       TAIL END OF TABLE DIFFERS FOR ADI12 AND ADI14.
;       FOR ADI12:
.=ADTYP+1
        .BLKB 1         ; (UNUSED)
ADUAD:  .BLKW 2         ; USER BUFFER ADDRESS
ADMUX:  .BLKB 8.        ; # OF CHANNELS IN EACH MUX (ZERO IF MUX IS
                        ; NOT PRESENT)
LGAD12: .BLKW   0
;       FOR ADI14:
.=ADTYP+1
ADCHN:  .BLKB 1         ; # OF CHANNELS ON THE CONVERTER
ADUADS: .BLKW   2*4     ; SPACE FOR UP TO 4 USER BUFFER ADDRESSES
LGAD14: .BLKW   0
;
; QIO ADDRESS CHECKING FLAGS
;
ALBUF=1                 ; BUFFER MUST BE WORD ALIGNED? 1=YES
ALBYT=2                 ; BYTE COUNT MUST BE WORD ALIGNED? 1=YES
ALBF2=4                 ; SECOND BUFFER MUST BE WORD ALIGNED? 1=YES
CB=100000               ; CONTROLLER FUNCTION FLAG
VFBITS=ALBUF!ALBYT!ALBF2!CB
;
; MODULE TYPES
;
DIGI=1                  ; DIGITAL SENSE INPUT
COS=2                   ; CHANGE-OF-STATE INPTRRUPT
DSI=3                   ; DIGITAL SENSE INTERRUPT (1 BIT/BYTE INT)
DIGO=4                  ; DIGITAL OUTPUT
SSO=5                   ; SINGLE SHOT OUTPUT
DAO=6                   ; DIGITAL TO ANALOG OUTPUT
ADI12=7                 ; ANALOG TO DIGITAL INPUT, 12 BITS
ADI14=8.                ; ANALOG TO DIGITAL INPUT, 14 BITS
IN08=9.                 ;8-BIT INPUT COUNTER                            ;JC031
IN16=10.                ;16-BIT INPUT COUNTER                           ;JC031
OU16=11.                ;16-BIT OUTPUT COUNTER                          ;JC031
;
; CSR BIT DEFINITION
;
RIF=1                   ; RESET INTERRUPT FLAG
GBIT=4                  ; RETURN GENERIC CODE
EBIT=100                ; INTERRUPT ENABLE FOR PCS
CBIT=2                  ; CLEAR PCS
;
; OTHER
;
RMTLG=8.                ; SIZE OF TABLE ENTRY FOR IO.RMT CALLER
RAMLG=16.               ; SIZE OF TABLE ENTRY FOR IO.RAM CALLER
NMTYP=11.               ;NUMBER OF MODULE TYPES                         ;JC031
NMTYP1=9.               ;NUMBER OF MODULE TYPES EXCLUDING A/D TYPES     ;JC031
ILGAIN=20000            ; BIT THAT CANNOT APPEAR IN A014 GAIN           ;**-2
ILLMEM=4                ; DEFINE ILLEGAL MEM REF TRAP
MTIN08=1000             ;MODULE TYPE 9. MASK WORD                       ;JC031
MTIN16=2000             ;MODULE TYPE 10. MASK WORD                      ;JC031
MTOU16=4000             ;MODULE TYPE 11. MASK WORD                      ;JC031
        .PAGE
        .SBTTL  LOCAL MACRO DEFINITIONS
.MACRO  MOVB$C  S,D
         CLR    D
         BISB   S,D
.ENDM

.MACRO  ERREX$  ER
        .IRP    E,<ER>
PCS'E': MOV     #IE.'E'&377,R0
        BR      PCSCOM
        .ENDM
.ENDM

.MACRO  ASSUME  A,COND,B
        .IF COND <A>-<B>
        .IFF

        .ERROR  A       ; ASSUME -- "A" IS NOT COND "B"
        .PRINT  B

        .ENDC
.ENDM
        .PAGE
        .SBTTL  LOCAL DATA STRUCTURES
        .PSECT
PCSTOP:

.IF DF  I$$PUI

PCTLH:  .WORD   0,PCTLH         ; TASK LINKAGE LIST

.ENDC

.IF DF  I$$PAD!I$$P14!I$$PCO!I$$PDI!I$$PTI                              ;JC031
                                                                        ;**-1
CNTBL:  .BLKW   N$$PCS          ; UCB STORAGE
TMP:    .BLKW   1               ; HOLDS UCB FOR INT SERVICE
RUN:    .BLKW   1               ; FORK PROCESS FLAG

.ENDC
.IF DF  I$$PAD ! I$$P14

NADC:   .WORD   0               ; NUMBER OF A/D CONVERTERS ON SYSTEM

.ENDC
.IF DF  I$$PTI                                                          ;JC031
                                                                        ;JC031
CTRTYP: .WORD   0       ; MODULE TYPES IN THIS CONFIGURATION            ;JC031
                                                                        ;JC031
.ENDC                                                                   ;JC031
.IF DF  I$$PPF

PRVMAP: .BLKW   1               ; START ADDR FOR CREATING PF TBLS
NBPWF:  .WORD   0               ; NUMBER OF BYTES SAVED ON PWR FAIL
                                                                        ;MSH026
        .IF DF LD$IP & R$$MPL                                           ;MSH026
                                                                        ;MSH026
PFCTB:  .WORD   0               ;THESE TABLES WILL BE IN POOL           ;MSH026
PFDTB:  .WORD   0                                                       ;MSH026
PFLEN:  .WORD   0               ;LENGTH OF POOL BLOCK ALLOCATED         ;MSH026
                                                                        ;MSH026
        .IFF                                                            ;MSH026
                                                                        ;MSH026
PFCTB:  .WORD   PWCTB           ;POINTERS TO IN-LINE TABLES             ;MSH026
PFDTB:  .WORD   PWDTB                                                   ;MSH026
                                                                        ;MSH026
PWCTB:  .BLKW   I$$PPF+1        ;POWER FAIL CONTROL TABLE               ;MSH026
PWDTB:  .BLKB   I$$PPF          ;POWER FAIL DATA TABLE                  ;MSH026
                                                                        ;MSH026
        .ENDC                                                           ;MSH026
        .EVEN                                                           ;**-2
PFPTR:  .WORD   0               ; FILL POINTER FOR CONTROL TABLE

.ENDC

;
; GENERIC CODE DEFINITION TABLE
;
$$$=0

GENCOD:

.IF DF  I$$PDO

        .BYTE   041, 4, DIGO, 4 ; M6010
        .BYTE   043, 4, DIGO, 4 ; M6010-YA
        .BYTE   001, 1, DIGO, 1 ; M6012
        .BYTE   002, 1, DIGO, 1 ; M6013
        .BYTE   022, 4, DIGO, 4 ; M6015                                 ;JC037
$$$=$$$+1

 .ENDC
.IF DF  I$$PSS

        .BYTE   021, 2, SSO, 2  ; M6011
$$$=$$$+1

.ENDC
.IF DF  I$$PDS

        .BYTE   141, 4, DIGI, 4 ; M5010
$$$=$$$+1

.ENDC
.IF DF  I$$PDI

        .BYTE   122, 2, DSI, 2  ; M5012
        .BYTE   123, 2, DSI, 2  ; M5012-YA
        .BYTE   101, 1, DSI, 1  ; M5013
$$$=$$$+1

.ENDC
.IF DF  I$$PCO

        .BYTE   121, 4, COS, 2  ; M5011
        .BYTE   124, 4, COS, 2  ; M5031                                 ;JC037
$$$=$$$+1

.ENDC
.IF DF  I$$PDA

        .BYTE   261, 8., DAO, 4 ; A630 DAC
        .BYTE   262,8., DAO, 4  ; A631 DAC                              ;JC037
$$$=$$$+1

.ENDC
.IF DF  I$$PAD

        .BYTE   301, 4, ADI12, 0 ; A014 ADC, DOUBLE-ENDED
        .BYTE   321, 4, ADI12, 0 ; A014 ADC, SINGLE-ENDED
$$$=$$$+1

.ENDC
.IF DF  I$$P14

        .BYTE   304, 4, ADI14, 8. ; A020 ADC, DOUBLE-ENDED
        .BYTE   324, 4, ADI14, 16. ; A020 ADC, SINGLE-ENDED
$$$=$$$+1

.ENDC
.IF DF  I$$PTI                                                          ;JC031
                                                                        ;JC031
        .BYTE   142, 2, IN08, 4 ;8-BIT INPUT COUNTER - M5016            ;JC031
$$$=$$$+1                                                               ;JC031
        .BYTE   144, 4, IN16, 2 ;16-BIT INPUT COUNTER - M5014           ;JC031
        .BYTE   145, 4, IN16, 2 ;16-BIT INPUT COUNTER - M5014           ;JC031
        .BYTE   146, 4, IN16, 2 ;16-BIT INPUT COUNTER - M5014           ;JC031
        .BYTE   147, 4, IN16, 2 ;16-BIT INPUT COUNTER - M5014           ;JC031
$$$=$$$+1                                                               ;JC031
        .BYTE    44, 4, OU16, 2 ;16-BIT OUTPUT COUNTER - M6014          ;JC031
$$$=$$$+1                                                               ;JC031
                                                                        ;JC031
.ENDC                                                                   ;JC031

        .WORD   0                       ; END OF GENCOD
NMODCF=$$$
;
; MULTIPLEXER DEFINITION TABLES FOR THE A014 A/D CONVERTER
;
MXDEF:  .BYTE   301,8.
        .BYTE   321,16.
        .BYTE   322,16.
        .BYTE   342,32.
        .BYTE   323,16.                                                 ;JC037
        .WORD   0                                                       ;**-1
;
; MAPPING TABLES
;
LSTMAP: PCSMTB-LGMAP                    ; POINTER TO LAST ENTRY
PCSMTB: .BLKW   N$$PCS*NMODCF*LGMAP
PCSMTX=.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;            ;MSH026
;
; DISPATCH TABLE
;
; POWER-DOWN ENTRY POINT MUST IMMEDIATELY PRECEDE THE DRIVER            ;MSH026
; DISPATCH TABLE FOR PROPER POWERFAIL OF A LOADABLE IPDRV               ;MSH026
;                                                                       ;MSH026
        .WORD   IPDWN           ;POWER-DOWN ROUTINE                     ;MSH026
                                                                        ;MSH026
        .IF DF R$$MPL                                                   ;MSH026
                                                                        ;MSH026
        DDT$    IP,N$$PCS,,,,NEW ;REMAINDER OF DISPATCH TABLE           ;MSH026
                                                                        ;MSH026
        .IFF                                                            ;MSH026
                                                                        ;MSH026
        DDT$    IP,N$$PCS                                               ;MSH026
                                                                        ;MSH026
        .ENDC                                                           ;MSH026
                                                                        ;MSH026
;                                                                       ;**-4
; QIO VERIFICATION/DISPATCH TABLE
;
; ENTRY CONSISTS OF TWO WORDS: QIO FUNCTION+FLAGS, QIO FUNCTION HANDLER
; ADDRESS
;
PCSDSP:
.IF DF  I$$PQO
 .IF DF I$$PSS

        .WORD   IO.MSO!CB, MSOUT                ; SINGLE SHOT OUTPUT

 .ENDC
 .IF DF I$$PDO

        .WORD   IO.MLO!CB, MLOUT                ; DIGITAL OUTPUT

 .ENDC
.ENDC
.IF DF I$$PRD

        .WORD   IO.RDD!CB!ALBUF!ALBYT!ALBF2, RDDIN; READ DIGITAL DATA

.ENDC
.IF DF  I$$PUI
 .IF DF I$$PCO

        .WORD   IO.CCI!ALBUF!ALBYT, COSCT       ; CONNECT COS TO BUFFER
        .WORD   IO.DCI, COSDCT                  ; DISCONNECT COS
        .WORD   IO.LDI, COSLNK                  ; LINK TASK TO COS
        .WORD   IO.UDI, COSUNL                  ; UNLINK COS

 .ENDC
 .IF DF I$$PDI

        .WORD   IO.CSI!ALBUF!ALBYT, DSICT       ; CONNECT DSI TO BUFFER
        .WORD   IO.DSI, DSIDCT                  ; DISCONNECT DSI
        .WORD   IO.LSI, DSILNK                  ; LINK TASK TO DSI
        .WORD   IO.USI, DSIUNL                  ; UNLINK DSI

 .ENDC
.IF DF  I$$PTI          ;COUNTER SUPPORT                                ;JC031
                                                                        ;JC031
        .WORD   IO.CTI!ALBUF!ALBYT,CTICT ;CONNECT CTR TO CIRC BUFFER    ;JC031
        .WORD   IO.DTI,CTIDCT           ;DISCONNECT CIRC BUFFER FROM CTR;JC031
        .WORD   IO.LTI,CTILNK           ;LINK TASK TO CTR INTERRUPTS    ;JC031
        .WORD   IO.UTI,CTIUNL           ;UNLINK TASK FROM CTR INTERRUPTS;JC031
                                                                        ;JC031
.ENDC                                                                   ;JC031
 .IF DF I$$PEF

        .WORD   IO.LEI, EFLNK                   ; LINK EF TO COS
        .WORD   IO.UEI, EFUNL                   ; UNLINK EF

 .ENDC

        .WORD   IO.NLK, UNLINK                  ; UNLINK ANY TASK
        .WORD   IO.RAD, RDACT                   ; READ ACTIVATING DATA

.ENDC

.IF DF  I$$PTI                                                          ;JC031
        .WORD   IO.ITI,CTIITI           ;SET COUNTER INITIAL VALUE      ;JC031
.ENDC                                                                   ;JC031
.IF DF  I$$PDA

        .WORD   IO.SAO,DASAO                    ; SINGLE ANALOG OUTPUT
        .WORD   IO.MAO!ALBUF!ALBYT,DAMAO        ; MULTIPLE ANALOG OUTPUT

.ENDC

.IF DF  I$$PAD!I$$P14

        .WORD   IO.RBC!ALBUF!ALBYT,ADINI        ; MULTIPLE ANALOG INPUT
        .WORD   IO.RAM!ALBUF!ALBYT,RDAMAP       ; READ ANALOG MAPPING

.ENDC

        .WORD   IO.RMT!ALBUF!ALBYT,RDMAP        ; READ MAPPING TABLE

        .WORD   0,0                             ; END OF TABLE

;
; INTERRUPT SERVICE ROUTINES FOR EACH MODULE TYPE (STARTING WITH 1)
;

.IF DF  I$$PAD!I$$P14!I$$PCO!I$$PDI!I$$PTI                              ;JC031
                                                                        ;**-1
IPSERV: .WORD   IPDISP          ; DIGI - NO INT'S FOR THIS MODULE TYPE

.IF DF I$$PCO&I$$PUI

        .WORD   COSSRV          ; COS INTERRUPTS

.IFF

        .WORD   IPDISP

.ENDC
.IF DF I$$PDI&I$$PUI

        .WORD   DSISRV          ; DSI INTERRUPTS

.IFF

        .WORD   IPDISP

.ENDC

        .WORD   IPDISP          ; DIGO - NO INT'S FOR THIS TYPE
        .WORD   IPDISP          ; SSO - NO INT'S FOR THIS TYPE
        .WORD   IPDISP          ; DAO - NO INT'S FOR THIS TYPE

.IF DF  I$$PAD

        .WORD   ADSRV1          ; A/D COMMON INTERRUPT SERVICE ENTRY    ;JC031
                                                                        ;**-1
.IFF

        .WORD   IPDISP

.ENDC
.IF DF  I$$P14

        .WORD   ADSRV1          ; A/D COMMON INTERRUPT SERVICE ENTRY    ;JC031
                                                                        ;**-1
.IFF

        .WORD   IPDISP

.ENDC
.IF DF  I$$PTI!I$$PUI                                                   ;JC031
                                                                        ;JC031
        .WORD   C08SRV          ;INTERRUPT SERVICE ENTRY FOR 8-BIT CTR  ;JC031
        .WORD   C16SRV          ;INTERRUPT SERVIVE FOR 16-BIT INPUT CTR ;JC031
        .WORD   C16SRV          ;INTERRUPT SERVICE FOR 16-BIT OUTPUT CTR;JC031
                                                                        ;JC031
.IFF                                                                    ;JC031
                                                                        ;JC031
        .WORD   IPDISP                                                  ;JC031
        .WORD   IPDISP                                                  ;JC031
        .WORD   IPDISP                                                  ;JC031
                                                                        ;JC031
.ENDC                                                                   ;JC031
.ENDC                           ; (I$$PAD!I$$P14!I$$PCO!I$$PDI)
        .PAGE                                                           ;MSH026
        .SBTTL  ONLINE-OFFLINE SWITCH ROUTINE                           ;MSH026
                                                                        ;MSH026
;       CONTROLLER STATUS CHANGE ENTRY POINT                            ;MSH026
;                                                                       ;MSH026
; INPUTS:       R2      KRB ADDRESS                                     ;MSH026
;               C=0     BRING CONTROLLER ONLINE                         ;MSH026
;               C=1     TAKE CONTROLLER OFFLINE                         ;MSH026
;                                                                       ;MSH026
; OUTPUTS:      $SCERR- UNCHANGED=SUCCESS                               ;MSH026
;                       ERROR CODE ON FAILURE                           ;MSH026
;                                                                       ;MSH026
;                                                                       ;MSH026
                                                                        ;MSH026
        .IF DF R$$MPL                                                   ;MSH026
                                                                        ;MSH026
IPKRB:  MOV     R2,R5           ;COPY KRB POINTER                       ;MSH026
        BCS     200$            ;BRANCH TO TAKE OFF-LINE                ;MSH026
                                                                        ;MSH026
        .IF DF LD$IP                                                    ;MSH026
                                                                        ;MSH026
        MOV     #<<I$$PPF+1>*2>,R1 ;#BYTES IN CONTROL TABLE             ;MSH026
        ADD     #I$$PPF,R1      ;#BYTES IN DATA TABLE                   ;MSH026
        CALL    $ALOCB          ;ALLOCATE POWER-FAIL BLOCK              ;MSH026
        BCC     100$            ;ERROR, RETURN OFF-LINE                 ;MSH026
        MOVB    #IE.UPN&377,$SCERR ;NOT ENUFF POOL FOR POWERFAIL BLOCK  ;MSH026
        RETURN                                                          ;MSH026
                                                                        ;MSH026
100$:   MOV     R1,PFLEN        ;SAVE LENGTH OF CORE BLOCK              ;MSH026
        MOV     R0,PFCTB        ;POINT TO CONTROL TABLE                 ;MSH026
        ADD     #<<I$$PPF+1>*2>,R0                                      ;MSH026
        MOV     R0,PFDTB        ;POINT TO DATA TABLE                    ;MSH026
                                                                        ;MSH026
        .IFTF                                                           ;MSH026
                                                                        ;MSH026
        CALLR   IPPWF                                                   ;MSH026
200$:                                                                   ;MSH026
        .IFT                                                            ;MSH026
                                                                        ;MSH026
        MOV     PFLEN,R1        ;GET LENGTH OF POWER-FAIL BLOCK         ;MSH026
        MOV     PFCTB,R0        ;POINT TO POWER-FAIL BLOCK              ;MSH026
        CALL    $DEACB          ;RETURN TO POOL                         ;MSH026
                                                                        ;MSH026
        .ENDC                                                           ;MSH026
                                                                        ;MSH026
        RETURN                                                          ;MSH026
                                                                        ;MSH026
        .ENDC                                                           ;MSH026
        .PAGE                                                           ;MSH026
;       UNIT ONLINE-OFFLINE STATUS CHANGE ENTRY POINT                   ;MSH026
;                                                                       ;MSH026
; INPUTS:       R3=CONTROLLER INDEX                                     ;MSH026
;               R4=SCB POINTER                                          ;MSH026
;               R5=UCB POINTER                                          ;MSH026
;                                                                       ;MSH026
;               C=0     BRING UNIT ONLINE                               ;MSH026
;               C=1     TAKE UNIT OFFLINE                               ;MSH026
;                                                                       ;MSH026
                                                                        ;MSH026
        .IF DF R$$MPL                                                   ;MSH026
                                                                        ;MSH026
IPUCB:  RETURN                  ;ALWAYS SUCCESSFUL                      ;MSH026
                                                                        ;MSH026
        .ENDC                                                           ;MSH026
        .PAGE
        .SBTTL  QIO FUNCTION VERIFICATION AND DISPATCH

; INPUTS:
; R1=I/O PACKET ADDRESS, R4=SCB ADDRESS, R5=UCB ADDRESS
;
IPINI:                                                                  ;MSH026
IPIOVF: MOV     R5,-(SP)        ; SAVE UCB ADDRESS
        MOV     R1,-(SP)        ; SAVE I/O PACKET
        MOV     I.FCN(R1),R2    ; FUNCTION CODE
        BIC     #VFBITS,R2      ; CLEAR VERIFICATION FLAGS
        ADD     #I.PRM,R1       ; GET POINTER TO PARAMETER BLOCK
        MOV     #PCSDSP,R3      ; GET POINTER TO VEROFICATION/DISPATCH TBL
10$:    MOV     (R3)+,R0        ; I/O FUNCTION+BITS
        BEQ     15$             ; END IF TABLE
        BIC     #VFBITS,R0      ; CLEAR VERIFICATION BITS
        CMP     R0,R2           ; SEE IF IT'S THE SAME CODE
        BEQ     20$             ; ..YES
        TST     (R3)+           ; ..NO--AT END OF TABLE?
        BNE     10$             ; ..NO--CHECK NEXT ENTRY
15$:    JMP     PCSIFC          ; ILLEGAL FUNCTION CODE
;
; GOT A LEGAL FUNCTION. TEST ARGUMENTS, IF REQUIRED, FOR ALIGNMENT
;
20$:    MOV     R1,R0           ; COPY ARGUMENT LIST
        MOV     -(R3),R2        ; GET THE FUNCTION
30$:    BIC     #^C7,R2         ; ISOLATE TEST BITS
40$:    BEQ     50$             ; ..WHAT TEST BITS?
        TST     (R0)+           ; SKIP RELOC BIAS IF PRESENT
        ASR     R2              ; SEE IF WE'RE TO TEST THIS ARGUMENT
        BCC     40$             ; IF CS, TEST ALIGNMENT
        BIT     #1,(R0)         ; TEST ARGUMENT ALIGNMENT
        BEQ     30$             ; SUCCEEDS
        JMP     PCSBYT          ; FAILED
;
; IO FUNCTION IS LEGAL, AND ARGUMENTS ARE OKAY.
;
50$:    MOV     I.TCB-I.PRM(R1),R0 ; COPY TCB ADDRESS
        TST     (R3)+           ; TEST FOR CONTROLLER FUNCTION
;
; CONTROLLER FUNCTION TEST ONLY APPLIES IF IO.FLN, IO.NLN FUNCTIONS ARE
; IMPLEMENTED AS IN ICS/ICR DRIVER
;
; PROCESS THE I/O FUNCTION
;
60$:    JMP     @(R3)+          ; GO
        .SBTTL  QIO FUNCTION PROCESSORS
.IF DF  I$$PQO
.IF DF  I$$PSS

        .PAGE
        .SBTTL   IO.MSO -- SINGLE SHOT OUTPUT (16 BITS)
; IO.MSO
; R0=CALLER TCB, R1=ARGUMENT BLOCK ADDRESS, R4=SCB, R5=UCB
; ARGUMENT BLOCK:       WD. 0 = STARTING POINT NUMBER
;                       WD. 1 = DATA BITS
;
MSOUT:  MOV     R1,R3           ; SAVE ARGUMENT BLOCK
        MOV     2(R3),4(R3)     ; COPY DATA MASK TO DATA BITS
        MOV     #SSO,R1         ; SET MODULE TYPE

.ENDC
.IF DF  I$$PDO

        BR      OUTCOM          ; GOTO COMMON CODE
        .PAGE
        .SBTTL   IO.MLO -- DIGITAL OUTPUT (16 BITS)
; IO.MLO
; R0=CALLER TCB, R1=ARGUMENT LIST ADDRESS, R4=SCB, R5=UCB
; ARGUMENT BLOCK:       WD.0 = STARTING POINT NUMBER
;                       WD.1 = DATA MASK
;                       WD.2 = DATA BITS (SET OR CLEAR ACC/TO MASK)
;
MLOUT:  MOV     R1,R3           ; SAVE ARGUMENT BLOCK
        MOV     #DIGO,R1        ; SET MODULE TYPE

.ENDC
.IF DF  I$$PSS ! I$$PDO
.ENABLE LSB

OUTCOM: MOV     (R3)+,R0        ; GET POINT NUMBER
        BIT     #7,R0           ; TEST FOR BYTE BOUNDARY ALIGNMENT
        BNE     30$             ; ..NOT  ON BOUNDARY                    ;JC031
        ASR     R0              ; CONVERT TO RELATIVE ENTRY NUMBER      ;**-1
        ASR     R0              ; ...
        ASR     R0              ; ...
        MOV     R0,R2           ; SAVE COPY OF RELATIVE ENTRY NUMBER
        MOV     #-1,R5          ; TELL PCSMAP TO RETURN TABLE ADDR
        CALL    PCSMAP          ; CONVERT TO PHYSICAL MODULE ADDRESS
         BCS    30$             ; ...ILLEGAL MODULE                     ;JC031
        MOVB    (R0)+,-(SP)     ; READ CURRENT MODULE VALUE             ;**-1
        TSTB    1(R3)           ; IS IT A TWO-BYTE MASK?
        BEQ     10$             ; ...NO
        CMP     R2,IPMMAX(R5)   ; TEST IF FIRST BYTE LAST IN DENSE SET
        BLT     5$              ; ..NO, NEXT SEQUENTIAL BYTE OKAY
        CLRB    1(R3)           ; ..YES, ONLY 8 BITS CHANGED
        BR      10$             ; ...
5$:     MOVB    (R0),1(SP)      ; ...YES, SET UP 16 BIT FIELD IN TEMP
10$:    BIC     (R3),(SP)       ; CLEAR OUT MASKED BITS
        COM     (R3)            ; MAKE SURE NO UNMASKED DATA BITS...
        BIC     (R3)+,(R3)      ; ...
        BIS     (R3),(SP)       ; AND REPLACE WITH DATA BITS
        COMB    -(R3)           ; TEST TWO-BYTE MASK
        BEQ     20$             ; IF EQ, ONLY ONE
        MOVB    1(SP),(R0)      ; UPDATE HIGH ORDER BYTE
20$:    MOVB    (SP)+,-(R0)     ; UPDATE LOW ORDER BYTE
        JMP     PCSDON
30$:    JMP     PCSMOD          ; (IE.MOD)                              ;JC031

.DSABL LSB
.ENDC
.ENDC                           ; (I$$PQO)
.IF DF  I$$PCO & I$$PUI

        .PAGE
        .SBTTL   IO.CCI -- CONNECT BUFFER TO COS INTERRUPTS
;
; IO.CCI
; (INPUT DATA AT CTCOM)
;
COSCT:  MOV     S.CI(R4),R3     ; GET UNSOLICITED INTERRUPT TABLE ADDR  ;JC037
                                                                        ;**-1
.ENDC
.IF DF  I$$PDI & I$$PUI

        BR      CTCOM           ; GO HANDLE.
        .PAGE
        .SBTTL   IO.CSI -- CONNECT BUFFER TO DSI INTERRUPTS
;
; IO.CSI
;
DSICT:  MOV     S.SI(R4),R3     ; GET UNSOLICITED INTERRUPT TABLE ADDR

.ENDC
.IF DF  I$$PTI&I$$PUI                                                   ;JC031
                                                                        ;JC031
        BR      CTCOM           ;BRANCH TO COMMON CODE                  ;JC031
        .PAGE                                                           ;JC031
        .SBTTL  IO.CTI -- CONNECT CIRCULAR BUFFER TO COUNTER INTERRUPTS ;JC031
;                                                                       ;JC031
;IO.CTI                                                                 ;JC031
;                                                                       ;JC031
CTICT:  MOV     S.TI(R4),R3     ;GET ADDR OF UNSOL INTERRUPT TABLE      ;JC031
        BEQ     PCMOD3          ;IF EQ NONE EXISTS                      ;JC031
        BIT     #T2.CHK!T2.FXD,T.ST2(R0) ;TASK FIXED OR CHKPTD?         ;JC031
        BEQ     PCPRI3          ;IF EQ NO ERROR                         ;JC031
        MOV     10(R1),R2       ;RETRIEVE MODULE TYPE                   ;JC031
        BEQ     10$             ; IF EQ CONNECT ALL                     ;JC031
        ASL     R2              ; FORM A WORD INDEX                     ;JC031
        MOV     $BTMSK(R2),R2   ; MAKE IT A BIT                         ;JC031
        BIT     R2,CTRTYP       ; VALID MODULE TYPE?                    ;JC031
        BEQ     PCMOD3          ; NO INFORM USER                        ;JC031
        MOV     R2,10(R1)       ; SAVE MODULE TYPE MASK IN ARG LIST     ;JC031
10$:    INCB    IMTYP(R3)       ; SET COUNTER FLAG                      ;JC031
        TST     IMTCB(R3)       ; TASK ALREADY CONNECTED?               ;JC031
        BEQ     CTCOM1          ; IF EQ NO                              ;JC031
        CMP     IMTCB(R3),R0    ; SAME TASK?                            ;JC031
        BNE     PCCON3          ; IF NE NO -ERROR                       ;JC031
        CMP     2(R1),IMSAD(R3) ; SAME BUFFER?                          ;JC031
        BNE     PCSPC3          ; IF NE NO -ERROR                       ;JC031
;                                                                       ;JC031
; SET REGISTERS FOR APPROPRIATE EXIT                                    ;JC031
;                                                                       ;JC031
        MOV     R1,R4           ; MOVE PARAM LIST TO R4                 ;JC031
        ADD     #10,R4          ; POINT TO MODULE TYPE                  ;JC031
        MOV     R0,R5           ; MOVE TCB ADDR TO R5                   ;JC031
        INCB    T.IOC(R5)       ; INC I/O COUNT FOR TASK                ;JC031
        ADD     #IMTYP,R3       ; POINT TO COUNTER FLAG WORD            ;JC031
        BR      CTRCMP          ; GO SET MODULE TYPE                    ;JC031
.ENDC                                                                   ;JC031
.IF DF  I$$PUI
.ENABL LSB

; CONNECT CIRCULAR BUFFER TO INTERRUPTS
;
; RO=CALLER TCB, R1=ARGUMENT BLOCK ADDR, R4=SCB, R5=UCB
; ARGUMENT BLOCK:       WD.0 = CIRCULAR BUF RELOCATION BIAS
;                       WD.1 = ADDRESS OF CIRCULAR BUFFER
;                       WD.2 = LENGTH OF BUFFER
;                       WD.3 = EVENT FLAG
;                       WD.4-5 NOT USED
;
CTCOM:  BEQ     PCMOD3          ; IF EQ MODULE DOES NOT EXIST HERE      ;JC031
        BIT     #T2.CHK!T2.FXD,T.ST2(R0)  ; CHECK TASK STATUS           ;**-1
        BEQ     PCPRI3          ; IF EQ TASK NOT FIXED OR CHKPTD        ;JC031
        TST     IMTCB(R3)       ; SEE IF TASK ASREADY CONNECTED         ;**-1
        BNE     PCCON3          ; IF EQ YES                             ;JC031
CTCOM1: CMP     (R1)+,(R1)+     ;  POINT TO LENGTH OF BUFFER            ;JC031
        MOVB    IMBPE(R3),R2    ; GET SIZE OF C.B. ENTRY                ;**-2
        CMP     (R2)+,(R2)+     ; ADJUST FOR HEADER
        CMP     (R1)+,R2        ; IS BUFFER BIG ENOUGH?
        BLO     PCSPC3          ; ...NO                                 ;JC031
        MOV     (R1),R2         ; GET EVENT FLAG (EF)                   ;**-1
        BEQ     PCIEF3          ; CAN'T USE EF 0                        ;JC031
        CMP     R2,#64.         ; TEST EF VALIDITY                      ;**-1
        BHI     PCIEF3          ; ...INVALID                            ;JC031
;                                                                       ;**-1
; ALL SEEMS IN ORDER. COPY DATA TO THE TABLE
;
        MOV     R1,R4           ; COPY ARG BLOCK POINTER
        SUB     #6,R4           ; POINT TO TOP
        TST     (R3)+           ; SKIP MAX POINT NUMBER
        MOVB    (R3)+,-(SP)     ; SAVE BYTES PER ENTRY
        MOVB    (SP),(R3)+      ; SET FORK NOT IN PROGRESS
        MOV     (R4),(R3)+      ; INIT STARTING BUFFER RELOC BIAS
        MOV     (R4)+,(R3)+     ; .... CURRENT BUFFER RELOC BIAS
        MOV     (R4),(R3)+      ; .... STARTING BUFFER ADDRESS
        MOV     (R4)+,(R3)      ; .... CURRENT DATA ADDRESS
        ADD     #4,(R3)         ; ADJUST
        MOV     (R3)+,(R3)+     ; CURRENT BUFFER ADDRESS
        MOV     #3,(R3)+        ; INIT FORTRAN FILL INDEX
        MOV     (R4)+,(R3)      ; SET LENGTH OF BUFFER IN BYTES
        ASR     (R3)+           ; MAKE THAT IN WORDS
        MOV     R0,R5           ; COPY TCB ADDRESS
        MOV     (R4)+,R0        ; EF
        CALL    $CEFI           ; CONVERT EVENT FLAG TO MASK ADDRESS
        MOV     R0,(R3)+        ; AND STORE
        MOV     R1,(R3)+        ; ...
        CLR     (R3)+           ; LOST DATA COUNTER
        MOV     R5,(R3)+        ; SAVE TCB ADDRESS                      ;JC031
        INCB    T.IOC(R5)       ; BIAS TASK'S OUTSTANDING I/O COUNT     ;**-1

 .IF DF D$$SHF

        MOV     T.PCB(R5),R0    ; GET ADDRESS OF PCB
        BIS     #PS.NSF,P.STAT(R0) ; INHIBIT TASK SHUFFLING

 .ENDC

        MOVB    (SP)+,R1        ; BYTES/ENTRY
        ASR     R1              ; =WORDS/ENTRY
        DEC     R1              ; ADJUST FOR EXISTENCE INDICATOR
        BIS     #3*400,R1       ; INCLUDE INITIAL FORTRAN INDEX
;                                                                       ;JC031
;THIS CODE DOES FINAL COUNTER SETUP. NOTE: FOR PROPER FUNCTIONING OF    ;JC031
; THE COMMON CODE IMTYP MUST ALWAYS BE ZERO FOR NON-COUNTER MODULE TYPES;JC031
;                                                                       ;JC031
CTRCMP: TSTB    (R3)                    ;NEED TO SETUP MODULE TYPE      ;JC031
        BEQ     50$                     ;IF EQ NO - EXIT                ;JC031
        DECB    (R3)                    ;RESET FLAG                     ;JC031
        MOV     (R4),R4                 ;MOVE MODULE TYPE TO R4         ;JC031
        BNE     40$                     ;IF EQ ALL TYPES                ;JC031
        MOV     CTRTYP,R1               ; SET R1 TO ALL CTR'S MASK WORD ;JC031
        BIC     (R3),R1                 ; CLEAR TYPES ALREADY CONNECTED ;JC031
        BIT     #MTIN08,R1              ; 8-BIT CONNECT?                ;JC031
        BEQ     10$                     ; IF EQ NO - PROCEED            ;JC031
        INCB    T.IOC(R5)               ; YES INCREMENT TASK I/O COUNT  ;JC031
10$:    BIT     #MTIN16,R1              ; 16-BIT INPUT?                 ;JC031
        BEQ     20$                     ; IF EQ NO - PROCEED            ;JC031
        INCB    T.IOC(R5)               ; YES INCREMENT TASK I/O COUNT  ;JC031
20$:    BIT     #MTOU16,R1              ; 16-BIT OUTPUT?                ;JC031
        BEQ     30$                     ; IF EQ NO PROCEED              ;JC031
        INCB    T.IOC(R5)               ; YES INCREMENT TASK I/O COUNT  ;JC031
30$:    DECB    T.IOC(R5)               ; FIX I/O COUNT                 ;JC031
        MOV     CTRTYP,R4               ; SET MASK WORD                 ;JC031
40$:    BIS     R4,(R3)                 ; SET MASK FOR CONNECTED COUNTER;JC031
50$:    JMP     PCSDN1                  ;GO                             ;JC031
;                                                                       ;JC031
; OUT OF RANGE ERRORS                                                   ;JC031
;                                                                       ;JC031
PCMOD3: JMP     PCMOD                   ; (IE.MOD)                      ;JC031
PCPRI3: JMP     PCPRI                   ; (IE.PRI)                      ;JC031
PCCON3: JMP     PCCON                   ; (IE.CON)                      ;JC031
PCSPC3: CLRB    IMTYP(R3)               ; CLEAR CTR FLAG                ;JC031
        JMP     PCSPC                   ; (IE.SPC)                      ;JC031
PCIEF3: JMP     PCIEF                   ; (IE.IEF)                      ;JC031
                                                                        ;**-1
.DSABL LSB
.ENDC                           ; (I$$PUI)
.IF DF  I$$PCO & I$$PUI

        .PAGE
        .SBTTL   IO.DCI -- DISCONNECT FROM COS
; IO.DCI
;
COSDCT: MOV     S.CI(R4),R3             ; GET UNSOL INTERRUPT TABLE ADDR;JC037
                                                                        ;**-1
.ENDC
.IF DF  I$$PDI & I$$PUI

        BR      DCTCOM          ; GO TO COMMON DISCONNECT CODE
        .PAGE
        .SBTTL   IO.DSI -- DISCONNECT FROM DSI
;
; IO.DSI
;
DSIDCT: MOV     S.SI(R4),R3     ; GET UNSOLICITED INTERRUPT TABLE

.ENDC
.IF DF  I$$PTI&I$$PUI                                                   ;JC031
        JMP     DCTCOM          ;BRANCH TO COMMON CODE                  ;JC031
                                                                        ;JC031
        .PAGE                                                           ;JC031
        .SBTTL  IO.DTI -- DISCONNECT CIRCULAR BUFFER FROM COUNTER INTERR;JC031
;                                                                       ;JC031
;IO.DTI                                                                 ;JC031
;                                                                       ;JC031
CTIDCT: MOV     S.TI(R4),R3             ;GET UNSOL INTERRUP TABLE ADDR  ;JC031
        BEQ     PCMOD                   ;IF EQ NONE EXISTS              ;JC031
        TST     IMTCB(R3)               ;CONNECTED?                     ;JC031
        BEQ     PCCON                   ;NO ERROR                       ;JC031
        MOV     (R1),R1                 ;GET MODULE TYPE TO DISCONNECT  ;JC031
        BEQ     10$                     ;IF EQ ALL                      ;JC031
        ASL     R1                      ;ADJUST FOR WORD INDEX          ;JC031
        MOV     $BTMSK(R1),R1           ;MOVE MTYP MASK BIT TO R1       ;JC031
        BIT     R1,CTRTYP               ; VALID MODULE TYPE?            ;JC031
        BEQ     PCMOD                   ; IF EQ NO                      ;JC031
        BIT     R1,IMTYP(R3)            ; THIS TYPE CONNECTED?          ;JC031
        BEQ     PCCON                   ; IF EQ NOT CONNECTED           ;JC031
        BIC     R1,IMTYP(R3)            ;CLEAR THIS MODULE TYPE         ;JC031
        BEQ     50$                     ;IF EQ ONE IS ALL               ;JC031
        DECB    T.IOC(R0)               ;OTHERWISE DEC IOC AND          ;JC031
        JMP     PCSDON                  ;EXIT                           ;JC031
10$:    MOV     #MTIN08,R1              ;SET 8-BIT CTR MASK             ;JC031
20$:    BIT     R1,IMTYP(R3)            ;IS THIS TYPE SET?              ;JC031
        BEQ     30$                     ;IF EQ NO                       ;JC031
        DECB    T.IOC(R0)               ; DECREMENT I/O COUNT           ;JC031
        BIC     R1,IMTYP(R3)            ;YES CLEAR IT                   ;JC031
        BEQ     40$                     ;IF EQ NO MORE                  ;JC031
30$:    ASL     R1                      ;RESET MTYP MASK                ;JC031
        BMI     40$                     ; CAN ONLY ARRIVE HERE          ;JC031
                                        ; IF NO COUNTERS ON SYSTEM      ;JC031
        BR      20$                     ;CHECK NEXT                     ;JC031
;                                                                       ;JC031
;                                                                       ;JC031
;                                                                       ;JC031
40$:    INCB    T.IOC(R0)               ; INCREMENT I/O COUNT BEFORE    ;JC031
                                        ; CALLING COMMON CODE BECAUSE   ;JC031
                                        ; COMMON ROUTINE WILL DECREMENT ;JC031
50$:    MOV     S.TI(R4),R3             ; RESET INTERRUPT TABLE ADDRESS ;JC031
;       ;BR     DCTCOM                  ; BRANCH TO COMMON CODE         ;JC031
.ENDC                                                                   ;JC031
.IF DF  I$$PUI

DCTCOM: CALL    DISCNC          ; DISCONNECT INDICATED CIRCULAR
         BCC    PCDON           ; (IS.SUC)
         BEQ    PCMOD           ; (IE.MOD) = MODULE ERROR
PCCON:  CLRB    IMTYP(R3)       ;RESET CTR FLAG                         ;JC031
        JMP     PCSCON          ; (IE.CON) = TASK NOT CONNECTED         ;JC031
                                                                        ;**-1
.ENDC                           ; (I$$PUI)

;
; OUT-OF-RANGE BRANCH CORRECTION
;
PCMOD:  JMP     PCSMOD
PCPRI:  JMP     PCSPRI
PCSPC:  JMP     PCSSPC          ; (IE.SPC) = PARAMETER PROBLEMS         ;JC031
PCIEF:  CLRB    IMTYP(R3)       ; RESET COUNTER FLAG                    ;JC031
        JMP     PCSIEF          ; (IE.IEF) = ILLEGAL EVENT FLAG         ;JC031
.ENABL LSB                                                              ;**-2

.IF DF  I$$PUI

        .PAGE
        .SBTTL   IO.RAD -- READ ACTIVATING DATA
;
; IO.RAD
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = ADDRESS OF USER BUFFER
;
RDACT:  BIT     #1,(R1)         ; VERIFY WORD ALIGNMENT OF BUFFER
        BNE     PCBYT1          ; (IE.BYT)                              ;JC031
        MOV     #PCTLH,R5       ; GET LINKED TASK LISTHEAD              ;**-1
10$:    MOV     (R5),R5         ; GET FIRST/NEXT ENTRY
        BEQ     PCNLK1          ; (IE.NLK) = TASK NOT LINKED            ;JC031
        CMP     R0,LTCB(R5)     ; TEST IF LINKAGE IS FOR CALLER TASK    ;**-1
        BNE     10$             ; ..NO, TRY NEXT LINKAGE
        MOV     (R1),R0         ; ..YES, GET BUFFER ADDRES
        MOV     #LLGH-LACT,R3   ;   AND COUNT

 .IF DF A$$CHK ! M$$MGE

        MOV     R3,R1           ; COPY  COUNT
        CALL    $ACHCK          ; ADDRESS CHECK USER BUFFER
         BCS    PCSPC           ; (IE.SPC) = BUFFER NOT ALL IN USER SPACE

 .ENDC
 .IF DF M$$MGE

        CALL    $RELOM          ; RELOCATE AND MAP TO USER BUFFER

 .ENDC

        ADD     #LACT,R5        ; POINT TO ACTICITY COUNT
        ASR     R3              ; MAKE WORD COUNT
        MTPS    S.PRI(R4)       ;;; LOCK OUT DEVICE
20$:    MOV     (R5),(R0)+      ;;; COPY, AND THEN...
        CLR     (R5)+           ;;; ...CLEAR EACH ENTRY
        DEC     R3              ;;; KEEP COUNT
        BNE     20$             ;;; MORE TO COME
        MTPS    #0              ; DONE

.ENDC                           ; (I$$PUI)

PCDON:  JMP     PCSDON          ; (IS.SUC)
PCBYT1: JMP     PCSBYT          ; (IE.BYT)                              ;JC031
PCNLK1: JMP     PCSNLK          ; (IE.NLK)                              ;JC031
.DSABL LSB
        .PAGE
        .SBTTL   IO.RMT -- READ PCS MAPPING TABLE
;
; IO.RMT
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = USER TABLE RELOCATION BIAS
;                       WD 1 = USER TABLE ADDRESS
;                       WD.2 = NUMBER OF BYTES IN USER TABLE
;
; FORMAT OF USER BUFFER ENTRY IS:
;
;       WD.0 = MODULE TYPE
;       WD.1 = MAXIMUM RELATIVE ENTRY NUMBER
;       WD.2 = .BYTE #ENTRIES IN DENSE SET, CONTROLLER INDEX
;       WD.3 = PHYSICAL ADDRESS OF FIRST RELATIVE ENTRY
;
RDMAP:  SUB     #RMTLG,4(R1)    ; TEST BUF SIZE
        BLT     PCBAD           ; (IE.BAD) = USER BUFFER TOO SMALL

.IF DF  M$$MGE

        MOV     (R1)+,KISAR6    ; MAP TO USER BUFFER

.IFF

        TST     (R1)+           ; SKIP NULL RELOCATION BIAS

.ENDC

        MOV     (R1)+,R3        ; START ADDRESS OF TABLE
        MOV     (R1),R2         ; BYTE COUNT
        MOV     #S.IPM,-(SP)    ; START OF MAPPING HEADERS
10$:    MOV     R4,R5           ; COPY SCB
        ADD     (SP),R5         ; GET NEXT MAP LIST
        MOV     (R5),R5         ; GET FIRST ENTRY
        BEQ     30$             ; DONE WITH THIS MODULE TYPE
20$:    MOV     IPMMOD(R5),(R3)+ ; COPY MODULE TYPE TO USER BFR
        MOV     (R5)+,R0        ; SAVE LINK
        MOV     (R5)+,R1        ; SAVE MIN ENTRY NUMBER...
        MOV     (R5),(R3)+      ; COPY MAX ENTRY # TO USER BUFFER
        NEG     R1              ; -MIN
        ADD     (R5),R1         ; CALCULATE NUMBER ENTRIES IN DENSE SET
        INC     R1              ; CONVERT TO #ENTRIES
        MOV     IPMLOW-IPMMAX(R5),-(SP) ; IPMLOW = LOW BYTE OFFSET
        CLRB    (SP)            ; MAKE ROOM FOR, THEN...
        BIS     (SP),R1         ; ...ADD CONTROLLER NUMBER TO # ENTRIES
        MOV     R1,(R3)+        ; AND SEND TO USER BUFFER
        SWAB    (SP)            ; CONTROLLER TO RIGHT HALF
        MOV     (SP)+,R1        ; CONTROLLER INDEX
        MOV     PCSBAS(R1),-(SP) ; GET BASE ADDRESS FOR THIS CONTROLLER
        MOVB$C  IPMLOW-IPMMAX(R5),R1 ; GET LOW BYTE OFFSET FOR DENSE SET
        ADD     (SP)+,R1        ; CALCULATE ABS LOW ADDRES
        MOV     R1,(R3)+        ; AND SEND TO USER BUFFER
;
; TEST FOR END OF USER TABLE
;
        SUB     #RMTLG,R2       ; ADJUST COUNT
        BLT     35$             ; LT IF DONE
        MOV     R0,R5           ; LINK TO NEXT
        BNE     20$             ; ...IF ANY
;
; DONE WITH CURRENT MODULE TYPE
;
30$:    CMP     (SP),#S.IPMX-2  ; TEST FOR END OF MAPPING LIST
        BHIS    35$             ; ...DONE
        ADD     #2,(SP)         ; NEXT MODULE TYPE
        BR      10$             ; ...GO
;
; CLEAN UP AND EXIT
;
35$:    TST     (SP)+           ; CLEAN STACK
        BR      PCDON           ; (IS.SUC)
        .PAGE
        .SBTTL  IO.RAM -- READ ANALOG MAPPING TABLE
;
; IO.RAM
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = USER TABLE RELOCATION BIAS
;                       WD.1 = USER TABLE ADDRESS
;                       WD.2 = NUMBER OF BYTES IN USER TABLE
;
; FORMAT OF USER BUFFER ENTRY IS:
;
;    FOR 12-BIT A/D CONVERTERS:
;       WD.0 = MODULE TYPE (ADI12)
;       WD.1 = MAX RELATIVE CHANNEL NUMBER ON THIS A/D
;       WD.2 = 0
;       WD.3 = PHYSICAL ADDRESS OF A/D CONTROL REGISTERS
;       WDS.4-7 = .BYTE # CHANNELS IN MUX 0, # CHANNELS IN MUX 1, ETC.
;
;    FOR 14-BIT A/D CONVERTERS:
;       WD.0 = MODULE TYPE (ADI14)
;       WD.1 = MAX RELATIVE CHANNEL NUMBER ON THIS A/D
;       WD.2 = .BYTE # CHANNELS ON A/D, 0
;       WD.3 = PHYSICAL ADDRESS OF A/D CONTROL REGISTERS
;       WDS.4-7 = UNUSED
;
; EACH A/D CONVERTER IN THE SYSTEM WILL HAVE ONE ENTRY IN THE USER
; BUFFER.  IF THERE ARE NOT ENOUGH CONVERTERS TO FILL THE BUFFER, THE
; LAST ENTRY WILL BE FOLLOWED BY A ZERO WORD (CONVERTER TYPE=0).
;

.IF DF  I$$PAD ! I$$P14

RDAMAP: SUB     #RAMLG,4(R1)    ; TEST USER BUFFER SIZE
        BLT     PCBAD           ; (IE.BAD) = USER BUFFER TOO SMALL

 .IF DF M$$MGE

        MOV     (R1)+,KISAR6    ; MAP TO USER BUFFER

 .IFF

        TST     (R1)+           ; SKIP NULL RELOCATION BIAS

 .ENDC

        MOV     (R1)+,R3        ; START ADDRESS OF USER BUFFER
        MOV     (R1),R2         ; BYTE COUNT
        MOV     S.ADC(R4),R5    ; POINT R5 AT ADC TABLE
        BEQ     PCDON           ; IF NONE, WE ARE DONE
        ADD     #ADCONV,R5      ; POINT AT INDIVIDUAL CONVERTER ENTRIES
        MOV     #16.,R1         ; THIS IS LOOP COUNTER
        MOV     #255.,-(SP)     ; THIS IS MAX CHANNEL # ON ADC
10$:    MOV     (R5)+,R0        ; POINT R0 AT AN ADC ENTRY
        BEQ     35$             ; IF EQ NONE, TRY NEXT
        MOVB    ADTYP(R0),(R3)+ ; STORE CONVERTER TYPE
        CLRB    (R3)+           ; CLEAR HIGH BYTE OF THAT
        MOV     (SP),(R3)+      ; MOVE MAXIMUM CHANNEL NUMBER

 .IF DF I$$PAD
  .IF DF I$$P14

        CMPB    ADTYP(R0),#ADI14 ; IS THIS A 14-BIT A/D?
        BEQ     20$             ; IF EQ YES

  .IFTF                         ; (I$$P14)

        CLR     (R3)+           ; CLEAR WD.2
        MOV     (R0),(R3)+      ; COPY BUS ADDRESS
        ADD     #ADMUX,R0       ; POINT AT MUX ADDRESSES
        .REPT   4
        MOV     (R0)+,(R3)+     ; COPY # CHANNELS ON EACH MUX
        .ENDR

  .IFT                          ; (I$$P14)

        BR      30$             ; GO COPY NEXT A/D

  .ENDC                         ; (I$$P14)
 .ENDC                          ; (I$$PAD)
 .IF DF I$$P14

20$:    MOVB    ADCHN(R0),(R3)+ ; COPY # CHANNELS ON THIS A/D
        CLRB    (R3)+           ; CLEAR HIGH BYTE OF THAT WORD
        MOV     (R0),(R3)+      ; COPY BUS ADDRESS OF A/D
        ADD     #RAMLG-10,R3    ; SKIP OVER UNUSED WORDS

 .ENDC

30$:    ADD     #256.,(SP)      ; UPDATE MAX CHANNEL NUMBER
        SUB     #RAMLG,R2       ; UPDATE COUNT OF BYTES IN BUFFER
        BLT     40$             ; IF LT DONE, CLEAN UP AND EXIT
        CLR     (R3)            ; FOLLOW ENTRY WITH ZERO AS A TERMINATOR
35$:    DEC     R1              ; COUNT CONVERTERS
        BNE     10$             ; LOOP TO TRY THE NEXT ONE
40$:    TST     (SP)+           ; POP MAX CHANNEL OFF STACK
        BR      PCSDON          ; (IS.SUC)

.ENDC                           ; (I$$PAD!I$$P14)


;
; OUT-OF-RANGE BRANCH CORRECTION
;
PCBYT:  BR      PCSBYT
PCNLK:  BR      PCSNLK
PCBAD:  BR      PCSBAD
        .PAGE
        .SBTTL   IO.RDD -- READ DIGITAL DATA
.IF DF  I$$PRD
.ENABL LSB
;
; IO.RDD
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = CONTROL BLOCK RELOCATION BIAS
;                       WD.1 = CONTROL BLOCK ADDRESS
;                       WD.2 = BYTE COUNT FOR CONTROL BLOCK
;                       WD.3 = DATA BLOCK ADDRESS (UNRELOCATED)
;
RDDIN:  MOV     R1,R3           ; COPY ARG BLOCK
        CMP     (R3)+,(R3)+     ; POINT TO SIZE
        MOV     R3,-(SP)        ; SAVE ARG BLOCK WD.2 ADDRESS

.IF DF  A$$CHK ! M$$MGE

        MOV     (R3)+,R1        ; GET SIZE
        ASR     R1              ; MAKE BYTE OFFSET FOR DATA BLOCK
        MOV     (R3),R0         ; GET DATA BUFFER ADDRESS
        CALL    $ACHCK          ; ADDRESS-CHECK IT
         BCS    90$             ; ERROR--NOT IS USER'S ADDR SPACE

 .IF DF M$$MGE

        CALL    $RELOC          ; RELOCATE DATA BLOCK

 .IFF

        MOV     R0,R2           ; BUFFER
        CLR     R1              ; RELOCATION BIAS

 .ENDC
.IFF                            ; (A$$CHK!M$$MGE)

        TST     (R3)+           ; SKIP OVER SIZE
        MOV     (R3),R2         ; GET ADDRESS OF BUFFER
        CLR     R1              ; FAKE RELOCATION BIAS

.ENDC                           ; (A$$CHK!M$$MGE)

        MOV     R1,U.BUF(R5)    ; SAVE DATA BUF ADDR IN UCB...
        MOV     R2,U.BUF+2(R5)  ; ...FOR USE BY $PTBYT SUBROUTINE
        MOV     -(R3),R2        ; GET THE COUNTER
        ASR     R2              ; MAKE IN WORD OFFSET
        ASR     R2              ; ..
        TST     -(R3)           ; BACK UP ARG BLOCK POINTER

.IF DF  M$$MGE

        MOV     -2(R3),KISAR6   ; MAP TO CONTROL BUFFER

.ENDC

        MOV     (R3),R3         ; GET BUFFER ADDRESS
10$:    MOV     (R3)+,R1        ; GET MODULE TYPE
        MOV     (R3)+,R0        ; GET REL ENTRY NUMBER
        CALL    PCSMAP          ; CONVERT TO HARDWARE ADDRESS
         BCS    80$             ; BAD MODULE
        .IF DF  I$$PTI                                                  ;JC031
                                                                        ;JC031
        CMP     #IN16,-2(R3)    ; 16-BIT INPUT COUNTER?                 ;JC031
        BEQ     20$             ; IF EQ YES READ IT                     ;JC031
        CMP     #OU16,-2(R3)    ; 16-BIT OUTPUT COUNTER?                ;JC031
        BNE     30$             ; IF NE NO - CHECK FOR 8-BIT            ;JC031
20$:    MOVB    1(R0),R1        ; READ HIGH BYTE FIRST                  ;JC031
        MOVB    (R0),-(SP)      ; NOW READ LOW                          ;JC031
        CALL    $PTBYT          ; PUT LOW BYTE IN FIRST                 ;JC031
        MOVB    R1,-(SP)        ; SET HIGH BYTE                         ;JC031
        CALL    $PTBYT          ; AND SEND TO USER                      ;JC031
        BR      50$             ; CHECK FOR MORE TO DO                  ;JC031
30$:    CMP     #IN08,-2(R3)    ; 8-BIT COUNTER?                        ;JC031
        BNE     40$             ; IF NE NO - GO READ DATA               ;JC031
        MOVB    -(R3),R1        ; 8-BIT COUNTER - NEED TO SELECT        ;JC031
        BICB    #^C<3>,R1        ;THE APPROPRIATE RELATIVE DEVICE       ;JC031
        BISB    R1,(R0)+        ; NUMBER WITHIN THE MODULE BEFORE       ;JC031
                                ; READING IT                            ;JC031
                                                                        ;JC031
        .ENDC                   ;(I$$PTI)                               ;JC031
                                                                        ;JC031
40$:    MOVB    (R0)+,-(SP)     ; PUSH DATA BYTE                        ;JC031
        CALL    $PTBYT          ; SEND DATA TO USER BUFFER              ;**-1
        CLR     -(SP)           ; PUT OUT SECOND BYTE OF 0
        CALL    $PTBYT          ; ..SINCE OUTPUT IS 1WD/ENTRY
50$:    DEC     R2              ; KEEP COUNT                            ;JC031
        BNE     10$             ; MORE TO COME                          ;**-1
        MOV     #IS.SUC&377,R0  ; SET SUCCESS EXIT
        BR      95$             ; ...AND GO
80$:    MOV     #IE.MOD&377,R0  ; MODULE NOT CONFIGURED--ERROR

.IF DF  A$$CHK ! M$$MGE

        BR      95$             ; GO

90$:    MOV     #IE.SPC,R0      ; ADDRESS SPACE ERROR
        MOV     -(R3),R2        ; GET COUNT
        ASR     R2              ; ...CONVERT TO WORDS

.ENDC

95$:    MOV     @(SP)+,R1       ; GET INITIAL COUNT
        ASR     R1              ; IN WORDS,
        SUB     R2,R1           ; AND CALCULATE FINAL COUNT
        BR      PCSDN2          ; EXIT WITH ERR IN R0, COUNT IN R1

.DSABL LSB
.ENDC                           ; (I$$PRD)
        .SBTTL   QIO FUNCTION COMMON EXITS
        .LIST MEB

ERREX$  <CON,IEF,PRI,SPC,NST,RSU,NOD>

ERREX$  <MOD,BYT,BAD,NLK>

.NLIST MEB

PCSIFC: MOV     #IE.IFC&377,R0

PCSCOM: CLR     R1              ; CLEAR SECOND WORD OF I/O STATUS
        BR      PCSDN2

PCSDON: CLR     R1              ; CLEAR SECOND WORD OF I/O STATUS
PCSDN1: MOV     #IS.SUC&377,R0  ; SELECT SUCCESS EXIT CODE
PCSDN2: MOV     (SP)+,R3        ; RESTORE I/O PACKET ADDRESS
        MOV     (SP)+,R5        ; RESTORE UCB ADDRESS
        CALLR   $IOFIN          ; FINISH UP AND EXIT
.IF DF  I$$PUI
.ENABL LSB
 .IF DF I$$PEF

        .PAGE
        .SBTTL   IO.LEI -- LINK EVENT FLAGS TO COS INTERRUPTS
;
; IO.LEI
;
; RO = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = EVENT FLAG
;                       WD.1 = STARTING POINT
;                       WD.2 = RESOURCE MASK
;                       WD.3-5 NOT USED
;
EFLNK:  CMP     (R1),#64.-8.    ; VALIDATE EF
        BHI     PCSIEF          ; (IE.IEF) =  ILLEGAL EVENT FLAG
        MOV     2(R1),10(R1)    ; COPY POINT NUMBER TO WD.4
        MOV     4(R1),12(R1)    ; COPY COS MASK TO WD.5
        BEQ     PCSMOD          ; (IE.MOD) = MODULE ERROR-NO POINTS
        CMP     (R1),#32.       ; SEE IF ANY LOCAL EVENT FLAGS LINKED
        BLO     5$              ; ..YES
        CLR     R0              ; NO, DON'T STORE TCB
5$:     MOV     R0,2(R1)        ; SAVE TCB IN WD.1
        MOV     S.CI(R4),R2     ; GET ADDRESS OF UNSOL INT TBL          ;JC037
        BEQ     PCSMOD          ; ...WHAT TABLE?                        ;**-1
        BR      10$             ; GO TO COMMON HANDLER

 .ENDC
 .IF DF I$$PDI

        .PAGE
        .SBTTL   IO.LSI -- LINK TASK TO DSI INTERRUPTS
;
; IO.LSI
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = TASK NAME
;                       WD.1 = TASK NAME
;                       WD.2 = NOT USED
;                       WD.3 = EVENT FLAG
;                       WD.4 = STARTING POINT NUMBER
;                       WD.5 = COS MASK
;

DSILNK:                         ; REFERENCE
  .IF DF I$$PEF

        CLR     4(R1)           ; FLAG AS A TASK LINKAGE

  .ENDC
        MOV     S.SI(R4),R2     ; GET UNSOLICITED INTERRUPT TABLE
        BEQ     PCSMOD          ; (IE.MOD)
        MOV     #DSI,R5         ; SET UP AS DSI MODULE TYPE
        BR      20$             ; GO TO COMMON CODE

 .ENDC                          ; (I$$PDI)
.IF DF  I$$PTI                                                          ;JC031
                                                                        ;JC031
        .PAGE                                                           ;JC031
        .SBTTL  IO.LTI -- LINK TASK TO COUNTER INTERRUPTS               ;JC031
;                                                                       ;JC031
;IO.LTI                                                                 ;JC031
;                                                                       ;JC031
CTILNK:                                                                 ;JC031
  .IF DF  I$$PEF                                                        ;JC031
        CLR     4(R1)           ;FLAG AS A TASK LINKAGE                 ;JC031
  .ENDC                                                                 ;JC031
                                                                        ;JC031
        MOV     S.TI(R4),R2     ;GET UNSOLICITED INTERRUPT TABLE        ;JC031
        BEQ     PCSMOD          ; IF EQ MODULE ERROR (IE.MOD)           ;JC031
        MOV     12(R1),R5       ; GET MODULE TYPE                       ;JC031
        ASL     R5              ; MAKE IT WORD INDEX                    ;JC031
        MOV     R5,R0           ; SAVE IT                               ;JC031
        MOV     $BTMSK(R5),R5   ; GET MODULE TYPE FLAG MASK             ;JC031
        BIT     R5,CTRTYP       ; VALID MODULE TYPE?                    ;JC031
        BEQ     PCSMOD          ; IF EQ NO (IE.MOD)                     ;JC031
        ADD     #S.IPM-2,R0     ; CALCULATE ADDRESS OF MAPPING..        ;JC031
        ADD     R4,R0           ; ..TABLE POINTER                       ;JC031
3$:     MOV     (R0),R0         ; GET FIRSR/NEXT ENTRY                  ;JC031
        BEQ     PCSMOD          ; BAD MODULE (IE.MOD)                   ;JC031
        CMP     10(R1),IPMMAX(R0) ; DEVICE NUMBER IN RANGE?             ;JC031
        BHI     3$              ; NO CHECK NEXT                         ;JC031
        MOV     IPMMAX(R0),IMAX(R2) ; YES SET MAX REL DEVICE NO. IN TBLE;JC031
        MOV     12(R1),R5       ; RETRIEVE MODULE TYPE                  ;JC031
        CMP     #IN08,IPMMOD(R0) ; IS THIS AN 8-BIT COUNTER?            ;JC031
        BNE     6$              ; IF NE NO - CONTINUE                   ;JC031
        MOVB    10(R1),12(R1)   ; SET ARG = REL DEVICE NO.              ;JC031
        BIC     #^C<3>,12(R1)   ; CLEAR ALL BUT DEVICE WITHIN DEVICE VAL;JC031
6$:     MOV     10(R1),R0       ; RETRIEVE RELATIVE DEVICE NUMBER       ;JC031
        INCB    IMTYP(R2)       ; SET COUNTER PROCESSING FLAG           ;JC031
        BR      25$             ; CONTINUE                              ;JC031
.ENDC                                                                   ;JC031
 .IF DF I$$PCO

        .PAGE
        .SBTTL   IO.LDI -- LINK A TASK TO COS INTERRUPTS
;
; IO.LDI
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = TASK NAME
;                       WD.1 = TASK NAME
;                       WD.2 = NOT USED
;                       WD.3 = EVENT FLAG
;                       WD.4 = STARTING POINT NUMBER
;                       WD.5 = COS MASK
;
COSLNK:                         ; REFERENCE
  .IF DF I$$PEF

        CLR     4(R1)           ; FLAG AS A TASK LINKAGE

  .ENDC
 .ENDC                          ; (I$$PCO)
 .IF DF I$$PCO ! I$$PEF

10$:    MOV     S.CI(R4),R2     ; GET ADDRESS OF UNSOL INT TBL          ;JC031
        BEQ     PCSMOD          ;(IE.MOD) MODULE TYPRE NOT DEFINED      ;JC031
        MOV     #COS,R5         ; SET UP MODULE TYPE                    ;**-1

 .ENDC

20$:    MOV     10(R1),R0       ; GET STARTING POINT AND VALIDATE
        BIT     #7,R0           ; ..MUST BE ON A BYTE BOUNDARY
        BNE     PCSMOD          ; (IE.MOD)
        CMP     R0,(R2)         ; COMPARE LIMITS
        BHI     PCSMOD          ; (IE.MOD) -- OUT OF RANGE
        ASR     R0              ; CONVERT TO RELATIVE ENTRY NUMBER
        ASR     R0              ; ...
        ASR     R0              ; ...
25$:    MOV     R1,R3           ; SAVE ARGUMENT BLOCK ADDRESS           ;JC031
        MOV     R5,R1           ; MODULE TYPE                           ;**-1
        MOV     R0,R5           ; SAVE RELATIVE ENTRY NUMBER
        CALL    PCSMAP          ; FIND PHYSICAL BYTE ADDRESS
         BCS    93$             ; BAD MODULE                            ;JC037
;                                                                       ;**-1
; NOW R0 = PHYSICAL BYTE ADDRESS, R1 = CONTROLLER INDEX, R2 = INT.
; TABLE, R3 = ARGUMENT BLOCK, R4 = SCB, R5 = RELATIVE ENTRY NUMBER
;
  .IF DF I$$PUN

        ASL     R1              ; DOUBLE-WORD INDEX
        ADD     R1,R2           ; BIAS INT TABLE ADDRESS FOR CONTROLLER

  .ENDC

        ADD     #IMLH,R2        ; POINT TO RESOURCE LISTHEAD
        MOV     R2,R1           ; COPY IT
30$:    MOV     (R1),R1         ; GET FIRST/NEXT RESOURCE LINKAGE
        BEQ     40$             ; NOT LINKED
        CMPB    R0,ILPBA(R1)    ; TEST IF LINKAGE IS FOR SAME BYTE
        BNE     30$             ; ..NO, KEEP CHECKING
        .IF DF I$$PTI                                                   ;JC031
                                                                        ;JC031
        TSTB    IMTYP-IMLH(R2)  ; COUNTER PROCESSING?                   ;JC031
        BEQ     35$             ; IF EQ NO                              ;JC031
        CMPB    12(R3),ILRES(R1) ; RESOURCE OVERLAP?                    ;JC031
        BNE     30$             ; IF NE NO - CHECK NEXT                 ;JC031
        JMP     103$            ; EXIT - (IE.RSU) RESOURCE IN USE       ;JC031
                                                                        ;JC031
        .ENDC                                                           ;JC031
                                                                        ;JC031
35$:    BITB    12(R3),ILRES(R1) ; RESOURCE OVERLAP?                    ;JC031
        BEQ     30$             ; NO KEEP CHECKING                      ;JC031
        JMP     103$            ; (IE.RSU) = RESOURCE IN USE            ;JC031
;                                                                       ;**-3
; RESOURCE NOT IN USE. VALIDATE TASK OR EF
;
40$:    MOV     R3,R1           ; SAVE ARG BLOCK ADDRESS
        MOV     R0,-(SP)        ; SAVE PHYSICAL BYTE ADDRESS
        MOVB    12(R3),1(SP)    ; GRAFT COS BYTE TO H/W ADDR OFFSET
        MOV     R2,-(SP)        ; SAVE LISTHEAD

  .IF DF I$$PCO ! I$$PDI
   .IF DF I$$PEF

        TST     4(R3)           ; SEE IF THIS IS EVENT FLAG LINKAGE
        BNE     60$             ; BRANCH IF YES

   .ENDC

        CALL    $SRSTD          ; SEE IF TASK IS IN TCB LIST
         BCS    100$            ; ..IT ISN'T
        CMP     6(R3),#64.      ; VALIDATE EVENT FLAG
        BHI     101$            ; ..NOT VALID
;
; R0=TCB, R1=R3=ARG BLOCK, R2=LISTHEAD, R4=SCB
; (SP) = COS/REL ADDRESS
;
        MOV     R5,-(SP)        ; SAVE RELATIVE ENTRY NUMBER
        MOV     R0,R5           ; COPY TCB
        MOV     6(R3),R0        ; GET EF
        CALL    $CEFI           ; CONVERT EF TO MASK AND ADDRESS
        MOV     R0,(R3)+        ; ..AND STORE IN ARG BLOCK
        MOV     R1,(R3)+
        MOV     (SP)+,(R3)      ; SAVE RELATIVE ENTRY IN ARG BLK
        CMP     -(R3),-(R3)     ; BACK TO TOP OF ARG BLOCK
;
; LOOK FOR TASK IN TASK LINKAGE QUEUE
;
        MOV     #PCTLH,R0       ; GET TASK LINKAGE LISTHEAD
45$:    MOV     (R0),R0         ; GET FIRST/NEXT ENTRY
        BEQ     50$             ; NOT LINKED YET
        CMP     R5,LTCB(R0)     ; TEST IF THIS IS RIGHT LINKAGE
        BNE     45$             ; ..NO, KEEP CHECKING
        MOV     R0,R5           ; ..YES, SAVE ADDR OF TASK LINKAGE ENTRY
        BR      70$             ; ...
;
; TASK NOT LINKED YET-ALLOCATE AND INITIALIZE AN ENTRY
;
50$:    MOV     #LLGH+ILGH,R1   ; SIZE OF TASK LINKAGE + RESOURCE LINKAGE
        CALL    $ALOCB          ; GO ALLOCATE IT
         BCS    102$            ; ..NO SPACE AVAILABLE
        CLR     (R0)            ; INIT LINK
        MOV     R0,@PCTLH+2     ; LINK IT TO END
        MOV     R0,PCTLH+2      ; ...AND TO LISTHEAD.
        MOV     R5,LTCB(R0)     ; SAVE TCB
        CLR     LUSE(R0)        ; INIT USE COUNT
        CLR     LACT(R0)        ; INIT ACTIVITY COUNT
        MOV     R0,R5           ; TASK LINKAGE ADDR SAVED
        ADD     #LLGH,R0        ; ..AND CALC ADDR OF RESOURCE LINKAGE
        BR      80$             ; ..GO

  .ENDC                         ;(I$$PCO!I$$PDI)
  .IF DF I$$PEF

60$:    MOV     R5,4(R3)        ; STORE RELATIVE ENTRY IN ARG BLK
        CLR     R5              ; FLAG "TASK LINKAGE ADDR"

  .IFTF

; R2=LISTHEAD, R4=SCB, R5=TASK LINKAGE ADDR OR 0(EF),
; (SP)=BYTE/RESOURCE WORD
;
70$:    MOV     #ILGH,R1        ; NEED TO ALLOCATE BLOCK OF THIS SIZE
        CALL    $ALOCB          ; FOR RESOURCE LINKAGE.
         BCS    102$            ; ..NO BUFFERS AVAILABLE
;
; INITIALIZE THE RESOURCE LINKAGE ENTRY
;
80$:    MOV     (SP)+,R2        ; RESTORE LISTHEAD ADDRESS
        CLR     (R0)+           ; LINK
        MOV     (SP)+,(R0)+     ; STORE PHYSICAL BYTE OFFSET/RES MASK
        MOV     R5,(R0)+        ; STORE TCB LINKAGE OR 0 IF EF LINK

  .IFT                          ; (I$$PEF)

        BNE     85$             ; IF NE, MUST BE TASK LINKAGE
        MOV     (R3),-(R0)      ; REPLACE WITH EF*2+1
        SEC                     ; ...
        ROL     (R0)+           ; ...

  .ENDC                         ; (I$$PEF)

85$:    MOV     (R3)+,(R0)+     ; EF MASK OR EF
        MOV     (R3)+,(R0)+     ; EF ADDRESS OR TCB ADDRESS
        CLR     (R0)+           ; RUN FLAG
        MOV     (R3),(R0)+      ; RELATIVE ENTRY NUMBER
        SUB     #ILGH-2,R0      ; BACK TO THE TOP

   .IF DF  I$$PCO!I$$PDI!I$$PTI                                         ;JC031
   .IF DF I$$PEF                                                        ;**-1

        TST     R5              ; SEE IF EF LINKAGE
        BEQ     90$             ; YES

   .ENDC

        INC     LUSE(R5)        ; COUNT THE RESOURCE LINK IN TASK LINK

  .IFTF                         ; (I$$PCO!I$$PDI)

90$:    MTPS    S.PRI(R4)       ;;; INHIBIT DEVICE INTERRUPTS
        MOV     R0,@2(R2)       ;;; UPDATE LAST RESOURCE LINK
        MOV     R0, 2(R2)       ;;; UPDATE TAIL POINTER
        MTPS    #0              ; ENABLE INTERRUPTS
        CLRB    IMTYP-IMLH(R2) ; CLEAR COUNTER FLAG                     ;JC037
PCDON1: JMP     PCSDON          ; (IS.SUC)
93$:    CLRB    IMTYP(R2)       ; CLEAR CTR FLAG                        ;JC037
        JMP     PCSMOD          ; EXIT (IE.MOD)                         ;JC037

  .IFT

100$:   CMP     (SP)+,(SP)+     ; CLEAN STACK
        CLRB    IMTYP-IMLH(R2)  ; CLEAR CTR FLAG                        ;JC037
        JMP     PCSNST          ; (IE.NST) - TASK NOT INSTALLED

101$:   CMP     (SP)+,(SP)+
        CLRB    IMTYP-IMLH(R2)  ; CLEAR CTR FLAG                        ;JC037
        JMP     PCSIEF          ; (IE.IEF) - ILLEGAL EVENT FLAG

  .ENDC                         ; (I$$PCO!I$$PDI)

102$:   CMP     (SP)+,(SP)+     ; CLEAR STACK
        CLRB    IMTYP-IMLH(R2)  ; CLEAR CTR FLAG                        ;JC037
        JMP     PCSNOD          ; (IE.NOD) - NO DYNAMIC BUFFERS
103$:   CLRB    IMTYP-IMLH(R2)  ; CLEAR COUNTER FLAG                    ;JC037
        JMP     PCSRSU          ;EXIT (IE.RSU)                          ;JC037

.DSABL LSB
.ENDC                           ; (I$$PUI)
.IF DF  I$$PUI
.ENABL LSB

 .IF DF I$$PEF

        .PAGE
        .SBTTL   IO.UEI - UNLINK EVENT FLAGS FROM COS
;
; IO.UEI
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = EVENT FLAG OR -1
;
; IF ARGUMENT IS -1, ALL EVENT FLAG LINKAGES ARE TO BE REMOVED.
;
EFUNL:  MOV     (R1),R1         ; GET EVENT FLAG
        BMI     COSUNL          ; IF -1, PASS DIRECTLY TO COMMON CODE
        SEC                     ; ELSE PASS AS EF*2+1 FOR MATCHING
        ROL     R1              ; IN THE RESOURCE LINKAGES

 .ENDC
 .IF DF I$$PCO ! I$$PEF

        .PAGE
        .SBTTL   IO.UDI - UNLINK TASK FROM COS INTERRUPTS
;
; IO.UDI
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0-1 = TASK NAME
;
COSUNL: MOV     #S.CI,R2        ; GET UNSOL INT TBL FOR COS             ;JC037
                                                                        ;**-1
 .ENDC
 .IF DF I$$PDI

        BR      UNLCOM          ; GO TO COMMON CODE
        .PAGE
        .SBTTL   IO.USI - UNLINK TASK FROM DIGITAL SENSE INTERRUPTS
;
; IO.USI
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0-1 = TASK NAME
;
DSIUNL: MOV     #S.SI,R2        ; GET UNSOLICITED TABLE FOR DSI

 .ENDC
                                                                        ;JC031
.IF DF  I$$PTI                                                          ;JC031
        BR      UNLCOM          ; BRANCH TO COMMON CODE                 ;JC031
        .PAGE                                                           ;JC031
        .SBTTL  IO.UTI -- UNLINK TASK FROM COUNTER INTERRUPTS           ;JC031
;                                                                       ;JC031
;IO.UTI                                                                 ;JC031
;                                                                       ;JC031
CTIUNL: MOV     4(R1),R3        ; RETRIEVE MODULE TYPE                  ;JC031
        BEQ     5$              ; IF EQ ALL TYPES                       ;JC031
        ASL     R3              ; MAKE WORD INDEX                       ;JC031
        MOV     $BTMSK(R3),R3   ; GET CTR MASK BIT                      ;JC031
        BIT     R3,CTRTYP       ; VALID MODULE TYPE?                    ;JC031
        BEQ     PCMOD4          ; IF EQ NO (IE.MOD)                     ;JC031
        MOV     S.TI(R4),R2     ; GET UNSOL TABLE ADDRESS               ;JC031
        MOVB    4(R1),IMTYP(R2) ; SAVE MODULE TYPE FOR LATER USE        ;JC031
5$:     MOV     #S.TI,R2        ; SET FOR COMMON UNLINK ROUTINE         ;JC031
                                                                        ;JC031
.ENDC                                                                   ;JC031
                                                                        ;JC031
;                                                                       ;JC031

UNLCOM: CALL    PCSUNL          ; UNLINK COMMON ROUTINE
        MOV     U.CW2(R5),R2    ; RETRIEVE LISTHEAD                     ;JC037
        CLRB    IMTYP(R2)       ; CLEAR COUNTER FLAG                    ;JC037
PCCOM:  JMP     PCSCOM          ; EXIT
PCMOD4: JMP     PCSMOD          ; (IE.MOD)                              ;JC031
.ENABL LSB
        .PAGE
        .SBTTL   IO.NLK - UNLINK TASK FROM ALL UNSOLICITED INTERRUPTS
;
; IO.NLK
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0-1 = TASK NAME
;
UNLINK: CLR     -(SP)           ; SAVE RESULT FLAG ON STACK
        MOV     #S.CI,R2        ; DEFINE TABLE FOR COS MODULES          ;JC037
        CALL    PCSUNL          ; UNLINK TASK FROM COS                  ;**-1
         BCS    30$             ; ERROR
         BMI    10$             ; NOT LINKED
        INC     (SP)            ; FLAG SUCCESS
10$:    MOV     #S.SI,R2        ; DEFINE TABLE FOR DSI MODULES
        CALL    PCSUNL          ; UNLINK TASK FROM DSI
         BCS    30$             ; ERROR
        BMI     20$             ; NOT LINKED                            ;JC031
        INC     (SP)            ; FLAG SUCCESS                          ;JC031
20$:    MOV     #S.TI,R2                ; DEFINE TABLE FOR CTR MODULES  ;JC031
        CALL    PCSUNL          ; UNLINK TASK FROM COUNTERS             ;JC031
         BCS    30$             ; ERROR                                 ;JC031
         BMI    30$             ; NOT LINKED                            ;JC031
        INC     (SP)            ; FLAG SUCCESS                          ;JC031
30$:    TST     (SP)+           ; CHECK FOR SUCCESS                     ;**-2
        BNE     PCDON1          ; IS.SUC EXIT
        BR      PCCOM           ; IE.NLK = TASK NOT LINKED

.DSABL LSB
.IF DF  I$$PTI                                                          ;JC031
                                                                        ;JC031
        .PAGE                                                           ;JC031
        .SBTTL  IO.ITI -- SET INITIAL COUNTER VALUE                     ;JC031
;                                                                       ;JC031
;IO.ITI                                                                 ;JC031
; INPUTS:                                                               ;JC031
;       R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB        ;JC031
; ARGUMENT BLOCK:   WD0 = MODULE TYPE, WD1 = RELATIVE DEVICE NUMBER     ;JC031
;                   WD3 = COUNTER VALUE                                 ;JC031
;                                                                       ;JC031
CTIITI: MOV     (R1),R0         ; RETRIEVE MODULE TYPE                  ;JC031
        ASL     R0              ; MAKE WORD INDEX                       ;JC031
        MOV     $BTMSK(R0),R0   ; GET CTR MASK WORD VALUE               ;JC031
        BIT     R0,CTRTYP       ; VALID COUNTER TYPE                    ;JC031
        BEQ     PCMOD4          ; NO ILLEGAL MODULE TYPE                ;JC031
        MOV     R1,R3           ; SAVE ARGUMENT BLOCK POINTER           ;JC031
        MOV     (R3),R1         ; SET MODULE TYPE IN R1                 ;JC031
        MOV     2(R3),R0        ; AND RELATIVE DEVICE ENTRY IN R0       ;JC031
        CALL    PCSMAP          ; CONVERT TO PHYSICAL ADDRESS           ;JC031
         BCS    PCMOD4          ; INVALID MODULE                        ;JC031
        CMP     #IN08,(R3)+     ; 8-BIT COUNTER?                        ;JC031
        BNE     10$             ; NO - MUST BE 16 - SET IT              ;JC031
        TST     2(R3)           ; IF 8-BIT CTR VALUE MUST BE ZERO       ;JC031
        BNE     PCMOD4          ; NOT ZERO ERROR (IE.MOD)               ;JC031
        MOV     (R3)+,R1        ; RETRIEVE RELATIVE DEVICE NUMBER       ;JC031
        BICB    #^C<3>,R1       ; CLEAR ALL BUT DEVICE WITHIN DEVICE BIT;JC031
        BISB    R1,(R0)+        ; SELECT APPROPRIATE COUNTER            ;JC031
        MOVB    (R3),(R0)       ; CLEAR COUNTER                         ;JC031
        JMP     PCSDN1          ; EXIT SUCCESS                          ;JC031
10$:    MOVB    3(R3),1(R0)     ; SET HIGH ORDER BYTE FIRST             ;JC031
        MOVB    2(R3),(R0)      ; NOW LOW BYTE                          ;JC031
        JMP     PCSDN1          ; EXIT SUCCESS                          ;JC031
                                                                        ;JC031
.ENDC                           ;(I$$PTI)                               ;JC031
                                                                        ;JC031
.ENDC                           ; (I$$PUI)
        .PAGE
        .SBTTL  IO.SAO -- SINGLE ANALOG OUTPUT
;
.IF DF  I$$PDA
.ENABL LSB

;
; IO.SAO
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
; ARGUMENT BLOCK:       WD.0 = CHANNEL
;                       WD.1 = VOLTAGE (10 BIT) TO BE OUTPUT
;
DASAO:  MOV     (R1)+,R0        ; GET THE CHANNEL
        MOV     (R1),R1         ; GET THE VOLTAGE
        CALL    DAOUT           ; OUTPUT IT
         BCS    1$              ; (ERROR-IE.MOD)
        JMP     PCSDON          ; DONE

1$:     JMP     PCSMOD
        .PAGE
        .SBTTL  IO.MAO -- MULTIPLE ANALOG OUTPUTS
;
; IO.MAO
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
;
; ARGUMENT BLOCK:       WD.0 = CHANNEL TABLE RELOCATION BIAS
;                       WD.1 = CHANNEL TABLE ADDRESS
;                       WD.2 = SIZE OF TABLES IN BYTES
;                       WD.3 = VOLTAGE TABLE VIRTUAL ADDRESS
;                       WD. 4-5 UNUSED
;
DAMAO:  MOV     R1,R3           ; COPY ARG BLOCK POINTER
        CMP     (R3)+,(R3)+     ; POINT TO WD.2 = SIZE
        MOV     (R3),-(SP)      ; SAVE INITIAL BYTE COUNT

.IF DF  A$$CHK ! M$$MGE

        MOV     (R3)+,R1        ; GET SIZE
        MOV     (R3),R0         ; ..AND ADDR OF VOLTAGE TABLE
        CALL    $ACHCK          ; CHECK ITS LIMITS
         BCS    90$             ; LIMIT ERROR - IE.SPC

.IF DF  M$$MGE

        CALL    $RELOC          ; RELOCATE VOLTAGE BLOCK

.IFF

        MOV     R0,R2           ; COPY VOLTAGE TABLE ADDRESS

.ENDC                           ; (M$$MGE)
.IFF                            ; (A$$CHK!M$$MGE)

        TST     (R3)+           ; SKIP OVER SIZE
        MOV     (R3),R2         ; GET VOLTAGE TABLE ADDRESS

.ENDC

        ASR     -(R3)           ; CONVERT BYTE COUNT TO WORD COUNT
        BEQ     85$             ; ERROR--TOO FEW BYTES
        MOV     -2(R3),R5       ; GET ADDRESS OF CHANNEL TABLE

.IF DF  M$$MGE

        MOV     R1,2(R3)        ; SAVE VOLTAGE TABLE RELOC BIAS
                                ;  IN I/O PACKET

.IFTF

20$:                            ; REFERENCE LABEL FOR LOOP

.IFT                            ; (M$$MGE)

        MOV     -4(R3),KISAR6   ; MAP TO CHANNEL TABLE

.IFTF

        MOV     (R5)+,R0        ; GET NEXT CHANNEL

.IFT

        MOV     2(R3),KISAR6    ; MAP TO VOLTAGE TABLE

.IFTF

        MOV     (R2)+,R1        ; GET NEXT VOLTAGE
        CALL    DAOUT           ; PROGRAM IT (R0=CHANNEL, R1=VOLTAGE)
         BCS    80$             ; MODULE ERROR

.IFT                            ; (M$$MGE)

        BIT     #20000,R5       ; TEST IF TABLE ADDR CROSSES 4K
        BEQ     30$             ;  BOUNDARY, BEQ IF NOT
        BIC     #20000,R5       ; YES, CORRECT MAP TO USE SAME APR
        ADD     #200,-4(R3)     ; ALSO CORRECT RELOC BIAS
30$:    BIT     #20000,R2       ; SAME TEST FOR VOLTAGE TABLE
        BEQ     40$             ; ...
        BIC     #20000,R2       ; ...
        ADD     #200,2(R3)      ; ...
40$:                            ; REFERENCE LABEL

.ENDC                           ; (M$$MGE)

        DEC     (R3)            ; KEEP COUNT OF TABLE ENTRIES
        BNE     20$             ; ..CONTINUING
;
; DONE WITH TABLE, NO ERRORS DETECTED.
;
        MOV     #IS.SUC&377,R0  ; SET SUCCESS RETURN
        BR      95$             ; ..
;
; VARIOUS ERROR CONDITIONS
;
80$:    MOV     #IE.MOD&377,R0  ; MODULE ERROR
        BR      95$

85$:    MOV     #IE.BYT&377,R0  ; TABLE ERROR OR SIZE ERROR
        BR      95$

.IF DF  A$$CHK ! M$$MGE

90$:    MOV     IE.SPC&377,R0   ; TABLE ADDRESS CHECK
        TST     (SP)+           ; SET RETURN COUNT TO ZERO
        CLR     R1
        BR      100$            ; ..

.ENDC

95$:    MOV     (SP)+,R1        ; GET INITIAL BYTE COUNT
        ASR     R1              ; ..TO WORD COUNT
        SUB     (R3),R1         ; FIND FINAL COUNT
100$:   JMP     PCSDN2          ; GO

.DSABL LSB

.ENDC                           ; (I$$PDA)
        .PAGE
        .SBTTL  IO.RBC - READ BLOCK OF A/D CHANNELS

.IF DF  I$$PAD!I$$P14

;
; IO.RBC
;
; R0 = CALLER TCB, R1 = ARGUMENT BLOCK, R4 = SCB, R5 = UCB
;
; ARGUMENT BLOCK:       WD.0 = DATA BUFFER RELOCATION BIAS
;                       WD.1 = DATA BUFFER ADDRESS
;                       WD.2 = NUMBER OF BYTES IN DATA BUFFER
;                       WD.3 = CONTROL BUFFER ADDRESS
;                       WD.4-5 UNUSED
;
; CONTROL WORD FORMAT:  <0-4> = CHANNEL NUMBER
;                       <5-7> = MUX NUMBER (MBZ ON A020 CHANNELS)
;                       <8-11> = A/D CONVERTER INDEX
;                       <12-15> = GAIN (MBZ ON A020 CHANNELS)
;
ADINI:  TST     S.ADC(R4)       ; IS THERE AN A/D ON THIS PCS?
        BEQ     PCMOD2          ; IF EQ NO, ERROR

 .IF DF A$$CHK ! M$$MGE

        MOV     6(R1),R0        ; GET VIRTUAL ADDR OF CNTRL BFR
        MOV     4(R1),R1        ; GET SIZE OF CNTRL/DATA BFRS
        CALL    $ACHCK          ; CHECK CONTROL BUFFER LIMITS
        BCS     PCSPC2          ; IF SET, LIMIT ERROR - IE.SPC

  .IF DF        M$$MGE

        CALL    $RELOC          ; RELOCATE AND MAP BUFFER

  .IFF                          ; (M$$MGE)

        MOV     R0,R2           ; PLACE BUFFER POINTER IN R2

  .ENDC                         ; (M$$MGE)
 .IFF                           ; (A$$CHK!M$$MGE)

        MOV     6(R1),R2        ; GET CONTROL BUFFER ADDRESS

 .ENDC                          ; (A$$CHK!M$$MGE)

        MOV     (SP),R3         ; RETRIEVE I/O PACKET ADDRESS
        ADD     #I.PRM+4,R3     ; POINT TO BYTE COUNT (CARRY CLEARED)
        ROR     (R3)+           ; CONVERT IT TO A WORD COUNT
        MOV     R1,(R3)+        ; STORE CONTROL BUFFER ADDRESS IN PACKET
        MOV     R2,(R3)+        ; ...
        .PAGE
;
; NOW, QUEUE UP THE PACKET, SINCE THE PROCESSING MAY BE HUNG UP ON
; A PREVIOUS PACKET.  IF IT IS THE FIRST ONE, IT WILL IMMEDIATELY BE
; DEQUEUED AGAIN WHEN WE CALL $GTPKT.
;
        MOV     (SP)+,R1        ; GET I/O PACKET ADDRESS AGAIN
        MOV     R4,R0           ; SET ADDRESS OF QUEUE LISTHEAD
        CALL    $QINSP          ; INSERT I/O PACKET IN QUEUE
        MOV     (SP)+,R5        ; SET R5=UCB ADDR AND CLEAN STACK
;
; THE FOLLOWING CODE IS EXECUTED WHEN A QIO REQUEST IS FIRST ISSUED,
; AND ALSO WHEN A PREVIOUS A/D REQUEST HAS BEEN FINISHED.
;
ADGPK:  CALL    $GTPKT          ; GET NEXT I/O PACKET
        BCC     ADRQ            ; IF CARRY CLEAR, WE GOT ONE!
        RETURN                  ; CONTROLLER IS BUSY.  RETURN TO CALLER
                                ; WITH REQUEST STILL QUEUED.  FOLLOWING
                                ; NEXT INTERRUPT, IF CURRENT PACKET IS
                                ; FINISHED, NEXT WILL BE DEQUEUD AT FORK
                                ; LEVEL.
;
; OUT-OF-RANGE BRANCH CORRECTION
;
PCMOD2: JMP     PCSMOD
PCSPC2: JMP     PCSSPC
;
; HERE, WE HAVE GOTTEN A PACKET AND THE CONTROLLER IS (PRESUMABLY)
; NOT BUSY.  INITIATE A/D CONVERSION(S) REQUESTED IN IT, STOPPING WHEN
; A BUSY CHANNEL IS ENCOUNTERED.
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;       R1 ->   I/O PACKET
;       R2 =    PCS UNIT NUMBER
;       R3 =    CONTROLLER INDEX
;       R4 ->   SCB
;       R5 ->   UCB
;
; THE I/O PACKET ARGUMENT BLOCK CONTAINS THE FOLLOWING PARAMETERS:
;       WD.0 =  RELOCATION BIAS OF DATA BUFFER
;       WD.1 =  ADDRESS OF DATA BUFFER
;       WD.2 =  WORD COUNT
;       WD.3 =  RELOCATION BIAS OF CONTROL BUFFER
;       WD.4 =  ADDRESS OF CONTROL BUFFER
;
ADRQ:   MOV     I.PRM+6(R1),U.CBF(R5) ; COPY CONTROL BFR ADDR TO UCB
        MOV     I.PRM+10(R1),U.CBF+2(R5) ; ...
        MOV     S.ADC(R4),R3    ; POINT R3 AT A/D MASTER TABLE
        CLR     ADFBC(R3)       ; CLEAR FINAL BYTE COUNT
        CLR     ADNXT(R3)       ; CLEAR NEXT CONVERSION ADDRESS
;
; TOP OF PACKET LOOP.  GET A CONTROL WORD AND INITIATE CONVERSION.
;
CNVRT:  CALL    $GTCWD          ; GET NEXT A/D CONTROL WORD ONTO STACK
        MOV     (SP),R0         ; ...AND ALSO GET IT INTO R0
        BIC     #170000,R0      ; REMOVE GAIN BITS FROM R0 TO GET CHAN
        MOV     S.ADC(R4),R3    ; GET MASTER A/D TABLE ADDRESS
        CMP     R0,(R3)         ; IS CHANNEL WITHIN LIMITS?
        BGT     10$             ; IF GT NO, ERROR                       ;JC031
;                                                                       ;**-1
; LOCATE ADC ENTRY FOR THIS CONVERTER (BITS 8-11 OF CHANNEL)
;
        MOV     R0,R1           ; COPY CHANNEL SO WE DONT CLOBBER IT
        SWAB    R1              ; RIGHT-JUSTIFY ADC NO.
        ASL     R1              ; MAKE IT INTO A WORD INDEX FOR TABLE
        BIC     #^C37,R1        ; REMOVE GARBAGE BITS
        ADD     #ADCONV,R1      ; INDEX INTO ADC POINTER LIST
        ADD     R3,R1           ; ...
        MOV     (R1),R1         ; R1 NOW POINTS AT A/D CONVERTER ENTRY
        BNE     15$             ; IF EQ NONE, BAD CHANNEL               ;JC031
10$:    JMP     ADMOD           ; ERROR                                 ;JC031
15$:                                                                    ;JC031
;                                                                       ;**-1
; NOW VERIFY THE CHANNEL-WITHIN-MUX NUMBER AGAINST THE MAXIMUM
; CHANNEL ON THE SELECTED MUX
;

 .IF DF I$$PAD & I$$P14

        CMPB    ADTYP(R1),#ADI12 ; IS THIS A 12-BIT CONVERTER?
        BNE     20$             ; IF NE NO, MUST BE 14-BITTER

 .ENDC
 .IF DF I$$PAD

        MOV     R0,R2           ; R2 WILL GET MUX #
        ASL     R2              ; RIGHT-JUSTIFY MUX #
        ASL     R2              ; ...
        ASL     R2              ; ...
        SWAB    R2              ; ...
        BIC     #^C7,R2         ; R2 NOW HAS MUX NO.
        ADD     R1,R2           ; POINT R2 AT MAX # CHANS FOR MUX
        ADD     #ADMUX,R2       ; ...
        BIC     #^C37,R0        ; ISOLATE CHANNEL IN R0
        CMPB    R0,(R2)         ; IS THE CHANNEL LEGAL ON THE MUX?
        BHIS    ADMOD           ; IF HIS NO, ILLEGAL CHANNEL
        BIT     #ILGAIN,(SP)    ; IS THE GAIN AN ILLEGAL VALUE?
        BNE     ADBAD           ; IF NE YES, BAD GAIN
        BIC     #7400,(SP)      ; CLEAR ADC # FROM CONTROL WORD
        BIS     #400,(SP)       ; SET "GO" BIT IN CONTROL

 .ENDC
 .IF DF I$$PAD & I$$P14

        BR      ADUNBL          ; RE-ENTER COMMON CODE

 .ENDC
 .IF DF I$$P14

20$:    CMPB    R0,ADCHN(R1)    ; IS THIS CHANNEL LEGAL?
        BHIS    ADMOD           ; IF HIS NO, ITS TOO BIG
        BIT     #170000,R0      ; IS THE GAIN PARAMETER ZERO?
        BNE     ADBAD           ; IF NE NO, ILLEGAL
        BIC     #^C17,(SP)      ; CLEAR ALL BUT CHANNEL IN CNTRL WORD

 .ENDC

;
; IF CONVERTER ISN'T BUSY, START THE CONVERSION.  ELSE SAVE DATA
; FOR LATER CONVERSION.
;
; AT THIS POINT, THE REGISTERS AND STACK ARE AS FOLLOWS:
;
;       R1 -> ADC ENTRY, R3 -> A/D CONVERTER TABLE FOR UNIT,
;       R4 -> SCB, R5 -> UCB
;       00(SP) = MODIFIED CONTROL WORD (READY TO ISSUE)
;       02(SP) = RETURN ADDRESS
;
ADUNBL: MTPS    #PR6            ;;; LOCK OUT DEVICE INTERRUPTS
        BIT     #1,(R1)         ;;; TEST DEVICE-BUSY FLAG
        BEQ     10$             ;;; IF EQ, NOT BUSY
        INCB    ADFR(R3)        ;;; BUSY, SET FORK REQUEST FLAG
        MOV     R1,ADNXT(R3)    ;;; SET PTR TO NEXT ADC ENTRY TO USE
        MOV     (SP)+,ADNXC(R3) ;;; SAVE CONTROL WORD TO ISSUE
        BR      XITPR0          ;;; RETURN TO CALLER, TRY LATER

10$:    INC     (R1)            ;;; SET DEVICE BUSY BIT
        MTPS    #0              ;;; AND THEN RE-ENABLE DEVICE INTERRUPTS
;
; HERE WE HAVE A CONVERSION TO INITIATE.  CONTROL WORD IS ON THE
; STACK.
;
        MOV     (R1),R2         ; R2 = ADDR+1 OF A/D CONVERTER
        INCB    ADIP(R3)        ; BUMP IN-PROGRESS COUNT

 .IF DF I$$PAD & I$$P14

        CMPB    ADTYP(R1),#ADI12 ; IS THIS A 12-BIT A/D?
        BNE     20$             ; IF NE NO, MUST BE 14 BITS

 .ENDC
 .IF DF I$$PAD

        MOV     U.BUF(R5),ADUAD(R1) ; SAVE DATA BUFFER ADDRESS IN ENTRY
        MOV     U.BUF+2(R5),ADUAD+2(R1) ; ...FOR BENEFIT OF INTERRUPTS
        MOVB    (SP),2-1(R2)    ; SELECT MUX AND CHANNEL
        SWAB    (SP)            ; POSITION GAIN AND GO BIT
        MOVB    (SP)+,3-1(R2)   ; PROGRAM GAIN AND MAKE IT GO!

 .ENDC
 .IF DF I$$PAD & I$$P14

        BR      FINAD           ; GO FINISH UP WITH CONVERSION

 .ENDC
 .IF DF I$$P14

20$:    MOV     R1,R0           ; POINT R0 AT BFR ADDR TABLE
        ADD     #ADUADS,R0      ; ...
        MOV     #4,-(SP)        ; PUSH LOOP COUNTER
        MTPS    #PR6            ;;; LOCKOUT INTERRUPTS TO AVOID SHUFFLES
30$:    TST     2(R0)           ;;; IS THIS ENTRY IN USE?
        BEQ     40$             ;;; IF EQ NO, WE CAN USE IT
        ADD     #4,R0           ;;; IN USE, BUMP POINTER
        DEC     (SP)            ;;; COUNT PASSES
        BGT     30$             ;;; LOOP IF NOT DONE
        ADD     #-4,R0          ;;; TABLE FULL, CLOBBER LAST ENTRY
                                ;;; ****NOTE**** ABOVE LOOP SHOULD NOT
                                ;;; EXIT TO THIS INSTRUCTION UNLESS
                                ;;; THERE IS A BUG OF SOME SORT
        CRASH                   ;;; CRASH SYSTEM SO WE FIND OUT ABOUT IT
40$:    TST     (SP)+           ;;; POP COUNT OFF STACK
        MOV     U.BUF(R5),(R0)+ ;;; COPY USER BUFFER ADDR INTO TABLE
        MOV     U.BUF+2(R5),(R0)+ ;;; ...
        MTPS    #0              ;;; NOW WE CAN RE-ALLOW INTERRUPTS
        MOVB    (SP)+,2-1(R2)   ; SELECT CHANNEL AND MAKE IT GO!
        BITB    #200,3-1(R2)    ; IS THAT THE LAST ONE IT CAN TAKE NOW?
        BNE     50$             ; IF NE YES, IT'S FULLY BUSY
        DEC     (R1)            ; NO, RESET BUSY BIT IN A/D ENTRY
50$:

 .ENDC

;
; THE CONVERSION HAS BEEN STARTED AND WILL INTERRUPT WITH DATA AT SOME
; FUTURE TIME.  IN THE INTERIM, WE WILL STEP THE BUFFER ADDRESS, COUNT
; THE CONVERSION, AND ATTEMPT TO INITIATE ANOTHER CONVERSION.
;
FINAD:  MOVB    S.ITM(R4),S.CTM(R4) ; ENABLE DEVICE TIMEOUT
        MOV     R5,R2           ; GET UCB POINTER
        ADD     #U.BUF+2,R2     ; POINT AT ADDR PART OF U.BUF
        ADD     #2,(R2)+        ; BUMP THE BUFFER POINTER
        DEC     (R2)            ; DECREMENT WORD COUNT (U.CNT)
        BLE     ADOK            ; IF DONE, GO FINISH THINGS UP

 .IF DF M$$MGE

        BIT     #20000,-(R2)    ; TEST FOR 4K OVERFLOW OF ADDR
        BEQ     60$             ; IF EQ, NO OVFLW: INITIATE NEW CNVRT   ;JC031
        BIC     #20000,(R2)     ; OVERFLOW:  RESET TO APR6 OFFSET       ;**-1
        ADD     #200,-(R2)      ; AND ADJUST ADDRESS BIAS

 .ENDC

60$:    JMP     CNVRT           ; GO INITIATE A NEW CONVERSION IF POSS. ;JC031
                                                                        ;**-1


; LINKAGES TO OUT-OF-RANGE BRANCHES
;
PCMOD1: JMP     PCSMOD

PCSPC1: JMP     PCSSPC



; EXIT CONDITIONS -- ENTERED WITH R4 -> SCB, R5 -> UCB, R3 -> A/D
;       CONVERTER TABLE ENTRY, 0(SP) = CONTROL WORD, 2(SP) = RETURN
;
ADMOD:  MOV     #IE.MOD&377,R0  ; IE.MOD = BAD CHANNEL NUMBER
        BR      ADPOP

ADBAD:  MOV     #IE.BAD&377,R0  ; IE.BAD = BAD GAIN CODE

ADPOP:  TST     (SP)+           ; POP CONTROL WORD FROM STACK
        BR      ADFORK          ; GO SEE ABOUT FORKING



; EXIT POINTS BELOW HERE HAVE THE SAME REGISTERS, BUT THE STACK
;       HAS ALREADY BEEN CLEANED.
;
ADOK:   MOV     #IS.SUC&377,R0  ; SET SUCCESS CODE

ADFORK: MTPS    #PR6            ;;; LOCK OUT DEVICE INTERRUPTS
        ASSUME  ADFR&1,EQ,0     ;;;
        ASSUME  ADIP,EQ,ADFR+1  ;;;
        MOV     ADFR(R3),R2     ;;; ****NOTE**** THAT THIS WORD CONTAINS
                                ;;; BOTH ADFR AND ADIP, SO WE ARE
                                ;;; ACTUALLY TESTING BOTH AT ONCE!  IF
                                ;;; EITHER IS NONZERO, THERE IS STILL
                                ;;; AT LEAST ONE INTERRUPT PENDING, SO
                                ;;; WE CAN'T FINISH THE PACKET YET.
        BEQ     20$             ;;; IF EQ, NOTHING IS PENDING
        INCB    ADFR(R3)        ;;; PENDING, ENSURE WE WILL FORK
20$:    MTPS    #0              ;;; RE-ENABLE DEVICE INTERRUPTS
        MOV     R0,ADSTS(R3)    ; SAVE RETURN STATUS FOR LATER
        TST     R2              ; ANY INTERRUPTS PENDING?
        BEQ     ADRLSP          ; IF EQ NO, WE CAN RELEASE PACKET

XITPR0: MTPS    #0              ;;; RE-ENABLE DEVICE INTERRUPTS
        RETURN                  ; RETURN TO OUR CALLER
;
; COME HERE WHEN THE I/O PACKET IS COMPLETELY FINISHED AND THERE ARE
; NO MORE INTERRUPTS PENDING.  R3, R4, AND R5 ARE AS ABOVE IN EXITS.
;
ADRLSP: MOV     ADFBC(R3),R1    ; GET COUNT OF SUCCESSFUL CONVERSIONS
        MOV     ADSTS(R3),R0    ; GET FINAL REQUEST STATUS
        CALL    $IODON          ; FINISH THE PACKET OFF
        JMP     ADGPK           ; GO TRY TO FIND ANOTHER PACKET.

 .ENDC                          ; (I$$PAD!I$$P14)
        .PAGE
        .SBTTL  PCS INTERRUPT SERVICE
.ENABL LSB

;+
; **- PCS INTERRUPT SERVICE
;-

$IPINT::                        ;;; REF

.IF DF  I$$PAD!I$$P14!I$$PCO!I$$PDI!I$$PTI                              ;JC031
                                                                        ;**-1
        INTSV$  IP,PR6,N$$PCS,TMP ;;; SAVE R4,R5 AND CONTROLLER INDEX

 .IF GT <N$$PCS-1>

        MOV     R4,TMP          ;;; STORE CONTROLLER INDEX

 .IFTF

        MOV     U.SCB(R5),R4    ;;; GET SCB ADDRESS

  .IF DF I$$PUN

        MOV     TMP,R5          ;;; SCB MAY HAVE WRONG CSR ADDRESS, SO
        MOV     PCSBAS(R5),R5   ;;; ..CALCULATE IT FROM TABLE OF BASE
        BIS     #377,R5         ;;; ..ADDRESSES

  .IFF

        MOV     S.CSR(R4),R5    ;;; GET CSR ADDRESS

  .ENDC

        TSTB    (R5)            ;;; VERIFY THAT READY BIT IS SET
        BPL     5$              ;;; ERROR-DISMISS INTERRUPT
        JSR     R3,SAVER        ;;; SAVE R3-R0 (CO-ROUTINE)
        MOVB$C  -1(R5),R3       ;;; READ IAR CONTENTS
        MOV     R3,-(SP)        ;;; ..AND SAVE MODULE OFFSET

 .IFT

        MOV     TMP,R1          ;;; GET CONTROLLER NUMBER
        ADD     PCSBAS(R1),R3   ;;; GET BASE ADDRESS OF CONTROLLER

 .IFF

        ADD     PCSBAS,R3       ;;; CONTROLLER=0

 .ENDC

        BISB    #GBIT,(R5)      ;;; SET GENERIC CODE
        MOVB$C  (R3),R0         ;;; READ GENERIC CODE
        BICB    #GBIT,(R5)      ;;; CLEAR
        CALL    FGCENT          ;;; FIND GENERIC CODE TBL ENTRY (R2)
         BCS    10$             ;;; BCS IF FOUND IT
        BISB    #RIF,(R5)       ;;; CLEAR INTERRUPT
        TSTB    (R3)            ;;; ...
IPDISP: TST     (SP)+           ;;; OOPS-ERROR
5$:     RETURN                  ;;; DISMISS INTERRUPT

10$:    MOVB    GCMOD(R2),R0    ;;; GET MODULE TYPE
        MOV     R0,R1           ;;; MODULE TYPE TO R1                   ;JC031
        ASL     R1              ;;; MAKE WORD INDEX                     ;JC031
        JMP     @IPSERV-2(R1)   ;;; GO TO INT SRV FOR MODULE TYPE       ;JC031
        .PAGE                                                           ;**-54
        .SBTTL   DIGITAL MODULE INTERRUPT SERVICE
.DSABL LSB

.ENABL LSB

.IF DF  I$$PCO
;+
; **- COSSRV = CHANGE OF STATE DIGITAL INTERRUPT SERVICE
;-
; R0 = MODULE TYPE, R4 = SCB, R5 = CSR                                  ;JC031
; (SP) = IAR CONTENTS                                                   ;JC031
; PROCESSOR AT PCS PRIORITY                                             ;JC031
;                                                                       ;JC031
COSSRV: MOVB$C  2(R3),R2        ;;; READ COS DATA BEFORE CLEARING       ;JC031
        BISB    #RIF,(R5)       ;;; CLEAR INTERUUPT                     ;JC031
        CLR     R1              ;;; CLEAR R1                            ;JC031
        BISB    (R3),R1         ;;; READ DATA AND CLEAR INTERRUPT       ;JC031
        MOV     S.CI(R4),R5     ;;; GET ADDR OF UNSOLICITED INT TABLE   ;JC031
                                                                        ;**-5
 .IF DF I$$PDI

        JMP     COMSRV          ;;; GO TO COMMON HANDLER                ;JC031
                                                                        ;**-1
 .ENDC
.ENDC                           ;;; (I$$PCO)
.IF DF  I$$PDI

;+
; **- DSISRV = DIGITAL SENSE INTERRUPT MODULE SERVICE
;-
;
; R0 = MODULE TYPE, R3 = MODULE ADDRESS, R4 = SCB                       ;JC031
; R5 = CSR, (SP) = IAR CONTENTS                                         ;JC031
; PS AT PR6                                                             ;JC031
;                                                                       ;JC031
DSISRV: BISB    #RIF,(R5)       ;;; CLEAR INTERRUPT                     ;JC031
        CLR     R1              ;;; CLEAR R1                            ;JC031
        BISB    (R3),R1         ;;; READ DATA AND CLEAR INTERRUPT       ;JC031
        MOV     S.SI(R4),R5     ;;; GET ADR OF UNSOLICITED INT TABLE    ;JC031
        MOV     #377,R2         ;;; GET FAKE COS DATA                   ;**-5
;
; CALCULATE RELATIVE BYTE OFFSET FOR THIS INPUT
;
        TST     S.COS(R4)       ;;; SEE IF A HISTORY TABLE EXISTS
        BEQ     3$              ;;; ...NO, COS=377                      ;JC031
        MOV     R3,-(SP)        ;;; SAVE WORK REG'S                     ;**-1
        MOV     R1,-(SP)        ;;; ..
        MOVB$C  4(SP),R1        ;;; COPY BYTE OFFSET
        MOV     R0,R2           ;;; .AND MODULE TYPE

 .IF GT N$$PCS-1

        MOV     TMP,R3          ;;; GET CONTROLLER INDEX

 .IFF

        CLR     R3              ;;; CONTROLLER INDEX

 .ENDC

        CALL    PH2REL          ;;; CALCULATE RELATIVE OFFSET
        BCC     5$              ;;; LEGAL
        CMP     (SP)+,(SP)+     ;;; ILLEGAL-CLEAR STACK
        BR      IPDISP          ;;; EXIT
;
3$:     JMP     COMSRV          ;;; GO TO COMMON HANDLER                ;JC031
; NOW SAVE CURRENT VALUE IN HISTORY TABLE AND CALCULATE WHICH
; BITS HAVE CHANGED STATE SINCE THE LAST INTERRUPT.
;
5$:     ADD     S.COS(R4),R3    ;;; GET ADDRESS OF SAVED BYTE
        MOVB$C  (R3),R2         ;;; GET LAST SAVED BYTE
        MOV     (SP),R1         ;;; GET CURRENT VALUE OF DATA
        MOVB    R1,(R3)         ;;; ..AND SAVE IN THE TABLE SLOT
        BIC     R2,(SP)         ;;; FOLLOWING THREE INSTRUCTIONS ARE XOR
        BIC     R1,R2           ;;; ..TO GET BITS WHICH HAVE CHANGED
        BIS     (SP)+,R2        ;;; ..SINCE LAST INTERRUPT IN R2
        MOV     (SP)+,R3        ;;; RESTORE R3

.ENDC
.IF DF  I$$PTI                                                          ;JC031
        BR      COMSRV          ; BRANCH TO COMMON SERVICE              ;JC031
                                                                        ;JC031
        .PAGE                                                           ;JC031
        .SBTTL  COUNTER INTERRUPT SERVICE ROUTINE                       ;JC031
;                                                                       ;JC031
;+                                                                      ;JC031
; **- C08SRV = 8-BIT INPUT COUNTER INTERRUPT HANDLING                   ;JC031
;-                                                                      ;JC031
;                                                                       ;JC031
; R0 = MODULE TYPE, R3 = MODULE ADDRESS, R4 = SCB                       ;JC031
; R5 = CSR, (SP) = IAR CONTENTS                                         ;JC031
; PS = PR6                                                              ;JC031
;                                                                       ;JC031
C08SRV: BISB    #RIF,(R5)       ;;; CLEAR INTERRUPT                     ;JC031
        CLR     R1              ;;; CLEAR R1                            ;JC031
        BISB    (R3),R1         ;;; READ STATUS AND CLEAR INTERRUPT     ;JC031
        MOV     R0,-(SP)        ;;; SAVE MODULE TYE                     ;JC031
        CLR     R2              ;;; SET TO CALC DEVICE NO.              ;JC031
        MOV     #20,R0          ;;; SET TO CHECK FOR REL DEVICE 0       ;JC031
C10$:   BIT     R0,R1           ;;; THIS ONE INTERRUPT?                 ;JC031
        BNE     C20$            ;;; IF NE YES - GO READ IT              ;JC031
        INC     R2              ;;; SET FOR NEXT                        ;JC031
        ASL     R0              ;;; REPOSITION BIT                      ;JC031
        BR      C10$            ;;; CHECK NEXT                          ;JC031
C20$:   BISB    R2,(R3)+        ;;; SELECT COUNTER                      ;JC031
        BISB    (R3),R1         ;;; READ COUNTER                        ;JC031
        MOV     (SP)+,R0        ;;; RESTORE R0                          ;JC031
        BR      CTISRV          ;;; BRANCH TO COMMON COUNTER PROCESSING ;JC031
;                                                                       ;JC031
;                                                                       ;JC031
;                                                                       ;JC031
;+                                                                      ;JC031
; **- C16SRV - 16-BIT COUNTER INTERRUPT SERVICE HANDLING                ;JC031
;-                                                                      ;JC031
;                                                                       ;JC031
; R0 = MODULE TYPE, R3 = MODULE ADDRESS, R4 = SCB                       ;JC031
; R5 = CSR, (SP) = IAR CONTENTS                                         ;JC031
; PS = PR6                                                              ;JC031
;                                                                       ;JC031
C16SRV: BISB    #RIF,(R5)       ;;; CLEAR INTERRUPT ENABLE              ;JC031
        CLR     R1              ;;; CLEAR R1                            ;JC031
        BISB    1(R3),R1        ;;; READ HIGH ORDER BYTE FIRST          ;JC031
        SWAB    R1              ;;; POSITION IT                         ;JC031
        BISB    (R3),R1         ;;; READ LOW BYTE                       ;JC031
        MOV     R0,R2           ;;; SET R2 FOR RESOURCE CHECKS          ;JC031
;                                                                       ;JC031
;+                                                                      ;JC031
; **- CTISRV - COMMON COUNTER INTERRUPT SERVICE PROCESSING              ;JC031
;-                                                                      ;JC031
;                                                                       ;JC031
CTISRV: MOV     S.TI(R4),R5     ;;; UNSOLICITED INTERRUPT TABLE ADDRESS ;JC031
        MOV     R2,-(SP)        ;;; SAVE OFFSET/MODULE TYPE AND..       ;JC031
        MOV     R0,-(SP)        ;;; MODULE TYPE                         ;JC031
        CLR     RUN             ;;; CLEAR FORK PROCESS FLAG             ;JC031
 .IF DF I$$PUN                                                          ;JC031
                                                                        ;JC031
        MOV     TMP,R0          ;;; GET CONTROLLER INDEX                ;JC031
        ASL     R0              ;;; MAKE IT A DOUBLE INDEX              ;JC031
        ADD     R5,R0           ;;; AND USE TO BIAS UNSOL INT TBL ADDR  ;JC031
                                                                        ;JC031
 .IFF                                                                   ;JC031
                                                                        ;JC031
        MOV     R5,R0           ;;; COPY UNSOL INT TABLE ADDR           ;JC031
 .ENDC                                                                  ;JC031
                                                                        ;JC031
        ADD     #IMLH,R0        ;;; GET RESOURCE LINKAGE LISTHEAD       ;JC031
B10$:   MOV     (R0),R0         ;;; GET FIRST/NEXT LINKAGE LISTHEAD     ;JC031
        BEQ     B50$            ;;; END OF LIST OR NO LINKAGE           ;JC031
        CMPB    4(SP),ILPBA(R0) ;;; RESOURCE LIST FOR THIS DEVICE?      ;JC031
        BNE     B10$            ;;; IF NE NO CHECK NEXT                 ;JC031
        CMPB    R2,ILRES(R0)    ;;; FOR THIS DEVICE WITHIN DEVICE?      ;JC031
        BNE     B10$            ;;; IF NE NO CHECK NEXT                 ;JC031
        INCB    ILRUN(R0)       ;;; FLAG LINKAGE                        ;JC031
        INC     RUN             ;;; FORK PROCESS NEEDED                 ;JC031
        MOV     ILTE(R0),R3     ;;; GET TASK LINKAGE ENTRY ADDRESS      ;JC031
        ADD     #LACT,R3        ;;; POINT TO ACTIVATION ENTRY           ;JC031
        TST     (R3)            ;;; CHECK ACTIVATION COUNT              ;JC031
        BNE     B30$            ;;; TABLE IN USE                        ;JC031
        INC     (R3)+           ;;; SET IN USE NOW                      ;JC031
                                                                        ;JC031
 .IF GT N$$PCS-1                                                        ;JC031
                                                                        ;JC031
        MOV     TMP,(R3)+       ;;; SAVE CONTROLLER INDEX               ;JC031
 .IFF                                                                   ;JC031
                                                                        ;JC031
        CLR     (R3)+           ;;; CONTROLLER INDEX=0                  ;JC031
 .IFTF                                                                  ;JC031
                                                                        ;JC031
        MOV     (SP),(R3)+      ;;; STORE MODULE TYPE                   ;JC031
        MOV     ILREL(R0),(R3)+ ;;; STORE RELATIVE DEVICE NUMBER        ;JC031
        MOV     R1,(R3)+        ;;; STORE DATA WORD                     ;JC031
        BR      B40$            ;;; CHECK NEXT LINKAGE                  ;JC031
;                                                                       ;JC031
;                                                                       ;JC031
B30$:   DEC     (R3)            ;;; TABLE IN USE - FLAG OVERFLOW        ;JC031
        BMI     B40$            ;;; ALREADY MISSED ONE                  ;JC031
        DEC     (R3)            ;;; SET COUNT NEGATIVE                  ;JC031
;                                                                       ;JC031
; PROCEED WITH NEXT RESOURCE LINKAGE                                    ;JC031
;                                                                       ;JC031
B40$:   MOV     2(SP),R2        ;;; RESTORE R2                          ;JC031
        BR      B10$            ;;; UNLINK NEXT                         ;JC031
;                                                                       ;JC031
; DONE WITH RESOURCE LINKAGES. TEST FOR CONNECTED BUFFER.               ;JC031
; R1 = DATA BYTE, R4 = SCB, R5 = UNSOLICITED INTERRUPT TABLE            ;JC031
; (SP) = MODULE TYPE, 2(SP) = OFFSET/MTYP, 4(SP) = IAR CONTENTS         ;JC031
;                                                                       ;JC031
B50$:   TST     IMTCB(R5)       ;;; CIRCULAR BUFFER CONNECTED?          ;JC031
        BEQ     B80$            ;;; IF EQ NO                            ;JC031
        MOV     (SP),R2         ;;; GET MODULE TYPE                     ;JC031
        ASL     R2              ;;; MAKE WORD INDEX                     ;JC031
        MOV     $BTMSK(R2),R2   ;;; GET MODULE TYPE MASK                ;JC031
        BIT     R2,IMTYP(R5)    ;;; IS THIS MODULE TYPE CONNECTED?      ;JC031
        BEQ     B80$            ;;; IF EQ NO                            ;JC031
        MOV     (SP),R2         ;;; GET MODULE TYPE                     ;JC031
        CLR     -(SP)           ;;; SAVE SPOT FOR REL ENTRY             ;JC031
        MOV     R1,-(SP)        ;;; SAVE DATA                           ;JC031
        MOV     10(SP),R1       ;;; RETRIEVE IAR                        ;JC031
                                                                        ;JC031
 .IFT                                                                   ;JC031
                                                                        ;JC031
        MOV     TMP,R3          ;;; GET CONTROLLER INDEX                ;JC031
                                                                        ;JC031
 .IFF                                                                   ;JC031
        CLR     R3              ;;; CONTROLLER INDEX=0                  ;JC031
 .ENDC                                                                  ;JC031
                                                                        ;JC031
        CALL    PH2REL          ;;; CONVERT PHYSICAL TO RELATIVE ENTRY  ;JC031
         BCS    B70$            ;;; IF C-SET MODULE NOT MAPPED          ;JC031
        CMPB    #IN08,IPMMOD(R2) ;;; 8-BIT COUNTER?                     ;JC031
        BNE     B60$            ;;; IF NE NO                            ;JC031
        ADD     6(SP),R3        ;;; YES ADD IN OFFSET FOR DEVICE WITHIN ;JC031
B60$:   MOV     R3,2(SP)        ;;; SAVE RELATIVE ENTRY NUMBER          ;JC031
        CLR     -(SP)           ;;; ADD EXTRA ARGUMENT                  ;JC031
        MOV     #1,-(SP)        ;;; SET EXISTENCE INDICATOR             ;JC031
        MOV     SP,R1           ;;; COPY POINTER TO CB DATA             ;JC031
        BR      COMSV1          ;;; BRANCH TO COMMON SERVICE            ;JC031
B70$:   JMP     94$             ;;; EXIT                                ;JC031
                                                                        ;JC031
B80$:   JMP     95$             ;;; OUT OF RANGE BRANCH                 ;JC031
.ENDC                                                                   ;JC031
                                                                        ;JC031
.IF DF  I$$PDI!I$$PCO!I$$PTI                                            ;JC031
;                                                                       ;**-1
; COMMON DIGITAL MODULE INTERRUPT SERVICE
;
COMSRV: MOV     R2,-(SP)        ;;; SAVE COS, MOD TYPE
        MOV     R0,-(SP)        ;;; ...
        CLR     RUN             ;;; CLEAR FORK PROCESS FLAG

 .IF DF I$$PUN

        MOV     TMP,R0          ;;; GET CONTROLLER INDEX
        ASL     R0              ;;; MAKE IT A DOUBLE INDEX
        ADD     R5,R0           ;;;  AND USE TO BIAS UNSOL INT TABLE ADDR

 .IFF

        MOV     R5,R0           ;;; COPY UNSOL INT TABLE ADDR

 .ENDC

        ADD     #IMLH,R0        ;;; GET RESOURCE LINKAGE LISTHEAD
10$:    MOV     (R0),R0         ;;; GET FIRST/NEXT RESOURCE LINK
        BEQ     55$             ;;; ..END OF LIST=NO RESOURCE LINK
        CMPB    4(SP),ILPBA(R0) ;;; TEST PHYS ADDR TO SEE IF THIS IS THE
        BNE     10$             ;;; ..RIGHT BYTE, IF NE, NOT.
        BITB    R2,ILRES(R0)    ;;; RIGHT BYTE--SEE IF RIGHT RESOURCE
        BEQ     10$             ;;; ..NO COMMON BITS
;
; GOT THE RIGHT LINKAGE (OR, A RIGHT LINKAGE, THERE COULD BE MORE THAN
; ONE). ISOLATE COMMON BITS AND ACTIVATE THE LINKAGE.
;
        MOVB    ILRES(R0),R3    ;;; GET BITS THAT APPLY TO THE LINKAGE
        COMB    R3              ;;; TRANSFORM THEM TO A MASK
        BICB    R3,R2           ;;;  AND EXCLUDE NON-RELEVANT BITS FROM
        INCB    ILRUN(R0)       ;;;  THE INTERRUPT. FLAG LINKAGE.
        INC     RUN             ;;;  FORK PROCESS WILL BE NEEDED

  .IF DF I$$PEF

        BIT     #1,ILTE(R0)     ;;; TEST EVENT FLAG LINKAGE
        BEQ     20$             ;;; ..IF EQ, NOT
        BISB    R2,ILCOS(R0)    ;;; .OR. INT BITS TO INDICATE EF'S TO SET
        BR      50$             ;;;  AND PROCEED.

  .ENDC

20$:    MOV     ILTE(R0),R3     ;;; TASK LINKAGE-GET TASK LINK ENTRY ADDR
        ADD     #LACT,R3        ;;; POINT TO ACTIVATION SECTION
        TST     (R3)            ;;; CHECK ACTIVATION COUNT
        BNE     30$             ;;; TABLE IN USE
        INC     (R3)+           ;;; NOT IN USE--FLAG IT.

 .IF GT N$$PCS-1

        MOV     TMP,(R3)+       ;;; SAVE CONTROLLER INDEX

 .IFF

        CLR     (R3)+           ;;; CONTROLLER INDEX=0

 .IFTF

        MOV     (SP),(R3)+      ;;; STORE MODULE TYPE
        MOV     ILREL(R0),(R3)+ ;;; STORE RELATIVE ENTRY NUMBER
        MOV     R1,(R3)+        ;;; STORE DATA BYTE
        MOV     R2,(R3)         ;;; STORE COS BYTE
        BR      50$             ;;; GO CHECK NEXT LINKAGE
;
30$:    DEC     (R3)            ;;; TABLE IN USE. FLAG OVERFLOW.
        BMI     50$             ;;; IF MI ALREADY MISSED AT LEAST ONE
        DEC     (R3)            ;;; SET COUNT NEGATIVE
;
; PROCEED WITH NEXT RESOURCE LINKAGE.
;
50$:    MOV     2(SP),R2        ;;; RESTORE COS BYTE
        BR      10$             ;;; UNLINK NEXT
;
; DONE WITH RESOURCE LINKAGES. TEST FOR CONNECTED BUFFER.
; R1 = DATA BYTE, R4 = SCB, R5 = UNSOLICITED INTERRUPT TABLE
; (SP) = MODULE TYPE, 2(SP) = COS, 4(SP) = IAR CONTENTS
;
55$:    TST     IMTCB(R5)       ;;; TEST FOR BUFFER
        BEQ     95$             ;;; ..NONE
        MOV     (SP),R2         ;;; GET MODULE TYPE
        CLR     -(SP)           ;;; SAVE SPOT FOR REL ENTRY
        MOV     R1,-(SP)        ;;; SAVE DATA
        MOV     10(SP),R1       ;;; PHYSICAL BYTE OFFSET

 .IFT                           ;;; (N$$PCS>1)

        MOV     TMP,R3          ;;; GET CONTROLLER INDEX

 .IFF

        CLR     R3              ;;; CONTROLLER INDEX

 .ENDC                          ;;; (N$$PCS>1)

        CALL    PH2REL          ;;; CONVERT PHYS TO RELATIVE ENTRY
         BCS    94$             ;;; ERROR-MODULE NOT MAPPED
        MOV     R3,2(SP)        ;;; SAVE RELATIVE ENTRY
        MOV     6(SP),R3        ;;; GET COS BYTE
        MOV     R3,-(SP)        ;;; GOT CIRC BUF ENTRY ON STACK
        MOV     #1,-(SP)        ;;; SET EXISTENCE INDICATOR
        MOV     SP,R1           ;;; COPY POINTER TO CB DATA
                                                                        ;JC031
COMSV1:                         ;;; COMMON INTERRUPT SERVICE ENTRY      ;JC031
                                ;;; FOR ALL NON-A/D INTERRUPTING MODULES;JC031
                                                                        ;JC031
  .IF DF M$$MGE                                                         ;**-1

        MOV     KISAR6,-(SP)    ;;; SAVE CURRENT MAP
        MOV     IMCBF(R5),KISAR6 ;;; MAP TO USER BUFFER

  .IFTF

        MOVB    IMBPE(R5),R2    ;;; GET #BYTES/ENTRY
        ASR     R2              ;;; MAKE THAT #WORDS/ENTRY
        MOV     IMCUR(R5),R0    ;;; CURRENT BUFFER POINTER
        TST     (R0)            ;;; TEST IN-USE FLAG
        BEQ     59$             ;;; ..BUFFER IS FREE
        CMP     IMLST(R5),#100001 ;;; ..BUF BUSY-TEST LOST DATA OVFLO
        BEQ     58$             ;;; ..OVERFLOW
        DEC     IMLST(R5)       ;;; STEP LOST DATA COUNT
58$:    MOV     IMLST(R5),(R0)  ;;; COPY LOST COUNT TO BUFFER
        BR      90$             ;;; FINISH UP
;
; TRANSFER DATA INTO CIRCULAR BUFFER ENTRY
;
59$:    CLR     IMLST(R5)       ;;; RESET LOST DATA COUNT
60$:    MOV     (R1)+,(R0)+     ;;; MOVE A WORD INTO CIRCULAR BUFFER

  .IFT                          ;;; (M$$MGE)

        BIT     #20000,R0       ;;; TEST FOR 4K BOUNDARY
        BEQ     80$             ;;; ..NOT THERE YET
        BIC     #20000,R0       ;;; BACK IT UP 4K
        ADD     #200,KISAR6     ;;;  BY ADJUSTING RELOCATION BIAS
        ADD     #200,IMCBF(R5)  ;;; ...

  .IFTF

80$:    INC     IMFIL(R5)       ;;; INCREMENT FILL INDEX
        CMP     IMLGH(R5),IMFIL(R5) ;;; CHECK BOUNDS OF BUFFER
        BHIS    85$             ;;; ..NOT AT END
        MOV     #3,IMFIL(R5)    ;;; WRAP TO TOP OF BUFFER
        MOV     IMSDA(R5),R0    ;;; ...

  .IFT

        MOV     IMSBF(R5),IMCBF(R4) ;;; WRAP RELOC BIAS
        MOV     IMCBF(R5),KISAR6 ;;; ...

  .IFTF

85$:    DEC     R2              ;;; KEEP COUNT OF DATA TRANSFERRED
        BGT     60$             ;;; NEXT ITEM
        MOV     R0,IMCUR(R5)    ;;; DONE. SAVE CURRENT ADDRESS.

  .IFT

        MOV     IMSBF(R5),KISAR6 ;;; RESET TO START OF BUF

  .IFTF

        MOV     IMFIL(R5),@IMSAD(R5) ;;; RESET FILL INDEX
        INC     RUN             ;;; SET FORK PROCESS FLAG
90$:                            ;;; REFERENCE

  .IFT

        MOV     (SP)+,KISAR6    ;;; RESTORE ORIGINAL MAP

  .ENDC                         ;;; (M$$MGE)

        MOV     (SP)+,(SP)+     ;;; CLEAN STACK
94$:    MOV     (SP)+,(SP)+     ;;; POP 2
95$:    ADD     #6,SP           ;;; CLEAN REST OF STACK
        TST     RUN             ;;; CHECK FORK FLAG
        BEQ     200$            ;;; ..NO FORK PROCESS NEEDED.
        .PAGE
        .SBTTL   DIGITAL INTERRUPT FORK PROCESSING
;
; FORK PROCESS REQUIRED - TAKE CARE NOT TO CALL IT TWICE
;
        TSTB    IMFIP(R5)       ;;; CHECK FORK-IN-PROGRESS FLAG
        BEQ     200$            ;;; ..ALREADY QUEUED
        CLRB    IMFIP(R5)       ;;; SET FORK-IN-PROGRESS
        MOV     R5,R4           ;;; COPY UNSOL INT ADDR
        ADD     #IMFRK+6,R4     ;;; POINT TO FORK BLOCK
        CALL    $FORK1          ;;; ENTER FORK QUEUE
        INCB    IMFIP(R5)       ; RESET FORK-IN-PROGRESS FLAG
;
; ACTIVATE ANY FLAGGED RESOURCE LINKS
;
        MOV     IMSCB(R5),R4    ; RESTORE SCB

 .IF DF I$$PUN

        CLR     -(SP)           ; INIT CONTROLLER INDEX

 .IFTF                          ; (I$$PUN)

100$:   MOV     R5,R3           ; GET LISTHEAD FOR RESOURCE LINKS
        ADD     #IMLH,R3        ; ...

 .IFT                           ; (I$$PUN)

        ADD     (SP),R3

 .IFTF                          ; (I$$PUN)

105$:   MOV     (R3),R3         ; GET FIRST/NEXT LINKAGE
        BNE     110$            ; GOT ONE

 .IFT                           ; (I$$PUN)

        CMP     (SP),#<4*<N$$PCS-1>> ; TEST FOR END OF CONTROLLER LIST
        BHIS    145$            ; ..DONE
        ADD     #4,(SP)         ; ..NEXT
        BR      100$            ; ...

 .IFF                           ; (I$$PUN)

        BR      150$            ; DONE

 .ENDC                          ; (I$$PUN)

;
; GOT AN ENTRY. SEE IF IT'S FLAGGED. IF SO, SET EVENT FLAG AND ACTIVATE
; TASK (IF APPROPRIATE)
;
110$:   TSTB    ILRUN(R3)       ; CHECK ACTIVATION FLAG
        BEQ     105$            ; ..NOT SET--TRY NEXT LINKAGE
        CLRB    ILRUN(R3)       ; RESET
        MOV     R3,-(SP)        ; PRESERVE LINKAGE POINTER

 .IF DF I$$PEF

        BIT     #1,ILTE(R3)     ; CHECK IF LINKED EVENT FLAG
        BEQ     130$            ; BEQ IF NOT
;
; THIS IS AN EVENT FLAG LINKAGE. SET EVENT FLAG FOR EACH BIT SET IN
; ILCOS.
;
        MOV     R5,-(SP)        ; SAVE R5, EF FOR BIT 0
        MOV     ILEVM(R3),-(SP) ; ...
        MOV     ILEVA(R3),R5    ; GET TCB ADDRESS
        CLR     -(SP)           ; INIT TEMP FOR COS
        MTPS    #PR6            ;;; LOCK OUT CHANGE ON COS BYTE
        MOVB    ILCOS(R3),(SP)  ;;; GET INTERRUPTING BITS
        CLRB    ILCOS(R3)       ;;; RESET THE FLAG
        MTPS    #0              ; RESTORE INT'S
        TSTB    (SP)            ; SEE IF ANY BITS CHANGED
        BEQ     125$            ; NO
115$:   ASR     (SP)            ; TEST FOR SET BIT
        BCC     120$            ; ..NOT THIS ONE
        MOV     2(SP),R0        ; BIT IS SET--SET THE EVENT FLAG
        CALL    $CEFI           ; CONVERT TO MASK AND ADDRESS
        BIS     R0,(R1)         ; SET EVENT FLAG
        MOV     R5,R0           ; COPY TCB
        BNE     118$            ; IF NE, LOCAL EVENT FLAGS INVOLVED
        CALL    $DRDSE          ; GLOBAL EF'S ONLY-DECLARE SIG EVENT
        BR      120$            ; ...
118$:   CALL    $SETCR          ; CONDITIONALLY SCHEDULE TASK
120$:   TST     (SP)            ; SEE IF ANYTHING LEFT
        BEQ     125$            ; ..NO
        INC     2(SP)           ; ..YES, NEXT EVENT FLAG
        BR      115$            ; CONTINUE
125$:   MOV     (SP)+,(SP)+     ; CLEAN STACK
        MOV     (SP)+,R5        ; CLEAN STACK, RESTORE R5
127$:   MOV     (SP)+,R3        ; ...
        BR      105$            ; NEXT LINKAGE

 .ENDC                          ; (I$$PEF)

;
; HANDLE ACTIVATION OF LINKED TASK ENTRY
;
130$:   MOV     ILTE(R3),R0     ; GET LINKED TASK ENTRY ADDR
        MOV     LTCB(R0),R0     ; GET TCB ADDRESS
        MOV     T.STAT(R0),R1   ; GET CURRENT TASK STATUS
        BIT     #TS.EXE,R1      ; IS TASK ACTIVE?
        BNE     140$            ; ..NO
        BIT     #T2.ABO,T.ST2(R0) ; IS TASK BEING ABORTED?
        BNE     142$            ; ..YES, IGNORE IT
        BIT     #TS.OUT,R1      ; IS TASK OUT OF MEMORY?
        BEQ     135$            ; ..NO, ACTIVATE IT
        BIT     #TS.CKP,R1      ; ..YES, IS IT CHECKPOINTED?
        BEQ     142$            ; ..NO, IGNORE IT
135$:   MOV     ILEVA(R3),R2    ; GET ADDRESS OF EF MASK
        BEQ     142$            ; ..NO EVENT FLAG TO SET
        BIS     ILEVM(R3),(R2)  ; SET THE EVENT FLAG
        CALL    $SETCR          ; CONDITIONALLY SCHEDULE TASK
        BR      142$            ; NEXT
;
; TASK IS NOT ACTIVE. REQUEST IT.
;
140$:   CLR     R1              ; SET DEFAULT UIC
        CALL    $TSKRT          ; REQUEST TASK
142$:   MOV     (SP)+,R3        ; CLEAN STACK
        BR      105$            ; NEXT MESSAGE
;
; DONE WITH RESOURCE LINKAGE ACTIVATION.
; ACTIVATE TASK IF ATTACHED TO CIRCULAR BUFFER.
;
 .IFDF I$$PUN

145$:   TST     (SP)+           ; CLEAR CONTROLLER INDEX FROM STACK

 .ENDC

150$:   MOV     IMTCB(R5),R0    ; GET TCB ADDR OF TASK CONNECTED
        BEQ     200$            ; ..NO CONNECTED TASK
        BIS     IMEVM(R5),@IMEVA(R5) ; SET EVENT FLAG
        CALL    $SETCR          ; CONDITIONALLY SCHEDULE TASK
200$:   RETURN                  ; EXIT ISR

.ENDC                           ; (I$$PCO!I$$PDI!I$$PTI)                ;JC031
        .IF DF  I$$PAD!I$$P14                                           ;JC031
                                                                        ;JC031
        .DSABL  LSB                                                     ;**-1
        .PAGE
        .SBTTL  A/D CONVERTER INTERRUPT PROCESSING

;                                                                       ;JC031
;+                                                                      ;JC031
; **- ADSRV1 - COMMON A/D SERVICE ROUTINE                               ;JC031
;-                                                                      ;JC031
;                                                                       ;JC031
; R0 = MODULE TYPE, R3 = MODULE ADDRESS, R4 = SCB                       ;JC031
; R5 = CSR, (SP) = IAR CONTENTS                                         ;JC031
; PS AT PR6                                                             ;JC031
;                                                                       ;JC031
ADSRV1: MOVB$C  (R3),R2         ;;; A/D INPUT, READ LOW-ORDER DATA      ;JC031
        SWAB    R2              ;;; MAKE SPACE FOR HIGH-ORDER DATA      ;JC031
        BISB    (R3)+,R2        ;;; PICK UP HIGH ORDER BYTE             ;JC031
        SWAB    R2              ;;; PUT LOW ORDER BYTE IN LOW ORDER BYTE;JC031
        CLR     R1              ;;; CLEAR R1                            ;JC031
        BISB    (R3)+,R1        ;;; PICK UP ADI14'S CHANNEL NO.         ;JC031
        SWAB    R1              ;;; PUT IN HIGH ORDER BYTE              ;JC031
        BISB    #RIF,(R5)       ;;; CLEAR INTERRUPT                     ;JC031
        BISB    (R3),R1         ;;; READ DATA AND CLEAR INTERRUPT       ;JC031
        CMPB    #ADI14,R0       ;;; 14-BIT A/D?                         ;JC031
        BEQ     A14SRV          ;;; YES BRANCH TO 14-BIT SERVICE ROUTINE;JC031
.ENDC                                                                   ;JC031
 .IF DF I$$PAD

;+
; **- A12SRV - 12-BIT A/D INTERRUPT SERVICE
;-
;
; R0 = MODULE TYPE, R1 = STATUS BITS (LOW BYTE), R2 = MODULE DATA,
;       R4 -> SCB, R5 -> PCS CSR, 0(SP) = IAR
;       CONTENTS, 2(SP) = RETURN ADDRESS
;
; PROCESSOR IS AT PCS PRIORITY
;
A12SRV: ASL     R2              ;;; LEFT-JUSTIFY DATA
        ASL     R2              ;;; ...
        ASL     R2              ;;; ...
        ASL     R2              ;;; ...
        SUB     #100000,R2      ;;; CONVERT FROM EXCESS-100000 TO TWO'S
                                ;;; ..COMPLEMENT FORMAT
        BIT     #14,R1          ;;; ANY ERRORS?
        BEQ     ADSRV           ;;; IF EQ, NONE
        MOV     #-1,R2          ;;; YES, SET DATA TO -1 TO FLAG

  .IF DF I$$P14

        BR      ADSRV           ;;; ...AND GO ENTER COMMON SERVICE

  .ENDC
 .ENDC                          ;;; (I$$PAD)
A14SRV:                         ; REFERENCE LABEL                       ;JC037
 .IF DF I$$P14

;+
; **- A14SRV - 14-BIT A/D INTERRUPT SERVICE
;-
;
; R0 = MODULE TYPE, R1 = STATUS BITS (LOW BYTE), CHANNEL INFO (HIGH
;       BYTE), R2 = MODULE DATA, R4 -> SCB, R5 -> PCS CSR,
;       0(SP) = IAR CONTENTS, 2(SP) = RETURN ADDRESS
;
; PROCESSOR IS AT PCS PRIORITY
;
        ASL     R2              ;;; LEFT-JUSTIFY DATA, TEST OVERRANGE   ;JC037
        BCC     10$             ;;; IF CLEAR, NOT OVERRANGE             ;**-1
        BIS     #77777,R2       ;;; IF OVERRANGE, MAKE MAX POSS. VALUE
10$:    BPL     20$             ;;; IF DATA IS POSITIVE, DON'T FUDGE
        BIC     #100000,R2      ;;; NEG. DATA, CONVERT SIGN/MAGNITUDE TO
        NEG     R2              ;;; ..TWO'S COMPLEMENT FORM
20$:    BIT     #14,R1          ;;; ANY ERRORS?
        BEQ     ADSRV           ;;; IF EQ NO, DON'T FUDGE DATA
        MOV     #-1,R2          ;;; SET DATA TO -1 TO FLAG ERROR
        BIT     #10,R1          ;;; DID DATA OVERRUN?
        BEQ     ADSRV           ;;; IF EQ, NO
        MOV     #-3,R2          ;;; YES, FLAG OVERRUN WITH SPCL VALUE

 .ENDC                          ; (I$$P14)
 .IF DF I$$PAD ! I$$P14

;
; COME HERE AFTER WE HAVE DONE PRELIMINARY CONVERTER-SPECIFIC
; PROCESSING.  AT THIS POINT, R2 HAS THE CONVERTED DATA, READY FOR
; PASSING ON TO THE USER.  IF AN ERROR HAS OCCURRED, R2 HAS BEEN SET
; TO -1 OR -3.  IF THE DATA WAS OVERRANGE ON A 14-BIT CONVERTER, R2 HAS
; BEEN SET TO THE MAXIMUM POSITIVE NUMBER OR ITS NEGATIVE (+/- 32767).
; SINCE THE MAXIMUM DATA WIDTH IS 14 BITS PLUS SIGN, VALID DATA CAN
; NEVER BE -1 OR -3.  THIS FACT IS USED LATER WHEN TESTING FOR ERRORS.
;
ADSRV:

  .IF GT <N$$PCS-1>

        MOV     TMP,R0          ;;; GET CONTROLLER INDEX IN R0
        MOVB    PCSBAS+1(R0),1(SP) ;;; MAKE 0(SP) BE PHYSICAL ADDRESS

  .IFF

        MOVB    PCSBAS+1,1(SP)  ;;; MAKE 0(SP) BE PHYSICAL ADDRESS

  .ENDC

        MOV     S.ADC(R4),R3    ;;; POINT AT A/D CONVERTER TABLE
        BEQ     NOSUCH          ;;; IF EQ, THERE AIN'T ANY
        TSTB    ADIP(R3)        ;;; ANY CONVERSIONS GOING?
        BEQ     NOSUCH          ;;; IF EQ, NO - DISMISS INTERRUPT
        ADD     #ADCONV,R3      ;;; POINT R3 AT ADC ENTRY PTR LIST
        MOV     #16.,R0         ;;; SET UP LOOP COUNTER

  .IF DF I$$P14
  .IFF

        INC     (SP)            ;;; SET BUSY BIT SO IT CAN MATCH TABLE
10$:    CMP     (SP),@(R3)+     ;;; IS THIS THE RIGHT ENTRY?

  .IFT

10$:    MOV     @(R3)+,R1       ;;; PICK UP BUS ADDRESS FROM ENTRY
        BIC     #1,R1           ;;; ENSURE BOTTOM BIT IS CLEAR
        CMP     (SP),R1         ;;; IS THIS THE RIGHT ENTRY?

  .ENDC

        BEQ     GOTAD           ;;; IF EQ, WE'VE GOT THE RIGHT ONE
        DEC     R0              ;;; WRONG ONE, TRY NEXT ONE
        BGT     10$             ;;; ...

NOSUCH: TST     (SP)+           ;;; SPURIOUS INTERRUPT, CLEAN STACK
        RETURN                  ;;; ...AND IGNORE THE DUMB THING

GOTAD:  MOV     -(R3),R3        ;;; POINT R3 AT ADC ENTRY
;
; AT THIS POINT, R3 POINTS TO THE ADC ENTRY AND R2 HAS THE NEEDED DATA.
;
        BIC     #1,(R3)         ;;; CLEAR BUSY BIT FOR THIS ENTRY
        ASSUME  ADUAD,EQ,ADUADS
20$:    MOV     R3,R1           ;;; COPY ADC ENTRY ADDRESS
        ADD     #ADUAD,R1       ;;; POINT R1 AT USER BUFFER ADDRESS

  .IF DF M$$MGE

        MOV     KISAR6,-(SP)    ;;; SAVE CURRENT KISAR6 MAPPING
        MOV     (R1)+,KISAR6    ;;; MAP TO USER BUFFER
        MOV     R2,@(R1)+       ;;; TRANSFER DATA TO USER
        MOV     (SP)+,KISAR6    ;;; RESTORE KISAR6 MAPPING

  .IFF

        MOV     R2,@2(R1)       ;;; TRANSFER DATA TO USER

  .ENDC

        CLR     ADUAD+2(R3)     ;;; CLEAR CONVERSION-IN-PROGRESS FLAG

  .IF DF I$$P14&I$$PAD

        CMPB    ADTYP(R3),#ADI12 ;;; 12-BIT A/D?
        BEQ     40$             ;;; IF EQ YES, DON'T SHUFFLE

  .ENDC
  .IF DF I$$P14

        ADD     #ADUADS,R3      ;;; POINT AT BUFFER-ADDRESS LIST
        MOV     R3,R1           ;;; POINT R1 AT 2ND ENTRY IN LIST
        ADD     #4,R1           ;;; ...
        MOV     #3,R0           ;;; LOOP COUNTER
30$:    MOV     (R1)+,(R3)+     ;;; SHUFFLE DATA DOWN 2 WORDS
        MOV     (R1)+,(R3)+     ;;; SHUFFLE 2ND WORD OF DATA
        BEQ     40$             ;;; IF ZERO DATA, WE'RE DONE
        DEC     R0              ;;; COUNT LOOP PASSES
        BGT     30$             ;;; ...AND LOOP FOR MORE
        CLR     (R3)+           ;;; WE MOVED WHOLE THING, CLEAR LAST
        CLR     (R3)+           ;;; ..ENTRY

  .ENDC

40$:    MOV     S.ADC(R4),R3    ;;; RECOVER ADC TABLE ADDRESS
        INC     ADFBC(R3)       ;;; COUNT CONVERSIONS
        DECB    ADIP(R3)        ;;; DECREMENT IN-PROGRESS COUNT

  .IF DF I$$P14

        BEQ     50$             ;;; IF EQ, ALL ARE DONE
        CMP     R2,#-3          ;;; DID ADI14 DATA OVERRUN?
        BNE     50$             ;;; IF NE NO, WE ARE DONE
        TST     R0              ;;; YES, WERE ANY MORE REQUESTS OUT?
        BNE     20$             ;;; IF NE YES, RETURN ERRORS FOR THEM

  .ENDC

50$:    TST     (SP)+           ;;; CLEAN OFF STACK
        TSTB    ADIP(R3)        ;;; TEST IN-PROGRESS COUNT
        BNE     55$             ;;; IF MORE LEFT, NEVER FORK
        TSTB    ADFR(R3)        ;;; FORK WANTED?
        BNE     60$             ;;; IF NE YES, GO DO FORK
55$:    RETURN                  ;;; NOT WANTED, JUST RETURN
60$:    CLRB    ADFR(R3)        ;;; CLEAR FORK REQUEST

  .IF DF I$$PUN

        MOV     CNTBL,R5        ;;; GET UCB ADDRESS

  .IFF                          ; (I$$PUN)
   .IFGT <N$$PCS-1>

        MOV     TMP,R5          ;;; GET CONTROLLER INDEX
        MOV     CNTBL(R5),R5    ;;; GET UCB ADDRESS

   .IFF                         ; (N$$PCS)

        MOV     CNTBL,R5        ;;; GET UCB ADDRESS

   .ENDC                        ; (N$$PCS)
  .ENDC                         ; (I$$PUN)

        CALL    $FORK           ;;; SWITCH TO USER STATE
        MOV     S.ADC(R4),R3    ; GET MASTER TABLE ADDRESS
        MOV     ADNXT(R3),R1    ; GET ENTRY ADDR OF BLOCKED CONVERSION
        BEQ     ADRLS           ; IF NONE, RELEASE PACKET
        MOV     ADNXC(R3),-(SP) ; GOT ONE, STACK CONTROL WORD
        CLR     ADNXT(R3)       ; CLEAR BLOCKED-CONVERSION POINTER
        JMP     ADUNBL          ; AND GO UNBLOCK CONVERSION

ADRLS:  JMP     ADRLSP          ; LINKAGE VECTOR FOR LONG BRANCH

 .ENDC                          ; (I$$PAD ! I$$P14)

.IFF                            ; (I$$PAD!I$$P14!I$$PCO!I$$PDI!I$$PTI)  ;JC031
                                                                        ;**-1
        RTI                     ;;; DISMISS SPURIOUS INTERRUPT

.ENDC
.DSABL LSB
        .PAGE
        .SBTTL  PCS POWER FAILURE SUBROUTINE
.ENABL LSB
;+
; **- $PCSPF = PCS POWER FAIL SUBROUTINE
; CALLED FROM SYSTEM POWER FAIL HANDLER IF I$$PPF IS DEFINED.
; FUNCTION: TO SAVE IN TABLE PFDTB THE BYTES WHOSE ADDRESSES
; HAVE BEEN ALREADY SET UP IN TABLE PFCTB
; SPEED IS THE UTMOST CONSIDERATION.
; USES OWN STACK: ONE WD FOR CALL, 2 FOR POSSIBLE TRAP.
; R0 AND R1 ARE DESTROYED.  IF MORE STACK SPACE IS NEEDED, MORE
; MUST BE ALLOCATED.
;-
        .BLKW   3               ; SAVE STACK
IPDWN:                                                                  ;MSH026
$PCSPF::

.IF DF I$$PPF

        CLR     NBPWF           ;;; INIT # BYTES SAVED
        MOV     PFCTB,R0        ;;;CONTROL TABLE                        ;MSH026
        MOV     PFDTB,R1        ;;;DATA TABLE (BYTES)                   ;MSH026
10$:    TST     (R0)            ;;; TEST FOR END OF LIST                ;**-2
        BEQ     20$             ;;; ..DONE
        MOVB    @(R0)+,(R1)+    ;;; SAVE A BYTE
        INC     NBPWF           ;;; COUNT IT
        BR      10$             ;;; NEXT
20$:

.ENDC

        RETURN
.DSABL LSB
        .PAGE
        .SBTTL  PCS POWER RECOVERY HANDLER
;+
; **- PCSPR = IP11 POWER RECOVERY HANDLER
; INPUTS: R3 = CONTROLLER INDEX, R4 = SCB, R5 = UCB
;
; THE POWER RECOVERY HANDLER IS ALWAYS CALLER ON POWER RECOVERY
; REGARDLESS OF OUTSTANDING I/O. THE FOLLOWING FUNCTIONS ARE
; PERFORMED:
;       1- RESTORE OUTPUTS (IF OPTION CONFIGURED)
;       2- EXAMINE PHYSICAL ADDRESS SPACE TO CREATE PCS MODULE
; MAPPING TABLE
;       3- INITIALIZE OUTPUT SAVE TABLE (IF OPTION CONFIGURED)
;       4- INITIALIZE UNSOLICITED INTERRUPT TABLES
;-
.ENABL LSB

IPPWF:                                                                  ;MSH026
PCSPR:  MOV     #5,R1           ; WAIT FOR PCS POWER SUPPLY!
        CLR     R0              ; (I DON'T LIKE THIS ANY MORE
1$:     DEC     R0              ;  THAN YOU DO..)
        BNE     1$              ; WAIT UP TO 1 SEC DEPENDING ON PROC
        DEC     R1              ; ...
        BNE     1$              ; ...

.IF DF  I$$PAD ! I$$P14 ! I$$PCO ! I$$PDI

        MOV     R5,CNTBL(R3)    ; SAVE UCB ADDRESS

.ENDC
.IF DF  I$$PAD ! I$$P14

        CLR     NADC            ; CLEAR COUNTER OF A/D CONVERTERS

.ENDC
        .IF DF  LD$IP                                                   ;MSH026
        MOV     S.FRK+10(R4),-(SP) ; GET DRIVER PCB ADDRESS             ;MSH026
                                                                        ;MSH026
        .IF DF  I$$PCO                                                  ;MSH026
        MOV     S.CI(R4),R2     ; RETRIEVE COS TABLE POINTER            ;MSH026
        MOV     (SP),IMPCB(R2) ; COPY PCB ADDRESS                       ;MSH026
        .ENDC                                                           ;MSH026
                                                                        ;MSH026
        .IF DF  I$$PDI                                                  ;MSH026
        MOV     S.SI(R4),R2     ; RETRIEVE DSI TABLE POINTER            ;MSH026
        MOV     (SP),IMPCB(R2) ; COPY PCB ADDRESS                       ;MSH026
        .ENDC                                                           ;MSH026
                                                                        ;MSH026
        .IF DF I$$PTI                                                   ;MSH026
        MOV     S.TI(R4),R2     ; RETRIEVE COUNTER TABLE POINTER        ;MSH026
        MOV     (SP),IMPCB(R2) ; COPY PCB ADDRESS                       ;MSH026
        .ENDC                                                           ;MSH026
                                                                        ;MSH026
        TST     (SP)+           ; CLEAN STACK                           ;MSH026
        .ENDC                                                           ;MSH026
                                                                        ;MSH026
.IF DF  I$$PPF
 .IF GT <N$$PCS-1>
  .IF NDF I$$PUN

        TST     R3              ; CHECK CONTROLLER INDEX
        BNE     20$             ; ONLY RESTORE OUTPUTS ONCE

  .ENDC
 .ENDC

        JSR     R0,SAVTR4       ; SAVE & CHANGE ILL MEM REF TRAP
        TST     NBPWF           ; GET NUMBER OF OUTPUTS TO RESTORE
        BEQ     20$             ; ..NOT TOO MANY
        MOV     S.CSR(R4),R2    ; SET UP CSR PTR FOR ILL MEM REF TRAP
        MOV     PFCTB,R0        ; CONTROL TABLE                         ;MSH026
        MOV     PFDTB,R1        ; DATA TABLE (BYTES)                    ;MSH026
10$:    TST     (R0)            ; CHECK END OF TABLE                    ;**-2
        BEQ     20$             ; ..DONE
        MOVB    (R1)+,@(R0)+    ; RESTORE A BYTE
        DEC     NBPWF           ; KEEP COUNT
        BGT     10$             ; GET NEXT
20$:

 .IF DF I$$PDI ! I$$PAD ! I$$P14

        CALL    UNMAP           ; DEALLOCATE OLD MAPPING TABLES

 .ENDC

        MOV     PFCTB,PFPTR     ; INIT CONTROL TABLE INSERTION PTR      ;MSH026
                                                                        ;**-1
.IFTF                           ; (I$$PPF)

;
; CREATE MODULE MAPPING TABLE
;
 .IF GT N$$PCS-1
  .IF NDF I$$PUN

        TST     R3              ; SEE IF THIS IS FIRST PASS
        BNE     22$             ; NO..LEAVE LSTMAP ALONE

  .ENDC
 .ENDC

        MOV     #PCSMTB-LGMAP,LSTMAP ; RESET LSTMAP
22$:

.IFF                            ; (I$$PPF)

        JSR     R0,SAVTR4       ; SAVE & CHANGE ILL MEM REF TRAP

.IFTF                           ; (I$$PPF)

        MOV     R3,-(SP)        ; PUSH CONTROLLER INDEX
        MOV     LSTMAP,R5       ; GET START ADDR FOR MAPPING TABLE

.IFT                            ; (I$$PPF)

        MOV     R5,PRVMAP       ; SAVE ADDR OF START OF NEW MAP SEGMENT
        ADD     #LGMAP,PRVMAP   ; ADJUST FOR INITIAL OFFSET

.IFTF

        MOV     R4,R0           ; COPY SCB
        ADD     #S.IPM,R0       ; GET ADDR OF FIRST MAP QUEUE
        MOV     #NMTYP,R1       ; MAX # OF MODULE TYPES                 ;JC031
25$:    CLR     (R0)+           ; INITIALIZE MAP HEADERS TO ZERO        ;**-1
        SOB     R1,25$          ; ..ONE FOR EACH MODULE TYPE
;
; GET BASE ADDRESS FOR THIS CONTROLLER AND INIT VARIABLES
;
30$:    MOVB    (SP),R0         ; GET CONTROLLER INDEX
        MOV     PCSBAS(R0),-(SP) ; SAVE BASE ADDRESS
        MOV     (SP),R3         ; COPY BASE ADDRESS
        MOV     R3,R2           ; CALCULATE CSR ADDRESS
        ADD     #377,R2         ; ...
        BICB    #EBIT,(R2)      ; CLEAR INTERRUPT ENABLE
        MOV     R2,-(SP)        ; SAVE CSR ADDRESS
;
; SET GENERIC BIT IN CSR AND READ EACH ADDRESS IN CONTROLLER'S
; ADDRESS SPACE
;
        CLR     -(SP)           ; INIT CURRENT MODULE TYPE
35$:    BISB    #GBIT,(R2)      ; SET GENERIC BIT
        CLC                     ; CLEAR C BIT-TO BE SET BY ILL MEM CODE
        MOVB    (R3),R0         ; READ GENERIC CODE OF THIS MODULE
        BICB    #GBIT,(R2)      ; RESET GENERIC BIT
        BCS     37$             ; BRANCH=ILL MEM REF=NO MODULE
        CALL    FGCENT          ; FIND GENERIC CODE IN DEF TABLE
         BCS    40$             ; ..FOUND SUPPORTED CODE
37$:    INC     R3              ; GENERIC CODE NOT SUPPORTED, SKIP IT
        CLR     (SP)            ; RESET MODULE TYPE
        BR      63$             ; AND TRY NEXT MODULE
;
; GOT A VALID CODE
;
40$:    TST     (R2)+           ; STEP TO 2ND WORD IN GENCOD TABLE

.IFT                            ; (I$$PPF)

        MOV     PFPTR,R0        ; GET CTL TBL INSERTION POINTER
        BEQ     43$             ; ..NOT INITIALIZED

 .IF DF I$$PDO

        CMPB    (R2),#DIGO      ; TEST IF THIS IS DIGITAL OUTPUT

 .ENDC
 .IF DF I$$PDA

        BEQ     42$             ; ..YES, STORE IN CONTROL TABLE
        CMPB    (R2),#DAO       ; ..NO, IS IT DAC MODULE?

 .ENDC

        BNE     43$             ; WRONG MODULE TYPE FOR RESTORATION
42$:    MOV     R3,(R0)         ; SAVE MODULE ADDRESS IN CONTROL TABLE
        MOVB    -1(R2),R1       ; GET # BYTES IN MODULE
421$:   MOV     PFCTB,-(SP)     ; TEST FOR END OF TABLE                 ;MSH026
        ADD     #<2*<I$$PPF-1>>,(SP)                                    ;MSH026
        CMP     R0,(SP)+                                                ;MSH026
        BHI     43$             ; ..TABLE S FULL                        ;**-1
        DEC     R1              ; SEE IF MULTIPLE BYTES TO RESTORE
        BEQ     422$            ; ..NO OR DONE
        MOV     (R0)+,(R0)      ; COPY ADDRESS FOR NEXT SEQUENTIAL BYTE
        INC     (R0)            ; MAKE IT THE NEXT BYTE
        BR      421$            ; CONTINUE
422$:   TST     (R0)+           ; COUNT LAST BYTE
43$:    MOV     R0,PFPTR        ; RESTORE INSERTION POINTER

.IFTF                           ; (I$$PPF)
 .IF DF I$$PAD
  .IF DF I$$P14

        CMPB    (R2),#ADI14     ; IS THIS AN A/D CONVERTER?
        BEQ     432$            ; IF EQ YES, MAP IT

  .ENDC

        CMPB    (R2),#ADI12     ; IS THIS AN A/D CONVERTER?
        BNE     435$            ; IF NE NO, DON'T MAP IT
432$:   MOV     (R2),(SP)       ; SET PREVIOUS MODULE TYPE
        CALL    ADMAP           ; A/D CONVERTER, GO MAP IT
        BR      63$             ; GO TRY NEXT MODULE ADDRESS

 .IFF                           ; (I$$PAD)
  .IF DF I$$P14

        CMPB    (R2),#ADI14     ; IS THIS AN A/D CONVERTER?
        BNE     435$            ; IF NE NO, DON'T MAP IT
        MOV     (R2),(SP)       ; SET PREVIOUS MODULE TYPE
        CALL    ADMAP           ; GO MAP IT SPECIALLY
        BR      63$             ; GO TRY NEXT MODULE ADDRESS

  .ENDC                         ; (I$$P14)
 .ENDC                          ; (I$$PAD)

435$:   CMPB    (R2),(SP)       ; SAME AS CURRENT MODULE TYPE?
        BEQ     55$             ; ..YES, COUNT IT
.IF DF  I$$PTI                                                          ;JC031
        CMPB    #IN08,(R2)      ; 8-BIT INPUT COUNTER?                  ;JC031
        BNE     450$            ; IF NE NO - CHECK NEXT                 ;JC031
        BIS     #MTIN08,CTRTYP  ; SET MASK IN FLAG WORD                 ;JC031
450$:   CMPB    #IN16,(R2)      ; 16-BIT INPUT COUNTER?                 ;JC031
        BNE     460$            ; IF NE NO - CHECK NEXT                 ;JC031
        BIS     #MTIN16,CTRTYP  ; SET MASK IN FLAG WORD                 ;JC031
460$:   CMPB    #OU16,(R2)      ; 16-BIT OUTPUT COUNTER?                ;JC031
        BNE     470$            ; IF NE NO - CONTINUE                   ;JC031
        BIS     #MTOU16,CTRTYP  ; SET MASK IN FLAG WORD                 ;JC031
.ENDC                                                                   ;JC031
470$:   MOVB    (R2),(SP)       ; ..NO, NEW MODULE TYPE                 ;JC031
        ADD     #LGMAP,R5       ; INITIALIZE MAP ENTRY FOR IT           ;**-1
        CMP     R5,#PCSMTX      ; TEST FOR END OF TABLE
        BLO     44$             ; ..NOT THERE
        SUB     #LGMAP,R5       ; AT END OF TABLE--BACK UP
        ADD     #10,SP          ; KILL STACK
        BR      66$             ; AND EXIT

44$:    MOVB    (SP),R0         ; GET MODULE TYPE
        ASL     R0              ; WORD OFFSET
        ADD     #S.IPM-2,R0     ; OFFSET TO MAP TABLE HEADER
        ADD     R4,R0           ; GET ADDRESS OF MAP HEADER

  .IF DF I$$PUN

        MOV     (R0),R1         ; GET FIRST LINK
        BEQ     50$             ; ..NONE
45$:    MOV     R1,R0           ; COPY LINK
        MOV     (R0),R1         ; CHECK NEXT ONE
        BNE     45$             ; ..NOT AT END YET
        MOV     IPMMAX(R0),R1   ; R1 = "OLD MAX RELATIVE ENTRY #"
        INC     R1              ; NEW MINIMUM RELATIVE ENTRY #
        BR      52$             ; UPDATE IT

  .ENDC

50$:    CLR     R1              ; MINIMUM RELATIVE ENTRY #
52$:    MOV     R5,(R0)         ; LINK THE NEW ENTRY
        CLR     (R5)+           ; INIT THE LINK
        MOV     R1,(R5)+        ; STORE MIN REL ENTRY
        DEC     R1              ; ADJUST FOR ADD AT 55$
        MOV     R1,(R5)+        ; STORE MAX REL ENTRY
        MOVB    (R2),(R5)+      ; STORE MODULE TYPE
        CLRB    (R5)+           ; SAVE SPARE SPOT
        MOV     R3,(R5)+        ; STORE MODULE ADDRESS
        MOVB    6(SP),-(R5)     ; PUT IN CONTROLLER INDEX
        SUB     #LGMAP-1,R5     ; BACK TO THE TOP
;
; UPDATE THE ENTRY
;
55$:    MOVB    1(R2),R0        ; GET NUMBER REL ENTRIES IN MODULE
        ADD     R0,IPMMAX(R5)   ; BIAS MAX REL ENTRY COUNT
60$:    MOVB    -(R2),R0        ; GET #BYTES/MODULE FROM GENCOD
        ADD     R0,R3           ; STEP H/W ADDRESS POINTER
63$:    MOV     4(SP),R0        ; SEE IF WE'RE AT END OF ADDR SPACE
        ADD     #376,R0         ; IAR OFFSET
        MOV     2(SP),R2        ; RESTORE CSR ADDRESS
        CMP     R3,R0           ; CHECK IT...
        BLO     35$             ; GO READ NEXT MODULE
        TST     (SP)+           ; CLEAR STACK (MODULE TYPE)
        BISB    #CBIT,(R2)      ; CLEAR PCS TIMEOUT LIGHT AFTER ALL THIS
        MOV     #23.,R3         ; DELAY AT LEAST 20 MICROSECONDS (ON
64$:    DEC     R3              ; ..AN 11/70), LONGER ON MOST PDP-11'S
        BNE     64$             ; ..TO GIVE PCS TIME TO CLEAR ITSELF
        BISB    #EBIT,(R2)      ; ENABLE PCS INT FOR THIS CONTROLLER
;
; END OF ADDRESS SPACE
;
        MOV     (SP)+,(SP)+     ; POP 2 (CSR, BASE ADDRESS)

  .IFDF I$$PUN

        CMPB    (SP),#<N$$PCS-1>*2 ; TEST IF THIS IS LAST PCS
        BGE     65$             ; ..YES
        ADD     #2,(SP)         ; NEXT CONTROLLER
        MOV     (SP),R3         ; UPDATE UCB POINTER!
        MOV     CNTBL-2(R3),CNTBL(R3) ; ...
        JMP     30$             ; ..                                    ;JC031
                                                                        ;**-1
  .ENDC

;
; DONE WITH LAST CONTROLLER
;
65$:    TST     (SP)+           ; CLEAN STACK
66$:    MOV     R5,LSTMAP       ; SAVE ADDRESS OF LAST MAP ADDRESS

 .IFT                           ; (I$$PPF)

        CLR     @PFPTR          ; DEFINE END OF CONTROL TABLE

.ENDC                           ; (I$$PPF)
;
; INIT NUMBER OF POINTS FOR COS AND DSI MODULES IN UNSOLICITED
; INTERRUPT TABLES
;
 .IF DF I$$PCO

        MOV     #COS,R1         ; DEFINE COS MODULE TYPE
        MOV     S.CI(R4),R0     ; GET UNSOL INT ADDR                    ;JC037
        CALL    INNPT           ; INIT THE TABLE                        ;**-1

 .ENDC
 .IF DF I$$PDI

        MOV     #DSI,R1         ; DEFINE DSI MODULE TYPE
        MOV     S.SI(R4),R0     ; GET UNSOL INT TABLE
        CALL    INNPT           ; INIT IT
;
; HERE WE ALLOCATE, IF NECESSARY, AND ZERO OUT THE CHANGE-OF-STATE
; HISTORY TABLE FOR DSI MODULES. ONE BYTE PER BYTE OF DSI MODULE IS
; ALLOCATED AND USED BY THE INTERRUPT HANDLER TO SAVE THE VALUE
; OF THE MOST RECENT INTERRUPT.
;
        MOV     S.COS(R4),R0    ; GET ADDRESS OF CURRENT HSTORY BLOCK
        BEQ     90$             ; ..NEVER GOT ONE
        MOV     S.NSI(R4),R1    ; GET SIZE OF CURRENT BLOCK
        ADD     #4,R5           ; R5=MAX BYTE # = # BYTES-S. CONVERT IT
        BIC     #3,R5           ; TO NEXT MULTIPLE OF 4 FOR ALLOCATION.
        CMP     R5,R1           ; IS TABLE THE RIGHT SIZE?
        BLE     100$            ; YES
        CALL    $DEACB          ; GET RID OF CURRENT BLOCK
90$:    MOV     R5,R1           ; GET SIZE OF NEW BUFFER
        CLR     S.COS(R4)       ; ..JUST IN CASE ALLOC FAILS
        CALL    $ALOCB          ; GET NEW BUFFER
        BCS     150$            ; ..CAN'T DO
        MOV     R0,S.COS(R4)    ; SAVE RESULTS
        MOV     R1,S.NSI(R4)
100$:   CLRB    (R0)+           ; INITIALIZE TABLE
        DEC     R1
        BNE     100$
150$:                           ; REFERENCE

 .ENDC

        RETURN


.DSABL LSB
        .PAGE
        .SBTTL  ADMAP - MAP A/D CONVERTER MODULES
;+
; **-ADMAP - A/D MAPPING SUBROUTINE
;
; INPUTS: R3 = PHYSICAL ADDRESS OF MODULE
;       DON'T TOUCH R5
;       R4 -> SCB
;       R2 -> MODULE TYPE FIELD OF GENERIC CODES TABLE
;       2(SP) = MODULE TYPE (ADI12 OR ADI14)
;       4(SP) -> CSR FOR THE UNIT
;       6(SP) -> MODULE BASE FOR UNIT
;       10(SP) = CONTROLLER INDEX (UNIT*2)
;
; OUTPUTS: R0 THROUGH R2 DESTROYED
;       R3 UPDATED TO POINT TO NEXT MODULE IN PCS
;       R4-R5 PRESERVED
;       STACK CONTENTS PRESERVED
;-
.IF DF  I$$PAD ! I$$P14

ADMAP:  MOV     R5,-(SP)        ; SAVE R5 ON STACK
                                ; ****NOTE**** THAT ALL STACK OFFSETS
                                ; ...ARE NOW TWO GREATER THAN AT CALL
        MOV     S.ADC(R4),R0    ; GET ADDRESS OF MASTER A/D TABLE
        BNE     30$             ; IF NE, THERE IS ONE ALREADY
        MOV     #ADLG,R1        ; LENGTH OF SPACE TO ALLOCATE
        MOV     R2,-(SP)        ; SAVE REGISTER THAT $ALOCB CLOBBERS
        CALL    $ALOCB          ; ALLOCATE SPACE FOR MAPPING TABLE
        MOV     (SP)+,R2        ; RESTORE REGISTER
        BCS     MAPDON          ; IF NO ROOM, GIVE UP RIGHT NOW
        MOV     R0,S.ADC(R4)    ; SET TABLE POINTER
        ASR     R1              ; THIS WILL BE CLEAR LOOP COUNTER
        MOV     R0,R5           ; COPY POINTER SO WE DON'T CLOBBER IT
20$:    CLR     (R5)+           ; CLEAR A WORD OF THE TABLE
        DEC     R1              ; COUNT PASSES
        BGT     20$             ; LOOP UNTIL WE'VE CLEARED IT ALL
30$:    ADD     #256.,(R0)      ; UPDATE MAXIMUM NUMBER OF CHANNELS
        CLRB    ADFR(R0)        ; CLEAR FORK-REQUEST FLAG
        CLRB    ADIP(R0)        ; CLEAR CONVERSIONS-IN-PROGRESS COUNT
        ADD     #2,NADC         ; UPDATE # ADC'S TIMES 2
        CMP     NADC,#2*16.     ; CHECK AGAINST 16-CONVERTER HARD LIMIT
        BGT     MAPDON          ; IF GT TOO MANY, IGNORE THIS CONVERTER
        ADD     NADC,R0         ; ...
        ADD     #ADCONV-2,R0    ; CALCULATE ADDRESS OF ADCONV ENTRY
        MOV     (R0),R1         ; GET ADDRESS OF ADC ENTRY
        BNE     50$             ; IF NE, THERE IS ONE ALREADY
        MOV     R0,-(SP)        ; SAVE PTR TO TABLE PTR
        MOV     R2,-(SP)        ; SAVE PTR TO GENERIC CODES TABLE

 .IF DF I$$PAD

        MOV     #LGAD12,R1      ; ASSUME WE HAVE A 12-BIT CONVERTER

  .IF DF I$$P14

        CMPB    (R2),#ADI12     ; IS THIS THE TRUTH?
        BEQ     40$             ; IF EQ YES, GO ALLOCATE BLOCK

  .ENDC
 .ENDC
 .IF DF I$$P14

        MOV     #LGAD14,R1      ; IT'S A 14-BITTER, SET BLOCK SIZE

 .ENDC

40$:    CALL    $ALOCB          ; ALLOCATE A BLOCK FOR THE TABLE
        MOV     (SP)+,R2        ; RESTORE R2
        MOV     R0,R1           ; COPY ADDRESS OF THE TABLE
        MOV     (SP)+,R0        ; POP PTR TO ADCONV ENTRY
        BCS     MAPDON          ; IF NONE AVAILABLE, ABORT THINGS
        MOV     R1,(R0)         ; STORE POINTER TO CONVERTER TABLE
50$:    MOV     R3,(R1)         ; STORE BUS ADDRESS OF A/D CONVERTER
        MOVB    (R2),ADTYP(R1)  ; STORE TYPE OF THE CONVERTER

 .IF DF I$$P14 & I$$PAD

        CMPB    (R2),#ADI14     ; IS THIS A 14-BIT A/D
        BEQ     MAP14           ; YES, GO MAP IT A DIFFERENT WAY

 .ENDC
 .IF DF I$$PAD

        ADD     #ADMUX,R1       ; POINT AT MAX-CHANNEL-ON-MUX BYTES
        CLR     -(SP)           ; SELECT MUX 0, CHANNEL 0
                                ; ****NOTE**** THAT ALL STACK ADDRESSES
                                ; ...ARE NOW 4 GREATER THAN AT CALL
        MOV     4+4(SP),R2      ; PICK UP CSR ADDR
60$:    MOVB    (SP),2(R3)      ; PROGRAM MUX N, CHANNEL 0
        BISB    #GBIT,(R2)      ; SET GENERIC BIT IN CSR
        CLC                     ; ENSURE CARRY IS CLEAR IF MUX IS THERE
        MOVB    2(R3),R0        ; ATTEMPT TO READ GENERIC CODE
        BICB    #GBIT,(R2)      ; CLEAR GENERIC BIT IN CSR
        BCC     63$             ; IF CC, THE MUX EXISTS
        BISB    #RIF,(R2)       ; SETTING RIF WILL CLEAR ERROR CONDITION
        TSTB    (R3)            ; ..WHEN WE READ BYTE 0 OF CONVERTER
        CLRB    (R1)+           ; SET # CHANNELS ON MUX TO ZERO
        BR      80$             ; GO TRY THE NEXT MUX
63$:    MOV     #MXDEF,R5       ; POINT AT MUX DEFINITION TABLE
65$:    CMPB    R0,(R5)+        ; IS THIS THE MUX TYPE WE WANT?
        BEQ     70$             ; IF EQ YES, GO STORE # CHANNELS
        TSTB    (R5)+           ; NO, SKIP OVER # CHANNELS AND TEST
        BNE     65$             ; IF NE, TABLE HAS MORE ENTRIES
        TSTB    -(R5)           ; END OF TABLE, MAKE R5 POINT AT A ZERO
70$:    MOVB    (R5),(R1)+      ; FOUND # CHANNELS, SAVE IT IN TABLE
80$:    ADD     #40,(SP)        ; MOVE TO NEXT MUX
        TSTB    (SP)            ; SEE IF # OVERFLOWED TO TOP BYTE
        BNE     60$             ; IF LOW BYTE NZ, DIDN'T OVERFLOW YET
        TST     (SP)+           ; CLEAN STACK
                                ; ****NOTE**** THAT ALL STACK ADDRESSES
                                ; ...ARE NOW 2 GREATER THAN AT CALL

  .IF DF I$$P14

        BR      MAPDON          ; GO CLEAN UP AND RETURN

  .ENDC                         ; (I$$P14)
 .ENDC                          ; (I$$PAD)
 .IF DF I$$P14

MAP14:  MOVB    1(R2),ADCHN(R1) ; SET NUMBER OF CHANNELS ON CONVERTER
        ADD     #ADUADS,R1      ; POINT AT USER-ADDRESSES STACK
        MOV     #2*4,R0         ; WORD SIZE OF THE STACK
10$:    CLR     (R1)+           ; CLEAR USER-ADDRESS STACK
        DEC     R0              ; ...
        BGT     10$             ; ...

 .ENDC                          ; (I$$P14)

MAPDON: MOV     (SP)+,R5        ; RESTORE R5
        ADD     #4,R3           ; UPDATE NEXT BUS ADDRESS TO TEST
        RETURN                  ; RETURN TO CALLER

.ENDC                           ; (I$$PAD!I$$P14)

        .PAGE
        .SBTTL  SAVTR4 - SAVE & REPLACE ILLEGAL MEM REF TRAP
;
; SAVTR4 - COROUTINE TO SAVE ILLEGAL REFERENCE TRAP AND REPLACE
; WITH LOCAL TRAP HANDLER FOR USE IN POWER RECOVERY HANDLER TO
; CREATE MAPPING TABLE.
;
; CALLING SEQUENCE:
;
;       JSR     R0,SAVTR4
;
SAVTR4: MOV     ILLMEM,-(SP)    ; SAVE OLD TRAP CONTENTS
        MOV     #IPILLM,ILLMEM  ; REPLACE WITH NEW
        CALL    (R0)            ; CO-ROUTINE CALL TO CALLER
        MOV     (SP)+,ILLMEM
        MOV     (SP)+,R0        ; UNDO THE CALL
        RETURN

;
; IPILLM - ILLEGAL MEM REF OCCURED DURING SET-UP OF MODULE MAP TABLES
; PRESUMABLY THIS MEANS A NON-EXISTENT MODULE WAS REFERENCED.
;
IPILLM: BIS     #1,2(SP)        ;;; SET CARRY BIT FOR RTI
        RTI                     ;;; PRAY
        .PAGE
        .SBTTL  UNMAP - RELEASE PREVIOUSLY ALLOCATED MAPPING TABLES
;
; UNMAP - SUBROUTINE TO RELEASE OLD MAPPING TABLES
;
; CALLING SEQUENCE:
;
;       JSR     PC,UNMAP
;
; INPUT PARAMETERS:
;
;       R4      POINTS TO THE SCB FOR THE UNIT BEING MAPPED NOW
;
; OUTPUT PARAMETERS:
;
;       NONE
;
; SIDE EFFECTS:
;
;       ALL CORE POINTED TO BY THE SCB THAT WAS ALLOCATED VIA $ALOCB
;       FOR MAPPING TABLES HAS BEEN DEALLOCATED.
;

.IF DF  I$$PDI ! I$$PAD ! I$$P14

UNMAP:  JSR     R3,SAVER        ; SAVE R0 THROUGH R3 IN COROUTINE

 .IF DF I$$PDI

        MOV     S.COS(R4),R0    ; IS THERE A COS TABLE IN THIS SCB?
        BEQ     10$             ; IF EQ NO, GO LOOK FOR ADC TABLES
        MOV     S.NSI(R4),R1    ; YES, GET SIZE FOR DEALLOCATION
        CLR     S.COS(R4)       ; CLEAR PTR TO FLAG IT'S GONE
        CALL    $DEACB          ; AND GET RID OF IT TO FREE UP SPACE
10$:

 .ENDC
 .IF DF I$$PAD ! I$$P14

        MOV     S.ADC(R4),R3    ; IS THERE AN ADC TABLE ON THIS UNIT?
        BEQ     50$             ; IF EQ NO, WE ARE DONE
        ADD     #ADCONV,R3      ; YES, POINT AT SUB-TABLE POINTERS
        MOV     #16.,-(SP)      ; THIS IS COUNT OF SUBTABLES
20$:    MOV     (R3)+,R0        ; IS THERE A SUBTABLE HERE?
        BEQ     40$             ; IF EQ NO, GO TRY NEXT ONE

  .IF DF I$$PAD

        MOV     #LGAD12,R1      ; ASSUME IT IS A 12-BIT A/D

   .IF DF I$$P14

        CMPB    ADTYP(R0),#ADI12 ; IS IT REALLY?
        BEQ     30$             ; IF EQ YES, GO DEALLOCATE

   .ENDC                        ; (I$$P14)
  .ENDC                         ; (I$$PAD)
  .IF DF I$$P14

        MOV     #LGAD14,R1      ; NO, IT MUST BE 14 BITTER

  .ENDC                         ; (I$$P14)

30$:    MOV     R3,-(SP)        ; SAVE REG $DEACB CLOBBERS
        CALL    $DEACB          ; GET RID OF THE SUBTABLE
        MOV     (SP)+,R3        ; RESTORE R3
40$:    DEC     (SP)            ; COUNT SUBTABLES
        BGT     20$             ; LOOP UNTIL WE'VE DONE THEM ALL
        TST     (SP)+           ; CLEAN LOOP COUNT OFF STACK
        MOV     S.ADC(R4),R0    ; NOW WE CAN GET RID OF ADC TABLE
        CLR     S.ADC(R4)       ; AND FLAG THAT IT IS GONE
        MOV     #ADLG,R1        ; ...
        CALL    $DEACB          ; ...

 .ENDC                          ; (I$$PAD!I$$P14)

50$:    RETURN                  ;

.ENDC                           ; (I$$PDI!I$$PAD!I$$P14)

        .PAGE
        .SBTTL  PCS I/O CANCEL AND TIMEOUT ENTRIES
;+
; **-PCSCAN = PCS I/O CANCEL
; DISCONNECT ANY CONNECTED CIRCULAR BUFFERS
; INPUT CONDITIONS:
; R0=ACTIVE I/O PACKET ADDR, R1=TCB ADDR OF CURRENT TASK,
; R3=CONTROLLER INDEX, R4=SCB ADDR, R5=UCB ADDR, PS=PR6
;
;-
IPCAN:                                                                  ;MSH026
PCSCAN: MOV     R1,R0           ;;; COPY TCB ADDRESS

.IF DF I$$PCO

        MOV     S.CI(R4),R3     ;;; CANCEL I/O ON COS MODULES           ;JC037
        CALL    DISCNC          ;;; ...                                 ;**-1

.ENDC
.IF DF I$$PDI

        MOV     S.SI(R4),R3     ;;; CANCEL I/O ON DSI MODULES
        CALL    DISCNC          ;;; ...

.ENDC
                                                                        ;JC031
.IF DF  I$$PTI                                                          ;JC031
                                                                        ;JC031
        MOV     S.TI(R4),R3     ; CANCEL I/O ON COUNTER MODULES         ;JC031
        CALL    DISCNC          ; ...                                   ;JC031
        BCS     30$             ; IF CARRY SET NO COUNTERS CONNECTED    ;JC031
        INCB    T.IOC(R5)       ; RESET I/O COUNT                       ;JC031
        MOV     IMTYP(R3),R2    ; RETRIEVE COUNTER MASK WORD            ;JC031
        BIT     #MTIN08,R2      ; 8-BIT COUNTERS CONNECTED?             ;JC031
        BEQ     10$             ; IF EQ NO                              ;JC031
        DECB    T.IOC(R5)       ; YES DECREMENT I/O COUNT               ;JC031
10$:    BIT     #MTIN16,R2      ; 16-BIT INPUT COUNTERS?                ;JC031
        BEQ     20$             ; IF EQ NO                              ;JC031
        DECB    T.IOC(R5)       ; YES DECREMENT I/O COUNT               ;JC031
20$:    BIT     #MTOU16,R2      ; 16-BIT OUTPUT COUNTER?                ;JC031
        BEQ     30$             ; IF EQ NO                              ;JC031
        DECB    T.IOC(R5)       ; DECREMENT I/O COUNT                   ;JC031
.ENDC                                                                   ;JC031
                                                                        ;JC031
30$:    RETURN                                                          ;JC031
                                                                        ;**-2
;+
; **-PCSTMO = PCS DEVICE TIMEOUT
; ABORT ANY OUTSTANDING A/D REQUESTS
;-
        .DSABL  LSB
IPOUT:                                                                  ;MSH026
PCSTMO:

.IF DF  I$$PAD!I$$P14

        MTPS    #0              ;;; ENABLE INTERRUPTS
        MOV     S.ADC(R4),R3    ; GET ADDRESS OF A/D TABLE
        BEQ     30$             ; IF EQ NONE, IGNORE TIMEOUT
        TSTB    ADIP(R3)        ; ANY CONVERSIONS IN PROGRESS?
        BEQ     30$             ; IF EQ NONE, IGNORE TIMEOUT
        CLRB    ADIP(R3)        ; YES, RESET COUNT OF THEM TO ZERO
        MOV     R3,R2           ; POINT R2 AT CONVERTER ENTRIES
        ADD     #ADCONV,R2      ; ...
        MOV     #16.,R0         ; MAXIMUM NO. OF CONVERTERS (LOOP CNT)
10$:    MOV     (R2)+,R1        ; GET POINTER TO AN ENTRY
        BEQ     20$             ; IF NONE, TRY NEXT
        ASSUME  ADUAD,EQ,ADUADS ;
        BIC     #1,(R1)         ; CLEAR CONVERTER-BUSY BIT
        TST     ADUAD+2(R1)     ; ANY CONVERSIONS OUTSTANDING?
        BEQ     20$             ; IF EQ NO, DON'T RESET STATUS
        MOV     #IE.DNR&377,ADSTS(R3) ; YES, SET STATUS TO "ABORTED"
        CLR     ADUAD+2(R1)     ; RESET OUTSTANDING CONVERSIONS FLAG

 .IF DF I$$P14
  .IF DF I$$PAD

        CMPB    ADTYP(R1),#ADI14 ; IS THIS A 14-BIT CONVERTER?
        BNE     20$             ; IF NE NO, DON'T MESS WITH ADDRS

  .ENDC                         ; (I$$PAD)

        ADD     #ADUADS,R1      ; POINT R1 AT USER-ADDRESS STACK
        MOV     #4*2,-(SP)      ; SIZE OF AREA TO BE CLEARED
15$:    CLR     (R1)+           ; CLEAR USER ADDRESSES
        DEC     (SP)            ; ...
        BGT     15$             ; ...
        TST     (SP)+           ; CLEAN STACK

 .ENDC                          ; (I$$P14)

20$:    DEC     R0              ; COUNT CONVERTERS
        BGT     10$             ; LOOP IF MORE ARE LEFT
        JMP     ADRLSP          ; GO RELEASE THE I/O PACKET

.ENDC                           ; (I$$PAD!I$$P14)

30$:    RETURN                  ; NO A/D OUTSTANDING, IGNORE TIMEOUT
        .PAGE
.IF DF I$$PUI
        .SBTTL   PCSUNL -- GENERAL UNLINKING SUBROUTINE
;
; CALLING SEQUENCE:
; R1 = MATCH PARAMETER, R2 = #S.XX WHERE XX=DI OR SI
;       CALL    PCSUNL
;        BCS    NO-SUCH-MODULE
;        BMI    NOT-LINKED
;
; MATCH PARAMETER = ADDRESS OF TASK NAME (TASK UNLINKING)
;                 = EF*2+1 FOR EVENT FLAG UNLINKING OF SPECIFIED EF FIELD
;                 = -1 TO REMOVE ALL EVENT FLAG LINKAGES
;
.ENABL LSB

PCSUNL: ADD     R4,R2           ; GET ADDR OF PTR TO UNSOL INT TABLE
        MOV     R1,-(SP)        ; SAVE WORK REG

 .IF DF I$$PUN

        CLR     -(SP)           ; SAVE SPOT FOR CONTROLLER INDEX

 .IFTF

        MOV     (R2),U.CW2(R5)  ; GET ADDRESS OF TABLE
        BEQ     A90$            ; TABLE NOT CONFIGURED                  ;JC031
        MOV     R1,U.CW3(R5)    ; SAVE MATCH PARAMETER                  ;**-1
        CLR     -(SP)           ; INITIALIZE MATCH COUNTER
5$:     MOV     U.CW2(R5),R0    ; FIND RESOURCE LINK LISTHEAD
        ADD     #IMLH,R0        ; ..

 .IFT

        ADD     2(SP),R0        ; ADD CONTROLLER DOUBLE INDEX

 .IFTF

 .IF DF I$$PEF

        BIT     #1,R1           ; TEST IF THIS IS EF LINKAGE REMOVAL
        BNE     35$             ; ..YES

 .IFTF

        MOV     R0,R2           ; COPY LISTHEAD
        MOV     R1,R3           ; COPY ADDRESS OF TASK NAME
        CALL    $SRSTD          ; SEE IF TASK IS INSTALLED
         BCS    A91$            ; ..NO                                  ;JC031
        MOV     R0,R3           ; COPY TCB ADDRESS                      ;**-1
        MOV     R2,R0           ; RESTORE LISTHEAD
        MOV     #PCTLH,R1       ; GET ADDR OF TASK LINKAGE LIST
10$:    MOV     (R1),R1         ; GET NEXT LINK
        BEQ     41$             ; TASK NOT LINKED
        CMP     R3,LTCB(R1)     ; TEST FOR THE RIGHT LINKAGE ENTRY
        BNE     10$             ; ..NOT YET
;
; HERE WE REMOVE A LINKAGE AS DEFINED BY R1 AND DEALLOCATE
; THE ENTRY.
;
30$:                                                                    ;JC031
                                                                        ;JC031
        .IF DF  I$$PTI                                                  ;JC031
                                                                        ;JC031
        MOV     U.CW2(R5),R2    ; RETRIEVE LISTHEAD                     ;JC031
        TSTB    IMTYP(R2)       ; COUNTER PROCESSING?                   ;JC031
        BEQ     34$             ; IF EQ NOT CTR OR ALL CTR'S            ;JC031
31$:    MOV     R0,-(SP)        ; SAVE CURRENT LINK                     ;JC031
        MOV     (R0),R0         ; POINT TO FIRST/NEXT                   ;JC031
        BNE     310$            ; CONTINUE                              ;JC031
        MOV     (SP)+,R0        ; RESTORE R0                            ;JC031
        BR      46$             ; CHECK NEXT CONTROLLER                 ;JC031
310$:   CMP     R1,ILTE(R0)     ; RESOURCE CONNECTED TO THIS TASK?      ;JC031
        BNE     32$             ; IF NE NO - CHECK NEXT                 ;JC031
        CMPB    IMTYP(R2),ILRES(R0) ;RIGHT MODULE TYPE?                 ;JC031
        BEQ     33$             ; IF EQ YES - REMOVE LINK               ;JC031
        CMPB    #IN08,IMTYP(R2) ; COULD BE 8-BIT CTR IS IT?             ;JC031
        BNE     32$             ; NOT PROCESSING 8-BIT COUNTERS         ;JC031
                                ; GO CHECK NEXT ENTRY                   ;JC031
        BITB    #10,ILRES(R0)   ; IS THIS AN 8-BIT ENTRY?               ;JC031
        BEQ     33$             ; IF EQ YES - REMOVE IT                 ;JC031
32$:    TST     (SP)+           ; CLEAN STACK                           ;JC031
        BR      31$             ; CHECK NEXT ENTRY                      ;JC031
33$:    MOV     (SP)+,R0        ; SET R0 WITH PTR TO ENTRY TO REMOVE    ;JC031
                                                                        ;JC031
        .ENDC                                                           ;JC031
                                                                        ;JC031
34$:    MOV     R1,-(SP)        ; SAVE MATCH PARAMETER                  ;JC031
        MTPS    S.PRI(R4)       ;;; INHIBIT DEVICE INTERRUPTS           ;**-1
        CALL    $QRMVT          ;;; REMOVE MATCHING LINK
         BCS    40$             ;;; ..NONE EXISTS
        MTPS    #0              ; ENABLE DEVICE
        INC     2(SP)           ; COUNT THE MATCH
        JSR     R5,DEALL        ; DEALLOCATE THE BLOCK
         .WORD  ILGH            ; LENGTH OF BLOCK
        MOV     (SP)+,R1        ; RESTORE MATCH FLAG

  .IFT                          ; (I$$PEF)

        BIT     #1,R1           ; TEST IF EF LINKAGE
        BNE     35$             ; ..YES, CONTINUE

 .IFTF

;
; HERE WE DO BOOKKEEPING IN THE TASK LINKAGE ENTRY AND
; DEALLOCATE IT IF NO RESOURCE LINKS REMAIN.
;
        DEC     LUSE(R1)        ; DECREMENT TASK USE COUNT
        BNE     30$             ; ..AND CONTINUE
        MOV     R0,-(SP)        ; SAVE LISTHEAD
        MOV     #PCTLH,R0       ; DEFINE TASK LINK LISTHEAD
        CALL    $QRMVT          ; PULL OUT THIS ENTRY
        MOV     (SP)+,R0        ; RESTORE RESOURCE LISTHEAD
        JSR     R5,DEALL        ; DEALLOCATE THE BLOCK (R1)
         .WORD  LLGH            ; SIZE OF BLOCK
        BR      41$             ; CHECK EF LINKAGE REMOVAL
A90$:   JMP     90$             ; OUT OF RANGE                          ;JC031
A91$:   JMP     91$             ; OUT OF RANGE                          ;JC031

  .IFT                  ; (I$$PEF)

;
; HERE WE FIND AN EVENT FLAG LINKAGE IF ALL ARE BEING REMOVED.
;
35$:    CMP     U.CW3(R5),#-1   ; TEST IF UNLINKING ALL EF'S
        BNE     30$             ; ..NO
        MOV     R0,R2           ; COPY LISTHEAD
38$:    MOV     (R2),R2         ; ..YES, FIND A MATCH FLAG
        BEQ     46$             ; NONE
        MOV     ILTE(R2),R1     ; GET TASK LINKAGE ENTRY
        BIT     #1,R1           ; TEST ODD BIT, MEANS EF LINKAGE
        BEQ     38$             ; ..NOT THERE
        BR      30$             ; GO UNLINK THIS ONE

  .IFTF

;
; DONE WITH THIS LIST
;
40$:    MTPS    #0              ; RESTORE PRIORITY
        MOV     (SP)+,R1        ; RESTORE MATCH
41$:

.IFT                            ; (I$$PEF)

        BIT     #1,R1           ; SEE IF THIS IS EF LINKAGE REMOVAL
        BNE     46$             ; ..YES, IGNORE FOLLOWING
;
; HERE WE REMOVE LOCAL EF LINKAGES WHERE EF'S BELONG TO THIS TASK
;
42$:    MOV     R3,-(SP)        ; ASSUME TCB IN R3
        TST     R1              ; IF 0, ONLY UNLINKING EF/TASK
        BEQ     43$             ; ..
        MOV     LTCB(R1),(SP)   ; SAVE TCB ADDRESS
43$:    MOV     R0,R1           ; COPY LISTHEAD
44$:    MOV     (R1),R1         ; CHECK EACH RESOURCE
        BEQ     45$             ; DONE
        BIT     #1,ILTE(R1)     ; FIND THOSE WHICH ARE EF LINKAGES
        BEQ     44$             ; ..THIS ONE ISN'T
        CMP     ILEVA(R1),(SP)  ; FIND THOSE WITH LOCAL EF'S FOR TASK
        BNE     44$             ; ..NOT THIS ONE
        MTPS    S.PRI(R4)       ;;; INHIBIT DEVICE
        CALL    $QRMVT          ;;; REMOVE THE ENTRY
        MTPS    #0              ; ENABLE DEVICE
        INC     2(SP)           ; COUNT THE REMOVED ENTRY
        JSR     R5,DEALL        ; DEALLOCATE THE BLOCK
         .WORD  ILGH            ; LENGTH OF BLOCK
        BR      43$             ; TRY FOR ANOTHER ONE
45$:    TST     (SP)+           ; CLEAR STACK

 .ENDC                          ; (I$$PEF)

46$:                            ; REFERENCE LABEL


 .IFT                           ; (I$$PUN)

        CMP     2(SP),#4*<N$$PCS-1> ; TEST IF ALL CONTROLLERS HANDLED
        BHIS    50$             ; ..YES
        ADD     #4,2(SP)        ; ..NO-CONTINUE WITH NEXT CONTROLLER
        MOV     U.CW3(R5),R1    ; RESTORE ORIGINAL MATCH
        JMP     5$              ; ..                                    ;JC031
                                                                        ;**-1
 .IFTF

50$:    TST     (SP)+           ; SEE IF ANY BLOCKS WERE DEALLOCATED
        BNE     95$             ; ..YES
55$:    MOV     #IE.NLK&377,R0  ; ..NO, TASK NOT LINKED ERROR
        BR      96$             ; ..
;
; ERROR AND EXIT CONDITIONS
;
90$:    MOV     #IE.MOD&377,R0  ; NO SUCH MODULE
        BR      92$
91$:    MOV     #IE.NST&377,R0  ; TASK NOT INSTALLED
        TST     (SP)+           ; POP MATCH COUNTER
92$:    SEC                     ; SET FAILURE RETURN CODE
        BR      97$

95$:    MOV     #IS.SUC&377,R0  ; SUCCESS
96$:    CLC                     ; SET SUCCESS RETURN CODE
97$:                            ; REFERENCE

 .IFT                           ; (I$$PUN)

        TST     (SP)+           ; POP CONTROLLER NUMBER

 .ENDC

        MOV     (SP)+,R1        ; RESTORE MATCH PARAMETER
        BISB    R0,R0           ; SET N BIT IF ERROR (IE.XXX)
        RETURN                  ; DONE

.DSABL LSB

.ENDC                           ; (I$$PUI)

;
; LOCAL SUBROUTINE TO DEALLOCATE BLOCK POINTED TO BY R1 AND
; PRESERVING R0. SIZE OF BLOCK IS PASSED AS IN-LINE ARGUMENT:
;       JSR     R5,DEALL
;       .WORD   SIZE-IN-BYTES
;
DEALL:  MOV     R0,-(SP)        ; SAVE R0
        MOV     R1,R0           ; COPY ADDRESS
        MOV     (R5)+,R1        ; GET SIZE
        CALL    $DEACB          ; DEALLOCATE BLOCK
        MOV     (SP)+,R0        ; RESTORE R0
;
; NOTE: R2 AND R3 ARE BLOWN BY THIS ROUTINE
;
        RTS     R5              ; RETURN
.IF DF  I$$PUI

.ENABL LSB
        .PAGE
        .SBTTL   DISCNC -- DISCONNECT CIRCULAR BUFFER FROM INTERRUPTS
;
; INPUTS:
; R0 = TCB, R3 = UNSOL INT TABLE, R4 = SCB, R5 = UCB
; PS MAY BE AT DEVICE PRIORITY,  CC'S SET FROM MOV R3,R3
;
; OUTPUTS:
;       BCC=SUCCESS
;       BCS/BEQ=NO SUCH MODULE, BNE=NOT CONNECTED TO BUFFER
;
DISCNC: BEQ     10$             ;;; NO SUCH TABLE
        CMP     R0,IMTCB(R3)    ;;; SEE IF TASK IS CONNECTED
        BNE     10$             ;;; ..NO
        CLR     IMTCB(R3)       ;;; RESET CONNECTION TABLE PARAMETERS
        CLR     IMEVA(R3)       ;;; ...
        CLR     IMEVM(R3)       ;;; ...
        DECB    T.IOC(R0)       ;;; DECREMENT OUTSTANDING I/O COUNT

 .IF DF D$$SHF

        MOV     T.PCB(R0),R1    ;;; GET ADDR OF PCB
        BIC     #PS.NSF,P.STAT(R1) ;;; ENABLE TASK SHUFFLING

 .ENDC

        BR      20$
10$:    SEC                     ;;; ERROR FLAG
20$:    RETURN                  ;;; COMMON EXIT

.DSABL LSB
.ENDC                           ;;; (I$$PUI)
        .PAGE
        .SBTTL   INNPT -- INITIALIZE MAX # PTS IN UNSOLICITED INT TABLES
;
; INPPT
;
; INPUTS:       R0 = ADDR OF UNSOLICITED INTERRUPT TABLE
;               R1 = MODULE TYPE
;               R4 = SCB
;               CC'S SET AS FROM TST R0
; OUTPUT:       R5 = MAX ENTRY OFFSET
;
.IF DF  I$$PUI
.ENABLE LSB

INNPT:  BEQ     30$             ; NO SUCH TABLE CONFIGURED
        ASL     R1              ; MAKE MODULE TYPE INTO WORD INDEX
        ADD     #S.IPM-2,R1     ; GET LISTHEAD FOR MAPPING TBL, THIS TYPE
        ADD     R4,R1           ; ...
        CLR     R2              ; INI MAX POINT NUMBER
        CLR     R5              ; SET UP TO RETURN MAX ENTRY#
10$:    MOV     (R1),R1         ; GET FIRST/NEXT MAP ENTRY (DENSE SET)
        BEQ     20$             ; DONE
        MOV     IPMMAX(R1),R2   ; GET CURRENT MAX ENTRY NUMBER
        MOV     R2,R5           ; COPY MAX ENTRY NUMBER
        BR      10$             ; CONTINUE
20$:    ASL     R2              ; CONVERT MAX ENTRY TO MAX POINT (MPY8)
        ASL     R2              ; ...
        ASL     R2              ; ...
        MOV     R2,(R0)         ; STORE IN UNSOLICITED INT TABLE
30$:    RETURN                  ; DONE

.DSABL LSB
.ENDC
        .PAGE
        .SBTTL   FGCENT -- FIND GENERIC CODE TABLE ENTRY
;
; INPUTS:       R0 = GENERIC CODE
; OUTPUT:       BCS/THIS MODULE NOT SUPPORTED
;               BCC/R2 HOLDS ADDRESS OF ENTRY IN TABLE GENCOD
;
FGCENT: MOV     #GENCOD,R2      ;;; GET TOP OF TABLE
10$:    CMPB    R0,(R2)         ;;; TEST GENERIC CODE VS TABLE ENTRY
        BEQ     20$             ;;; ..FOUND RIGHT ENTRY
        CMP     (R2)+,(R2)+     ;;; NOT FOUND--STEP TO NEXT ENTRY
        TST     (R2)            ;;; TEST END OF TABLE
        BNE     10$             ;;; ..NOT THERE
        BR      30$             ;;; END OF TABLE--MODULE NOT SUPPORTED
20$:    SEC                     ;;; FLAG SUCCESS
30$:    RETURN                  ;;; EXIT
.DSABL LSB
        .PAGE
        .SBTTL   SAVER -- COROUTINE TO SAVE/RESTORE REGISTERS R3-R0

.IF DF  I$$PAD!I$$P14!I$$PCO!I$$PDI!I$$PTI                              ;JC031
                                                                        ;**-1
; CALLED BY:    JSR     R3,SAVER
; REENTERED BY: RETURN
;
SAVER:  MOV     R2,-(SP)        ;;; SAVE REGISTERS ON STACK
        MOV     R1,-(SP)        ;;; ...
        MOV     R0,-(SP)        ;;; ...
        CALL    (R3)            ;;; CO-ROUTINE CALL
        MOV     (SP)+,R0
        MOV     (SP)+,R1
        MOV     (SP)+,R2
        MOV     (SP)+,R3        ;;; RESTORE ALL
        RETURN                  ;;; RETURN TO $INTSV COROUTINE

.ENDC
        .PAGE
        .SBTTL  DAOUT -- OUTPUT VOLTAGE TO DAC
.IF DF  I$$PDA

;
; INPUTS:       R0 = RELATIVE ENTRY NUMBER OF DAC CHANNEL
;               R1 = VOLTAGE TO BE OUTPUT (10 BITS)
;               R4 = SCB ADDRESS
;
; OUTPUTS:      R0 CHANGED, ALL OTHER REGISTERS UNMODIFIED
;               C/C = NO ERROR, OUTPUT WAS DONE
;               C/S = ILLEGAL CHANNEL, NO OUTPUT DONE
;
DAOUT:  MOV     R5,-(SP)        ; SAVE REGISTER
        MOV     R1,-(SP)        ; SAVE VOLTAGE
        MOV     #DAO,R1         ; SET MODULE TYPE
        CALL    PCSMAP          ; FIND ADDR OF DAC MODULE
         BCS    10$             ; ILLEGAL MODULE
        MOVB    1(SP),1(R0)     ; OUTPUT HIGH ORDER BYTE
        MOVB    (SP),(R0)       ; OUTPUT LOW ORDER BYTE
10$:    MOV     (SP)+,R1        ; RESTORE VOLTAGE
        MOV     (SP)+,R5        ; RESTORE
        RETURN                  ; DONE

.ENDC
.ENABL LSB
        .PAGE
        .SBTTL   PH2REL -- CONVERT PHYSICAL MODULE ADDR TO REL ENTRY NUMBER
;
; INPUTS:       R1 = PHYSICAL BYTE ADDR RELATIVE TO BASE
;               R2 = MODULE TYPE
;               R3 = CONTROLLER INDEX
;               R4 = SCB
; OUTPUTS:      C/S = NO SUCH MODULE
;               C/C: R3 = RELATIVE ENTRY NUMBER
;
; R1 AND R2 ARE MODIFIED
;
PH2REL: ASL     R2              ;;; MAKE WORD INDEX OF MODULE TYPE
        ADD     #S.IPM-2,R2     ;;; CALCULATE ADDR OF MAP HEADER
        ADD     R4,R2           ;;; ...
10$:    MOV     (R2),R2         ;;; GET FIRST/NEXT MAP ENTRY, THIS TYPE
        BEQ     50$             ;;; DONE, NO SUCH MODULE
        CMPB    R3,IPMCON(R2)   ;;; SEE IF RIGHT CONTROLLER
        BNE     10$             ;;; KEEP LOOKING
;
; GOT THE RIGHT DENSE SET. CALCULATE RELATIVE ENTRY NUMBER.
;
        MOVB$C  IPMLOW(R2),R3   ;;; GET BYTE OFFSET OF FIRST ENTRY
        SUB     R3,R1           ;;; CALC RELATIVE BYTE OFFSET OF MODULE

.IF DF  I$$PCO                  ;;; (COS MODULES HAVE FUNNY REQUIREMENTS)

        CMPB    IPMMOD(R2),#COS ;;; IS THIS A COS MODULE?
        BNE     20$             ;;; ..NO
        ASR     R1              ;;; YES, COMPENSATE FOR ALTERNATING PRS
        ADC     R1              ;;;  OF COS BYTES

.ENDC
20$:                            ; REFERENCE

.IF DF  I$$PDA

        CMPB    IPMMOD(R2),#DAO ;;; DAC MODULE?
        BNE     30$             ;;; ..NO
        ASR     R1              ;;; ..YES, COMPENSATE FOR 2 BYTES/ENTRY
30$:    CMPB    IPMMOD(R2),#IN08        ;;; 8-BIT INPUT COUNTER?        ;JC031
        BNE     35$                     ;;; IF NE NO                    ;JC031
;                                                                       ;JC031
; FOR 8-BIT COUNTERS THIS ROUTINE CALCULATE THE LOWEST RELATIVE DEVICE  ;JC031
; NUMBER FOR THE MODULE. TO GET THE ACTUAL RELATIVE ENTRY THE OFFSET    ;JC031
; FOR DEVICE NUMBER WITHIN THIS MODULE MUST BE ADDED TO THE RESULT OF   ;JC031
; THIS ROUTINE.                                                         ;JC031
;                                                                       ;JC031
        ASR     R1                      ;;; ALLOW FOR 2 BYTES PER MODULE;JC031
        ASL     R1                      ;;; AND THEN FOUR RELATIVE ENTRI;JC031
        ASL     R1                      ;;; PER 2 BYTE MODULE           ;JC031
35$:    CMPB    IPMMOD(R2),#IN16        ;;; 16-BIT INPUT COUNTER?       ;JC031
        BEQ     40$                     ;;; IF EQ YES                   ;JC031
        CMPB    IPMMOD(R2),#OU16        ;;; 16-BIT OUTPUT COUNTER?      ;JC031
        BNE     45$                     ;;; IF NE NO                    ;JC031
40$:    ASR     R1                      ;;; TWO BYTES PER DEVICE        ;JC031
45$:                                    ;;; REFERENCE LABEL             ;JC031
                                                                        ;**-1
.ENDC

;
; (HERE, SIMILAR COMPENSATION MUST BE ADDED FOR OTHER MODULES
;  WITH SPECIAL REQUIREMENTS--I.E. NOT ONE BYTE/ENTRY)
;
        MOVB$C  IPMMIN(R2),R3   ;;; GET MINIMUM RELATIVE ENTRY, THIS SET
        ADD     R1,R3           ;;; CALCULATE RELATIVE ENTRY NUMBER
        CLC
        BR      60$             ;;; (NOTE, C/C UNLESS ERROR!)
50$:    SEC                     ;;; FLAG ERROR
60$:    RETURN

.DSABL LSB
.ENABL LSB
        .PAGE
        .SBTTL   PCSMAP -- CONVERT REL BYTE NUMBER TO PHYSICAL ADDRESS
; INPUTS:       R0 = RELATIVE BYTE NUMBER
;               R1 = MODULE TYPE
;               R4 = SCB ADDRESS
; OUTPUTS:      C/S = FAILURE
;               C/C = SUCCESS: R0=PHYSICAL ADDRESS, R1=CONTROLLER INDEX
; IF R5<0 ON INPUT, R5=MAP ENTRY ADDRESS ON SUCCESS EXIT
; OTHER REGISTERS PRESERVED
;
PCSMAP: MOV     R2,-(SP)        ; WORK REGISTERS
        MOV     R3,-(SP)        ; ...
        ASL     R1              ; MAKE WORD INDEX OF MODULE TYPE
        ADD     #S.IPM-2,R1     ; GET MAP HEADER
        ADD     R4,R1           ; ...
10$:    MOV     (R1),R1         ; FIRST/NEXT DENSE SET ENTRY
        BEQ     99$             ; ERROR - END OF LIST
PCSM1:  CMP     R0,IPMMAX(R1)   ; CHECK RANGE OF DENSE SET
        BHI     10$             ; NOT RIGHT SET YET
        MOVB$C  IPMLOW(R1),R2   ; GET RELATIVE OFFSET OF 1ST ENTRY
        MOV     IPMMIN(R1),R3   ; GET MIN RELATIVE ENTRY NUMBER
        SUB     R3,R0           ; CALCULATE LOCAL RELATIVE ENTRY NBR
        BEQ     20$             ; WANT FIRST ENTRY IN DENSE SET

.IF DF  I$$PCO

        CMPB    IPMMOD(R1),#COS ; TEST FOR COS ENTRY
        BNE     15$             ; ...NOT COS
        MOV     R0,R3           ; ADJUST FOR SPECIAL COS ADDRESSING
        BIC     #1,R0           ; STRIP ODD BIT
        ASL     R0              ; MAKE DOUBLE INDEX
        ASR     R3              ; SAVE ODD OFFSET IN CARRY
        ADC     R2              ;  AND USE TO BIAS PHYSICAL OFFSET
        BR      20$             ; ...
15$:                            ; REFERENCE LABEL

.ENDC

.IF DF  I$$PDA

        CMPB    IPMMOD(R1),#DAO ; TEST FOR ANALOG OUTPUT
        BNE     17$             ; ..NO
        ASL     R0              ; ADJUST FOR 2 BYTES/ENTRY
;       BR      20$             ; (ENABLE IF OTHER TESTS REQUIRED)
17$:                            ; REFERENCE

.ENDC
.IF DF  I$$PTI                                                          ;JC031
                                                                        ;JC031
        CMPB    IPMMOD(R1),#IN16 ;16-BIT COUNTER?                       ;JC031
        BEQ     18$             ;IF EQ YES                              ;JC031
        CMPB    IPMMOD(R1),#OU16 ;16-BIT COUNTER?                       ;JC031
        BEQ     18$             ; YES                                   ;JC031
        CMPB    IPMMOD(R1),#IN08 ;8-BIT INPUT COUNTER?                  ;JC031
        BNE     19$             ;  NO CONTINUE                          ;JC031
        ASR     R0              ; FIX RELATIVE BYTE FOR 8-BIT COUNTER   ;JC031
        ASR     R0              ; REL DEVICE /4) * 2                    ;JC031
18$:    ASL     R0              ; ADJUST FOR 2 BYTE DEVICE              ;JC031
        BR      20$             ; CONTINUE                              ;JC031
;                                                                       ;JC031
19$:                                                                    ;JC031
                                                                        ;JC031
.ENDC                                                                   ;JC031

20$:    ADD     R2,R0           ; ADD LOCAL RELATIVE TO BYTE OFFSET
        TST     R5              ; WANT ENTRY ADDR RETURNED?
        BPL     50$             ; ..NO
        MOV     R1,R5           ; ..YES
50$:    MOVB    IPMCON(R1),R1   ; GET CONTROLLER INDEX
        ADD     PCSBAS(R1),R0   ; ADD IN BASE ADDRESS
        CLC                     ; NO ERROR
        BR      100$            ; ...
99$:    SEC                     ; ERROR
100$:   MOV     (SP)+,R3
        MOV     (SP)+,R2        ; RESTORE WORK REGISTERS
        RETURN

.DSABL LSB

;                                                                       ;MSH026
; THIS DRIVER CURRENTLY IS SUPPORTED ONLY UP TO 4K WORDS IF IT IS       ;MSH026
; LOADABLE. IT MUST BE RECONFIGURED IF GREATER THAN 4K WORD SUPPORT     ;MSH026
; IS DESIRED. THIS IS BECAUSE THE DRIVER IS RESPONSIBLE FOR MAPPING     ;MSH026
; ANY PART OF ITSELF THAT IS ABOVE THE 4K WORD BOUNDARY.                ;MSH026
;                                                                       ;MSH026
        .IF DF LD$IP                                                    ;MSH026
                                                                        ;MSH026
        .IF GT <PCSBOT-PCSTOP>-20000                                    ;MSH026
                                                                        ;MSH026
        .ERROR          ;DRIVER TOO LARGE TO BE LOADABLE                ;MSH026
                                                                        ;MSH026
        .ENDC                                                           ;MSH026
                                                                        ;MSH026
        .ENDC                                                           ;MSH026
                                                                        ;MSH026
PCSBOT:                         ;LAST ADDRESS OF DRIVER                 ;MSH026
.END                                                                    ;**-11
        .TITLE IPMAP
;
; AREA TO READ PCS MAP INTO BY ISA FORTRAN SUBROUTINES
;
NMOD=13

IPMAP:: .BLKW   NMOD*N$$PCS*4
        .WORD   0

$I=0

IPMAPF::        .REPT   N$$PCS
        .WORD   $I*4*NMOD       ; OFFSET IN IPMAP FOR THIS CONTROLLER
$I=$I+1
                .ENDR

.IF DF I$$PUN

        LGIPMP==NMOD * N$$PCS * 4 * 2 ;BYTE LENGTH OF MAP ENTRY

.IFF

        LGIPMP==NMOD * 4 * 2

.ENDC

        .PCSBS==I$$PB0                  ; GLOBALLY DEFINE BASE ADDRESS
        .PCSNC==N$$PCS          ;GLOBALLY DEFINE NUMBER OF CONTROLLERS
        .IIF DF I$$PUN,.PCSNC==1;(WE WANT NUMBER OF PERCEIVED CONTROLLERS)
.END
        .TITLE  ISCOM
        .IDENT  /00/
 
;
; COPYRIGHT (C) 1975, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 00
;
; C. A. MONIA   18-JUL-75
;
; DSS11 DEVICE COMMON BLOCK
;
;+
;
; **-ISCOM-DSS11 DIGITAL INPUT SUBSYSTEM DEVICE COMMON BLOCK
;
; THIS MODULE DEFINES THE DSS11 DEVICE COMMON BLOCK THAT IS REFERENCED
; WHENEVER A TASK READS DSS11 DIGITAL INPUT POINTS.
;
;-
 
        .PSECT  ISCOM,RW,GBL,OVR,D
 
        .BLKB   I$$SSC&77               ; COMPUTE OFFSET FROM 32W BOUNDARY
        .BLKW   I$$SDS*4                ; ALLOCATE SPACE FOR DEVICE REGISTERS
 
        .END
        .TITLE  ISDRV
        .IDENT  /01/
 
;
; COPYRIGHT (C) 1975, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 01
;
; C. MONIA 17-JUL-75
;
; PREVIOUSLY MODIFIED BY:
;
;       T. J. MILLER
;
; MODIFIED BY:
;
; DRS/DSS11 DIGITAL I/O SUBSYSTEM DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$,PKTDF$,TCBDF$
 
        HWDDF$                  ; DEFINE HARDWARE OFFSETS
        PKTDF$                  ; DEFINE I/O PACKET OFFSETS
        TCBDF$                  ; DEFINE TCB OFFSETS
 
;
; EQUATED SYMBOLS
;
; INTERRUPT LINK OFFSETS
;
 
        .ASECT
 
.=0
ILTE:   .BLKW   1               ; ADDRESS OF LINKED TASK ENTRY(0=NONE)
ILEVM:  .BLKW   1               ; EVENT FLAG MASK
ILEVA:  .BLKW   1               ; EVENT FLAG ADDRESS
ILRUN:  .BLKW   1               ; RUN FLAG (1=RUN TASK)
ILCSR:  .BLKW   1               ; BUS ADDRESS OF CSR REGISTER
ILGH:   .BLKW   0               ; LENGTH OF INTERRUPT ENTRY
 
;
; LINKED TASK ENTRY OFFSETS
;
 
.=0
LNEXT:  .BLKW   1               ; LINK TO NEXT (0=NONE)
LTCB:   .BLKW   1               ; TCB ADDRESS OF LINKED TASK
LACT:   .BLKW   1               ; ACTIVITY COUNT
LHWR:   .BLKW   1               ; HARDWARE DEPENDANT DATA
LLGH:   .BLKW   0               ; LENGTH OF ENTRY
 
;
; ILLEGAL INTERRUPT POINT MASK
;
 
IPMSK=0
 
        .IF NE  16.-I$$S11
 
IPMSK=100000
 
        .REPT   16.-I$$S11-1
IPMSK=IPMSK/2
        .ENDR
 
        .ENDC
 
 
        .PSECT
 
;
; LOCAL DATA
;
; DRIVER DISPATCH TABLE
;
 
$ISTBL::.WORD   ISCHK           ; DEVICE INITIATOR ENTRY POINT
        .WORD   ISCAN           ; CANCEL I/O ENTRY POINT
        .WORD   ISCAN           ; DEVICE TIMEOUT ENTRY POINT
        .WORD   ISPWF           ; POWER RECOVERY ENTRY POINT
 
;
; FORK REQUEST FLAG
;
 
        .IF DF  I$$SLK
 
FORK:   .BLKW   1               ;
 
 
;
; DIGITAL INTERRUPT LINKED TASK LISTHEAD
;
 
ISLNK:  .WORD   0               ; LIST INITIALLY EMPTY
        .WORD   .-2             ; LAST POINTS TO FIRST
 
;
; DIGITAL INTERRUPT RESOURCE MASK
;
 
ISRES:  .WORD   0               ; ALL RESOURCES AVAILABLE INITIALLY.
 
;
; DIGITAL INTERRUPT LINKAGE TABLE
;
 
ILTBL:                          ;
 
 
        .IF DF  I$$SDR&I$$SDS
 
BUS0=I$$SSC
BUS1=I$$SRC
REP0=I$$SDS
REP1=I$$SDR
 
        .IF LT  I$$SRC-I$$SSC
 
BUS0=I$$SRC
BUS1=I$$SSC
REP0=I$$SDR
REP1=I$$SDS
 
        .ENDC
 
        .IFF
 
BUS1=0
REP1=0
 
        .IF DF  I$$SDR
 
REP0=I$$SDR
BUS0=I$$SRC
 
        .IFF
 
REP0=I$$SDS
BUS0=I$$SSC
 
        .ENDC
 
        .ENDC
 
        .REPT   REP0
        .BLKB   ILGH-2
        .WORD   BUS0
BUS0=BUS0+10
        .ENDR
 
        .REPT   REP1
        .BLKB   ILGH-2
        .WORD   BUS1
BUS1=BUS1+10
        .ENDR
 
        .ENDC
 
 
;
; DIGITAL OUTPUT PREVIOUS STATE TABLE
;
 
        .IF DF  I$$SDR
 
ISPRV:  .BLKW   I$$SDR*3                ;
 
;
; DIGITAL OUTPUT BUS ADDRESS LIST
;
 
ISBUS:                                  ;
 
ADDR=I$$SRC+2
        .REPT   I$$SDR
        .REPT   3
        .WORD   ADDR
ADDR=ADDR+2
        .ENDR
ADDR=ADDR+2
        .ENDR
 
        .ENDC
 
;
; ADDRESS OF UCB
;
 
ISUCB:  .BLKW   1               ;
 
;
; TEMPORARY PSW STORAGE
;
 
TMP:    .BLKW   1               ;
 
 
;+
;
; **-ISCHK-DRS/DSS-11 DIGITAL I/O SUBSYSTEM PARAMETER CHECKING
;
; THIS ROUTINE IS ENTERED FROM QIO DIRECTIVE PROCESSING WHEN AN
; I/O REQUEST IS RECIEVED FOR THE DRS/DSS-11 DIGITAL INPUT-OUTPUT
; SUBSYSTEMS DEVICES. DRS/DSS-11 REQUESTS CONTAIN PARAMETERS THAT
; MUST BE CHECKED IN THE CONTEXT OF THE ISSUING TASK. THEREFORE
; THE I/O REQUEST IS NOT QUEUED BEFORE CALLING THE DRIVER.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK
;
; OUTPUTS:
;
;       DEPENDANT UPON FUNCTION TO BE PERFORMED
;
; DRS/DSS-11 FUNCTION INDEPENDANT I/O PACKET
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF REQUESTER TASK TCB.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE.
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;
;-
 
ISCHK:                          ;
        MOV     R1,-(SP)        ; SAVE I/O PACKET ADDRESS
        MOV     I.TCB(R1),R0    ; GET ADDRESS OF TCB
        MOV     I.FCN(R1),R2    ; GET FUNCTION CODE
        BIC     #7,R2           ; CLEAR FUNCTION BITS
        ADD     #I.PRM,R1       ; POINT TO PARAMETER BLOCK
 
        .IF DF  I$$SLK
 
        CMP     R2,#IO.RAD      ; READ ACTIVATING DATA?
        BEQ     ISRAD           ; IF EQ YES
        CMP     R2,#IO.LDI      ; LINK TO DIGITAL INTERRUPTS?
        BEQ     ISLD            ; IF EQ YES
        CMP     R2,#IO.NLK      ; UNLINK FROM INTERRUPTS
        BEQ     ISUNL           ; IF EQ YES
        CMP     R2,#IO.UDI      ; UNLINK FROM DIGITAL INTERRUPTS
 
        .ENDC
 
        .IF DF  I$$SDR&I$$SLK
 
        BEQ     ISUNL           ; IF EQ YES
 
        .ENDC
 
        .IF DF  I$$SDR
 
        CMP     R2,#IO.MLO      ; LATCHING OUTPUT?
 
        .IFTF
 
        BNE     ISIFC           ; IF NE NO ILLEGAL FUNCTION
 
;+
;
; **-ISLAT-PERFORM BISTABLE DIGITAL OUTPUT
;
; FUNCTION DEPENDANT I/O PACKET FORMAT
;
;       WD. 12 -- INITIAL POINT
;       WD. 13 -- MASK WORD
;       WD. 14 -- DATA WORD
;       WD. 15 -- NOT USED
;       WD. 16 -- NOT USED
;       WD. 17 -- NOT USED
;
;-
 
        .IFT
 
ISLAT:                          ;
        MOV     (R1)+,R2        ; GET POINT NUMBER
        BIT     #17,R2          ; POINT ON MODULE BOUNDARY?
        BNE     ISMOD           ; IF NE NO
        CMP     R2,#<I$$SDR>*48.-1 ; POINT EXIST?
        BHI     ISMOD           ; IF HI NO
        ASR     R2              ; CONVERT TO WORD OFFSET
        ASR     R2              ; ...
        ASR     R2              ; ...
        BIC     (R1),ISPRV(R2)  ; CLEAR ALL BITS THAT WILL CHANGE STATE
        COM     (R1)            ; SET ALL BITS THAT WILL NOT CHANGE
        BIC     (R1)+,(R1)      ; CLEAR ALL BITS THAT WILL NOT CHANGE
        BIS     (R1),ISPRV(R2)  ; SET NEW PREVIOUS STATE
        MOV     ISPRV(R2),@ISBUS(R2) ; SET NEW MODULE STATE
        BR      ISSUC           ;
 
        .ENDC
 
 
;+
;
; **-ISUNL-UNLINK A TASK FROM INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT
;
;       WD. 12 -- FIRST HALF OF TASK NAME
;       WD. 13 -- SECOND HALF OF TASK NAME
;       WD. 14 -- NOT USED
;       WD. 15 -- NOT USED
;       WD. 16 -- NOT USED
;       WD. 17 -- NOT USED
;
;-
 
        .IF DF  I$$SLK
 
ISUNL:                          ;
        MOV     R1,R3           ; COPY ADDRESS OF PARAMETER BLOCK
        CALL    $SRSTD          ; SEARCH FOR TASK TCB ADDRESS
        BCS     ISNLK           ; IF C/S TASK NOT INSTALLED
        MOV     #ISLNK,R2       ; GET ADDRESS OF LINKED TASK LISTHEAD
10$:                            ;
        MOV     R2,R4           ; SAVE ADDRESS OF PREVIOUS FOR RELINK
        MOV     (R2),R2         ; GET ADDRESS OF NEXT
        BEQ     ISNLK           ; IF EQ TASK NOT LINKED
        CMP     LTCB(R2),R0     ; ENTRY BELONG TO THIS TASK?
        BNE     10$             ; IF NE NO
        MOV     #ILTBL,R0       ; GET ADDRESS OF INTERRUPT LINK TABLE
        MOV     #I$$S11,R1      ; GET NUMBER OF DRS/DSS MODULES
        MOV     #1,R3           ; SET 1-BIT MASK
20$:                            ;
        CMP     (R0),R2         ; TASK LINKED TO THIS INTERRUPT?
        BNE     30$             ; IF NE NO
        MOVB    #PR4,PS         ;;; INHIBIT DEVICE INTERRUPTS
        CLR     (R0)            ;;; UNLINK THIS TASK
        BIC     R3,ISRES        ;;; FREE UP THE RESOURCE
        CLR     @ILCSR(R0)      ;;; DISABLE DEVICE INTERRUPTS
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
30$:                            ;
        ADD     #ILGH,R0        ; POINT TO NEXT ENTRY
        ASL     R3              ; SHIFT MASK
        DEC     R1              ; DECREMENT DEVICE COUNT
        BNE     20$             ; IF NE GO AGAIN
        MOV     R2,R0           ; COPY ADDRESS OF BLOCK
        MOV     (R2),(R4)       ; RELINK REMAINING ENTRIES
        BNE     40$             ; IF NE NO NEW LAST
        MOV     R4,ISLNK+2      ; SET NEW LAST
40$:                            ;
        MOV     #LLGH,R1        ; GET LENGTH OF ENTRY
        CALL    $DEACB          ; DEALLOCATE BLOCK
 
;
; RETURN SUCCESS STATUS
;
 
        .IFTF
 
ISSUC:                          ;
        MOV     #IS.SUC&377,R0  ;
        BR      ISCMN           ;
 
;
; BAD PARAMETER SPECIFIED
;
 
        .IFT
 
ISBAD:                          ;
        MOV     #IE.BAD&377,R0  ;
        BR      ISCMN           ;
 
;
; BUFFER BYTE ALIGNED
;
 
ISBYT:                          ;
        MOV     #IE.BYT&377,R0  ;
        BR      ISCMN
 
;
; ILLEGAL EVENT FLAG SPECIFIED
;
 
ISIEF:                          ;
        MOV     #IE.IEF&377,R0  ;
        BR      ISCMN           ;
 
;
; ILLEGAL FUNCTION CODE
;
 
        .IFTF
 
ISIFC:                          ;
        MOV     #IE.IFC&377,R0  ;
        BR      ISCMN           ;
 
;
; NON-EXISTENT MODULE OR POINT SPECIFIED
;
 
ISMOD:                          ;
        MOV     #IE.MOD&377,R0  ;
        BR      ISCMN           ;
 
;
; TASK NOT LINKED
;
 
        .IFT
 
ISNLK:                          ;
        MOV     #IE.NLK&377,R0  ;
        BR      ISCMN           ;
 
;
; NO DYNAMIC STORAGE AVAILABLE TO LINK TASK
;
 
ISNOD:                          ;
        MOV     #IE.UPN&377,R0  ;
        BR      ISCMN           ;
 
;
; TASK NOT INSTALLED
;
 
ISNST:                          ;
        MOV     #IE.NST&377,R0  ;
        BR      ISCMN           ;
 
;
; RESOURCE IN USE
;
 
ISRSU:                          ;
        MOV     #IE.RSU&377,R0  ;
        BR      ISCMN           ;
 
;
; BUFFER OUTSIDE OF TASK'S ADDRESS SPACE
;
 
ISPC:                           ;
        MOV     #IE.SPC&377,R0  ;
 
;
; COMMON EXIT FOR ALL FUNCTIONS
;
 
        .IFTF
 
ISCMN:                          ;
        CLR     R1              ; CLEAR CONTENTS OF SECOND I/O STATUS WORD
        MOV     (SP)+,R3        ; GET ADDRESS OF I/O PACKET
        MOV     ISUCB,R5        ; GET UCB ADDRESS
        CALLR   $IOFIN          ; COMPLETE REQUEST
 
;
; BRANCH POINT - LINK TO DIGITAL INTERRUPT
;
 
        .IFT
 
ISLD:                           ;
        BR      ISLDI           ;
 
 
;+
;
; **-ISRAD-READ ACTIVATING DATA
;
; FUNCTION DEPENDANT I/O PACKET FORMAT
;
;       WD. 12 -- ADDRESS OF 6-WORD BUFFER TO RECEIVE ACTIVATING DATA
;       WD. 13 -- UNUSED
;       WD. 14 -- UNUSED
;       WD. 15 -- UNUSED
;       WD. 16 -- UNUSED
;       WD. 17 -- UNUSED
;
;-
 
ISRAD:                          ;
        BIT     #1,(R1)         ; BUFFER ALIGNED PROPERLY?
        BNE     ISBYT           ; IF NE NO
        MOV     #ISLNK,R4       ; GET ADDRESS OF LINKED TASK LISTHEAD
10$:                            ;
        MOV     (R4),R4         ; GET LINK TO NEXT
        BEQ     ISNLK           ; IF EQ TASK NOT LINKED
        CMP     LTCB(R4),R0     ; THIS TASK LINKED?
        BNE     10$             ; IF NE NO
        MOV     (R1),R0         ; GET BUFFER ADDRESS
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     #12.,R1         ; GET SIZE REQUIRED
        CALL    $ACHCK          ; ADDRESS-CHECK THE BUFFER
        BCS     ISPC            ; IF C/S BUFFER OUTSIDE OF TASK SPACE
 
        .ENDC
 
        .IF DF  M$$MGE
 
        CALL    $RELOM          ; RELOCATE AND MAP TO USER SPACE
 
        .ENDC
 
        ADD     #LACT,R4        ; POINT TO THE ACTIVATION COUNT
        MOVB    #PR4,PS         ;;; INHIBIT DEVICE INTERRUPTS
        MOV     (R4),(R0)+      ;;; COPY ACTIVATION COUNT
        CLR     (R4)+           ;;; RESET THE COUNT
        CLR     (R0)+           ;;; SET PHYSICAL UNIT TO ZERO
        MOV     #1,(R0)+        ;;; RETURN GENERIC CODE FOR DIGITAL INTERRUPTS
        CLR     (R0)+           ;;; SET MODULE NUMBER TO ZERO
        MOV     (R4),(R0)+      ;;; RETURN MODULE DATA
        MOV     (R4),(R0)       ;;; RETURN CHANGE-OF STATE
        CLRB    PS              ; ALLOW DEVICE INTERRUPTS
        BR      ISSUC           ;
 
;+
;
; **-ISLDI-LINK TO DIGITAL INTERRUPTS
;
; FUNCTION DEPENDANT I/O PACKET FORMAT:
;
;       WD. 12 -- FIRST HALF OF TASK NAME
;       WD. 13 -- SECOND HALF OF TASK NAME
;       WD. 14 -- UNUSED
;       WD. 15 -- EVENT FLAG NUMBER
;       WD. 16 -- MODULE NUMBER (MUST BE ZERO)
;       WD. 17 -- CHANGE-OF-STATE MASK
;
;-
 
ISLDI:                          ;
        MOV     R1,R3           ; COPY ADDRESS OF PARAMETER BLOCK
        CALL    $SRSTD          ; SEARCH FOR TCB ADDRESS
        BCS     ISNST           ; IF C/S TASK NOT INSTALLED
        MOV     R0,R5           ; SAVE TCB ADDRESS
        ADD     #6,R1           ; POINT TO EVENT FLAG NUMBER
        MOV     (R1)+,R0        ; GET EFN
        CMP     R0,#64.         ; LEGAL EVENT FLAG NUMBER?
        BHI     ISIEF           ; IF HI NO
        TST     (R1)+           ; LEGAL INITIAL POINT?
        BNE     ISMOD           ; IF NE NO
        MOV     (R1),R4         ; GET CHANGE-OF-STATE MASK
        BEQ     ISBAD           ; IF EQ BAD PARAMETERS
        BIT     R4,#IPMSK       ; DOES POINT EXIST?
        BNE     ISMOD           ; IF NE NO
        BIT     R4,ISRES        ; RESOURCE AVAILABLE?
        BNE     ISRSU           ; IF NE NO
        MOV     R0,-(SP)        ; SAVE EVENT FLAG NUMBER
        MOV     #LLGH,R1        ; GET ADDRESS OF LINKED TASK ENTRY
        CALL    $ALOCB          ; ALLOCATE BLOCK
        MOV     (SP)+,R3        ; RESTORE EVENT FLAG NUMBER
        BCS     ISNOD           ; IF C/S NO DYNAMIC STORAGE
        MOV     R0,-(SP)        ; SAVE ADDRESS OF ENTRY
        MOV     R3,R0           ; COPY EVENT FLAG NUMBER
        CALL    $CEFI           ; CONVERT TO MASK AND ADDRESS
        MOV     (SP)+,R2        ; RESTORE ADDRESS OF LINKED TASK ENTRY
        CLR     (R2)            ; CLEAR LINK TO NEXT
        MOV     R2,@ISLNK+2     ; LINK ENTRY TO LAST
        MOV     R2,ISLNK+2      ; SET NEW LAST
        TST     (R2)+           ; POINT TO TCB ADDRESS
        MOV     R5,(R2)+        ; SET ADDRESS OF TCB
        CLR     (R2)+           ; CLEAR ACTIVATION COUNT
        MOV     #ILTBL-ILGH,R2  ; GET ADDRESS OF INTERRUPT LINK TABLE MINUS OFFSET
        MOV     R4,R3           ; COPY RESOURCE MASK
10$:                            ;
        ADD     #ILGH,R2        ; POINT TO NEXT ENTRY
20$:                            ;
        ROR     R3              ; ROTATE MASK
        BCS     30$             ; IF C/S LINK THIS MODULE
        BNE     10$             ; IF NE GO AGAIN
        BR      40$             ; ELSE TESTED ALL ENTRIES
30$:                            ;
        MOV     ISLNK+2,(R2)+   ; ALLOCATE THIS RESOURCE
        MOV     R0,(R2)+        ; SET EVENT FLAG MASK
        MOV     R1,(R2)+        ; SET EVENT FLAG ADRESS
        CLR     (R2)+           ; CLEAR RUN FLAG
        BIS     #100,@(R2)+     ; ENABLE DEVICE INTERRUPTS
        BR      20$             ; GO AGAIN
40$:                            ;
        BIS     R4,ISRES        ; ALLOCATE ALL REQUESTED BITS
        JMP     ISSUC           ;
;+
;
; **-$ISINT-DRS/DSS11 INTERRUPT SERVICE ROUTINE
;
;-
 
        .IFTF
 
$ISINT::                        ;;;
 
        .IFF
 
        RTI                     ;;; IGNORE SPURIOUS INTERRUPT
 
        .IFT
 
        MOVB    PS,TMP          ;;; SAVE PROCESSOR STATUS WORD
        CALL    $INTSV,PR4      ;;; SAVE R4-R5, SET PRIORITY
        MOV     TMP,R5          ;;; GET PS WORD
        BIC     #^C<17>,R5      ;;; CLEAR ALL BUT DEVICE NUMBER
        CMP     R5,#I$$S11      ;;; LEGAL DEVICE NUMBER
        BHIS    ISCAN           ;;; IF HI NO EXIT ISR
        ASL     R5              ;;; CONVERT TO WORD OFFSET
        MOV     $BTMSK(R5),R4   ;;; GET CORRESPONDING BIT MASK
        MOV     R5,-(SP)        ;;; COPY WORD OFFSET
        ASL     R5              ;;; CONVERT TO INTERRUPT LINK TABLE OFFSET
        ASL     R5              ;;; ...
        ADD     (SP)+,R5        ;;;
        ADD     #ILTBL,R5       ;;; COMPUTE ENTRY ADDRESS
        TST     @ILCSR(R5)      ;;; RESET INTERRUPT REQUEST
        BIT     R4,ISRES        ;;; RESOURCE ALLOCATED
        BEQ     ISCAN           ;;; IF EQ NO
        INC     ILRUN(R5)       ;;; SET RUN FLAG
        MOV     (R5),R5         ;;; GET ADDRESS OF LINKED TASK ENTRY
        ADD     #LACT,R5        ;;; POINT TO ACTIVITY COUNT
        TST     (R5)            ;;; PREVIOUS DATA READ BY TASK
        BNE     10$             ;;; IF NE NO
        INC     (R5)+           ;;; SET ACTIVATION COUNT
        MOV     R4,(R5)         ;;; RECORD MODULE DATA
        BR      30$             ;;;
10$:                            ;;;
        BMI     20$             ;;; IF MI TASK ALREADY MISSED ONE COUNT
        CLR     (R5)            ;;; SET COUNT TO ZERO
20$:                            ;;;
        DEC     (R5)+           ;;; DECREMENT COUNT
        BIS     R4,(R5)         ;;; MERGE MODULE DATA
30$:                            ;;;
        TST     FORK            ;;; FORK PENDING?
        BNE     ISCAN           ;;; IF NE YES
        INC     FORK            ;;; SET FORK PENDING
        MOV     ISUCB,R5        ;;; GET ADDRESS OF UCB
        CALL    $FORK           ;;; CREATE A SYSTEM PROCESS
        CLR     FORK            ; CLEAR FORK-PENDING
        MOV     #I$$S11,R5      ; GET NUMBER OF DRS/DSS INSTALLED
        MOV     #ILTBL,R4       ; GET ADDRESS OF INTERRUPT LINK TABLE
40$:                            ;
        TST     (R4)            ; ANY TASK LINKED?
        BEQ     70$             ; IF EQ NO
        TST     ILRUN(R4)       ; RUN FLAG SET
        BEQ     70$             ; IF EQ NO
        CLR     ILRUN(R4)       ; RESET RUN FLAG
        MOV     (R4),R0         ; GET ADDRESS OF LINKED TASK ENTRY
        MOV     LTCB(R0),R0     ; GET TCB ADDRESS
        MOV     T.STAT(R0),R1   ; COPY TASK STATUS WORD
        BIT     #TS.EXE,R1      ; TASK ACTIVE?
        BNE     60$             ; IF NE NO
        BIT     #T2.ABO,T.ST2(R0) ; TASK BEING ABORTED?
        BNE     70$             ; IF NE YES
        BIT     #TS.OUT,R1      ; TASK OUT OF MEMORY?
        BEQ     50$             ; IF EQ NO
        BIT     #TS.CKP,R1      ; TASK CHECKPOINTED?
        BEQ     70$             ; IF EQ NO
50$:                            ;
        MOV     ILEVA(R4),R2    ; GET ADDRESS OF EVENT FLAG MASK
        BEQ     70$             ; IF EQ NONE SPECIFIED
        BIS     ILEVM(R4),(R2)  ; SET EVENT FLAG
        CALL    $SETCR          ; ISSUE CONDITIONAL SCHEDULE REQUEST
        BR      70$             ; GO AGAIN
60$:                            ;
        CLR     R1              ; SET DEFAULT UIC
        CALL    $TSKRT          ; REQUEST TASK
70$:                            ;
        ADD     #ILGH,R4        ; POINT TO NEXT INTERRUPT LINK ENTRY
        DEC     R5              ; DECREMENT MODULE COUNT
        BNE     40$             ; IF NE GO AGAIN
 
        .IFTF
 
;+
;
; **-ISCAN-CANCEL I/O AND DEVICE TIMEOUT ENTRY POINT
;
;-
 
ISCAN:                          ;;;
        RETURN                  ;;;
 
;+
;
; **-ISPWF-DEVICE DEPENDANT POWER RECOVERY CODE
;
; THIS CODE IS ENTERED TO RESTORE THE STATE OF ALL INTERRUPT ENABLE BITS AND
; LATCHING OUTPUTS UPON POWER RECOVERY.
;
;-
 
ISPWF:                          ;
        MOV     R5,ISUCB        ; SAVE THE UCB ADDRESS
 
        .IFT
 
        MOV     #ILTBL,R0       ; GET ADDRESS OF INTERRUPT LINK TABLE
        MOV     #I$$S11,R1      ; SET NUMBER OF MODULES
10$:                            ;
        TST     (R0)            ; TASK LINKED?
        BEQ     20$             ; IF EQ NO
        BIS     #100,@ILCSR(R0) ; ENABLE MODULE INTERRUPTS
20$:                            ;
        ADD     #ILGH,R0        ; POINT TO NEXT ENTRY
        DEC     R1              ; DECREMENT MODULE COUNT
        BNE     10$             ; IF NE GO AGAIN
 
        .ENDC
 
        .IF DF  I$$SDR&I$$SPW
 
        MOV     #ISPRV,R0       ; GET ADDRESS OF PREVIOUS STATE TABLE
        MOV     #ISBUS,R1       ; GET ADDRESS OF BUS VECTOR TABLE
        MOV     #I$$SDR*3,R2    ; GET COUNT OF ADDRESSES TO REFRESH
30$:                            ;
        MOV     (R0)+,@(R1)+    ; REFRESH BISTABLE OUTPUTS
        DEC     R2              ; DECREMENT ADDRESS COUNT
        BNE     30$             ; IF NE GO AGAIN
 
        .ENDC
 
        RETURN                  ;
 
        .END
 
        .TITLE  LADRV
        .IDENT  /V03.08/
;

; DIGITAL EQUIPMENT CORP., MAYNARD MASS.
; COPYRIGHT (C) 1977,1978,1979
;
; THIS SOFTWARE IS FURNISHED UNDER  A LICENSE FOR USE ONLY  ON  A
; SINGLE COMPUTER SYSTEM AND MAY BE  COPIED ONLY WITH  THE INCLU-
; SION OF  THE  ABOVE  COPYRIGHT NOTICE.  THIS SOFTWARE,  OR  ANY
; OTHER COPIES THEREOF, MAY NOT BE  PROVIDED  OR  OTHERWISE  MADE
; AVAILABLE TO ANY OTHER PERSON EXCEPT  FOR  USE  ON  SUCH SYSTEM
; AND TO  ONE WHO AGREES  TO  THESE LICENSE  TERMS.  TITLE TO AND
; OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES REMAIN IN DEC.
;
; THE INFORMATION IN THIS SOFTWARE  IS  SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED  AS  A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; VERSION       V03.08
;
;
; CHARLES A. SAMUELSON
; MICHAEL SCHWARTZ
; CLARK A. D'ELIA
;
; NOV. 22, 1977
;
; MODIFIED BY:
;
;       M. HARVEY       SEPT. 28, 1978
;               MSH012  22-BIT MODE MODIFICATIONS
;
;       M. HARVEY       OCT. 4, 1978
;               MSH014  ABORT LPA11 ALONG WITH USER IN CASE OF
;                       DEPLETED DYNAMIC STORAGE REGION
;
;       M. HARVEY       NOV. 13, 1978
;               MSH020  STOP AST'S FROM CLOBBERING IOSB
;
;       M. HARVEY       JAN. 5, 1979
;               MSH022  CONDITIONALIZE DRIVER SO IT WILL
;                       RUN UNDER RSX11M AND RSX11M+
;
;
; LPA11 LABORATORY PERIPHERAL ACCELERATOR CONTROLLER DRIVER
;
;
;
;
; MACRO LIBRARY CALLS
;
        .MCALL  HWDDF$,PKTDF$,TCBDF$,UCBDF$,SCBDF$
        HWDDF$                          ;DEFINE HARDWARE REGISTERS
        PKTDF$                          ;DEFINE I/O PACKET OFFSETS
        SCBDF$                          ;DEFINE STATUS CONTROL BLOCK OFFSETS
        TCBDF$                          ;DEFINE TASK CONTROL BLOCK OFFSETS
        UCBDF$                          ;DEFINE UNIT CONTROL BLOCK OFFSETS
;
; QIO DIRECTIVE DESCRIPTIONS
;
;       IO.LOD, ... ,<BUF,2048.>
;               BUF - BUFFER OF MICRO - CODE TO LOAD
;                       BUFFER SIZE MUST BE 2048. BYTES
;               ISSUEING TASK MUST BE PRIVILEGED
;               VERIFIES NO ACTIVE USERS FOR LPA11
;               HARDWARE RESETS LPA11
;               LOADS AND VERIFIES MICRO - CODE
;               STARTS LPA11 AND ENABLES INTERRUPTS
;               RETURNS WHEN READY IN INTERRUPT IS POSTED
;               THIS IS A TRANSFER FUNCTION-(THE QIO DOES ADDRESS
;               CHECKS AND RELOCATES THE USER BUFFER)
;
;       IO.INI, ... ,<BUF,278.>
;               BUF - BUFFER CONTAINING LPA11 INITIALIZE RDA
;                       BUFFER SIZE MUST BE AT LEAS 278. BYTES
;               ISSUEING TASK MUST BE PRIVILEGED
;               SENDS AN INITIALIZE COMMAND TO LPA11
;
;       IO.CLK, ... ,<MODE,CKCSR,PRESET>
;               MODE - LPA11 CLOCK START MODE WORD
;               CKCSR - IMAGE TO WRITE INTO LPA11 REAL TIME CLOCK CONTROL REGISTER
;               PRESET - IMAGE TO WRITE INTO LPA11 REAL TIME CLOCK PRESET BUFFER REGISTER
;               ISSUES AN LPA11 CLOCK START COMMAND
;
;       IO.STA, ... ,<BUF,40.>
;               BUF - POINTER TO LPA11 SAMPLE START RDA
;                       BUFFER SIZE MUST BE AT LEAST 40. BYTES
;               ISSUES AN LPA11 DATA TRANSFER START COMMAND
;               THIS IS A TRANSFER FUNCTION-(THE QIO DOES ADDRESS
;               CHECKS AND RELOCATES THE USER BUFFER)
;
;         SUBFUNCTION CODE DIFFINTIONS FOR IO.STA
;
;               BIT 0 = 0   GIVE AST FOR EVERY BUFFER IF AST SPECIFIED
;               BIT 0 = 1   GIVE AST ONLY FOR EXCEPTION CONDITIONS
;
;
;       IO.STP, ... ,<USERID>
;
;               CALL MUST SUPPLY LUN
;               USERID - USER INDEX NUMBER <0-7> TO STOP
;               STOPPING TASK MUST BE THE SAME AS STARTING TASK
;
;
; DEFAULT UIC OF LOADER TASK = [1,1]
;
TUIC=401                                ;DEFAULT UIC OF LOADER TASK
;
;
;
; ASSEMBLY CONDITIONALS
;
;       M$$MGE                          ;MEMORY MANAGEMENT
;       A$$CHCK                         ;ADDRESS CHECK
;       A$$TRP                          ;AST SUPPORT
;       M$$EXT                          ;22 BIT 11/70 EXT MEM.
;       M$$PRO                          ;MULTI-PROCESSOR SUPPORT                ;MSH022
;       R$$MPL                          ;RSX-11M PLUS SUPPORT                   ;MSH022
;
;
;
; DRIVER DISPATCH TABLE
;
        .IF NDF R$$MPL                                                          ;MSH022
                                                                                ;MSH022
        DDT$    LA,L$$A11,<INP,OUT>,,<UCBSV>                                    ;MSH022
                                                                                ;MSH022
        .IFF                                                                    ;MSH022
                                                                                ;MSH022
        DDT$    LA,L$$A11,<INP,OUT>,,<UCBSV>,<NEW>                              ;MSH022
                                                                                ;MSH022
        .ENDC                                                                   ;MSH022
;                                                                               ;**-8
        .IF     GT      L$$A11-1
;
TEMP:   .BLKW   1                       ;TEMP STORAGE FOR CONT. NUM.
;
        .ENDC
;
;
        .PAGE                                                                   ;MSH022
        .SBTTL  ONLINE/OFFLINE ENTRY POINTS                                     ;MSH022
;                                                                               ;MSH022
;   CONTROLLER STATUS CHANGE ROUTINE                                            ;MSH022
;                                                                               ;MSH022
; INPUTS:       R2 = KRB ADDRESS                                                ;MSH022
;                                                                               ;MSH022
;               C = 0   ,BRING CONTROLLER ONLINE                                ;MSH022
;               C = 1   ,TAKE CONTROLLER OFFLINE                                ;MSH022
;                                                                               ;MSH022
; OUTPUTS:      $SCERR= UNCHANGED FOR SUCCESS                                   ;MSH022
;                     = ERROR CODE FOR FAILURE                                  ;MSH022
;                                                                               ;MSH022
;                                                                               ;MSH022
; THE LPA11-K IS BOTH A UNIT AND ITS OWN CONTROLLER. ALL                        ;MSH022
; THE REAL WORK WILL BE DONE AT THE UNIT ONLINE/OFFLINE ENTRY POINT.            ;MSH022
;                                                                               ;MSH022
        .IF DF R$$MPL                                                           ;MSH022
                                                                                ;MSH022
LAKRB:  RETURN                          ;ALWAYS SUCCESSFUL                      ;MSH022
                                                                                ;MSH022
;;;;;;;;                                                                        ;MSH022
;                                                                               ;MSH022
;    UNIT STATUS CHANGE ROUTINE                                                 ;MSH022
;                                                                               ;MSH022
; INPUTS:       R3 = CONTROLLER INDEX                                           ;MSH022
;               R4 = SCB POINTER                                                ;MSH022
;               R5 = UCB POINTER                                                ;MSH022
;                                                                               ;MSH022
;               C = 0   ,BRING UNIT ONLINE                                      ;MSH022
;               C = 1   ,TAKE UNIT OFFLINE                                      ;MSH022
;                                                                               ;MSH022
; OUTPUTS:      $SCERR= UNCHANGED FOR SUCCESS                                   ;MSH022
;                     = ERROR CODE FOR FAILURE                                  ;MSH022
;                                                                               ;MSH022
;                                                                               ;MSH022
LAUCB:  BCS     100$                                                            ;MSH022
        CALLR   LAPWF                   ;BRING UNIT ONLINE                      ;MSH022
                                                                                ;MSH022
100$:   TST     S.PKT(R4)               ;ANYONE ACTIVE?                         ;MSH022
        BNE     200$                    ;YES, BRANCH                            ;MSH022
        MOV     #U.LAUT,R0              ;POINT TO ACTIVE USER TABLE             ;MSH022
        ADD     R5,R0                   ;   IN THE UCB                          ;MSH022
        MOV     #8.,R2                  ;MAXIMUM OF 8. USERS                    ;MSH022
110$:   TST     (R0)+                   ;THIS USER ACTIVE?                      ;MSH022
        BNE     200$                    ;YES, BRANCH                            ;MSH022
        DEC     R2                      ;DECREMENT COUNTER                      ;MSH022
        BGT     110$                    ;TRY THE NEXT USER                      ;MSH022
        MTPS    S.PRI(R4)               ;;; LOCK OUT INTERRUPTS                 ;MSH022
        MOV     #40000,@S.CSR(R4)       ;;; HARDWARE RESET LPA11-K              ;MSH022
        MTPS    #0                      ;;; ALLOW INTERRUPTS                    ;MSH022
        RETURN                          ;LPA11-K READY FOR OFFLINE              ;MSH022
                                                                                ;MSH022
200$:   MOVB    #IE.RSU&377,$SCERR      ;RESOURCE IN USE ERROR                  ;MSH022
        RETURN                          ;NO OFFLINE YET                         ;MSH022
                                                                                ;MSH022
        .ENDC                                                                   ;MSH022
        .PAGE
        .SBTTL  LPA11 DRIVER I/O INITIATOR ENTRY POINT - LAINI -**
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS RECEIVED FOR THE LPA11 LABORATORY PERIPHERAL ACCELERATOR.  FIVE
; FUNCTIONS ARE RECOGNIZED BY THE LPA11 DRIVER.  SPECIAL USER BUFFERS
; ARE ADDRESS CHECKED WHERE NECESSARY.  ERROR FREE REQUESTS ARE PLACED
; IN THE I/O QUEUE THAT IS MAINTAINED BY THE DRIVER.
;
; ADDRESS CHECKING FOR THE USER'S DBP BUFFER IS DONE IN THE QIO ROUTINE
; BEFORE THIS DRIVER IS CALLED.
;
; INPUTS:
;
;       R1=ADDRESS OF I/O REQUEST PACKET
;       R4=ADDRESS OF STATUS CONTROL BLOCK
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED
;
; OUTPUTS:
;
;       A QUEUED I/O PACKET WITH USER BUFFERS ADDRESS CHECKED AND
;       RELOCATED.  PACKET MAY BE DEQUEUED WHEN $GTPKT IS CALLED IF
;       IT IS THE ONLY PACKET IN THE QUEUE.
;
; FUNCTION INDEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER
;       WD. 02 -- ADDRESS OF THE TCB OF REQUESTER TASK
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER
;       WD. 05 -- I/O FUNCTION CODE
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (READ OR DISPLACEMENT+140000)
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;
;
;
; THE I/O PACKET PARAMETER LIST IS USED BY THE DRIVER TO STORE
; INFORMATION REGARDING THE REQUEST.
; THIS INFORMATION IS CALCULATED AS THE REQUEST IS PROCESSED.
; CONVENTIONS FOR I/O PACKET PARAMETER LIST USEAGE ARE:
;
;
; WD. 12 - I.PRM   -FIRST PARAMETER SUPPLIED BY ISSUEING TASKS QIO
; WD. 13 - I.PRM+2 -SECOND PARAMETER SUPPLIED BY ISSUEING TASKS QIO
; WD. 14 - I.PRM+4 -THIRD PARAMETER SUPPLIED BY ISSUEING TASKS QIO
; WD. 15 - I.PRM+6 -LOW ORDER 16 BITS OF PHYSICAL ADDRESS OF REQUEST RDA
; WD. 16 - I.PRM+10-HIGH ORDER 2 BITS OF PHYSICAL ADDRESS OF REQEUST RDA
; WD. 17 - I.PRM+12-EVENT FLAG MASK FOR CONTINUING DATA TRANSFER REQUEST
; WD. 20 - I.PRM+14-EVENT FLAG ADDRESS
; WD. 21 - I.PRM+16-RESERVED FOR RSX-11M
;
;
;
LAINI:
        TST     I.IOSB+4(R1)            ;IOSB SUPPLIED?
        BEQ     ELABAD                  ;NO, BAD PARAMETERS ERR
        MOV     R1,-(SP)                ;SAVE I/O PACKET ADDRESS
        MOV     I.FCN(R1),R3            ;I/O FUNCTION CODE
        BIC     #377,R3                 ;CLEAR LOW BYTE
        CMP     #IO.INI,R3              ;INITIALIZE REQUEST?
        BNE     5$                      ;NO, CONTINUE
        JMP     LAINIT                  ;YES
5$:     CMP     #IO.CLK,R3              ;CLOCK START REQUEST?
        BNE     15$                     ;NO, CONTINUE
        JMP     LACLOK                  ;YES
15$:    CMP     #IO.STP,R3              ;STOP REQUEST?
        BNE     2$                      ;NO
        JMP     LASTOP                  ;YES
;
; IT IS EITHER A LOAD MICRO-CODE REQUEST OR A START DATA TRANSFER REQEUST
; COPY USER BUFFER POINTERS SO $GTWRD WILL OPERATE
;
2$:     MOV     I.PRM(R1),U.BUF(R5)     ;RELOCATION BIAS
        MOV     I.PRM+2(R1),U.BUF+2(R5) ;OFFSET
        CMP     #IO.STA,R3              ;START?
        BNE     3$                      ;NO
        JMP     LASTRT                  ;YES
3$:     CMP     #IO.LOD,R3              ;LOAD MICRO-CODE?
        BNE     ELAIFC                  ;NO, ILLEGAL FUNCTION
        JMP     LALOAD                  ;YES, JMP TO LOAD
;
;
; *******************************************
;
; ** - ERROR HANDLING PATHS FOR LADRV - INITIATOR ENTRY ONLY
;      INTERRUPT ROUTINES AND OTHER ENTRY POINTS REPORT THEIR OWN ERRORS
;
;
ELAIFC: MOV     #IE.IFC&377,R0          ;ILLEGAL FUNCTION ERROR
        BR      EROR                            ;FINISH ERROR HANDLING
;
ELAPRI: MOV     #IE.PRI&377,R0          ;PRIVILEGE ERROR
        BR      EROR
;
ELASPC: MOV     #IE.SPC&377,R0          ;USER BUFFER ADDR CHECK ERROR
        BR      EROR
;
ELABCC: MOV     #IE.BCC&377,R0          ;LOAD ERROR FOR MICRO-CODE
        BR      EROR                    ;EXIT
;
ELARSU: MOV     #IE.RSU&377,R0          ;RESOURCE IN USE - CANNOT INITIALIZE
        BR      EROR
;
ELANOD: MOV     #IE.NOD&377,R0          ;SYSTEM DYNAMIC MEMORY EXHAUSTED
        BR      EROR
;
ELABAD: MOV     #IE.BAD&377,R0          ;BAD PARAMETERS
;
EROR:
        MOV     (SP)+,R3                ;ERROR ENCOUNTERED
        CLR     R1                      ;SET UP IOSB WORD 2
        CALLR   $IOFIN                  ;I/O COMPLETION
;
;
ELAPR2: MOV     #IE.PRI&377,R0          ;PRIVILEGE ERROR
        BR      ERORGT
;
ELASP2: MOV     #IE.SPC&377,R0          ;USER BUFF ADDR CHECK ERROR
;
ERORGT: MOV     (SP)+,R3
        CLR     R1
        CALL    $IOFIN
        BR      GETPKT
;
; *******************************************
;
        .PAGE
        .SBTTL  RETREIVE I/O PACKET AND ISSUE REQUEST TO LPA-11
;
; INSERT PACKET IN I/O QUEUE
; THE DRIVER WAS ENTERED BEFORE THE PACKET WAS QUEUED
; NOW WE PUT IT IN THE QUEUE AND GO TO $GTPKT
;
QUEPKT:                                 ;QUEUE AN I/O PACKET FOR THE DRIVER
        MOV     (SP)+,R1                ;GET ADDRESS OF PACKET
        MOV     R4,R0                   ;SCB ADDRESS OF CONTROLLER TO INSERT PACKET INTO
        CLR     I.PRM+16(R1)            ;INITIALIZE FLAG WORD                   ;MSH012
        CALL    $QINSP                  ;INSERT IN QUEUE
                                        ;AND FALL THROUGH TO $GTPKT
;
; TRY TO RETREIVE AN I/O PACKET AND TRANSMITT TO LPA11
;
GETPKT:
;
; BEFORE WE DEALLOCATE A NEW REQUEST FROM THE CONTROLLERS I/O QUEUE,
; TRY AND FETCH A STOP REQUEST FROM THE STOP REQUEST QUEUE
;
        MOV     U.SCB(R5),R4            ;POINT TO SCB
        TSTB    S.STS(R4)               ;CONTOLLER BUSY?
        BEQ     198$                                                            ;MSH012
        JMP     14$                     ;YES, GO AWAY                           ;MSH012
198$:   MOV     U.LASL(R5),R1           ;LOOK AT STOP QUEUE                     ;MSH012
        BEQ     200$                    ;EMPTY, TRY $GTPKT                      ;**-2
        MOV     (R1),U.LASL(R5)         ;NEW FIRST ENTRY
        INCB    S.STS(R4)               ;SET CONTOLER BUSY
        BISB    #US.BSY,U.STS(R5)       ;SET UNIT BUSY
        MOV     R1,S.PKT(R4)            ;SET CURRENT I/O PACKET ADDRESS
        MOVB    S.CON(R4),R3            ;MOVE CONTROLLER INDEX TO R3

        .IF DF M$$PRO                                                           ;MSH022
                                                                                ;MSH022
        CALL    $CFORK                  ;WE MUST RUN ON CORRECT PROCESSOR       ;MSH022
                                                                                ;MSH022
        .ENDC                                                                   ;MSH022
                                                                                ;MSH022
        BR      210$                    ;GIVE REQUEST TO LPA11
;
; TRY AND RETREIVE AN I/O PACKET FROM THE CONTROLLERS I/O QUEUE
;
;
200$:   CALL    $GTPKT
        BCS     14$
210$:   MOV     R5,UCBSV(R3)            ;SAVE UCB PTR. FOR INT ROUTINE          ;MSH022
        BICB    #US.MDM,U.STS(R5)       ;CLEAR ABORT CURRENT REQUEST FLAG       ;**-9
        CMP     #IO.LOD,I.FCN(R1)       ;A LOAD MICROCODE FUNCTION?
        BNE     220$                                                            ;MSH012
        MOVB    S.ITM(R4),S.CTM(R4)     ;SET DEVICE TIMEOUT COUNT               ;MSH012
        BR      12$                                                             ;MSH012
220$:                                                                           ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
        CMP     #IO.INI,I.FCN(R1)       ;INITIALIZE RDA?                        ;MSH012
        BNE     222$                    ;NO, BRANCH                             ;MSH012
        MOV     #139.*2,U.CNT(R5)       ;LENGTH OF RDA TO BE MAPPED             ;MSH012
        MOV     I.PRM+6(R1),U.BUF+2(R5) ;LOW 16 BITS OF RDA ADDRESS             ;MSH012
        MOVB    I.PRM+10(R1),U.BUF+1(R5) ;HIGH 6 BITS OF RDA ADDRESS            ;MSH012
        CALL    MAP                     ;GO MAP UMR'S                           ;MSH012
        MOV     M.UMVL(R3),I.PRM+6(R1)  ;LOW 16 BITS OF UMR VIRTUAL ADDRESS     ;MSH012
        MOVB    M.UMVH(R3),I.PRM+10(R1) ;HIGH 2 BITS (IN BITS 4 AND 5)          ;MSH012
        ASR     I.PRM+10(R1)            ;MOVE THOSE ADDRESS BITS                ;MSH012
        ASR     I.PRM+10(R1)            ;       TO BITS 2 AND 3                 ;MSH012
        BR      250$                                                            ;MSH012
                                                                                ;MSH012
222$:   CMP     #IO.STA,I.FCN(R1)       ;START I/O FUNCTION?                    ;MSH012
        BNE     250$                    ;NO, BRANCH                             ;MSH012
        TST     I.PRM+16(R1)            ;ANY UMR'S MAPPED?                      ;MSH012
        BNE     250$                    ;YES, START CONVERTED TO STOP PACKET    ;MSH012
        MOV     I.PRM+2(R1),U.CNT(R5)   ;LENGTH OF MAPPED REGION                ;MSH012
        MOV     I.PRM+6(R1),R2          ;GET RDA ADDRESS                        ;MSH012
        MOV     4(R2),U.BUF+2(R5)       ;USW LOW 16 BITS                        ;MSH012
        MOVB    6(R2),U.BUF+1(R5)       ;USW HIGH 2 BITS                        ;MSH012
        CALL    MAP                     ;GO MAP UMR'S                           ;MSH012
        MOV     R5,-(SP)                ;SAVE UCB POINTER                       ;MSH012
        ADD     #4,R2                   ;POINT TO USW IN RDA                    ;MSH012
        MOV     M.UMVL(R3),(R2)+        ;POINT LPA TO MAPPED USW                ;MSH012
        MOVB    M.UMVH(R3),(R2)         ;GET USW HIGH 2 BITS                    ;MSH012
        ASRB    (R2)                    ;MOVE TO BITS 0 AND 1                   ;MSH012
        ASRB    (R2)                                                            ;MSH012
        ASRB    (R2)                                                            ;MSH012
        ASRB    (R2)+                                                           ;MSH012
        MOVB    (R2)+,R0                ;GET VALID BUFFER MASK                  ;MSH012
        BIC     #^C<7>,R0               ;ISOLATE MASK BITS                      ;MSH012
        MOVB    M.UMVH(R3),R5           ;GET BASE ADDRESS HIGH 2 BITS           ;MSH012
225$:   ADD     M.UMVL(R3),(R2)+        ;ADD UMR BASE ADDRESS LOW BITS          ;MSH012
        ADC     (R2)                    ;DONT FORGET THE CARRY                  ;MSH012
        ADD     R5,(R2)+                ;ADD UMR BASE ADDRESS HI 2 BITS         ;MSH012
        DEC     R0                                                              ;MSH012
        BGE     225$                    ;BRANCH IF NOT DONE                     ;MSH012
        MOV     (SP)+,R5                ;RESTORE UCB POINTER                    ;MSH012
250$:                                                                           ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        MOVB    S.ITM(R4),S.CTM(R4)     ;SET DEVICE TIMEOUT COUNT               ;MSH012
        MOV     S.CSR(R4),R0            ;GET DEVICE CSR ADDRESS                 ;**-1
        MOV     I.PRM+6(R1),4(R0)       ;SET  LOW 16 BITS OF RDA ADDRESS
        BIC     #14,(R0)                ;CLEAR PREVIOUS EXTENDED ADDRESS BITS
        MOV     I.PRM+10(R1),R2
        INC     R2                      ;SET GO BIT
        BIS     R2,(R0)                 ;GIVE TO LPA
12$:    RETURN
;
; THERE IS NOTHING TO DO FOR THIS UNIT
; CHECK TO SEE IF ANY DYNAMIC STOREAGE NEEDS TO BE DEALLOCATED
;
14$:    TST     (R4)                    ;BECAUSE I/O LIST IS EMPTY?
        BNE     12$                     ;NO, JUST EXIT
16$:    MOV     U.LADS(R5),R0           ;ANY DSR ALLOCATED?
        BEQ     12$                     ;NO, EXIT
        MOV     (R0),U.LADS(R5)         ;YES, REMOVE THIS PACKET AND POINT TO NEXT
        MOV     #30.*2,R1               ;DEALLOCATE 30. WORDS
        CALL    $DEACB                  ;DEALLOCATE BUFFER
        BR      16$                     ;CONTINUE TILL NONE LEFT
        .PAGE                                                                   ;MSH012
;                                                                               ;MSH012
;       THIS SUBROUTINE SETS UP THE UNIBUS MAPPING REGISTERS NEEDED             ;MSH012
;       TO MAP THIS USER'S REQUEST WITH THE FOLLOWING STEPS:                    ;MSH012
;                                                                               ;MSH012
;               - GET A WORK BLOCK FROM POOL TO USE AS A MAPPING BLOCK          ;MSH012
;               - SET UP THE MAPPING BLOCK BY REQUESTING UMRS FROM EXEC         ;MSH012
;               - MAKE SURE WE ARE UNDER THE SYSGEN DEFINED LIMIT               ;MSH012
;               - LOAD THE UMRS                                                 ;MSH012
;                                                                               ;MSH012
;                                                                               ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
MAP:    MOV     (SP),-(SP)              ;RESERVE A WORD AT TOP OF STACK         ;MSH012
        MOV     R1,-(SP)                ;SAVE PACKET POINTER                    ;MSH012
        MOV     R2,-(SP)                ;SAVE R2                                ;MSH012
        MOV     R5,-(SP)                ;SAVE UCB POINTER                       ;MSH012
        MOV     #20.,R1                 ;GET 10. WORDS                          ;MSH012
        CALL    $ALOCB                  ;  FROM POOL                            ;MSH012
        BCC     10$                     ;BRANCH IF SUCCESSFUL                   ;MSH012
        MOV     #IE.NOD&377,-(SP)       ;SET ERROR CODE                         ;MSH012
        BR      15$                                                             ;MSH012
10$:    MOV     4(SP),R3                ;GET PACKET POINTER                     ;MSH012
        MOV     R0,I.PRM+4(R3)          ;STORE POINTER TO NEW BLOCK             ;MSH012
        MOV     (SP),R5                 ;GET UCB POINTER                        ;MSH012
        MOV     U.SCB(R5),R4            ;GET SCB POINTER                        ;MSH012
        CLR     (R0)                    ;INITIALIZE CONTEXT SAVE WORD           ;MSH012
        CALL    $STMP1                  ;SET UP THE UMR'S                       ;MSH012
        MOV     (SP)+,10(SP)            ;MOVE DQUMR POINTER TO TOP OF STACK     ;MSH012
        TST     -10(R0)                 ;WERE WE BLOCKED BY EXEC?               ;MSH012
        BNE     12$                     ;YES, REPORT IT                         ;MSH012
        MOV     M.UMRN(R0),R3           ;GET NUMBER OF UMR'S*4                  ;MSH012
        ASR     R3                      ;GET NUMBER OF UMR'S                    ;MSH012
        ASR     R3                                                              ;MSH012
        SUB     R3,U.LAUB+2(R5)         ;SUBTRACT FROM TOTAL AVAILABLE          ;MSH012
        BGE     20$                     ;BRANCH IF ALL THERE                    ;MSH012
        ADD     R3,U.LAUB+2(R5)         ;RESTORE TOTAL VALUE                    ;MSH012
        MOV     #IE.DUN&377,-(SP)       ;SET ERROR CODE                         ;MSH012
        BR      13$                                                             ;MSH012
12$:    MOV     #IE.BLK&377,-(SP)       ;EXEC BLOCKED DRIVER FOR UMRS           ;MSH012
13$:    MOV     R0,R2                   ;COPY MAPPING BLOCK POINTER             ;MSH012
        CALL    $DEUMR                  ;DEALLOCATE THE UMR'S                   ;MSH012
        SUB     #10,R0                  ;POINT TO START OF WORK BLOCK           ;MSH012
        MOV     #20.,R1                 ;10. WORDS LONG                         ;MSH012
        CALL    $DEACB                  ;RETURN BLOCK TO POOL                   ;MSH012
15$:    MOV     (SP)+,R0                ;POP ERROR CODE                         ;MSH012
        MOV     (SP)+,R5                ;RESTORE UCB POINTER                    ;MSH012
        MOV     U.SCB(R5),R4            ;RESTORE SCB POINTER                    ;MSH012
        MOV     (SP)+,R2                ;RESTORE R2                             ;MSH012
        MOV     (SP)+,2(SP)             ;MOV PACKET POINTER OVER RETURN ADDR    ;MSH012
        TST     (SP)+                   ;CLEAN STACK                            ;MSH012
        CLR     S.PKT(R4)               ;CLEAR CURRENT PACKET POINTER           ;MSH012
        CLRB    S.STS(R4)               ;MARK CONTROLLER NOT BUSY               ;MSH012
        BICB    #US.BSY,U.STS(R5)       ;MARK UNIT NOT BUSY                     ;MSH012
        JMP     EROR                                                            ;MSH012
                                                                                ;MSH012
20$:    MOV     R0,R3                   ;COPY POINTER TO MAPPING BLOCK          ;MSH012
        MOV     (SP)+,R5                ;GET UCB POINTER                        ;MSH012
        MOV     U.SCB(R5),R4            ;GET SCB POINTER                        ;MSH012
        CALL    $MPUB1                  ;LOAD THE UMR'S                         ;MSH012
        MOV     (SP)+,R2                ;RESTORE R2                             ;MSH012
        MOV     (SP)+,R1                ;RESTORE THE PACKET POINTER             ;MSH012
        MOV     #1,I.PRM+16(R1)         ;MARK MAPPED                            ;MSH012
        RETURN                                                                  ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
        .PAGE                                                                   ;**-6
        .SBTTL  DEVICE INITIALIZE REQUEST
;
;
; ***** PROCESS AN INITIALIZE REQUEST FOR LPA11 *************
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- VIRTUAL ADDRESS OF RDA BUFFER FOR INITIALIZATION
;       WD. 13 -- LENGTH IN BYTES OF THE INIT RDA BUFFER
;       WD. 14 -- NOT USED
;       WD. 15 -- LOW ORDER 16 BITS OF PHYSICAL RDA ADDR
;       WD. 16 -- HIGH ORDER 2 BITS OF PHYSICAL RDA ADDR-BIT POS. 3 AND 2
;       WD. 17 -- NOT USED
;       WD. 20 -- NOT USED
;
; RDA FORMAT FOR INITIALIZATION COMMAND
;
;       WD. 00 -- MODE WORD-CONTAINS MICROCODE VERSION NO. AND
;                           INITIALIZE CODE (000)
;       WD. 01 THRU 12 -- DEVICE ADDRESSES ON THE I/O BUS
;
;       REMAINDER OF BUFFER IS THE DEDICATED MODE DISPATCH TABLE
;       WHICH IS A TABLE OF CONSTANTS REQUIRED FOR DEDICATED MODE
; PROCESS AN INITIALIZE REQUEST FOR LPA11
;
LAINIT:
        CMP     I.PRM+2(R1),#139.*2     ;MUST SPECIFY AT LEAST 139. WORDS
        BHIS    10$                                                             ;MSH012
        JMP     ELASPC                  ;ERROR, RDA TOO SHORT                   ;MSH012
;                                                                               ;**-1
; INITIALIZING TASK MUST BE PRIVILEGED!!!
;
10$:    MOV     I.TCB(R1),R0            ;GET TCB OF REQUESTOR TASK              ;MSH012
        BIT     #T3.PRV,T.ST3(R0)       ;TASK PRIVILEGED?                       ;**-1
        BNE     15$                                                             ;MSH012
        JMP     ELAPRI                  ;NO, ERROR                              ;MSH012
15$:    MOV     I.PRM(R1),R0            ;ADDRESS OF RDA                         ;MSH012
                                                                                ;**-2
        .IF DF  A$$CHK!M$$MGE

        MOV     #139.*2,R1              ;LENGTH OF INIT RDA IN BYTES
        CALL    $ACHCK                  ;CALL ADDR CHECK ROUTINE
        BCC     20$                                                             ;MSH012
        JMP     ELASPC                  ;ERROR RETURNED                         ;MSH012
20$:                                                                            ;MSH012
        .ENDC                                                                   ;**-2

        CALL    CVTP                    ;CONVERT RDA ADDRESS TO PHYSICAL ADDRESS
        MOV     (SP),R3                 ;POINT R3 TO I/O PACKET
        MOV     R1,I.PRM+6(R3)          ;SAVE LOW ORDER 16 BITS OF PHYSICAL RDA  ADDRESS
                                                                                ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
        ASR     R2                      ;RIGHT JUSTIFY THE ADDRESS BITS         ;MSH012
        ASR     R2                                                              ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        MOV     R2,I.PRM+10(R3)         ;AND HIGH ORDER 2 BITS
        JMP     QUEPKT                  ;INSERT PACKET IN I/O QUEUE             ;MSH012
        .PAGE                                                                   ;**-4
        .SBTTL  PROCESS CLOCK START RDA
;
;
;
; ***** PROCESS LPA11-K REAL TIME CLOCK START RDA *********
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- CLOCK START MODE WORD
;                 CONTAINS  CLO CK ID (A OR B) AND  CLO CK START  CODE
;       WD. 13 -- CLOCK STATUS WORD
;       WD. 14 -- CLOCK PRESET WORD
;       WD. 15 -- LOW ORDER 16 BITS OF RDA ADDRESS
;       WD. 16 -- HIGH ORDER 2 BITS-ALWAYS ZERO FOR THIS FUNCTION BECAUSE
;                 THE RDA IS IN THE I/O PACKET ITSELF WHICH RESIDES IN
;                 KERNEL ADDRESS SPACE
;       WD. 17 -- NOT USED
;       WD. 20 -- NOT USED
;
;
; RDA FOR CLOCK START COMMAND IS 1ST 3 PARAMETER WORDS IN IO PACKET
;
LACLOK:
        MOV     I.PRM(R1),R0            ; INSURE THIS IS A CLOCK START
        BIC     #^C<7>,R0               ;ISOLATE LOW THREE BITS
        DEC     R0                      ;IF A CLOCK START,SHOULD GO FROM 1 TO 0
        BEQ     5$                      ;YES, LEGAL CLOCK START
        JMP     ELABAD                  ;NO, BAD PARAMETERS ERROR               ;MSH012
5$:     MOV     R1,I.PRM+6(R1)          ;MAKE I/O PACKET A CLOCK START RDA      ;**-1
        ADD     #I.PRM,I.PRM+6(R1)      ;POINT RDA ADDRESS TO IT
        CLR     I.PRM+10(R1)            ;KERNAL MODE IS PHYSICAL ADDRESS
        JMP     QUEPKT                                                          ;MSH012
;                                                                               ;**-1
;
;
        .PAGE
        .SBTTL  LOAD MICRO CODE
;
; ******* FUNCTION TO LOAD MICRO CODE ***************
; ALSO DOES A HARDWARE INITIALIZE AND START UP OF LPA11
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- 16 BIT RELOCATION BIAS
;       WD. 13 -- OFFSET
;       WD. 14 -- LENGTH IN BYTES OF MICRO-CODE
;       WD. 15 -- NOT USED
;       WD. 16 -- NOT USED
;       WD. 17 -- NOT USED
;       WD. 20 -- NOT USED
;
; ***** THERE IS NO RDA FOR THE LOAD COMMAND *******
;
LALOAD:
        CMP     I.PRM+4(R1),#1024.*2    ;MUST LOAD EXACTLY 1024 MICRO INSTRUCTIONS
        BEQ     5$                      ;PROPER NUMBER, CONITNUE
        JMP     ELASPC                  ;ERROR - INCORRECT NUMBER OF BYTES IN BUFFER
;
; LOADING TASK MUST BE PRIVILEGED!!
;
5$:     MOV     I.TCB(R1),R2            ;ISSUEING TASK MUST BE PRIVILEGED!
        BIT     #T3.PRV,T.ST3(R2)       ;TASK PRIVILEGED?
        BNE     10$                     ;YES, CONTINUE
        JMP     ELAPRI                  ;NO, ERROR
;
; CHECK TO MAKE SURE THERE ARE NOT ACTIVE USERS
; WE DON'T WANT TO DO A HARDWARE RESET FOR THE POOR GUY!
;
10$:    TST     S.PKT(R4)               ;ANYONE ACTIVE?
        BEQ     15$                     ;NO, OKAY SO FAR
12$:    JMP     ELARSU                  ;YES, ERROR
15$:    MOV     #U.LAUT,R0              ;POINT TO ACTIVE USER TABLE
        ADD     R5,R0                   ;IN UCB
        MOV     #8.,R2
20$:    TST     (R0)+                   ;A USER HERE?
        BNE     12$                     ;YES, RESOURCE IN USE ERROR
        DEC     R2                      ;END OF LIST?
        BGT     20$                     ;NO CONTINUE
;
; HARDWARE RESET LPA11-K
;
        .IF DF M$$PRO                                                           ;MSH022
                                                                                ;MSH022
        CALL    $CFORK                  ;CORRECT PROCESSOR                      ;MSH022
                                                                                ;MSH022
        .ENDC                                                                   ;MSH022
                                                                                ;MSH022
        MTPS    S.PRI(R4)               ;;;GO TO PRIORITY OF DEVICE
        MOV     #40000,@S.CSR(R4)       ;;;RESET
        MTPS    #0                      ;;;RESET PRIORITY
;
; GET 1024 WORDS FROM USER BUFFER AND LOAD INTO MICRO PROCESSOR
; CHECK EACH WORD LOADED TO VERIFY
;
        CLR     R0                      ;R0 IS ADDRESS TO LOAD INTO
        MOV     S.CSR(R4),R1            ;POINT R1 TO DEVICE CSR
22$:    CALL    $GTWRD                  ;GET WORD FROM USER BUFFER
        CLR     (R1)                    ;CLEAR CSR
        MOV     R0,4(R1)                ;SET CRAM ADDRESS
        MOV     (SP),6(R1)              ;CRAM CONTENTS
        MOV     #2000,(R1)              ;SELECT ADDRESS
        BIS     #20000,(R1)             ;WRITE CRAM
        CLR     (R1)                    ;RESET
;
; NOW VERIFY THAT IT IS THERE FOR GRINNS
;
        MOV     R0,4(R1)                ;CRAM ADDRESS
        MOV     #2000,(R1)              ;SELECT CRAM AT ADDRESS
        CMP     (SP)+,6(R1)             ;DATA EQUAL
        BEQ     26$                     ; YES,OK
        JMP     ELABCC                  ;NO, LOAD ERROR FOR MICRO-CODE
26$:    INC     R0                      ;NEXT WORD
        CMP     R0,#1024.               ;END OF WCS?
        BLT     22$                     ;NOT YET
        MOV     #104000,(R1)            ;SET RUN AND ENABLE ARBITRATION
        .REPT   5
        NOP                             ;WAIT FOR THINGS TO GET GOING
        .ENDR
        BIS     #100,(R1)+              ;SET INTERRUPT ENABLE FOR READY IN
        BIS     #100,(R1)               ;SET INTERRUPT ENABLE FOR READY OUT
        JMP     QUEPKT
;
;
        .PAGE
        .SBTTL  STOP LPA11 ACTIVE REQUEST
;
; ****** ISSUE A STOP RDA COMMAND TO LPA11-K **********
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT
;
;       WD. 12 -- USER INDEX TO STOP
;       WORDS 13 THRU 20 NOT USED
;
; THE STOP QIO MUST CONTAIN A LUN (POINT TO CORRECT CONTROLLER)
; ROUTINE USES TCB ADDRESS TO ESTABLISH UNIQUENESS OF REQUEST
; TO STOP.
;
; ******** NOTE !!!  THIS STOP PACKET IS IMMEDIATELY DEALLOCATED.  THE
; ORIGINAL START PACKET WAS CONVERTED INTO A STOP PACKET IN THE READY
; OUT INT. ROUTINE, AFTER THE START REQUEST WAS ACCEPTED.  IT IS THAT
; PACKET THAT GETS QUEUED FOR THE STOP REQUEST.
;
;
LASTOP:
        MOV     I.PRM(R1),R0            ;PARAM IS USER INDEX TO STOP
        BIC     #^C<7>,R0               ;INSURE INDEX FROM 0-7
        ASL     R0                      ;MAKE INTO A WORD INDEX
        ADD     R5,R0                   ;POINT TO UCB+INDEX
        MOV     U.LAUT(R0),R1           ;GET PACKET PTR OF START
        BEQ     40$                     ;USER NOT ACTIVE
        MOV     (SP),R3                 ;GET PACKET PTR OF STOP
;
        CMP     I.TCB(R3),I.TCB(R1)     ;STOP TASK SAME AS START TASK?
        BNE     40$                     ;NO, NOT THIS USER
        CLR     U.LAUT(R0)              ;CLEAR TABLE ENTRY SO WE WON'T BE HERE AGAIN
                                        ;THIS USER MATCHES!!!!
;
; INSERT THE STOP PACKET INTO THE STOP QUEUE FOR THE LPA11
; A SEPARATE I/O QUEUE IS MAINTAINED BY THE DRIVER FOR STOP FUNCTIONS
;
        MOV     U.LASL(R5),(R1)         ;INSERT NEXT ENTRY POINTER INTO CURRENT POINTER
        MOV     R1,U.LASL(R5)           ;POINT STOP QUEUE TO THIS ENTRY
;
        CLR     R0                      ;STATUS IS REQEUST PENDING
36$:    MOV     (SP)+,R3                ;ADDRESS OF "STOP" PACKET
        CLR     R1                      ;IOSB(2) IS ZERO
        CALL    $IOFIN                  ;DEALLOCATE STOP COMMAND PACKET
        JMP     GETPKT                  ;LOOK FOR SOMETHING TO DO
;
40$:    MOV     #1,R0                   ;USER NOT ACTIVE
        BR      36$

;
;
        .PAGE
        .SBTTL  PROCESS START DATA TRANSFER REQUEST
;
; ***** PROCESS START DATA TRANSFER RDA **************
;
; ADDRESS CHECKING AND RELOCATION OF USER DATA BUFFERS IS DONE HERE
;  (BEFORE THE I/O PACKET IS QUEUED)
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF ADDR OF INPUT RDA BUFFER
;       WD. 13 -- INPUT RDA ADDRESS OFFSET
;       WD. 14 -- LENGTH OF INPUT RDA IN BYTES
;       WD. 15 -- LOW ORDER 16 BITS OF PHYSICAL RDA ADDRESS
;       WD. 16 -- HIGH ORDER 2 BITS - ALWAYS ZERO FOR THIS FUNCTION
;                 BECAUSE THE "REAL" RDA BUFFER IS DYNAMICALLY
;                 ALLOCATED IN SYSTEM DYNAMIC MEMORY IE. IN KERNEL
;                 ADDRESS SPACE.
;       WD. 17 -- EVENT FLAG MASK
;       WD. 20 -- EVENT FLAG ADDRESS
;       WD. 21 -- RESERVED FOR RSX-11M
;
; ***** NOTE !!!
;       ONCE THE 1ST TWO I.PRM WORDS HAVE BEEN MOVED FROM THE I/O
;       PACKET TO THE UCB (FOR USE BY $GTWRD), THESE LOCATIONS ARE
;       NO LONGER NEEDED FOR THE INPUT RDA ADDRESS AND ARE FREE FOR
;       OTHER USEFUL DATA.  THIS ROUTINE STORES THE FOLLOWING INFORMATION
;       IN THESE TWO WORDS:                                                     ;MSH012
;                                                                               ;**-1
;       WD. 12 -- I.PRM+0-BUFFER WORD COUNT
;       WD. 13 -- I.PRM+2-#WORDS TO BE MAPPED BY UMR'S (22-BIT MODE ONLY)       ;MSH012
;
;       THE READY OUT ROUTINE STORES THE FOLLOWING INFORMATION IN THE
;       SECOND OF THESE TWO WORDS:
;
;       WD. 13 -- I.PRM+2 - THE STOP RDA ITSELF
;
;       WHEN THE UMR'S HAVE TO BE MAPPED IN GETPKT, A BLOCK IS ALLOCATED        ;MSH012
;       FROM POOL. THE ADDRESS OF THAT BLOCK IS STORED HERE FOR LATER           ;MSH012
;       DEALLOCATION FOLLOWING A READY-OUT INTERRUPT:                           ;MSH012
;                                                                               ;MSH012
;       WD. 14 -- I.PRM+4-UMR MAPPING BLOCK                                     ;MSH012
;                                                                               ;MSH012
; NOTE THAT THE ORIGINAL DATA FROM THESE LOCATIONS HAS BEEN SAVED IN
; THE UCB  ENTRY POINT TO THE DRIVER (NEAR LABEL 2$) AT THE
; THE UCB AT THE ENTRY POINT TO THE DRIVER (NEAR LABEL 2$).
;
; THE RDA BUFFER AS SET UP BY THE CALLING ROUTINE IS AS FOLLOWS:
;
; WORD 00 - LPA-11 MODE WORD
; WORD 01 - NUMBER OF WORDS TO TRANSFER PER BUFFER
; WORD 02 - ADDRESSS OF USER STATUS WORD
; WORD 03 - LOW BYTE ONLY - VALID BUFFER MASK
; WORD 04 - BUFFER 0 ADDRESS
; WORD 05 - BUFFER 1 ADDRESS
; WORD 06 - BUFFER 2 ADDRESS
; WORD 07 - BUFFER 3 ADDRESS
; WORD 10 - BUFFER 4 ADDRESS
; WORD 11 - BUFFER 5 ADDRESS
; WORD 12 - BUFFER 6 ADDRESS
; WORD 13 - BUFFER 7 ADDRESS
; WORD 14 - ADDRESS OF RANDOM CHANNEL LIST
; WORD 15 - DELAY WORD
; WORD 16 - CHANNEL INCR (HIGH BYTE) / START CHANNEL (LOW BYTE)
; WORD 17 - NUMBER OF CHANNELS TO SAMPLE IN SEQUENCE
; WORD 20 - NUMBER OF CLOCK OVERFLOWS BETWEEN STARTS OF SEQUENCE
; WORD 21 - EVENT MARK WORD / DIGITAL START WORD
; WORD 22 - START WORD MASK
; WORD 23 - EVENT MARK MASK
; WORD 24 - NUMBER OF ELEMENTS IN RANDOM CHANNEL LIST                           ;MSH012
;
; THIS ROUTINE CONVERTS THIS INPUT FORMAT RDA INTO THE REAL RDA
; WHICH IS USED BY THE LPA-11.  THIS ROUTINE DOES THE ADDRESS
; CHECKING AND RELOCATION OF USER BUFFERS CONVERTING THEM TO
; 2 WORD PHYSICAL ADDRESSES. IT DOES THE SAME FOR THE RANDOM
; CHANNEL LIST AND USER STATUS WORD.  THE FINAL RDA IS CREATED IN
; TASK DYNAMIC MEMORY AND POINTED TO BY WORDS 15 AND 16 IN THE
; I/O PACKET.
;
LASTRT:
        MOV     #30.*2,R1               ;ALLOCATE DYNAMIC STOREAGE
        CALL    $ALOCB
        BCC     42$                     ;GOT ONE
        JMP     ELANOD
;
; LINK THIS PACKET INTO THE LIST OF DSR FOR THE UNIT
;
42$:    MOV     U.LADS(R5),(R0)         ;POINT THIS PACKET TO NEXT PACKET
        MOV     R0,U.LADS(R5)           ;POINT LIST TO THIS PACKET
        TST     (R0)+                   ;POINT R0 TO SECOND WORD OF PACKET
;
        MOV     (SP),R2                 ;GET I/O PACKET ADDRESS
        MOV     R0,I.PRM+6(R2)          ;SAVE ADDRESS OF NEW RDA
        CLR     I.PRM+10(R2)            ;EXTENDED ADDRESS IS ZERO
        MOV     R0,R3                   ;COPY ADDRESS OF NEW RDA
        CALL    $GTWRD                  ;MODE
        MOV     (SP)+,(R3)
        BIC     #7,(R3)                 ;MAKE SURE THIS IS A "START" RDA
        BIS     #2,(R3)+
        CALL    $GTWRD                  ;TRANSFER COUNT
        MOV     (SP),(R3)+              ;LEAVE COUNT ON STACK FOR LATER
        BLE     62$                     ;ERROR, TRANSFER COUNT MUST BE 1-32K
        MOV     (SP),I.PRM(R2)          ;SAVE BUFF WORD COUNT
        ASL     (SP)                    ;MAKE TRANSFER COUNT BYTE VALUE
        CALL    $GTWRD                  ;USER STATUS WORD ADDRESS

        .IF DF  A$$CHK!M$$MGE

        MOV     #120,R1                 ;ADDRESS CHECK ENTIRE IBUF ARRAY
        MOV     (SP),R0                 ;GET USW ADDRESS
        SUB     #4,R0                   ;PT TO START OF IBUF(=IOSB ADDR)
        CALL    $ACHCK
        BCS     60$                     ;ADDRESS CHECK ERROR IF C SET

        .ENDC

        MOV     (SP),R0                 ;RESTORE USW ADDRESS                    ;MSH012
        CALL    CVTP                    ;RLOCATE USW                            ;**-3
        MOV     R1,(R3)+                ;SAVE USW ADDRESS LOW
        ASR     R2
        ASR     R2
        MOVB    R2,(R3)+                ;SAVE USW ADDRESS HIGH
                                                                                ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
        MOV     #76.,R4                 ;OFFSET FROM USW TO FIRST BUFFER        ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        MOV     #8.,-(SP)               ;COUNTER FOR EIGHT BUFFERS
        CALL    $GTWRD                  ;NUMBER OF BUFFERS
        MOVB    (SP),(R3)+              ;SAVE IN RDA
        BIC     #^C<7>,(SP)             ;AND OUT ALL BUT NUMBER OF BUFFERS
        CLR     -(SP)                   ;HIGH 2 BITS OF OFFSET                  ;MSH012
44$:    CALL    $GTWRD                  ;BUFFER ADDRESS
        MOV     (SP),R0

        .IF DF  A$$CHK!M$$MGE

        MOV     12(SP),R1               ;ADDRESS CHECK                          ;MSH012
        CALL    $ACHCK                                                          ;**-1
        BCS     154$                    ;ADDRESS CHECK ERROR                    ;MSH012
                                                                                ;**-1
        .ENDC

        .IF NDF M$$EXT                                                          ;MSH012
                                                                                ;MSH012
        MOV     (SP)+,R0                ;GET ADDRESS OF BUFFER
        CALL    CVTP
        MOV     R1,(R3)+                ;SAVE ADDRESS IN RDA
        ASR     R2
        ASR     R2
        MOV     R2,(R3)+
                                                                                ;MSH012
        .IFF                                                                    ;MSH012
                                                                                ;MSH012
        TST     (SP)+                   ;CLEAN STACK                            ;MSH012
        MOV     R4,(R3)+                ;SET BUFFER ADDR AS OFFSET FROM USW     ;MSH012
        MOV     (SP),(R3)+              ;SET HIGH 2 BITS                        ;MSH012
        ADD     10(SP),R4               ;SPAN PAST THIS BUFFER                  ;MSH012
        ADC     (SP)                    ;DONT FORGET THE CARRY                  ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        DEC     4(SP)                   ;COUNT DOWN TOTAL BUFFERS               ;MSH012
        DEC     2(SP)                   ;COUNT DOWN BUFFERS TO USE              ;MSH012
        BGE     44$                     ;LOOP TIL DONE                          ;MSH012
        MOV     (SP)+,R2                ;GET HIGH 2 BITS OF OFFSET              ;MSH012
        TST     (SP)+                   ;CLEAN BUFFER TO USE COUNTER            ;MSH012
46$:    DEC     (SP)                    ;ANY BUFFERS NOT IN USE                 ;**-4
        BLT     50$                     ;NO, ALL DONE
        CALL    $GTWRD                  ;FETCH WORD FROM USER
        TST     (SP)+                   ;IGNORE
        CLR     (R3)+                   ;CLEAR NEW RDA
        CLR     (R3)+
        BR      46$                     ;AND LOOP
50$:    MOV     R2,(SP)                 ;CLEAR STACK OF BUFFER COUNT            ;MSH012
        CALL    $GTWRD                  ;GET RANDOM CHANNEL LIST ADDRESS        ;**-1
        MOV     (SP)+,R0

        .IF DF  A$$CHK!M$$MGE

        BEQ     52$                     ;RCL NOT IN USE IF ADDRESS ZERO
        MOV     #2,R1                   ;ADDRESS CHECK FIRST WORD
        CALL    $ACHCK
        BCS     57$                     ;ERROR, BAD BUFFER                      ;MSH012
52$:                                                                            ;**-1

        .ENDC

        .IF NDF M$$EXT                                                          ;MSH012
                                                                                ;MSH012
        CALL    CVTP                    ;RELOCATE
        MOV     R1,(R3)+                ;SAVE IN RDA
        ASR     R2
        ASR     R2
        MOV     R2,(R3)+                ;SAVE HIGHT ORDER BITS
        TST     (SP)+                   ;CLEAN HIGH 2 BITS FROM STACK           ;MSH012
                                                                                ;MSH012
        .IFF                                                                    ;MSH012
                                                                                ;MSH012
        MOV     R4,(R3)+                ;OFFSET FROM USW                        ;MSH012
        MOV     (SP)+,(R3)+             ;SET UMR HIGH 2 BITS                    ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        MOV     #6,-(SP)                ;SEVEN MORE ENTRIES IN RDA
54$:    CALL    $GTWRD
        MOV     (SP)+,(R3)+
        DEC     (SP)                    ;END?
        BGE     54$                     ;NO, LOOP
        TST     (SP)+
                                                                                ;MSH012
        .IF DF  M$$EXT                                                          ;MSH012
                                                                                ;MSH012
        CALL    $GTWRD                  ;GET RCL LENGTH                         ;MSH012
        ADD     (SP)+,R4                ;FINAL LENGTH FOR UMR MAPPING           ;MSH012
        MOV     4(SP),R3                ;GET PACKET POINTER                     ;MSH012
        MOV     R4,I.PRM+2(R3)          ;SAVE FOR UMR MAPPING                   ;MSH012
        MOV     (SP),R0         ;CHECK THAT REGION STARTING WITH THE USW        ;MSH012
        MOV     R4,R1           ;AND (R4) BYTES LONG IS WITHIN USER'S           ;MSH012
        CALL    $ACHCK          ;ADDRESS SPACE. THE USER SHOULD KNOW THAT       ;MSH012
        BCS     60$             ;HIS IBUF,RCL AND BUFFERS MUST BE CONTIGUOUS    ;MSH012
        MOV     U.SCB(R5),R4            ;RESTORE SCB POINTER                    ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        ADD     #4,SP                   ;CLEAR USW AND COUNT FROM STACK         ;MSH012
        MOV     (SP),R3                 ;GET PACKET POINTER
        MOVB    I.EFN(R3),R0            ;CALCULATE EVENT FLAG MASK FOR LATER
        MOV     R5,-(SP)                ;SAVE R5
        MOV     I.TCB(R3),R5            ;TASK TCB ADDRESS
        CALL    $CEFI                   ;CONVERT EFN TO MASK AND ADDRESS
        MOV     (SP)+,R5                ;RESTORE R5
        MOV     R0,I.PRM+12(R3)         ;SAVE EVENT FLAG MASK
        MOV     R1,I.PRM+14(R3)         ;AND EVENT FLAG ADDRESS
        JMP     QUEPKT                  ;FINISH IN COMMON CODE
;
; ERROR - BAD BUFFER ADDRESS
;
154$:   TST     (SP)+                                                           ;MSH012
55$:    TST     (SP)+                   ;CLEAR FROM STACK                       ;MSH012
56$:    TST     (SP)+                   ;CLEAR FROM STACK                       ;MSH012
57$:    TST     (SP)+                   ;CLEAR FROM STACK                       ;MSH012
60$:    TST     (SP)+                   ; CLEAN STACK SOME MORE                 ;**-4
62$:    TST     (SP)+                   ;WHAT A CLEAN STACK!                    ;**-3
64$:    JMP     ELASP2                  ; BAD BUFFER
;
        .PAGE
        .SBTTL  READY IN INTERRUPT PROCESSING
;
; INTERRUPT SUBROUTINE FOR READY IN INTERRUPTS
;
; ********************
; LABEL $LAOUT:: IS ADDED TO CONFORM TO RSX-11M SYSGEN NAMING CONVENTION
; WHICH SPECIFIES THAT FOR DUAL VECTORED DEVICES, THE LOW VECTOR IS
; NAMED $XXINP AND THE HIGH VECTOR IS NAMED $XXOUT.  FOR THE LPA-11 KMC
; MODULE, THE HIGHEST PRIORTY VECTOR (THE OUTPUT) MUST COME FIRST.  THUS
; THE OUTPUT VECTOR IS NAMED $LAINP AND THE INPUT VECTOR IS NAMED $LAOUT
; ********************
;
$LAOUT::
;
;
LARDI::
        INTSV$  LA,PR5,L$$A11,,<UCBSV>                                          ;MSH022
        CALL    $FORK                   ;;;GO TO FORK LEVEL                     ;**-1
;
; FORK PROCESSING FOR READY IN INTERRUPTS
;
        MOV     U.SCB(R5),R4            ;POINT TO STATUS CONTROL BLOCK
        CLRB    S.CTM(R4)               ;CLEAR DEVICE TIMEOUT COUNTER
        CLRB    S.STS(R4)               ;CLEAR CONTROLER STATUS TO NOT BUSY
        BICB    #US.BSY,U.STS(R5)       ;CLEAR UNIT BUSY STATUS
        MOV     S.PKT(R4),R3            ;REQUEST FINISHED?
        BEQ     70$                     ;YES
        MOV     #1,R0                   ;FINISH IT SUCCESSFULLY
        CLR     S.PKT(R4)               ;MARK FREE
        BIT     #2,I.PRM+16(R3)         ;DID WE RUN OUT OF POOL?                ;MSH014
        BEQ     66$                     ;NO, BRANCH                             ;MSH014
        BIC     #2,I.PRM+16(R3)         ;YES, CLEAR THAT BIT                    ;MSH014
        MOV     #IE.NOD&377,R0          ;SET APPROPRIATE ERROR CODE             ;MSH014
66$:    CLR     R1                      ;SECOND IOSB WORD IS ZERO
                                                                                ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
        CMP     #IO.INI,I.FCN(R3)                                               ;MSH012
        BEQ     68$                                                             ;MSH012
        CMP     #IO.STA,I.FCN(R3)       ;START PACKET CONVERTED TO STOP?        ;MSH012
        BNE     69$                     ;NO, BRANCH                             ;MSH012
        TST     I.PRM+16(R3)            ;ANY UMRS MAPPED?                       ;MSH012
        BEQ     69$                     ;NO, BRANCH                             ;MSH012
68$:    CALL    UNMAP                   ;YES, UNMAP THEM                        ;MSH012
        MOV     U.SCB(R5),R4            ;RESTORE SCB POINTER                    ;MSH012
        CALL    $DQUMR                  ;WAKE UP PROCESS WAITING FOR UMRS       ;MSH012
69$:                                                                            ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        CALL    $IOFIN                  ;END OF REQUEST PROCESSING
70$:    JMP     GETPKT                  ;TRY AND GET ANOTHER PACKET
;
        .PAGE
        .SBTTL  LPA11-K READY OUT INTERRUPT PROCESSING
;
; INTERRUPT SUBROUTINE FOR LPA11 READY OUT INTERRUPTS
;
; ******************
; LABEL $LAINP:: IS ADDED TO CONFORM TO RSX-11M SYSGEN NAMING CONVENTION
; SEE COMMENT AT INPUT INTERRUPT FOR FURTHER EXPLANATION.
; ******************
;
$LAINP::
;
LARDO::
        INTSV$  LA,PR5,L$$A11,,<UCBSV>                                          ;MSH022
        MOV     #U.LAFB+6,R4            ;;;POINT TO READY OUT FORK BLOCK        ;**-1
        ADD     R5,R4                   ;;;
        CALL    $FORK1                  ;;;GO TO FORK LEVEL
;
; FORK PROCESSING FOR LPA11 READY OUT INTERRUPTS
;
        MOV     U.SCB(R5),R4            ;POINT TO SCB
        MOV     S.CSR(R4),R2            ;DEVICE CSR ADDRESS
        MOV     2(R2),R0                ;LPA11 OUT STATUS WORD
        MOV     6(R2),R1                ;GET MAINTENANCE STATUS BYTE
        BIC     #200,2(R2)              ;ACKNOWLEDGE READY OUT INTERRUPT
        MOV     R0,R3                   ;GET USER INDEX
        ASL     R3                      ;MAKE WORD OFFSET
        BIC     #^C<16>,R3
        ADD     R5,R3                   ;POINT TO USRTB IN UCB
        BIC     #377,R0                 ;AND OUT READY OUT BYTE
        BEQ     100$                    ;EQUAL IS START REQUEST PROCESSED
        BPL     71$                     ;POSITIVE IS NORMAL STATUS
        JMP     102$                    ;MINUS IS ERROR
;
; COMMON CODE FOR REPORTING NORMAL USER STATUS
;
71$:
        MOV     U.LAUT(R3),R2           ;GET I/O PACKET ADDRESS IN R2
        MOV     I.PRM(R2),R1            ;SET WORD COUNT IN IOSB WD. 2
;                                       IOSB WD. 1 =400 FROM LPA11-K
72$:
        MOV     R5,-(SP)                ;SAVE UCB                               ;MSH014
        MOV     R3,-(SP)                ;SAVE USRTB POINTER
        MOV     U.LAUT(R3),R3           ;POINT R3 TO I/O PACKET
        BEQ     75$                     ;IF NO USER NOW, JUST EXIT
        MOV     I.TCB(R3),R2            ;POINT TO REQUESTING TASK TCB
        BIT     #T2.ABO,T.ST2(R2)       ;TASK BEING ABORTED?
        BNE     75$                     ;YES, SKIP EVENT FLAG
        MOV     I.IOSB+2(R3),R4         ;GET IOSB BIAS                          ;MSH020
        MOV     I.IOSB+4(R3),R2         ;GET IOSB OFFSET                        ;MSH020
        ADD     #4,R2                   ;POINT TO 2ND IOSB                      ;MSH020
        CMP     #140100,R2              ;MAPPING STILL VALID?                   ;MSH020
        BHI     172$                    ;YES, BRANCH                            ;MSH020
        SUB     #64.,R2                 ;NO, MAP NEXT 32-WORD BLOCK             ;MSH020
        INC     R4                                                              ;MSH020
172$:                                                                           ;MSH020
                                                                                ;**-1
        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)            ;SAVE KISAR6
        MOV     R4,KISAR6               ;MAP USER'S IOSB                        ;MSH020
                                                                                ;**-1
        .IFTF

        MOV     R0,(R2)+                ;STORE STATUS BYTE
        MOV     R1,(R2)                 ;IOSB HIGH WORD

        .IFT

        MOV     (SP)+,KISAR6            ;RESTORE MAPPING

        .ENDC
;
; ***************************************************
;

73$:

        .IF DF  A$$TRP

;
; IF BIT 0 OF THE QIO FUNCTION CODE IS SET, DO NOT QUEUE AST HERE
;
        BIT     #1,I.FCN(R3)                    ;IS SUBFUNCTION CODE BIT 0 SET?
        BNE     74$                             ;YES, DO NOT QUEUE AST
;
        TST     I.AST(R3)               ;AST REQUESTED?
        BEQ     74$                     ;NO
        MOV     #6.*2,R1                ;YES, ALLOCATE AN AST BLOCK
        CALL    $ALOCB
        BCS     77$                     ;ERROR, NO DYNAMIC MEMORY
        MOV     R0,R1                   ;COPY BLOCK ADDRESS
        TST     (R0)+                   ;POINT PAST AST LIST LINK WORD
        MOV     #6.*2,(R0)+             ;SIZE OF AST BLOCK
        MOV     #8.*2,(R0)+             ;NUMBER OF BYTES TO ALLOCATE ON USER'S STACK
        MOV     I.AST(R3),(R0)+         ;AST VIRTUAL ADDRESS
        MOV     #1,(R0)+                ;NUMBER OF EXTRA WORDS TO PUT ON USER'S STACK
        MOV     I.IOSB(R3),(R0)         ;IOSB ADDRESS
        ADD     #4,(R0)                 ;POINT TO 2ND IOSB BLOCK                ;MSH020
        MOV     I.TCB(R3),R0            ;POINT TO TASK'S TCB
        ADD     #T.ASTL,R0              ;POINT TO TASK'S AST LISTHEAD
        CALL    $QINSF                  ;INSERT AST BLOCK IN TASK'S AST LIST
74$:

        .ENDC

        MOV     I.TCB(R3),R5            ;POINT TO TASK TCB
        MOV     I.PRM+12(R3),R0         ;SET ARGS FOR SETM
        MOV     I.PRM+14(R3),R1
        CALL    $SETM
;
;
75$:
        CMP     (SP)+,(SP)+             ;CLEAN STACK                            ;MSH014
                                                                                ;**-1
;
76$:    RETURN                          ;RETURN
;
;

;                                                                               ;MSH014
;  WE RAN OUT OF POOL FOR AST BLOCK. QUEUE STOP PACKET FOR THIS USER            ;MSH014
;  AND SET BIT 2 OF I.PRM+16 TO SET UP PROPER ERROR CODE.                       ;MSH014
;                                                                               ;MSH014
        .IF DF  A$$TRP

77$:    MOV     (SP)+,R3                ;POP USER TABLE POINTER                 ;MSH014
        MOV     (SP)+,R5                ;POP UCB POINTER                        ;MSH014
        MOV     U.LAUT(R3),R2           ;GET THIS USER'S CONVERTED PACKET       ;MSH014
        CLR     U.LAUT(R3)              ;DEACTIVATE THIS ENTRY                  ;MSH014
        MOV     U.LASL(R5),(R2)         ;MOVE STOP QUEUE BEHIND THIS USER       ;MSH014
        MOV     R2,U.LASL(R5)           ;SET NEW QUEUE HEADER                   ;MSH014
        BIS     #2,I.PRM+16(R2)         ;MARK FOR 'NO POOL' ERROR               ;MSH014
        JMP     GETPKT                  ;TRY TO DEALLOCATE STOP PACKET          ;MSH014
                                                                                ;**-5
        .ENDC

;
;
;
; STATUS RETURN OF ZERO
; TRANSFER REQUEST SUCCESSFULLY STARTED
;
100$:
        MOV     S.PKT(R4),R2            ;GET CURRENT I/O PACKET ADDRESS
        MOV     R2,U.LAUT(R3)           ;STORE IT IN USRTB
        MOV     R3,R1                   ;RETURN INDEX TO USER
        SUB     R5,R1                   ;GET INDEX BACK
        ASR     R1
        CLR     S.PKT(R4)               ;RELINQUISH CURRENT PACKET
;
; THE FOLLOWING CODE TURNS THE ORIGONAL START REQUEST I/O PACKET
; INTO A STOP PACKET FOR ITSELF.  THIS ALLOWS ANYONE TO STOP THE
; REQUEST BY SIMPLY RE-QUEUEING THIS PACKET.
;
        MOVB    R1,I.PRM+3(R2)          ;USER I.D.
        MOVB    #3,I.PRM+2(R2)          ;STOP!
        MOV     R2,I.PRM+6(R2)          ;ADDRESS OF STOP RDA WE JUST MADE
        ADD     #I.PRM+2,I.PRM+6(R2)    ;ADD IN OFFSET TO PROPER PLACE
        CLR     I.PRM+10(R2)            ;CLEAR EXTENDED BITS
; ABOVE 5 INSTR. CREATE 1 WORD STOP RDA WHICH RESIDES IN IPRM+2.                ;MSH012
;                                                                               ;**-1
        BITB    #US.MDM,U.STS(R5)       ;CANCEL I/O REQUESTED?
        BNE     101$                    ;YES, GO CANCEL
        CLR     R0                      ;IOSB WORD 1 ON ACCEPT START
;                                                                               ;MSH012
; TIMEOUT RAISED TO 255 SEC. IN CASE USER SPECIFIED AN EXTREMELY SLOW           ;MSH012
; CLOCK RATE AND IS USING DEDICATED MODE. AFTER THE LPA GETS THE FIRST          ;MSH012
; 256 WORDS OF DATA, IT WILL ISSUE A READY-IN. THE DRIVER WILL CLEAR            ;MSH012
; THE TIMEOUT THERE. IF THE LPA WILL BE WAITING LONGER THAN 255 SECONDS         ;MSH012
; BEFORE IT CAN ISSUE A READY-IN (DATA SWEEP DELAYED FOR HOURS FOR              ;MSH012
; INSTANCE) THIS TIMEOUT CAN BE DISABLED HERE (AND ONLY HERE).                  ;MSH012
;                                                                               ;MSH012
; ANY READY-IN WILL CLEAR THE TIMEOUT. THUS, IF THE DRIVER RECEIVES             ;MSH012
; ANOTHER REQUEST SUCH AS A CLOCK QIO, THE TIMEOUT LENGTHENED HERE              ;MSH012
; WILL BE NULLIFIED WHEN THE LPA ISSUES THE READY-IN FOLLOWING THE              ;MSH012
; CLOCK REQUEST.                                                                ;MSH012
;                                                                               ;MSH012
        MOVB    #255.,S.CTM(R4)         ;STRETCH TIMEOUT COUNT NOW              ;MSH012
        JMP     72$                     ;NO, CONTINUE
;
; US.MDM FLAGS THAT A CANCEL I/O OCCURED FOR TASK WHILE START REQUEST WAS
; IN PROGRESS.  IMMEDIATELY QUEUE A STOP FOR THIS USER INTO THE DRIVERS
; STOP REQUEST QUEUE.
;
101$:   MOV     U.LAUT(R3),R1           ;POINT TO ORIGINAL I/O PACKET
        CLR     U.LAUT(R3)              ;FLAG THAT THE REQUEST IS BEING STOPPED
        MOV     U.LASL(R5),(R1)         ;INSERT IN DRIVERS STOP REQUEST QUEUE
        MOV     R1,U.LASL(R5)           ;POINT TO IT
        RETURN                          ;BACK TO CALLER
;
; ERROR REPORTED (STATUS RETURN NEGATIVE)
; DISPATCH ON ERROR BITS
;
102$:
        MOV     R0,R2                   ;COPY STATUS
        BIC     #^C<160000>,R2          ;EXTRACT ERROR TYPE FIELD
        CMP     R2,#160000              ;FATAL HARDWARE ERROR?
        BNE     104$                    ;NO
        BISB    #IE.FHE&377,R0          ;YES, SET RSX ERROR CODE
        CLRB    S.CTM(R4)               ;NO TIME OUTS NOW
        BR      LAOUT2                  ;REPORT ERROR TO USERS
104$:
        CMP     R2,#140000              ;START ERROR?
        BEQ     106$                    ;YES
        MOV     U.LAUT(R3),R2           ;USER ERROR, GET I/O PACKET PNTR
        BEQ     76$                     ;USER NOT ACTIVE NOW
        CLR     U.LAUT(R3)              ;DEACTIVATE THE USER
        MOV     R2,R3                   ;COPY I/O PACKET ADDRESS
        CMP     #124000,R0              ;RESULT OF USW BIT 14 STOP?
        BNE     103$                    ;NO
        MOVB    #IS.SUC&377,R0          ;YES, SET RSX STATUS AS SUCCESS
                                        ;SIGN EXTEND 0 TO HIGH BYTE
        MOV     I.PRM(R2),R1            ;SET WORD COUNT IS IOSB WORD 2
        BR      111$                    ;FINISH
103$:
        CMP     #121400,R0              ;BUFFER OVERRUN/UNDERRUN ERROR?
        BNE     110$                    ;NO
        BISB    #IE.DAO&377,R0          ;SET RSX OVERRUN ERROR STATUS
        BR      111$                    ;FINISH
106$:
        MOV     S.PKT(R4),R3            ;START ERROR, GET I/O PACKET POINTER
        BEQ     76$                     ;NO USER HERE NOW
        CLR     S.PKT(R4)               ;CLEAR PACKET POINTER
110$:
        BISB    #IE.ABO&377,R0          ;SET RSX STATUS AS ABORT
111$:                                                                           ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
        TST     I.PRM+16(R3)            ;ANY UMRS MAPPED?                       ;MSH012
        BEQ     113$                    ;NO, BRANCH                             ;MSH012
        CALL    UNMAP                   ;YES, UNMAP AND DEALLOCATE THEM         ;MSH012
        MOV     U.SCB(R5),R4            ;GET SCB POINTER                        ;MSH012
        CALL    $DQUMR                  ;WAKE UP WAITING PROCESS                ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
113$:   CALLR   $IOFIN                  ;FLUSH THE PACKET                       ;MSH012
;                                                                               ;**-1
        .PAGE
        .SBTTL  DEVICE TIME-OUT AND POWERFAIL LOGIC
;
; DEVICE TIME-OUT AND DEVICE POWER FAIL
; RESET LPA11
; SET I/O COMPLETION FOR ALL USERS WITH STATUS OF IE.PWR
;
;
; POWER FAIL ----
;       REQUEST LOADER TASK IF PRESENT
;
LAPWF:


        .IF DF M$$MGE & L$$DRV & LD$LA

        MOV     S.FRK+8.(R4),U.LAFB+8.(R5)      ;INITIALIZES FORK BLOCK IN UCB FOR
                                                ;FORK1 CALL.  NEEDED FOR MAPPED
                                                ;SYSTEMS WITH LOADABLE DRIVERS
        .ENDC


        MOV     R5,R3                   ;LOADER TASK NAME
        ADD     #U.CW2,R3               ;IN UCB  U.CW2 AND U.CW3
        CALL    $SRSTD                  ;IS IT INSTALLED IN SYSTEM?
        BCS     112$                    ;NO, DON'T LOAD ON STARTUP
        MOV     #TUIC,R1                ;DEFAULT UIC OF LOADER TASK
        MOV     R4,-(SP)                ;SAVE R4 AND R5
        MOV     R5,-(SP)
        CALL    $TSKRT                  ;REQUEST LOADER TASK TO RUN
        MOV     (SP)+,R5                ;RESTORE R5 AND R4
        MOV     (SP)+,R4
112$:   MOV     #IE.VER&377,R0          ;UNRECOVERABLE ERROR
        CLRB    S.CTM(R4)               ;CLEAR TIME OUT COUNTER
        CLR     R1                      ;ZERO IOSB+2                            ;MSH012
        BR      LAOUT2                  ;LET ANY ACTIVE USERS KNOW
;
; DEVICE TIME OUT
;
LAOUT:
        .IF DF M$$PRO                                                           ;MSH022
                                                                                ;MSH022
        CALL    $CFORK                  ;CORRECT PROCESSOR                      ;MSH022
                                                                                ;MSH022
        .ENDC                                                                   ;MSH022
                                                                                ;MSH022
        MOV     2(R2),R1                ;;;GET LAST READY OUT STATUS            ;MSH012
                                        ;;;DATA MAY BE IRRELEVANT               ;MSH012
        CLRB    R1                      ;;;CLEAR LOW BYTE                       ;MSH012
        BIS     R1,R0                   ;;;COMBINE LPA STATUS WITH IE.DNR       ;MSH012
        MOV     6(R2),R1                ;;;GET MAINTENANCE STATUS WORD          ;MSH012
LAOUT2: MOVB    S.PRI(R4),@#PS          ;;;GO TO PRIORITY OF DEVICE             ;**-6
        MOV     #40000,@S.CSR(R4)       ;;;DO A DEVICE RESET TO MAKE SURE
        CLRB    @#PS                    ;;;RESET PRIORITY                       ;MSH012
        CLRB    S.STS(R4)               ;CLEAR CONTROLLER STATUS TO NOT BUSY    ;**-1
        BICB    #US.BSY,U.STS(R5)       ;CLEAR UNIT BUSY STATUS
        BICB    #US.MNT,U.STS(R5)       ;UNMAPPING FLAG                         ;MSH012
        MOV     S.PKT(R4),R3            ;A REQUEST IN PROCESS?
        BEQ     116$                    ;NO
                                                                                ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
        TST     I.PRM+16(R3)            ;ANY UMR'S MAPPED?                      ;MSH012
        BEQ     114$                    ;NO, BRANCH                             ;MSH012
        CALL    UNMAP                   ;DEALLOCATE THE UMR'S                   ;MSH012
        BISB    #US.MNT,U.STS(R5)       ;MARK UMRS DEALLOCATED                  ;MSH012
114$:                                                                           ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        CALL    $IOFIN                  ;DEALLOCATE PACKET                      ;MSH012
        MOV     U.SCB(R5),R4            ;POINT TO SCB                           ;**-1
        CLR     S.PKT(R4)               ;CLEAR CURRENT PACKET POINTER
116$:   MOV     #-7,-(SP)                                                       ;MSH012
        MOV     #U.LAUT,R2                                                      ;**-1
        ADD     R5,R2                   ;POINT TO USRTB IN UCB
120$:   MOV     (R2),R3                 ;NEXT ENTRY
        BEQ     122$                    ;NO REQUEST ACTIVE
        MOV     R2,-(SP)
                                                                                ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
        TST     I.PRM+16(R3)            ;ANY UMR'S MAPPED?                      ;MSH012
        BEQ     121$                    ;NO, BRANCH                             ;MSH012
        CALL    UNMAP                   ;DEALLOCATE THE UMR'S                   ;MSH012
        BISB    #US.MNT,U.STS(R5)       ;MARK UMRS DEALLOCATED                  ;MSH012
121$:                                                                           ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        CALL    $IOFIN                  ;REQEUST ACTIVE, TELL HIM ITS OVER
        MOV     (SP)+,R2
122$:   CLR     (R2)+                   ;CLEAR ENTRY
        INC     (SP)                    ;ANY MORE ENTRIES IN LIST?              ;MSH012
        BLE     120$                    ;YES, CONTINUE                          ;MSH012
        TST     (SP)+                   ;ALL DONE, EXIT                         ;**-2
                                                                                ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
        MOV     U.LAUB(R5),U.LAUB+2(R5) ;INITIALIZE #OF AVAILABLE UMRS          ;MSH012
        BITB    #US.MNT,U.STS(R5)       ;ANY UMR'S DEALLOCATED?                 ;MSH012
        BEQ     LACANG                  ;NO, BRANCH                             ;MSH012
        CALL    $DQUMR                  ;DEQU WAITING PROCESS                   ;MSH012
        BICB    #US.MNT,U.STS(R5)       ;CLEAR UMR DEALLOCATED FLAG             ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        BR      LACANG
;
        .PAGE                                                                   ;MSH012
;                                                                               ;MSH012
; *********************************                                             ;MSH012
;                                                                               ;MSH012
;       THIS SUBROUTINE WILL UNMAP THIS USER'S UMRS AND RETURN THEM TO          ;MSH012
;       THE LPA POOL. IT WILL DEALLOCATE THE WORK BLOCK TAKEN FROM DSR          ;MSH012
;       IN SUBROUTINE 'MAP'.                                                    ;MSH012
;                                                                               ;MSH012
        .IF DF M$$EXT                                                           ;MSH012
                                                                                ;MSH012
UNMAP:  MOV     I.PRM+4(R3),R2          ;GET ADDRESS OF WORK BLOCK              ;MSH012
        ADD     #10,R2                  ;POINT TO MAP AREA                      ;MSH012
        MOV     R3,-(SP)                ;SAVE PACKET POINTER                    ;MSH012
        MOV     M.UMRN(R2),R3           ;GET #OF UMRS TO RECOVER                ;MSH012
        ASR     R3                                                              ;MSH012
        ASR     R3                                                              ;MSH012
        ADD     R3,U.LAUB+2(R5)         ;RECOVER THE UMRS                       ;MSH012
        CALL    $DEUMR                  ;DEALLOCATE THE UMR'S                   ;MSH012
        MOV     (SP),R3                 ;RESTORE PACKET POINTER                 ;MSH012
        MOV     R0,-(SP)                ;SAVE IOSB                              ;MSH012
        MOV     R1,-(SP)                ;SAVE IOSB+2                            ;MSH012
        MOV     R5,-(SP)                ;SAVE UCB POINTER                       ;MSH012
        MOV     I.PRM+4(R3),R0          ;GET ADDRESS OF WORK BLOCK              ;MSH012
        MOV     #20.,R1                 ;WORK BLOCK IS 10. WORDS                ;MSH012
        CALL    $DEACB                  ;RETURN WORK BLOCK TO POOL              ;MSH012
        MOV     (SP)+,R5                ;RESTORE UCB POINTER                    ;MSH012
        MOV     (SP)+,R1                ;RESTORE IOSB+2                         ;MSH012
        MOV     (SP)+,R0                ;RESTORE IOSB                           ;MSH012
        MOV     (SP)+,R3                ;RESTORE PACKET POINTER                 ;MSH012
        CLR     I.PRM+16(R3)            ;MARK UNMAPPED                          ;MSH012
        RETURN                                                                  ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
        .PAGE
        .SBTTL  CANCEL I/O ENTRY
;
; CANCEL I/O FOR A PARTICULAR TASK
; ALL REQUESTS ARE SCANNED FOR THE TCB OF THE TASK
; EACH ACTIVE REQUEST FOR THE TASK IS MARKED FOR ABORT
; ACTUAL REQUEST STOP IS ISSUED AT READY IN INTERRUPT TIME
;
LACAN:
        MOV     #U.LAUT,R0              ;;;POINT TO ACTIVE REQUEST TABLES
        ADD     R5,R0                   ;;;IN UCB
        MOV     #8.,R2                  ;;;NINE POSSIBLE ENTRIES + CURRENT ENTRY
        MOV     S.PKT(R4),R3            ;;;REQUEST IN PROGRESS?
        BEQ     126$                    ;;;NO REQUEST IN PROCESS
        CMP     I.TCB(R3),R1            ;;;TCB'S MATCH?
        BNE     126$                    ;;;NO, DON'T CANCEL IT
        BISB    #US.MDM,U.STS(R5)       ;;;YES, MARK REQ. FOR ABORT WHEN IT FINISHES
126$:   MOV     (R0)+,R3                ;;;NEXT USER ACTIVE?
        BEQ     130$                    ;;;NO
        CMP     I.TCB(R3),R1            ;;;TASK TCB'S MATCH?
        BNE     130$                    ;;;NO
;
; STOP THE REQUEST BY PLACING THE ORIGONAL I/O PACKET INTO THE DRIVERS
; STOP I/O QUEUE
;
        MOV     U.LASL(R5),(R3)         ;;;INSERT NEXT INTO NEW CURRENT
        MOV     R3,U.LASL(R5)           ;;;INSERT CURRENT AS FIRST
;
        CLR     -2(R0)                  ;;;DEALLOCATE USER TABLE
130$:   DEC     R2                      ;;;NEXT USER
        BGT     126$                    ;;;STILL SOME TO CHECK
        MTPS    #0                      ;;;RESET PRIORITY                       ;MSH012
LACANG: JMP     GETPKT                  ;GO TO GET A PACKET IF WE CAN           ;MSH012
        .PAGE                                                                   ;**-2
        .SBTTL  MISC SERVICE ROUTINES
;
; CONVERT VIRTUAL ADDRESS TO PHYSICAL ADDRESS
; ENTRY
;       R0 - CONTAINS VIRTUAL ADDRESS
;
; EXIT
;       R0 - DESTROYED
;       R1 - PHYSICAL ADDRESS BITS 0-15
;       R2 - PHYSICAL ADDRESS BITS 16-17
;       R3, R4, R5 PRESERVED
;
CVTP:                                                                           ;**-1

        .IF DF  M$$MGE

        MOV     R0,R2                   ;COPY VIRTUAL ADDRESS
        SWAB    R2                      ;EXTRACT APR NUMBER
        .REPT   4
        ASR     R2
        .ENDR
        BIC     #^C<16>,R2
        MOV     UISAR0(R2),R2           ;PAGE ADDRESS FIELD FROM KT11
        MOV     R0,R1                   ;COPY VIRTUAL ADDRESS
        ASL     R1                      ;EXTRACT BLOCK NUMBER
        ASL     R1
        SWAB    R1
        BIC     #^C<177>,R1             ;BLOCK NUMBER
        ADD     R2,R1                   ;BLOCK NUMBER+PAGE ADDRESS BLOCK
        MOV     R1,R2
        SWAB    R2                      ;EXTRACT BITS 16-17
                                                                                ;MSH012
        .IF NDF M$$EXT                                                          ;MSH012
                                                                                ;MSH012
        BIC     #^C<14>,R2              ;PHYSICAL ADDRESS BITS 16-17
                                                                                ;MSH012
        .IFF                                                                    ;MSH012
                                                                                ;MSH012
        BIC     #^C<374>,R2             ;PHYSICAL ADDRESS BITS 16-21            ;MSH012
                                                                                ;MSH012
        .ENDC                                                                   ;MSH012
                                                                                ;MSH012
        .REPT   6                       ;GET BLOCK * 64.
        ASL     R1
        .ENDR
        BIC     #^C<77>,R0
        ADD     R0,R1                   ;PHYSICAL ADDRESS BITS 0-15

        .IFF

        MOV     R0,R1                   ;LOW 16 BITS IS PHYSICAL ADDRESS
        CLR     R2

        .ENDC

        RETURN
        .END                                                                    ;**-2
        .TITLE  LKDRV
        .IDENT  /01.01/
 
;
; COPYRIGHT (C) 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 01.01
;
; B. S. MCCARTHY 22-MAR-78
; B. SCHREIBER   14-SEP-78
;
;
; MODIFIED BY:
;
;       B. S. MCCARTHY 21-NOV-78
;
;       BM002 -- CORRECT SENSE OF 'LS11' BIT
;
; LP11/LS11 LINE PRINTER CONTROLLER DRIVER
; FOR USE WITH COMM-IOP-LP OPTION
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$, HWDDF$, PKTDF$, UCBDF$
        ABODF$                  ; DEFINE TASK ABORT CODES
        HWDDF$                  ; DEFINE HARDWARE REGISTERS
        PKTDF$                  ; DEFINE I/O PACKET OFFSETS
        UCBDF$                  ; DEFINE UCB OFFSETS
        .PAGE

;       LOCAL DATA BIT DEFINITIONS

;       SOME OF THESE DEFINITIONS ARE INCLUDED FOR INFORMATION ONLY
;       AND ARE NOT REFERENCED IN THE DRIVER

;       LINE PRINTER STATUS WORD BIT DEFINITIONS (U.CW2)

LS11   = 100000                 ; LS11 PRINTER (1=YES)
LOWER  =  40000                 ; PRINTER KNOWN TO KMC-11 (1=YES)
ABRT   =  20000                 ; ABORT ISSUED
PWRFLG =  10000                 ; POWER FAIL RECOVERY IN PROGRESS
RQINPR =   4000                 ; REQUEST IN PROGRESS WHEN POWER FAILED
KNOWN  =   2000                 ; PRINTER KNOWN TO KMC-11 (1=YES)

;       LINE PRINTER WIDTH KNOWN TO KMC (LOW BYTE OF U.CW3)

SAVWID = 377                    ; CURRENT SET WIDTH IN LOW BYTE

;       KMC-11/COMM-IOP-LP BIT DEFINITIONS

;       KMC CSR WORD 0 (SEL0)

RUN    = 100000                 ; RUN BIT (1=KMC RUNNING)
MC     =  40000                 ; MASTER CLEAR (SET TO 1 TO CLEAR KMC)
RQI    =    200                 ; REQUEST INPUT (SET TO REQUEST KMC INPUT_
IEO    =     20                 ; OUTPUT INTERRUPT ENABLE (SET TO ENABLE)
IEI    =      1                 ; INPUT INTERRUPT ENABLE (SET TO ENABLE)

;       KMC CSR WORD 1 (SEL2)

PRTNUM =   3400                 ; PRINTER NUMBER MASK
RDYO   =    200                 ; READY OUTPUT (1=READY)
RDYI   =     20                 ; READY INPUT (1=READY)
FNCBSI =      3                 ; BASE IN FUNCTION
FNCCTI =      1                 ; CONTROL IN FUNCTION
FNCBAI =      0                 ; BASE IN FUNCTION

;       KMC CSR WORD 2 (SEL4)

POLCNT = 177400                 ; POLLING COUNT FOR BASE IN FUNCTION

;       KMC CSR WORD 3 (SEL6)

KOPKOE =    200                 ; KILL ON ERROR OPTION (FOR CONTROL IN)
KOPNXT =     40                 ; DON'T EXPAND TABS OPTION
KOPVTL =     20                 ; CONVERT VT TO LF OPTION
KOPDRN =     10                 ; DISCARD RUBOUTS/NULLS OPTION
KOPDNP =      4                 ; DISCARD NON-PRINTING CHARACTERS OPTION
KOPLUC =      2                 ; CONVERT LOWER TO UPPER CASE OPTION
KOPFPR =      1                 ; FAST PRINTER OPTIMIZATIONS OPTION

KMCABF =     10                 ; KILL (ABORT) FINISHED ON CONTROL OUT
KMCNXM =      6                 ; NON-EXISTENT MEMORY (WE CAN'T GET THIS?)
KMCONL =      4                 ; PRINTER ERROR CONDITION CLEAR
KMCOFL =      2                 ; PRINTER ERROR OCCURED (PAPER JAM,ETC.)

BEXT   = 140000                 ; BUS EXTENSION BITS FOR BUFF. ADDR. IN
KILASN =  20000                 ; KILL ASSIGN BIT
KILL   =  10000                 ; KILL BIT

;       BUFFER DESCRIPTOR BITS

LASTBF = 100000                 ; LAST DESCRIPTOR IN LIST

;       LOCAL DATA

LDNAM:  .RAD50  /LPINIT/        ; MICROCODE LOADER TASK NAME
PWFCNT: .WORD   0               ; POWERFAIL INITIALIZATION COUNT
KMCSR2: .WORD   0               ; KMC-11 CSR ADDRESS +2

;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   L$$P11          ;ADDRESS OF UNIT CONTROL BLOCK
        .PAGE
;
; DRIVER DISPATCH TABLE
;

$LPTBL::.WORD   LKINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   LKCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   LKOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   LKPWF           ;POWERFAIL ENTRY POINT
        .PAGE

;+
; **-LKINI-LP11/LS11 LINE PRINTER CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
LKINI:  CALL    $GTPKT          ; GET AN I/O PACKET TO PROCESS
        BCS     25$             ; IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; LINE PRINTER I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.WLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF I/O BUFFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- CARRIAGE CONTROL BYTE.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;
        .PAGE

        MOV     R5,CNTBL(R3)    ; SAVE ADDRESS OF REQUEST UCB

        BIC     #ABRT,U.CW2(R5) ; CLEAR REQUEST ABORTED

        .IF DF  M$$MGE&M$$EXT

        CALL    $STMAP          ; SETUP UNIBUS MAP

        .ENDC                   ; M$$MGE&M$$EXT

;       TEST TO SEE IF KMC KNOW'S ABOUT THIS PRINTER
;       AND ISSUE BASE IN IF NECESSARY

LKIN1:  BIT     #KNOWN,U.CW2(R5) ; PRINTER KNOWN ?
        BNE     10$             ; IF NE YES
        CALL    WTKMC           ; WAIT FOR KMC READY
        MOV     U.KCS6(R5),R0   ; POINT TO LAST REGISTER OF KMC
        MOV     S.CSR(R4),(R0)  ; FILL IN CSR ADDRESS
        MOV     #L$$KPC*256.,-(R0) ; SET UP POLLING COUNT
        CLR     R4              ; SCRATCH FOR UNIT/FUNCTION
        BISB    U.UNIT(R5),R4   ; SET UNIT NUMBER
        SWAB    R4              ; PUT IT IN HIGH BYTE
        BIS     #FNCBSI,R4      ; SET BASE IN FUNCTION
        MOV     R4,-(R0)        ; AND ISSUE FUNCTION
        MOV     U.SCB(R5),R4    ; RESTORE SCB ADDRESS
        BIS     #KNOWN,U.CW2(R5) ; SET PRINTER KNOWN

;       TEST TO SEE IF PRINTER HAS BEEN INITIALIZED FOR CORRECT WIDTH
;       (CURRENT SET WIDTH IN U.CW3)

10$:    CMPB    U.CW4(R5),U.CW3(R5) ; BUF SIZE CURRENT WIDTH ?
        BEQ     20$             ; IF EQ YES, CONTROL IN WAS ISSUED
        CALL    WTKMC           ; WAIT FOR KMC READY
        MOV     U.KCS6(R5),R0   ; POINT TO END OF REGISTERS.
        MOV     #KOPDRN,R4      ; SET FUNCTION TO DISCARD RUBOUTS/NULLS
        BIT     #LOWER,U.CW2(R5) ; LOWER CASE PRINTER
        BNE     11$             ; IF NE YES, OK
        BIS     #KOPLUC,R4      ; SET LOWER TO UPPER CASE SUPPORT
11$:                            ; REF LABEL
        .IF DF  L$$11R
        BIT     #LS11,U.CW2(R5) ; FAST PRINTER ?
        BNE     12$             ; IF NE NO                              ;BM002
        BIS     #KOPFPR,R4      ; SET FAST PRINTER OPTIMIZATIONS        ;**-1
        .ENDC                   ; DF L$$11R

12$:    MOV     R4,(R0)         ; SET OPTIONS WORD
        MOV     U.CW4(R5),-(R0) ; SET PRINTER WIDTH
        CLR     R4              ; SCRATCH FOR UNIT NUMBER/FUNCTION
        BISB    U.UNIT(R5),R4   ; SET IN UNIT NUMBER
        SWAB    R4              ; PUT IT IN HIGH BYTE
        BIS     #FNCCTI,R4      ; SET CONTROL IN FUNCTION
        MOV     R4,-(R0)        ; ISSUE FUNCTION
        MOV     U.SCB(R5),R4    ; RESTORE SCB ADDRESS
        MOVB    U.CW4(R5),U.CW3(R5) ; SET PRINTER SIZE SET
        .PAGE

;       BUILD ADDRESS BUFFER IN I/O PACKET AND ISSUE REQUEST

20$:                            ; REFERENCE LABEL

        .IF DF  M$$MGE & M$$EXT

        MOV     R1,-(SP)        ; SAVE I/O PACKET ADDRESS
        CALL    $MPUBM          ; MAP UNIBUS TO MEMORY
        MOV     (SP)+,R1        ; RESTORE I/O PACKET ADDRESS

        .ENDC                   ; M$$MGE & M$$EXT

        CALL    WTKMC           ; WAIT FOR KMC READY
        MOV     U.BUF+2(R5),I.PRM+10(R1) ; SET LOW PART OF BUFFER ADDR.
        MOV     U.CNT(R5),I.PRM+12(R1) ; AND LENGTH OF BUFFER
        MOV     U.BUF(R5),R0    ; GET HIGH TWO BITS OF ADDR.
        SWAB    R0              ; PUT IN HIGH BYTE
        ASR     R0              ; SHIFT INTO BITS 10/11
        ASR     R0              ;
        BIS     #LASTBF,R0      ; SET FOR LAST FUNCTION
        BISB    I.PRM+6(R1),R0  ; SET VFC BITS IN
        MOV     R0,I.PRM+14(R1) ; STORE INTO BUFF ADDR DESC.

;       BUFFER DESCRIPTOR BUILT IN WORDS 4,5,6 OF PARAM LIST

        MOV     U.KCS6(R5),R0   ; POINT TO LAST ADDRESS OF KMC
        CLR     (R0)            ; CLEAR OUT KILL BITS
        MOV     R1,R4           ; COPY PACKET ADDRESS
        ADD     #I.PRM+10,R4    ; POINT TO BUFFER DESCRIPTOR
        MOV     R4,-(R0)        ; FILL IN BUFFER ADDRESS
        CLR     R4              ; SCRATCH FOR UNIT NUMBER
        BISB    U.UNIT(R5),R4   ; SET IN UNIT NUMBER
        SWAB    R4              ; PUT IT IN HIGH BYTE
        MOV     R4,-(R0)        ; AND START TRANSFER
25$:    RETURN                  ; EXIT FROM DRIVER
        .PAGE
;
;       POWERFAIL PROCESSING MARKS A DEVICE AS UNKNOWN AND OF UNKNOWN
;       WIDTH. THE CONTROLLER IS MARKED AS BUSY EVEN IF IT IS IDLE, TO
;       PREVENT EARLY DEQUEUEING OF REQUESTS. A TIMEOUT IS FORCED IN 5
;       SECONDS, AND THE MICROCODE LOADER (LPINIT) IS REQUESTED. IF
;       LPINIT IS NOT INSTALLED AN ERROR MESSAGE IS ISSUED. WHEN
;       THE TIMEOUT OCCURS WE CHECK TO SEE IF THE KMC IS RUNNING.
;

LKPWF:  BIS     #PWRFLG,U.CW2(R5) ; SET POWERFAIL IN PROGRESS
        TST     CNTBL(R3)       ; REQUEST IN PROGRESS
        BEQ     LKPWF0          ; IF EQ NO
        BIS     #RQINPR,U.CW2(R5) ; SET REQUEST IN PROGRESS FLAG
LKPWF0: BIC     #KNOWN,U.CW2(R5) ; SET PRINTER UNKNOWN
        CLRB    U.CW3(R5)       ; AND SET WIDTH TO 0 (FORCING ZERO)
        BISB    #US.KPF!US.BSY,U.STS(R5) ; SET POWERFAIL INTERLOCK
        MOVB    #1,S.STS(R4)    ; FAKE CONTROLLER BUSY
        MOVB    #5,S.CTM(R4)    ; FORCE 5 SECOND TIMEOUT
        DEC     PWFCNT          ; IS THIS FIRST PRINTER ?
        BLT     30$             ; IF LT YES, INVOKE REST OF POWERFAIL
        RETURN                  ; ELSE EXIT FROM DRIVER

30$:    MOV     #L$$P11-1,PWFCNT ; SET UP COUNT OF REST OF PRINTERS

        MOV     U.KCSR(R5),R0   ; GET CSR ADDRESS OF PRINTER
        MOV     #MC,(R0)+       ; MASTER CLEAR KMC-11
        MOV     R0,KMCSR2       ; SAVE ADDRESS OF SECOND CSR

;       REQUEST MICROCODE LOADER IF INSTALLED

        MOV     #LDNAM,R3       ; GET NAME OF MICROCODE LOADER
        CALL    $SRSTD          ; LOOK IT UP
        BCS     40$             ; IF CS NOT THERE, ISSUE MESSAGE
        CALLR   $EXRQN          ; REQUEST LOADER

40$:    MOV     #T.NKLF,R0      ; MESSAGE NUM "MICROCODE LOADER NOT ..."
        CALLR   $DVMSG          ; PRINT MESSAGE AND EXIT
        .PAGE
;+
; **-$LPINT-LP11/LS11 LINE PRINTER CONTROLLER INTERUPTS
;       (INTERRRUPTS ARE FROM COMM IOP, NOT PRINTER)
;
;       INPUT INTERRUPTS SHOULD NOT OCCUR, AND ARE THEREFORE
;       DISMISSED IMMEDIATELY.
;
;       OUTPUT INTERRUPTS ARE CAUSED FOUR WAYS:
;
;       1) - BUFFER ADDRESS OUT - INDICATES SUCCESSFUL COMPLETION
;            OF AN OUTPUT OPERATION
;       2) - CONTROL OUT - KMCABF SET IN KCS3 - ABORT COMPLETED
;       3) - CONTROL OUT - KMCONL SET IN KCS3 - PREVIOUS ERROR CLEARED
;       4) - CONTROL OUT - OTHER - ERROR CONDITION ON PRINTER
;-

$LPINP::                        ; IGNORE INPUT INTERRUPTS
                                ; ($LPINP IS NEEDED TO MAKE DRIVER LOAD
                                ; CORRECTLY)
        .IF NDF L$$DRV ! M$$MGE ! LD$LP

        RTI

        .IFF

        RETURN

        .ENDC
        .PAGE
$LPOUT::                        ;;; REF LABEL

        .IF NDF L$$DRV ! M$$MGE ! LD$LP

        JSR     R5,$INTSV       ;;; SINCE THERE'S ONE KMC VECTOR,
        .WORD   ^C<PR5>&PR7     ;;; NORMAL UCB CALC. DOESN'T WORK

        .ENDC

        MOV     @KMCSR2,R4      ;;; GET PRINTER NUMBER FROM KMC
        BIC     #^C<PRTNUM>,R4  ;;; STRIP OFF JUNK
        SWAB    R4              ;;; INTO LOW HALF OF REG
        ASL     R4              ;;; AND CREATE WORD INDEX
        MOV     CNTBL(R4),R5    ;;; GET UCB ADDRESS
        BEQ     90$             ;;; IF EQ DISMISS SPURIOUS INTERRUPT
        MOV     U.SCB(R5),R4    ;;; GET SCB ADDRESS
        CALL    $FORK           ;;; CREATE A SYSTEM PROCESS
        MOV     KMCSR2,R0       ; GET ADDRESS (KMCCSR+2)
        MOVB    4(R0),R1        ; CAPTURE PRINTER ERROR CODE BYTE
        MOV     (R0),R0         ; AND INTERRUPT CAUSE

        BIC     #RDYO,@KMCSR2   ; RELEASE KMC
        BIT     #1,R0           ; WAS IT A CONTROL OUT ?

        BNE     70$             ; IF NE YES
        MOV     #IS.SUC,R0      ; SET SUCCESS STATUS
60$:    MOV     S.PKT(R4),R1    ; GET I/O PACKET ADDRESS
        MOV     I.PRM+4(R1),R1  ; GET REQUESTED BYTE COUNT
        CALL    $IODON          ; FINISH I/O OPERATION
        MOV     U.SCB(R5),R4    ; GET SCB ADDRESS
        MOVB    S.CON(R4),R4    ; AND CONTROLLER INDEX
        CLR     CNTBL(R4)       ; CLEAR UCB TABLE ENTRY
        JMP     LKINI           ; AND START DRIVER AGAIN

70$:    CMPB    #KMCABF,R1      ; ABORT FINISHED ?
        BNE     80$             ; IF EQ NO
75$:    MOV     #IE.ABO,R0      ; SET ABORT STATUS
        BR      60$             ; AND OUT NORMALLY

80$:    CMPB    #KMCONL,R1      ; PRINTER BACK NOW ?
        BNE     LKOUT           ; IF EQ NO, MUST BE ERROR
        RETURN                  ; ELSE YES, THAT'S NICE.

90$:    BIC     #RDYO,@KMCSR2   ; RELEASE KMC
        RETURN                  ; AND EXIT FROM DRIVER
        .PAGE
;
;       TIMEOUT PROCESSING IS ENTERED FOR ANY OF THE FOLLOWING
;
;       1. 5 SECONDS AFTER POWER FAIL RECOVERY (ALSO LOAD,BOOT)
;          THE DRIVER IS ENTERED AND TESTS TO SEE IF RECOVERY
;          IS COMPLETE. IF IT IS, THE DRIVER STARTS OR RESTARTS
;          AN OPERATION AS NECESSARY. IF NOT, THE TIMEOUT COUNT
;          IS RESET TO 5 AND THE DRIVER EXITS.
;
;       2. FOLLOWING AN IO.KIL, IF THE REQUEST IS NOT COMPLETED
;          NORMALLY BEFORE THE NEXT TIMEOUT CHECK, THEN A HARDWARE
;          ABORT IS ISSUED HERE.
;
;       3. AFTER A DEVICE ERROR, THE TIMEOUT SECTION TAKES CARE OF
;          ISSUING NOT READY MESSAGES.
;

LKOUT:  MTPS    #0              ;;;ALLOW INTERRUPTS
        BIT     #PWRFLG,U.CW2(R5) ; POWERFAIL RECOVERY IN PROGRESS ?
        BEQ     99$             ; IF EQ NO
        BITB    #US.KPF,U.STS(R5) ; KMC RECOVERY COMPLETE ?
        BEQ     93$             ; IF EQ YES
        MOVB    #5,S.CTM(R4)    ; BETTER LUCK NEXT TIME
        RETURN                  ; (IN 5 SECONDS OR SO)
93$:    BIC     #PWRFLG,U.CW2(R5) ; CLEAR POWERFAIL FLAG
        BIT     #ABRT,U.CW2(R5) ; ABORT REQUESTED ?
        BNE     75$             ; IF EQ YES, BUT REQUEST IS ALREADY
                                ; ABORTED (AND HOW) DUE TO KMC FAILURE
        BIT     #RQINPR,U.CW2(R5) ; REQUEST IN PROGRESS WHEN WE WENT DOWN ?
        BEQ     96$             ; IF NE NO
        BIC     #RQINPR,U.CW2(R5) ; CLEAR REQUEST IN PROGRESS
        MOV     S.PKT(R4),R1    ; RESTORE I/O PACKET ADDRESS
        JMP     LKIN1           ; AND RESTART REQUEST
96$:    CLRB    S.STS(R4)       ; CLEAR FAKE CONTROLLER BUSY
        BICB    #US.BSY,U.STS(R5) ; AND DECLARE UNIT IDLE
        JMP     LKINI           ; TRY TO ACTIVATE CONTROLLER
99$:    BIT     #ABRT,U.CW2(R5) ; ABORT REQUESTED ?
        BEQ     100$            ; IF NE NO

        CALL    WTKMC           ; WAIT TILL IT'S READY
        MOV     U.KCS6(R5),R0   ; POINT TO LAST CSR
        MOV     #KILL,(R0)      ; SET KILL FUNCTION
        CLR     -(R0)           ; NO BUFF ADDR
        CLR     R1              ; SCRATCH FOR PRINTER NUMBER
        BISB    U.UNIT(R5),R1   ; SET IN UNIT NUMBER
        SWAB    R1              ; PUT IT IN HIGH BYTE
        MOV     R1,-(R0)        ; FILL IN PRINTER NUMBER AND START KILL
        RETURN                  ; WAIT TIL IT'S ALL OVER
        .PAGE

;       PROCESS DEVICE NOT READY MESSAGES

100$:                           ; REF LABEL
        .IF DF  T$$KMG

        MOV     #T.NDNR,R0      ; SET FOR DEVICE NOT READY MESSAGE

        .IFTF                   ; DF T$$KMG

        MOVB    #1,S.CTM(R4)    ; SET TIMEOUT FOR 1 SECOND

        .IFT                    ; DF T$$KMG

        DECB    S.STS(R4)       ; TIME TO OUTPUT MESSAGE ?
        BNE     120$            ; IF NE NO

        .IF NDF L$$PTO

        MOVB    #15.,S.STS(R4)  ; SET TO OUTPUT NEXT MESSAGE IN
                                ; 15. SECONDS

        .IFF                    ; NDF L$$PTO

        MOVB    #L$$PTO,S.STS(R4) ; SET TO OUTPUT NEXT MESSAGE IN
                                  ; L$$PTO SECONDS
        BNE     110$            ; IF NE LP NOT READY MESSAGES ENABLED
        INCB    S.STS(R4)       ; LP NOT READY MESSAGE NOT WANTED, SO
        BR      120$            ; RE-BUSY CONTROLLER

        .ENDC                   ; NDF L$$PTO

110$:   CALLR   $DVMSG          ; OUTPUT MESSAGE

        .ENDC                   ; DF T$$KMG

120$:   RETURN                  ; OUT !

        .DSABL LSB
        .PAGE
;
; CANCEL I/O OPERATION-FORCE I/O TO COMPLETE IF DEVICE IS NOT READY
;

LKCAN:  CMP     R1,I.TCB(R0)    ;;; REQUEST FOR CURRENT TASK?
        BNE     10$             ;;; IF NE NO
        BIS     #ABRT,U.CW2(R5) ;;; SET FOR ABORT IF DEVICE NOT READY
        MOVB    #1,S.CTM(R4)    ;;; FORCE TIMEOUT IN 1 SECOND (OR LESS)
10$:    RETURN                  ;;;

;
;       SUBROUTINE TO WAIT FOR THE KMC TO BE READY
;
;       INPUTS:
;
;               R5 = UCB ADDRESS OF THE PRINTER
;
;       R0 IS DESTROYED.

WTKMC:  MOV     U.KCSR(R5),R0   ; GET KMC CSR ADDRESS
        BIS     #RQI,(R0)       ; REQUEST KMC INPUT
10$:    TST     (R0)            ; IS THE KMC-11 RUNNING ?
        BPL     20$             ; IF IT CAN'T TAKE A JOKE, POWERFAIL
        BIT     #RDYI,@KMCSR2   ; READY BIT SET ?
        BEQ     10$             ; IF EQ NO, WAIT SOME MORE
        BIC     #RQI,(R0)       ; CLEAR REQUEST INPUT
        RETURN                  ; YES, BO BACK
20$:    BIS     #PWRFLG!RQINPR,U.CW2(R5) ; SET POWERFAIL IN PROGRESS
        TST     (SP)+           ; WE WON'T BE RETURNING TO CALLER
        JMP     LKPWF0          ; FINISH IN COMMON CODE

        .END
        .TITLE  LOADR
        .IDENT  /11/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 11
;
; D. N. CUTLER 28-OCT-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 12-MAY-77
;
;               TM083 -- CORRECT BUG WHICH CAN CRASH MAPPED SYSTEMS
;                       WITHOUT PLAS WHEN A READ OPERATION FAILS.
;
;       T. J. MILLER 19-MAY-77
;
;               TM084 -- ADDITIONALLY PASS UCB ADDRESS TO TKTN ON
;                       CHECKPOINT WRITE FAILURE.
;
;       T. J. MILLER 29-SEP-77
;
;               TM112 -- CLEAR RECEIVE BY REFERENCE CONTROL BLOCK ADDRESS ON
;                       LOAD FAILURES.
;
;       CHUCK SPITZ 30-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES AND HANDLE ALL
;                       ASTS FROM TCB. (GET RID OF T2.BFX, ALSO)
;
;       CHUCK SPITZ     30-MAR-79
;               CS045 -- ADD CHECKING OF THE LUT AND WINDOWS ON
;                       INITIAL TASK LOAD
;
;       CHUCK SPITZ     17-MAY-79
;               CS053 -- DON'T CALL SCHDR IF INVALID TASK IMAGE
;
; TASK TO LOAD AND CHECKPOINT ALL NONRESIDENT TASKS
;
; MACRO LIBRARY CALLS
;


        .IF NDF R$$11S

        .MCALL  ABODF$,HDRDF$,HWDDF$,PCBDF$,TCBDF$
        .MCALL  DIR$,WSIG$S
        ABODF$                  ;DEFINE TASK ABORT CODES
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;
; LOCAL DATA
;
; READ/WRITE I/O DPB
;

LDRDP:  .BYTE   3,12.           ;DIC, DPB SIZE
LDRFC:  .BLKW   1               ;FUNCTION CODE
        .BYTE   1               ;LUN 1
        .BLKB   1               ;UNUSED BYTE
        .BYTE   1               ;EFN 1
        .BLKB   1               ;UNUSED BYTE
        .WORD   IOSB            ;I/O STATUS DOUBLEWORD ADDRESS
        .WORD   0               ;NO AST SERVICE ROUTINE
LDRBF:  .BLKW   1               ;BUFFER ADDRESS
LDRLN:  .BLKW   1               ;BUFFER LENGTH
LDRTK:  .BLKW   1               ;POINTER TO REQUEST TASK TCB
LDRBK:  .BLKW   2               ;LBN OF I/O TRANSFER
IOSB:   .BLKW   2               ;I/O STATUS DOUBLEWORD

;+
; **-$LOADR-NONRESIDENT TASK LOADER
;
; THIS TASK IS CALLED UPON TO:
;
;       1-READ A NONRESIDENT TASK INTO MEMORY AND INITIALIZE IT FOR EXECUTION.
;       2-READ A PREVIOUSLY CHECKPOINTED TASK BACK INTO MEMORY AND RESTART ITS
;               EXECUTION.
;       3-WRITE A CHECKPOINT IMAGE OF A RUNNING TASK AND FREE ITS PARTITION.
;
; INPUT IS RECEIVED VIA THE LOADER QUEUE WHICH CONTAINS A PRIORITY ORDERED
; LIST OF TASK TCB'S. THE FIRST (HIGHEST PRIORITY) TCB IS REMOVED FROM THE
; QUEUE, PROCESSED, AND THEN THE LOADER SELECTS THE NEXT TCB FROM THE LIST.
;-

$LOADR::CALL    $SWSTK,40$      ;SWITCH TO SYSTEM STATE
        CLR     LDRTK           ;INITIALLY CLEAR CURRENT TCB POINTER
        MOV     $TKTCB,R0       ;PICK UP LOADER TCB ADDRESS
        ADD     #T.RCVL,R0      ;POINT TO RECEIVE LISTHEAD
        CALL    $QRMVF          ;REMOVE ENTRY FROM QUEUE
        BCC     10$             ;IF CC GOT ONE
        CALLR   $STPCT          ;STOP FOR NOW
10$:    MOV     R1,LDRTK        ;SAVE TCB ADDRESS


        .IF DF  C$$CKP&D$$ISK&M$$MGE

        BIT     #TS.OUT,T.STAT(R1) ;CHECKPOINT WRITE REQUEST?
        BNE     30$             ;IF NE NO
        MOV     T.PCB(R1),R2    ;GET ADDRESS OF TASK PCB
        MOV     P.HDR(R2),R3    ;GET ADDRESS OF TASK HEADER
        MOV     P.REL(R2),KISAR6 ;SETUP TO ACCESS TASK PARTITION


        .IF DF  P$$LAS

        ADD     T.OFF(R1),KISAR6 ;ADD IN OFFSET TO TASK HEADER

        .ENDC


        MOV     #140000,R2      ;SET ADDRESS BIAS OF TASK PARTITION
        MOV     H.WND(R3),R4    ;POINT TO NUMBER OF WINDOW BLOCKS
        TST     W.BLVR+2(R4)    ;TASK MAPPED TO EXEC?
        BNE     15$             ;IF NE YES
        MOV     H.DSW(R2),H.DSW(R3) ;COPY DSW TO REAL TASK HEADER
15$:    MOV     H.HDLN(R3),R4   ;GET LENGTH OF HEADER IN BYTES
        ASR     R4              ;CONVERT TO WORD COUNT
20$:    MOV     (R3)+,(R2)+     ;MOVE HEADER INTO TASK PARTITION
        DEC     R4              ;ANY MORE WORDS TO MOVE?
        BGT     20$             ;IF GT YES

        .ENDC


30$:    RETURN                  ;RETURN TO TASK STATE
40$:    MOV     LDRTK,R5        ;RETRIEVE TCB ADDRESS
        BEQ     $LOADR          ;IF EQ THERE WAS NONE, TRY AGAIN
        MOV     T.PCB(R5),R4    ;GET ADDRESS OF TASK PCB
        MOV     R5,R3           ;CALCULATE ADDRESS OF FIRST TASK STATUS WORD
        ADD     #T.STAT,R3      ;
        MOV     #IO.RLB,LDRFC   ;ASSUME READ FUNCTION


        .IF DF  C$$CKP&D$$ISK

        BIT     #TS.OUT,(R3)    ;CHECKPOINT WRITE REQUEST?
        BNE     50$             ;IF NE NO
        MOV     #IO.WLB,LDRFC   ;SET WRITE FUNCTION

        .ENDC


50$:    MOV     #LDRBF,R0       ;POINT TO DPB BUFFER ADDRESS


        .IF DF  M$$MGE

        MOV     #140000,(R0)+   ;SET APR6 LOAD ADDRESS BIAS

        .IFF

        MOV     P.REL(R4),(R0)+ ;SET PARTITION LOAD ADDRESS
        MOV     P.SIZE(R4),(R0) ;SET SIZE OF TRANSFER IN BYTES

        .IFT


        .IF DF  P$$LAS

        MOV     P.SIZE(R4),-(SP) ;PUSH SIZE OF TRANSFER
        CLR     R2              ;INITIALIZE MULTI-TRANSFER COUNT
        MOV     #6,R1           ;SET COUNT FOR SIX SHIFTS
        BIT     #TS.CKP,(R3)    ;CHECKPOINT REQUEST?
        BNE     55$             ;IF NE YES
        SUB     T.OFF(R5),(SP)  ;ELSE REDUCE TASK SIZE BY OFFSET
55$:    ASL     (SP)            ;CONVERT TO DOUBLE PRECISION BYTE COUNT
        ROL     R2              ;
        DEC     R1              ;DONE YET?
        BGT     55$             ;IF GT NO

        .IFF

        MOV     P.SIZE(R4),(R0) ;PICK UP TRANSFER SIZE
        SWAB    (R0)            ;CONVERT TO BYTES
        RORB    (R0)            ;
        ROR     (R0)            ;
        ROR     (R0)            ;

        .ENDC


        .ENDC


        CMP     (R0)+,(R0)+     ;POINT TO LBN
        MOVB    T.LBN(R5),(R0)+ ;INSERT HIGH PART OF LBN
        CLRB    (R0)+           ;
        MOV     T.LBN+1(R5),(R0) ;INSERT LOW PART OF LBN
        MOV     T.LDV(R5),-(SP) ;TENTATIVELY PUSH LOAD DEVICE UCB


        .IF DF  C$$CKP&D$$ISK

        BIT     #TS.CKP,(R3)    ;CHECKPOINT REQUEST?
        BEQ     60$             ;IF EQ NO


        .IF DF  D$$YNC

        BIT     #T2.CAF,T.ST2(R5) ;DYNAMIC SPACE ALLOCATION FAILURE?
        BNE     56$             ;IF NE YES
        MOV     T.CPCB(R5),R1   ;POINT TO CHECKPOINT PCB
        MOV     P.REL(R1),(R0)  ;SET RELATIVE BLOCK NUMBER IN FILE
        MOV     P.MAIN(R1),R1   ;POINT TO CHECKPOINT FILE DESCR PCB
        TST     (R1)+           ;POINT TO UCB ADDRESS
        MOV     (R1)+,(SP)      ;SET UCB ADDRESS
        MOV     (R1)+,-(R0)     ;SET HIGH PART OF LBN
        ADD     (R1),2(R0)      ;ADD IN LOW PART OF LBN
        ADC     (R0)            ;ADD CARRY
        BR      60$             ;
56$:                            ;REF LABEL

        .ENDC


        MOV     T.MXSZ(R5),R1   ;PICK UP PARTITION SIZE
        ADD     #7,R1           ;ROUND UP TO NEXT 512. BLOCK
        ROR     R1              ;CONVERT TO 512. WORD BLOCKS
        ASR     R1              ;
        ASR     R1              ;
        SUB     R1,(R0)         ;CALCULATE STARTING LBN OF CKP AREA
        SBC     -(R0)           ;

        .ENDC


60$:    MOV     $HEADR,R1       ;GET ADDRESS OF LOADER HEADER
        MOV     (SP)+,H.LUN(R1) ;ASSIGN LUN 1 TO LOAD DEVICE


        .IF DF  M$$MGE

        MTPS    #PR7            ;;;LOCK OUT INTERRUPTS


        .IF DF  P$$LAS

        MOV     P.REL(R4),R1    ;;;PICK UP RELOCATION BIAS OF PARTITION
        BIT     #TS.CKP,(R3)    ;;;CHECKPOINT REQUEST?
        BNE     65$             ;;;IF NE YES
        ADD     T.OFF(R5),R1    ;;;ELSE ADD IN OFFSET TO TASK IMAGE
65$:    MOV     #177000,LDRLN   ;;;SET TENTATIVE LENGTH OF TRANSFER
        SUB     #177000,(SP)    ;;;REDUCE ACTUAL COUNT TO TRANSFER
        SBC     R2              ;;;
        BGE     70$             ;;;IF GE FULL TRANSFER
        ADD     (SP),LDRLN      ;;;ELSE REDUCE SIZE OF TRANSFER
        BEQ     80$             ;;;IF EQ LAST TRANSFER DID IT
70$:    MOV     R1,UISAR6       ;;;SET APR BIAS FOR TRANSFER

        .IFF

70$:    MOV     P.REL(R4),UISAR6 ;;;SET RELOCATION BIAS FOR I/O TRANSFER

        .ENDC


        .IFF

70$:                            ;;;REFERENCE LABEL

        .IFTF

        DIR$    #LDRDP          ;;;REQUEST I/O TRANSFER


        .IF DF  P$$LAS&M$$MGE

        BCS     75$             ;;;IF CS LOAD FAILURE (NO POOL)
        ADD     #1770,R1        ;;;UPDATE APR BIAS
        ADD     #177,LDRBK+2    ;;;UPDATE BLOCK NUMBER
        ADC     LDRBK           ;;;
        TST     R2              ;;;WAS IT THE LAST TRANSFER?
        BLT     80$             ;;;IF LT YES
        TSTB    IOSB            ;;;WAS TRANSFER SUCCESSFUL?
        BPL     65$             ;;;IF PL YES
        BR      80$             ;;;BRANCH ON ERROR

        .IFF

        BCC     80$             ;;;IF CC REQUEST WAS QUEUED

        .IFTF

75$:    WSIG$S                  ;;;WAIT FOR SIGNIFICANT EVENT
        BR      70$             ;;;RETRY I/O
80$:                            ;;;REF LABEL

        .IFT

        TST     (SP)+           ;;;POP LOW-ORDER TRANSFER COUNT

        .ENDC


        .IFT

        CLRB    PS              ;;;ALLOW INTERRUPTS

        .ENDC


84$:    CALL    $SWSTK,$LOADR   ;SWITCH TO SYSTEM STATE


        .IF DF  C$$CKP&D$$ISK

        BIT     #TS.OUT,(R3)    ;TASK IN MEMORY?
        BNE     110$            ;IF NE NO
        TSTB    IOSB            ;SUCCESSFUL WRITE?
        BMI     90$             ;IF MI NO
        BIS     #TS.OUT,(R3)    ;SET TASK OUT OF MEMORY


        .IF DF  M$$MGE

        MOV     P.HDR(R4),R0    ;GET ADDRESS OF TASK HEADER
        MOV     H.HDLN(R0),R1   ;GET LENGTH OF HEADER IN BYTES
        CALL    $DEACB          ;DEALLOCATE HEADER

        .ENDC


        .IF DF  E$$XPR

        BIT     #PS.SYS,P.STAT(R4) ;SYSTEM CONTROLLED PARTITION?
        BEQ     85$             ;IF EQ NO
        MOV     P.SWSZ(R4),P.SIZE(R4) ;SET SIZE FROM SWAP SIZE
85$:                            ;REF LABEL

        .ENDC


        MOV     P.MAIN(R4),R0   ;CALCULATE ADDRESS OF WAIT QUEUE LISTHEAD
        ADD     #P.WAIT,R0      ;
        MOV     R5,R1           ;SET TCB ADDRESS
        CALL    $QINSP          ;INSERT TASK BACK IN PARTITION WAIT QUEUE
        MOV     R5,R0           ;SET TCB ADDRESS
        CALLR   $RLPAR          ;RELEASE PARTITION
90$:    MOV     #T.NCWF,R0      ;SET CHECKPOINT WRITE FAILURE


        .IF DF  D$$YNC

        MOV     $HEADR,R4       ;PICK UP PTR TO OWN HEADER
        MOV     H.LUN(R4),R4    ;PICK UP UCB ADDRESS OF WRITE ERROR

        .ENDC


        CALL    $DVMSG          ;OUTPUT MESSAGE
        BIC     #TS.CKP,T.STAT(R5) ;CLEAR CHECKPOINT FLAG


        .IF DF  D$$YNC

95$:    BIT     #T2.CAF,T.ST2(R5) ;SPACE ALLOCATED IN CHECKPOINT FILE?
        BNE     97$             ;IF NE NO
        SAVNR                   ;SAVE R4 AND R5
        MOV     T.CPCB(R5),R0   ;PICK UP ADDRESS OF CHECKPOINT PCB
        MOV     P.MAIN(R0),R2   ;POINT TO MAIN PCB
        MOV     R2,R4           ;COPY POINTER TO MAIN PCB
        MOV     P.PRI(R2),R5    ;SAVE UCB ADDRESS
96$:    MOV     R2,R1           ;COPY LAST SUB PCB ADDRESS
        MOV     P.SUB(R1),R2    ;POINT TO NEXT SUB PCB
        CMP     R2,R0           ;POINTING TO PCB TO UNLINK?
        BNE     96$             ;IF NE NO
        MOV     P.SUB(R0),P.SUB(R1) ;UNLINK CHECKPOINT PCB
        MOV     #P.SIZE+2,R1    ;SET SIZE TO DEALLOCATE
        CALL    $DEACB          ;DEALLOCATE CHECKPOINT PCB
        TST     P.REL(R4)       ;CHECKPOINT FILE STILL IN USE?
        BEQ     97$             ;IF EQ YES
        TST     P.SUB(R4)       ;CHECKPOINT FILE EMPTY?
        BNE     97$             ;IF NE NO
        MOV     #20,R0          ;SET TKTN CODE
        CALL    $DVMSG          ;QUEUE MESSAGE TO TKTN
97$:                            ;REF LABEL

        .ENDC


        RETURN                  ;

        .ENDC


110$:                           ;REF LABEL


        .IF DF  M$$MGE

        MOV     P.REL(R4),KISAR6 ;MAP TO TASK PARTITION


        .IF DF  P$$LAS

        ADD     T.OFF(R5),KISAR6 ;ADD IN OFFSET TO TASK HEADER

        .ENDC


        MOV     140000+H.HDLN,R1 ;ASSUME SUCCESSFUL READ
        CMPB    #17,140000+H.IPS ;VALID TASK IMAGE?
        BNE     115$            ;IF NE NO TREAT AS UNSUCCESSFUL READ
        TSTB    IOSB            ;SUCCESSFUL READ?
        BPL     120$            ;IF PL YES
115$:   MOV     #H.NLUN+2+W.BLGH+2,R1 ;SET LENGTH OF MINIMUM HEADER
        CLR     140000+H.NLUN   ;CLEAR NUMBER OF LUNS WORD
        MOVB    #-1,IOSB        ;INDICATE READ FAILURE                  ; CS053
120$:   MOV     R1,2(SP)        ;SAVE LENGTH OF HEADER
        CALL    $ALOCB          ;ALLOCATE A BLOCK FOR TASK HEADER
        BCC     130$            ;IF CC BLOCK ALLOCATED
        MOV     @$HEADR,R0      ;GET SAVED STACK POINTER
        MOV     #84$,4(R0)      ;ALTER RETURN ADDRESS
        CALLR   $TKWSE          ;WAITFOR SIGNIFICANT EVENT
130$:   MOV     R0,P.HDR(R4)    ;SAVE ADDRESS OF NEW HEADER
        MOV     2(SP),R1        ;RETRIEVE LENGTH OF HEADER IN BYTES
        MOV     #140000,R2      ;SET APR6 ADDRESS BIAS
        MOV     R1,H.HDLN(R2)   ;SET LENGTH OF HEADER
        MOV     R0,R3           ;CALCULATE HEADER GUARD WORD POINTER
        TST     -(R3)           ;
        MOV     R3,H.GARD(R2)   ;
        ADD     R1,H.GARD(R2)   ;
        MOV     R3,H.WND(R2)    ;CALCULATE NUMBER OF WINDOW BLOCKS PTR
        MOV     H.NLUN(R2),R3   ;CALCULATE NUMBER OF LUN WORDS
        ASL     R3              ;
        ASL     R3              ;
        ADD     #H.NLUN+4,R3    ;FINISH CALCULATION
        ADD     R3,H.WND(R2)    ;
        ASR     R1              ;CONVERT LENGTH TO WORDS
140$:   MOV     (R2)+,(R0)+     ;MOVE TASK HEADER TO CORE BLOCK
        DEC     R1              ;ANY MORE WORDS TO MOVE?
        BGT     140$            ;IF GT YES
        MOV     R5,R3           ;RESET R3 TO ADDRESS OF FIRST TASK STATUS
        ADD     #T.STAT,R3      ;WORD

        .ENDC


        BIC     #TS.OUT,(R3)+   ;CLEAR TASK OUT OF MEMORY
        MOV     P.HDR(R4),R0    ;GET ADDRESS OF TASK HEADER
        TSTB    IOSB            ;SUCCESSFUL READ?                       ; CS045
        BMI     144$            ;IF MI NO                               ; CS045
        BIT     #TS.CKP,-2(R3)  ;CHECKPOINT READ?                       ; CS045
        BNE     144$            ;IF NE YES, DON'T TOUCH LUT             ; CS045
        MOV     R0,-(SP)        ;SAVE REGISTERS                         ; CS045
        MOV     R3,-(SP)        ;                                       ; CS045
        CALL    SCHDR           ;SCAN LUT AND WINDOWS                   ; CS045
        MOV     (SP)+,R3        ;RESTORE REGISTERS                      ; CS045
        MOV     (SP)+,R0        ;                                       ; CS045
144$:                           ;REF LABEL                              ; CS045


        .IF DF  S$$WPC

        MOVB    #S$$WPR,H.SPRI(R0) ;INITIALIZE SWAPPING PRIORITY

        .ENDC


        .IF DF  M$$MGE

        MOV     H.WND(R0),R1    ;POINT TO NUMBER OF WINDOW BLOCKS
        CALL    $MAPTK          ;MAP FIRST TASK ADDRESS WINDOW

        .ENDC


        CMPB    #17,H.IPS(R0)   ;VALID TASK IMAGE?
        BNE     180$            ;IF NE NO TREAT AS UNSUCCESSFUL READ
        TSTB    IOSB            ;READ ERROR?
        BMI     180$            ;IF MI YES


        .IF DF  C$$CKP&D$$ISK

        BIT     #TS.CKP,-2(R3)  ;CHECKPOINT READ?
        BNE     150$            ;IF NE YES

        .IFTF


        .IF DF  P$$LAS&M$$MGE

        MOV     H.WND(R0),R0    ;POINT TO NUMBER OF WINDOW BLOCKS
        MOV     R0,R3           ;COPY POINTER TO NUMBER OF WINDOW BLOCKS
        MOV     #LDRBK,R1       ;POINT TO SAVE AREA
        MOV     (R3)+,(R1)+     ;SAVE NUMBER OF WINDOW BLOCKS
        MOV     R5,R0           ;COPY TCB POINTER
        ADD     #T.ATT,R0       ;POINT TO ATTACHMENT DESCRIPTOR LISTHEAD
        MOV     R0,-(SP)        ;SAVE LISTHEAD POINTER
        MOV     (R0)+,(R1)+     ;SAVE FIRST LISTHEAD WORD
        MOV     (R0),(R1)       ;SAVE SECOND LISTHEAD WORD
        MOV     (SP)+,(R0)      ;REINITIALIZE SECOND LISTHEAD WORD
145$:   CLR     R1              ;CLR NEXT ATTACHMENT DESCRIPTOR ADDRESS
        MOV     (R3),R2         ;PICK UP NEXT PCB ADDRESS (W.BPCB)
        BEQ     148$            ;IF EQ THERE IS NONE
        MOV     #AS.RED,R4      ;SET FOR ATTACH WITH READ ACCESS
        BIT     #4,W.BLPD(R3)   ;MAPPED WITH WRITE ACCESS?
        BEQ     146$            ;IF EQ NO
        BIS     #AS.WRT,R4      ;ADD WRITE ACCESS FOR ATTACH
146$:   CALL    $CRATT          ;ATTACH TO REGION
        BCC     148$            ;IF CC SUCCESSFUL
        MOV     @$HEADR,R0      ;RETRIEVE SAVED STACK POINTER
        MOV     R3,(R0)+        ;SAVE WINDOW BLOCK POINTER AS R4
        MOV     R5,(R0)+        ;SAVE TCB ADDRESS AS R5
        MOV     #147$,(R0)      ;MODIFY RETURN ADDRESS
        CALLR   $TKWSE          ;WAIT FOR SIGNIFICANT EVENT
147$:   CALL    $SWSTK,$LOADR   ;SWITCH TO SYSTEM STATE
        MOV     R4,R3           ;RESTORE WINDOW BLOCK POINTER
        BR      145$            ;REATTEMPT THE ATTACH
148$:   MOV     R1,W.BATT(R3)   ;SET ADDRESS OF ATTACHMENT DESCRIPTOR
        ADD     #W.BLGH,R3      ;POINT TO NEXT WINDOW BLOCK
        DEC     LDRBK           ;ANY MORE WINDOWS TO PROCESS?
        BGT     145$            ;IF GT YES
        MOV     LDRBK+2,@T.ATT+2(R5) ;ADD ON OLD DESCRIPTORS
        BEQ     149$            ;IF EQ IT WAS NULL
        MOV     LDRBK+4,T.ATT+2(R5) ;POINT TO LAST ORIGINAL DESCRIPTOR
149$:   MOV     R5,R3           ;RESTORE POINTER TO SECOND STATUS WORD
        ADD     #T.ST2,R3       ;

        .ENDC


        BIT     #T2.FXD,(R3)    ;TASK BEING FIXED?                      ; CS017
        BNE     160$            ;IF NE, YES, JUST RETURN                ; CS017
        MOV     R5,R0           ;SET ADDRESS OF TASK TCB                ;**-2
        CALL    $BILDS          ;BUILD A STACK FOR TASK JUST STARTING


        .IF DF  D$$YNC

        BR      155$            ;

        .IFTF

150$:                           ;REF LABEL

        .IFT

        MOV     R3,-(SP)        ;SAVE R3
        CALL    95$             ;DEALLOCATE CHECKPOINT SPACE
        MOV     (SP)+,R3        ;RESTORE R3
155$:                           ;REFERENCE LABEL

        .ENDC


        .IFT

        BIC     #TS.CKP,-(R3)   ;CLEAR CHECKPOINT FLAG
        BIT     #TS.CKR,(R3)    ;CHECKPOINT REQUESTED?
        BEQ     160$            ;IF EQ NO
        BIC     #TS.CKR,(R3)    ;CLEAR CHECKPOINT REQUEST FLAG
        MOV     R5,R1           ;SET ADDRESS OF TASK TCB
        CALL    $CHKPT          ;CHECKPOINT TASK

        .ENDC


160$:   RETURN                  ;                                       ; CS017
180$:   BIC     #T2.FXD,(R3)    ;CLEAR FIXED FLAG                       ; CS017
        BIC     #TS.EXE,-(R3)   ;CLEAR NOT IN EXECUTION                 ;**-44


        .IF DF  M$$MGE

        MOV     #77406,(R1)     ;SET ACCESS LAST PDR
        MOV     #UISDR0&377+<1*256.>,-(R1) ;SET FIRST PDR AND # PDR'S
        CMP     -(R1),-(R1)     ;
        CLR     -(R1)           ;CLEAR ATTACHMENT DESCRIPTOR ADDRESS
        CMP     -(R1),-(R1)     ;
        MOV     R4,-(R1)        ;SET PCB ADDRESS
        MOV     #1,-(R1)        ;INDICATE ONE WINDOW BLOCK

        .ENDC


185$:   CLR     H.NLUN(R0)      ;CLEAR NUMBER OF LUNS


        .IF DF  P$$LAS&P$$SRF

        CLR     H.RRVA(R0)      ;CLEAR REC BY REF CONTROL BLK ADDR

        .ENDC


        ADD     #H.FPSA,R0      ;POINT TO FLOATING POINT SAVE POINTER
        CLR     (R0)            ;CLEAR SAVE AREA POINTER
        TST     -(R0)           ;SKIP EFN SAVE ADDRESS
        CLR     -(R0)           ;CLEAR ADDRESS OF RECEIVE CONTROL BLOCK
        CLR     -(R0)           ;CLEAR ADDRESS OF FLOATING POINT CONTROL BLOCK
        CLR     -(R0)           ;CLEAR ADDRESS OF POWERFAIL CONTROL BLOCK
        MOV     R0,H.GARD-H.PFVA(R0) ;SET GUARD WORD TO DUMMY SAVE AREA


        .IF DF  C$$CKP&D$$ISK

        BIT     #TS.CKP,(R3)    ;CHECKPONT READ?
        BNE     187$            ;IF NE YES

        .IFTF

        MOV     R5,R0           ;SET ADDRESS OF TASK TCB
        CALL    $ACTTK          ;PUT TASK IN ACTIVE LIST
        MOV     #S.CLRF,R0      ;SET LOAD FAILURE

        .IFT

        BR      190$            ;
187$:   BIC     #TS.CKP!TS.CKR,(R3) ;CLEAR CHECKPOINT FLAGS
        MOV     #S.CCRF,R0      ;SET CHECKPOINT READ FAILURE

        .ENDC


190$:   MOV     R5,R1           ;SET ADDRESS OF TASK TCB
        CALLR   $ABTSK          ;ABORT TASK

;                                                                       ; CS045
; THIS ROUTINE SCANS THE HEADER AND VALIDATES THE LUT AND WINDOW BLOCKS.; CS045
; TASKS WHICH ARE SIMULTANEOUSLY INSTALLED IN TWO DIFFERENT SYSTEMS     ; CS045
; MAY HAVE INVALID UCBS IN THE LUT OR INVALID PCBS IN THE WINDOW BLOCKS.; CS045
; IF THIS IS THE CASE, THE TASK IS ABORTED.                             ; CS045
;                                                                       ; CS045
; INPUTS:                                                               ; CS045
;                                                                       ; CS045
;       R0=HEADER ADDRESS.                                              ; CS045
;       R5=TCB ADDRESS.                                                 ; CS045
;                                                                       ; CS045
; OUTPUTS:                                                              ; CS045
;                                                                       ; CS045
;       IOSB IS SET TO -1 IF THE HEADER IS INVALID.                     ; CS045
;                                                                       ; CS045
;       R0 - R3 ARE DESTROYED.                                          ; CS045
;                                                                       ; CS045
                                                                        ; CS045
SCHDR:  TST     H.NLUN(R0)      ;ANY LUNS?                              ; CS045
        BEQ     100$            ;IF EQ NO                               ; CS045
        BIT     #T2.ABO,T.ST2(R5) ;TASK ALREADY MARKED FOR ABORT?       ; CS045
        BNE     140$            ;IF NE YES                              ; CS045
        SAVNR                   ;SAVE R4 AND R5                         ; CS045
        MOV     #$DEVHD,R2      ;POINT TO DEVICE LISTHEAD               ; CS045
10$:    MOV     (R2),R2         ;POINT TO NEXT DCB                      ; CS045
        BEQ     60$             ;IF EQ END OF LIST                      ; CS045
        MOVB    D.UNIT+1(R2),-(SP) ;CALCULATE NUMBER OF UCBS            ; CS045
        SUB     D.UNIT(R2),(SP) ;                                       ; CS045
        MOV     D.UCB(R2),R4    ;GET ADDRESS OF FIRST UCB               ; CS045
20$:    MOV     R0,R1           ;COPY HEADER ADDRESS                    ; CS045
        ADD     #H.NLUN,R1      ;POINT TO NUMBER OF LUNS                ; CS045
        MOV     (R1)+,R3        ;GET NUMBER OF LUNS                     ; CS045
30$:    DEC     R3              ;ANY LUNS LEFT?                         ; CS045
        BLT     50$             ;IF LT NO                               ; CS045
        CMP     (R1)+,R4        ;UCB MATCH?                             ; CS045
        BNE     40$             ;IF NE NO                               ; CS045
        BIS     #1,(R1)         ;INDICATE UCB MATCH                     ; CS045
40$:    TST     (R1)+           ;POINT TO NEXT LUT ENTRY                ; CS045
        BR      30$             ;SCAN NEXT LUT ENTRY                    ; CS045
50$:    ADD     D.UCBL(R2),R4   ;POINT TO NEXT UCB                      ; CS045
        DECB    (SP)            ;ANY UCBS LEFT?                         ; CS045
        BGE     20$             ;IF GE YES                              ; CS045
        TST     (SP)+           ;CLEAN THE STACK                        ; CS045
        BR      10$             ;SCAN NEXT DCB                          ; CS045
60$:    MOV     R0,R1           ;COPY ADDRESS OF HEADER                 ; CS045
        ADD     #H.NLUN,R1      ;POINT TO NUMBER OF LUT ENTRIES         ; CS045
        MOV     (R1)+,R3        ;GET NUMBER OF LUT ENTRIES              ; CS045
70$:    DEC     R3              ;ANY LEFT?                              ; CS045
        BLT     100$            ;IF LT NO                               ; CS045
        TST     (R1)+           ;POINT TO SECOND LUT WORD               ; CS045
        BEQ     80$             ;IF EQ NOT ASSIGNED                     ; CS045
        TST     (R1)            ;UCB ADDRESS FOUND IN DEVICE TABLES?    ; CS045
        BNE     80$             ;IF NE YES                              ; CS045
        CLR     H.NLUN(R0)      ;CLEAR THE NUMBER OF LUNS               ; CS045
        BR      150$            ;ABORT THE TASK                         ; CS045
80$:    CLR     (R1)+           ;CLEAR SECOND LUT WORD                  ; CS045
        BR      70$             ;SCAN NEXT LUT ENTRY                    ; CS045
100$:                           ;REF LABEL                              ; CS045
                                                                        ; CS045
        .IF DF M$$MGE                                                   ; CS045
                                                                        ; CS045
        MOV     H.WND(R0),R1    ;POINT TO THE NUMBER OF WINDOWS         ; CS045
        MOV     (R1)+,R3        ;GET NUMBER OF WINDOWS                  ; CS045
110$:   MOV     (R1),R0         ;IS THIS WINDOW MAPPED?                 ; CS045
        BEQ     130$            ;IF EQ NO                               ; CS045
        MOV     P.MAIN(R0),R0   ;GET MAIN PCB ADDRESS                   ; CS045
        MOV     #$PARHD,R2      ;GET ADDRESS OF PARTITION LIST HEAD     ; CS045
120$:   MOV     (R2),R2         ;GET ADDRESS OF NEXT PCB                ; CS045
        BEQ     150$            ;IF EQ END OF LIST                      ; CS045
        CMP     R0,R2           ;PCB FOUND IN PARTITION LIST?           ; CS045
        BNE     120$            ;IF NE NO CONTINUE SEARCH               ; CS045
130$:   DEC     R3              ;ANY WINDOWS LEFT?                      ; CS045
        BLE     140$            ;IF LE NO                               ; CS045
        ADD     #W.BLGH,R1      ;POINT TO NEXT WINDOW BLOCK             ; CS045
        BR      110$            ;CONTINUE SCANNING                      ; CS045
                                                                        ; CS045
        .ENDC   ;M$$MGE                                                 ; CS045
                                                                        ; CS045
140$:   RETURN                  ;                                       ; CS045
150$:   MOV     #S.CINS,R0      ;GET ABORT CODE                         ; CS045
        MOV     R5,R1           ;COPY TCB ADDRESS                       ; CS045
        MOVB    #-1,IOSB        ;SET ERROR CODE                         ; CS045
        CALLR   $ABTSK          ;ABORT THE TASK                         ; CS045
                                                                        ; CS045
        .ENDC


        .IIF NDF L$$LDR .END


        .IIF DF L$$LDR  .END    $LOADR
        .TITLE  LOWCR
        .IDENT  /09/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 09
;
; D. N. CUTLER 11-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       P. J. BEZEREDI 18-AUG-77
;
;               PB031 -- ADDITION OF SUPPORT FOR NEW CRASH DUMP
;
;       CHUCK SPITZ 4-MAY-79
;               CS051 -- ADD 20 WORDS TO STACK FOR DECNET
;
;
; LOW CORE POINTERS, TRAP VECTORS, AND INTERRUPT VECTORS
;
; THIS FILE MUST BE FIRST IN THE TASK BUILDER COMMAND FILE SINCE
; IT OCCUPIES LOCATIONS STARTING AT REAL ZERO.
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,PCBDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PCBDF$  ,,SYSDEF        ;DEFINE PCB OFFSETS AND SIZE

        .PSECT

;
; LOCAL MACROS
;
;       GENVT-GENERATE VECTOR ENTRY
;

        .MACRO  GENVT ARG
        .IF DF  E$$NSI
        .WORD   $NS'ARG
        .IFF
        .WORD   $NONSI
        .ENDC
        .WORD   PR7!<<<$$$-START>/4>&17>
        .ENDM

START:

        .REPT   V$$CTR/4
$$$=.
        GENVT   \<<$$$-START>/<4*20>>
        .ENDR

.=START+4
        .WORD   $TRP04          ;TRAPS TO 4 (ODD,STACK,NONEX MEM)
        .WORD   PR7             ;
        .WORD   $ILINS          ;ILLEGAL (RESERVED) INSTRUCTION TRAPS
        .WORD   PR7             ;
        .WORD   $TRACE          ;BREAK POINT (TRACE) TRAPS
        .WORD   PR7             ;
        .WORD   $IOTRP          ;
        .WORD   PR7             ;
        .WORD   $NONSI          ;NONSENSE INTERRUPT
        .WORD   PR7             ;
        .WORD   $EMTRP          ;EMT INSTRUCTION TRAPS
        .WORD   PR7             ;
        .WORD   $TRTRP          ;TRAP INSTRUCTION TRAPS
        .WORD   PR7             ;
        JMP     $CRASH          ;JUMP TO CRASH DUMP ROUTINE
.DSW::  .WORD   .+2             ;ADDRESS OF DIRECTIVE STATUS
        .BLKW   1               ;DIRECTIVE STATUS WORD
        .BLKW   1               ;FCS IMPURE AREA POINTER
        .BLKW   1               ;FORTRAN IMPURE AREA POINTER
        .BLKW   1               ;OVERLAY RUN TIME SYSTEM IMPURE AREA POINTER
        .BLKW   1               ;RESERVED FOR EXPANSION
        .BLKB   V$$CTR-60       ;

;
; EXECUTIVE STACK AREA
;

        .BLKW   40.             ;SYSTEM STACK FOR MAPPED AND REAL SYSTEMS.


        .IF DF  D$$H11!M$$MGE!M$$NET

        .BLKW   20.             ;

        .ENDC


        .IF DF  I$$C11

        .BLKW   30.             ;

        .ENDC


        .IF DF  P$$LAS

        .BLKW   P.LGTH/2        ;DEFINE EXTRA STACK FOR PLAS SYSTEMS

        .ENDC

        .IF DF M$$NET                                                   ; CS051
                                                                        ; CS051
        .BLKW   20.             ;DEFINE EXTRA STACK FOR DECNET          ; CS051
                                                                        ; CS051
        .ENDC   ;M$$NET                                                 ; CS051
                                                                        ; CS051

$STACK::                        ;REF LABEL

        .END
        .TITLE  LPDRV
        .IDENT  /V08.1/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 07
;
; D. N. CUTLER 9-NOV-73
;
; PREVIOUSLY MODIFIED BY:
;
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       E. L. BAATZ 9-SEP-77
;
;               EB081 -- ALLOW SYSGEN SPECIFIED INTERVAL BETWEEN DEVICE
;                       NOT READY MESSAGES
;
;       E. E. OUYANG    2-OCT-78
;
;               EO501 -- DETECT TIMEOUT WITH NO ERROR (REF SPR# 000000)
;
;       P. J. KOBAR     1-DEC-78
;
;               PJK002 --  ALLOW SOME TIME BEFORE SETTING BUSY/FAULT
;
;               PJK003 -- CONVERT TO UPPERCASE IF SET /NOLOWER=LP:
;
; LP11/LS11 LINE PRINTER CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$,HWDDF$,PKTDF$
        ABODF$                  ;DEFINE TASK ABORT CODES
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS

;
; EQUATED SYMBOLS
;
; LINE PRINTER STATUS WORD BIT DEFINITIONS (U.CW2)
;

LS11=100000                     ;LS11 PRINTER (1=YES)
CRJT=40000                      ;CARRIAGE RETURN JUST OUTPUT (1=YES)
FORM=20000                      ;FORM FEED REQUIRED (1=YES)
CRTY=10000                      ;CARRIAGE RETURN REQUIRED (1=YES)
ABRT=4000                       ;ABORT REQUEST IF HUNG (1=YES)
LFCT=3000                       ;UNPROCESSED LINE FEED COUNT FIELD
LFBT=1000                       ;UNPROCESSED LINE FEED ADD/SUB BIT
BHLD=400                        ;BYTE HELD BACK FOR CARRIAGE RETURN (1=YES)
LP.LCA=100                      ;LOWER CASE ALLOWED (1=YES)             ;PJK003
BLCT=7                          ;UNPROCESSED BLANK COUNT FIELD
BLBT=1                          ;UNPROCESSED BLANK ADD/SUB BIT

;
; LINE PRINTER HORIZONAL POSITION AND HELD BACK BYTE (U.CW3)
;

HORPS=0                         ;HORIZONAL POSITION
HELDB=1                         ;BYTE HELD BACK

;                                                                       ; EO501
; DEFINE TIMEOUT WITH NO ERROR BIT IN S.STS FOR LP                      ; EO501
;                                                                       ; EO501
                                                                        ; EO501
TMONO=200                       ; 1=TIMEOUT WITH NO ERROR               ; EO501
                                                                        ; EO501
;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   L$$P11          ;ADDRESS OF UNIT CONTROL BLOCK


        .IF GT  L$$P11-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC


;
; DRIVER DISPATCH TABLE
;

$LPTBL::.WORD   LPINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   LPCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   LPOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   LPPWF           ;POWERFAIL ENTRY POINT

;+
; **-LPINI-LP11/LS11 LINE PRINTER CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
LPINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     LPPWF           ;IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R3=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; LINE PRINTER I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.WLB).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF I/O BUFFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- CARRIAGE CONTROL BYTE.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

        MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB
        MOV     R5,R3           ;CALCULATE ADDRESS OF PRINTER STATUS WORD
        ADD     #U.CW2,R3       ;
        BIC     #FORM!CRTY!ABRT!LFCT!BHLD!BLCT,(R3) ;CLEAR STATUS BITS
        MOVB    I.PRM+6(R1),R0  ;GET CARRIAGE CONTROL BYTE
        BEQ     30$             ;IF EQ NO CARRIAGE CONTROL
        CMPB    #'$,R0          ;CARRIAGE RETURN AT END OF LINE?
        BEQ     10$             ;IF EQ NO
        BIS     #CRTY,(R3)      ;SET FOR CARRIAGE RETURN AT AND OF LINE
10$:    CMPB    #'+,R0          ;LINE FEED AT BEGINNING OF LINE?
        BEQ     30$             ;IF EQ NO
        CMPB    #'1,R0          ;FORM FEED AT BEGINNING OF LINE?
        BNE     20$             ;IF NE NO
        ADD     #FORM-LFBT,(R3) ;SET FOR FORM FEED AT BEGINING OF LINE
20$:    ADD     #LFBT,(R3)      ;ADD IN ONE LINE FEED
        CMPB    #'0,R0          ;DOUBLE SPACE?
        BNE     30$             ;IF NE NO
        ADD     #LFBT,(R3)      ;ADD IN ONE LINE FEED
30$:    CALL    LPRNT           ;FILL LINE PRINTER BUFFER
        BCC     50$             ;IF CC REQUEST FINISHED
        BITB    #TMONO,S.STS(R4) ;TIMEOUT NO ERROR BIT SET?             ; EO501
        BEQ     40$             ;NO                                     ; EO501
        MOVB    #1,S.CTM(R4)    ;SET TIME OUT COUNT 1                   ; EO501
        BR      41$             ;SKIP                                   ; EO501
40$:    MOVB    S.ITM(R4),S.CTM(R4) ;RESET DEVICE TIMEOUT COUNT
41$:    BISB    #100,@S.CSR(R4) ;ENABLE PRINTER INTERRUPT               ; EO501
                                                                        ; EO501
                                                                        ;**-1
;
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE. THIS IS DONE TO AVOID A RACE CONDITION
; THAT COUND EXIST IN RESTARTING THE I/O OPERATION
;

LPPWF:  RETURN                  ;

;+
; **-$LPINT-LP11/LS11 LINE PRINTER CONTROLLER INTERUPTS
;-

$LPINT::                        ;;;REF LABEL
        INTSV$  LP,PR4,L$$P11   ;;;GENERATE INTERRUPT SAVE CODE
        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF STATUS CONTROL BLOCK
        CLRB    @S.CSR(R4)      ;;;DISABLE PRINTER INTERRUPTS
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        TST     @S.CSR(R4)      ;PRINTER READY?
        BMI     70$             ;IF MI NO
        MOV     R5,R3           ;CALCULATE ADDRESS OF PRINTER STATUS WORD
        ADD     #U.CW2,R3       ;
        CALL    LPRNT           ;FILL LINE PRINTER BUFFER
        BCS     40$             ;IF CS OPERATION DID NOT FINISH
50$:    MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        MOV     I.PRM+4(R1),R1  ;GET NUMBER OF BYTES PROCESSED
        MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL STATUS
60$:    CALL    $IODON          ;FINISH I/O OPERATION
        BR      LPINI           ;

;
; DEVICE TIMEOUT RESULTS IN A NOT READY MESSAGE BEING OUTPUT AT
; A SYSGEN SPECIFIED INTERVAL.  TIMEOUTS ARE CAUSED BY POWERFAILURE
; AND PRINTER FAULT CONDITIONS.
;

LPOUT:  CLRB    @S.CSR(R4)      ;;;DISABLE PRINTER INTERRUPT
        MTPS    #0              ;;;ALLOW INTERRUPTS
70$:    MOV     R5,R3           ;CALCULATE ADDRESS OF RELOCATION BIAS
        ADD     #U.BUF,R3       ;
        MOV     S.PKT(R4),R1    ;GET ADDRESS OF I/O PACKET
        ADD     #I.PRM,R1       ;POINT TO RELOCATION BIAS
        MOV     (R1)+,(R3)+     ;RESET RELOCATION BIAS
        MOV     (R1)+,(R3)+     ;RESET BUFFER ADDRESS
        MOV     (R1),(R3)       ;RESET BYTE COUNT
        MOV     #IE.ABO&377,R0  ;ASSUME REQUEST IS TO BE ABORTED
        ADD     #U.CW2-U.CNT,R3 ;ADJUST TO PRINTER STATUS WORD
        BIT     #ABRT,(R3)      ;ABORT REQUEST?
        BNE     60$             ;IF NE YES
        TST     @S.CSR(R4)      ;PRINTER READY?
        BMI     80$             ;NOT READY(ERROR BIT SET)               ; EO501
        BITB    #TMONO,S.STS(R4) ;WAS TIMEOUT WITH NO ERROR BIT?        ; EO501
        BNE     71$             ;YES IF NE                              ; EO501
        BISB    #TMONO,S.STS(R4) ;NO, SET THE BIT(TO CLEAR WHEN IODON)  ; EO501
        BR      30$             ;LP READY, TRY IT NOW                   ; EO501
71$:    BICB    #TMONO,S.STS(R4) ;2 TIMEOUTS WITH NO ERROR => ERROR     ; EO501
80$:                            ;LP NOT READY                           ; EO501
                                                                        ;**-1
        .IF DF  T$$KMG

        MOV     #T.NDNR,R0      ;SET FOR NOT READY MESSAGE

        .IFTF

        MOVB    #1,S.CTM(R4)    ;SET TIMEOUT FOR 1 SECOND

        .IFT

        DECB    S.STS(R4)       ;TIME TO OUTPUT MESSAGE?
        BNE     LPPWF           ;IF NE NO

        .IF NDF L$$PTO

        MOVB    #15.,S.STS(R4) ;SET TO OUTPUT NEXT MESSAGE IN 15. SECONDS

        .IFF

        MOVB    #L$$PTO,S.STS(R4) ;SET TO OUTPUT NEXT MESSAGE IN
                                ;L$$PTO SECONDS
        BNE     90$             ;IF NE LP NOT READY MESSAGES ENABLED
        INCB    S.STS(R4)       ;LP NOT READY MESSAGES NOT WANTED, SO
        BR      LPPWF           ;REBUSY CONTROLLER

        .ENDC

90$:    CALLR   $DVMSG          ;OUTPUT MESSAGE

        .IFF

        BR      LPPWF           ;

        .ENDC

        .DSABL  LSB

;
; CANCEL I/O OPERATION-FORCE I/O TO COMPLETE IF DEVICE IS NOT READY
;

LPCAN:  CMP     R1,I.TCB(R0)    ;;;REQUEST FOR CURRENT TASK?
        BNE     10$             ;;;IF NE NO
        BIS     #ABRT,U.CW2(R5) ;;;SET FOR ABORT IF DEVICE NOT READY
10$:    RETURN                  ;;;

;
; SUBROUTINE TO FILL LINE PRINTER BUFFER
;

LPRNT:  MOV     S.CSR(R4),R1    ;GET ADDRESS OF CONTROL STATUS REGISTER
        MOV     U.BUF+2(R5),R0  ;GET ADDRESS OF USER BUFFER


        .IF DF  M$$MGE

        MOV     U.BUF(R5),KISAR6 ;MAP TO USER BUFFER

        .IFTF

5$:     MOV     #5,R2           ; SET LOOP COUNT                        ;PJK002
10$:    BIT     #100200,(R1)    ;PRINTER FAULT OR READY?
        BMI     20$             ;IF MI PRINTER FAULT
        BNE     40$             ;IF NE PRINTER READY
        DEC     R2                                                      ;PJK002
        BNE     10$                                                     ;PJK002
20$:    SEC                     ;SET BUSY INDICATOR
30$:    MOV     R0,U.BUF+2(R5)  ;SAVE ADDRESS OF NEXT BYTE IN USER BUFFER

        .IFT

        MOV     KISAR6,U.BUF(R5) ;SAVE MAPPING INFORMATION

        .ENDC


        RETURN                  ;
35$:    TST     -(R3)           ;ADJUST TO PRINTER STATUS WORD
40$:    BIT     #FORM!LFCT!BHLD!BLCT,(R3) ;FORM, LINE FEED, BYTE HELD, OR BLANK
        BEQ     50$             ;IF EQ NO
        BIT     #BLCT,(R3)      ;ANY BLANKS TO BE OUTPUT?
        BNE     80$             ;IF NE YES
        BIT     #BHLD,(R3)      ;BYTE HELD BACK FOR CARRIAGE RETURN?
        BNE     65$             ;IF NE YES
        BIT     #FORM,(R3)      ;FORM FEED TO BE OUTPUT?
        BNE     60$             ;IF NE YES
        SUB     #LFBT,(R3)+     ;REDUCE LINE FEED COUNT
        MOVB    #12,R2          ;SET TO OUTPUT A LINE FEED
        BR      100$            ;
50$:    TST     U.CNT(R5)       ;ANY MORE BYTES TO OUTPUT?
        BNE     70$             ;IF NE YES
        BIT     #CRTY,(R3)      ;CARIAGE RETURN AT END OF LINE?
        BEQ     30$             ;IF EQ NO
        BIC     #CRTY,(R3)+     ;CLEAR CARRIAGE RETURN BIT
        MOVB    #15,R2          ;SET TO OUTPUT A CARRIAGE RETURN
        BR      100$            ;
60$:    BIC     #FORM,(R3)+     ;CLEAR FORM FEED BIT
        MOVB    #14,R2          ;SET TO OUTPUT A FORM FEED
        BR      100$            ;
65$:    BIC     #BHLD,(R3)      ;CLEAR BYTE HELD FOR CARRIAGE RETURN
        MOVB    3(R3),R2        ;RETRIEVE HELD BYTE
        BR      150$            ;
70$:    MOVB    (R0)+,R2        ;GET NEXT BYTE FROM USER BUFFER


        .IF DF  M$$MGE

        BIT     #20000,R0       ;OVERFLOW 4K BOUNDRY?
        BEQ     75$             ;IF EQ NO
        BIC     #20000,R0       ;CLEAR OVERFLOW BIT
        ADD     #200,KISAR6     ;UPDATE RELOCATION BIAS

        .ENDC


75$:    DEC     U.CNT(R5)       ;DECREMENT BYTE COUNT
        CMPB    #177,R2         ;RUBOUT?
        BEQ     50$             ;IF EQ YES
        TST     (R3)+           ;ADJUST TO HORIZONAL POSITION
        CMPB    #11,R2          ;HORIZONAL TAB?
        BNE     90$             ;IF NE NO
        MOVB    (R3),-(SP)      ;GET CURRENT HORIZONAL POSITION
        BIS     #177770,(SP)    ;CALCULATE BLANK COUNT TO NEXT TAB STOP
        NEG     (SP)            ;
        BIS     (SP)+,-(R3)     ;SET BLANK COUNT
80$:    DEC     (R3)+           ;REDUCE BLANK COUNT
        MOVB    #' ,R2          ;SET TO OUTPUT A BLANK
90$:    BHI     110$            ;IF HI OUTPUT BYTE
        CMPB    #15,R2          ;LF, CR, VT, OR FF?
        BLO     110$            ;IF LO NO
        CMPB    #13,R2          ;VERTICLE TAB?
        BEQ     110$            ;IF EQ YES
100$:   CLRB    (R3)            ;CLEAR HORIZONAL POSITION
        BR      120$            ;
110$:   CMPB    (R3),U.CW4(R5)  ;CARRIAGE OVERFLOW?
        BHIS    35$             ;IF HIS YES
        INCB    (R3)            ;INCREMENT HORIZONAL POSITION
120$:   TST     -(R3)           ;LS11 PRINTER?


        .IF DF  L$$11R

        BMI     150$            ;IF MI YES
        CMPB    R2,#15          ;CARRIAGE RETURN?
        BHI     130$            ;IF HI NO
        BEQ     160$            ;IF EQ YES
        CMPB    R2,#14          ;FORM FEED?
        BEQ     140$            ;IF EQ YES
        CMPB    R2,#12          ;LINE FEED?
        BEQ     140$            ;IF EQ YES
130$:   BIT     #CRJT,(R3)      ;CARRIAGE RETURN JUST OUTPUT?
        BEQ     150$            ;IF EQ NO
        BIS     #BHLD,(R3)      ;SET BYTE HELD BACK FOR CARRIAGE RETURN
        MOVB    R2,3(R3)        ;SAVE BYTE HELD BACK
        MOVB    #15,R2          ;SET TO OUTPUT CARRIAGE RETURN
140$:   BIC     #CRJT,(R3)      ;CLEAR CARRIAGE RETURN JUST OUTPUT

        .IFTF

;                                                                       ;PJK003
; TEST THE PRINTER CASE INDICATION IN CW2                               ;PJK003
; IF IT DOES NOT INDICATE LOWER CASE ALLOWED (LP.LCA=0),                ;PJK003
; FORCE LOWER CASE CHARACTERS TO UPPER CASE                             ;PJK003
;                                                                       ;PJK003
150$:                                                                   ;PJK003
        BIT     #LP.LCA,U.CW2(R5)       ; IS /LOWER=LP                  ;PJK003
        BNE     155$                    ;YES, SKIP CONVERT              ;PJK003
        CMPB    #141,R2                 ;'A' OR ABOVE                   ;PJK003
        BHI     155$                    ;NO                             ;PJK003
        CMPB    #172,R2                 ;YES, 'Z' OR BELOW              ;PJK003
        BLO     155$                    ;NO                             ;PJK003
        BIC     #40,R2                  ;YES, CONVERT IT                ;PJK003
155$:   MOVB    R2,2(R1)        ;OUTPUT BYTE                            ;PJK003
        JMP     5$              ; GO AGAIN                              ;PJK002
                                                                        ;**-2
        .IFT

160$:   BIS     #CRJT,(R3)      ;SET CARRIAGE RETURN JUST OUTPUT
        JMP     5$              ;                                       ;PJK002
                                                                        ;**-1
        .ENDC


        .END
        .TITLE  LSDRV
        .IDENT  /09.1/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 08
;
; D. N. CUTLER 7-JAN-74
;
; PREVIOUSLY MODIFIED BY:
;
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       B. SCHREIBER    30-NOV-77
;
;               BS033 -- CLEAR I.PRM+16 BEFORE CALLING $IOFIN
;                        (IN CASE RMS BLOCK LOCKING).
;
;       B. SCHREIBER    19-MAY-78
;
;               BS049 -- FIX HANDLING OF DIGITAL INPUT WD. AT INTERRUPT
;
; LPS11 LABORATORY PERIPHERAL SYSTEM CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,PKTDF$,TCBDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;
; EQUATED SYMBOLS
;
; SAMPLE CONTROL BLOCK OFFSET DEFINITIONS
;


        .PSECT  LSCTLQ,D,ABS

SLINK:  .BLKW   1               ;SAMPLE QUEUE THREAD WORD
RQPKT:  .BLKW   1               ;ADDRESS OF I/O REQUEST PACKET
STATE:  .BLKW   1               ;CURRENT SAMPLE STATE
RSTAT:  .BLKB   1               ;SAMPLE STATUS BYTE
FINST:  .BLKB   1               ;FINAL I/O STATUS
IOSB2:  .BLKW   2               ;SECOND I/O STATUS WORD ADDR & REL BIAS
STRBF:  .BLKW   1               ;STARTING BUFFER ADDR & RELOCATION BIAS
CURBF:  .BLKW   3               ;CURRENT BUFFER ADDR & RELOCATION BIAS
FULBF:  .BLKW   1               ;SIZE OF FULL BUFFER IN WORDS
SMCNT:  .BLKW   1               ;SPACE REMAINING TO END OF BUFFER
HAFBF:  .BLKW   1               ;SIZE OF HALF BUFFER IN WORDS


        .IF DF  L$$SDR

DBMSK:  .BLKW   1               ;DIGITAL INPUT/OUTPUT START MASK
DSMSK:  .BLKW   1               ;DIGITAL INPUT STOP MASK

        .ENDC


CYCNT:  .BLKW   1               ;NUMBER OF CLOCK TICKS TO NEXT SAMPLE
CRSET:  .BLKW   1               ;CLOCK TICKS RESET VALUE TO NEXT SAMPLE
SAMCT:  .BLKW   1               ;# OF SAMPLE BUFFERS REMAINING IN RQST
DATAW:  .BLKW   1               ;FUNCTION DEPENDENT DATA WORD
STRST:  .BLKW   1               ;STARTING SAMPLE STATE


        .IF DF  L$$SBF

STKSAV: .BLKW   1               ;CHANNEL (DATAW) SAVE WORD

        .ENDC


SLGTH:                          ;LENGTH OF SYNCH SAMPLE CONTROL BLOCK


        .PSECT



;
; SAMPLE CONTROL BLOCK STATUS BYTE BIT DEFINITIONS
;

SPARE=200                       ;SPARE BIT
STROT=100                       ;SET DIGITAL OUTPUT BIT AT START (1=YES)
STPIN=40                        ;STOP ON DIGITAL INPUT BIT CLEAR (1=YES)
STPBR=20                        ;STOP ON BUFFER RUNOUT (1=YES)
GAINR=10                        ;AUTOGAIN RANGING REQUESTED (1=YES)
SPARE=4                         ;SPARE BIT
RQEFN=2                         ;REQUEST EFN SETTING (1=YES)
STPRQ=1                         ;STOP SAMPLE REQUEST (1=YES)

;
; A/D TIMEOUT LOOP COUNT
;

TMOCNT=20.

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   L$$PS1          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK


        .IF DF  L$$SDR

DGIWD:  .BLKW   L$$PS1          ;DIGITAL INPUT WORD LAST SYNCHRONOUS SAMPLE

        .ENDC


TEMP:   .BLKW   1               ;TEMPORARY STORAGE


        .IF DF  L$$SBF

DLYCNT: .BLKW   L$$PS1          ;CLOCK COUNT FOR A/D DELAY
ADCHN:                          ;CURRENT A/D CHANNEL NUMBER
ADFLG=ADCHN+1                   ;A/D CONVERSION ENABLE FLAG
        .REPT   L$$PS1
        .BYTE   377,0
        .ENDR

        .ENDC



;
; FORK REQUEST FLAG
;

FKFLG:  .WORD   0

;
; LEGAL FUNCTION VECTOR
;

LGFCN:  .BYTE   IO.SDO/256.     ;WRITE DIGITAL OUTPUT REGISTER
        .BYTE   IO.LED/256.     ;WRITE LED DISPLAY LIGHTS
        .BYTE   IO.REL/256.     ;WRITE RELAY
        .BYTE   IO.SDI/256.     ;READ DIGITAL INPUT REGISTER
        .BYTE   IO.STP/256.     ;STOP IN PROGRESS REQUEST
        .BYTE   IO.HIS/256.     ;SYNCHRONOUS HISTOGRAM SAMPLING
        .BYTE   IO.MDO/256.     ;SYNCHRONOUS DIGITAL OUTPUT
        .BYTE   IO.ADS/256.     ;SYNCHRONOUS A/D SAMPLING
        .BYTE   IO.MDA/256.     ;SYNCHRONOUS D/A OUTPUT
        .EVEN

;
; DRIVER DISPATCH TABLE
;

$LSTBL::.WORD   LSINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   LSCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   LSOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   LSPWF           ;POWERFAIL ENTRY POINT

;+
; **-LSINI-LPS11 LABORATORY PERIPHERAL SYSTEM CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS RECEIVED FOR THE LPS11 LABORATORY PERIPHERAL SYSTEM. NINE FUNCTIONS ARE
; RECOGNIZED BY THE LPS11 DRIVER. FUNCTIONS ARE EITHER EXECUTED IMMEDITATELY
; OR PLACED IN A SAMPLE REQUEST QUEUE THAT IS MAINTAINED BY THE DRIVER.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; FUNCTION INDEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE.
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;
; OUTPUTS:
;
;       IF THE FUNCTION IS READ SINGLE A/D CHANNEL, WRITE DIGITAL OUTPUT
;       REGISTER, WRITE LED DISPLAY LIGHTS, OR WRITE RELAY, THEN THE
;       FUNCTION IS EXECUTED IMMEDIATEDLY. ELSE A SECONDARY CONTROL BLOCK
;       IS CONSTRUCTED AND LINKED INTO THE SAMPLE REQUEST QUEUE.
;-

LSINI:  MOV     U.SCB(R5),R2    ;GET ADDRESS OF SCB
        MOV     R1,R3           ;SAVE I/O PACKET ADDRESS
        ADD     #I.PRM,R1       ;POINT TO FIRST PARAMETER
        MOV     S.CSR(R2),R4    ;GET ADDRESS OF CONTROL STATUS REGISTER
        MOV     #LGFCN,R0       ;POINT TO LEGAL FUNCTION VECTOR
        MOVB    I.FCN+1(R3),-(SP) ;GET I/O FUNCTION CODE
        CMPB    (SP),(R0)+      ;WRITE DIGITAL OUTPUT REGISTER?


        .IF DF  L$$SDR

        BEQ     DIGIO           ;IF EQ YES

        .IFF

        BEQ     LSONP           ;IF EQ YES

        .IFTF

        CMPB    (SP),(R0)+      ;WRITE LED DISPLAY LIGHTS?
        BEQ     WRLED           ;IF EQ YES
        CMPB    (SP),(R0)+      ;WRITE RELAY?

        .IFT

        BEQ     WRRLY           ;IF EQ YES
        CMPB    (SP),(R0)+      ;READ DIGITAL INPUT REGISTER?
        BEQ     RDDIN           ;IF EQ YES

        .IFF

        BEQ     LSONP           ;IF EQ YES
        CMPB    (SP),(R0)+      ;READ DIGITAL INPUT REGISTER?
        BEQ     LSONP           ;IF EQ YES

        .ENDC


        CMPB    (SP),(R0)+      ;STOP IN PROGRESS REQUEST?
        BEQ     STOPR           ;IF EQ YES
        JMP     LSFCN           ;ELSE HANDLE FUNCTION

;
; **-STOPR-STOP IN PROGRESS REQUST
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- BUFFER ADDRESS OF PREVIOUS REQUEST.
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

STOPR:  MOV     (R1),R0         ;GET ADDRESS OF BUFFER
        MOV     R2,R4           ;SAVE ADDRESS OF SCB
        CALL    $RELOC          ;RELOCATE BUFFER ADDRESS
        MOV     R3,-(SP)        ;SAVE I/O PACKET ADDRESS
        MOV     R5,R3           ;CALCULATE ADDRESS OF SAMPLE QUEUE LISTHEAD
        ADD     #U.BUF,R3       ;
        MOVB    S.PRI(R4),PS    ;;;LOCK OUT DEVICE INTERRUPTS
10$:    MOV     (R3),R3         ;;;GET ADDRESS OF NEXT ENTRY
        BEQ     20$             ;;;IF EQ DONE
        MOV     RQPKT(R3),R0    ;;;GET ADDRESS OF I/O PACKET
        CMP     $TKTCB,I.TCB(R0) ;;;REQUEST FOR CURRENT TASK?
        BNE     10$             ;;;IF NE NO
        CMP     R1,STRBF(R3)    ;;;RELOCATION BIAS MATCH?
        BNE     10$             ;;;IF NE NO
        CMP     R2,STRBF+4(R3)  ;;;BUFFER ADDRESS MATCH?
        BNE     10$             ;;;IF NE NO
        MOVB    #IE.ABO,FINST(R3) ;;;SET FINAL STATUS ABORT
        CALL    TERMS           ;;;TERMINATE SAMPLE REQUEST
20$:    CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        MOV     (SP)+,R3        ;RESTORE I/O PACKET ADDRESS
        BR      LSSUC           ;TAKE COMMON EXIT


        .IF DF  L$$SDR

;
; **-RDDIN-READ DIGITAL INPUT REGISTER
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- DIGITAL INPUT MASK WORD.
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

RDDIN:  SEC                     ;INDICATE DIGITAL INPUT REQUEST
DIGIO:  BITB    #20,U.CW2+1(R5) ;LPSDR-A PRESENT?
        BEQ     LSONP           ;IF EQ NO
        BCC     WRDOT           ;BRANCH IF DIGITAL OUTPUT REQUEST


        .IF GT  L$$PS1-1

        MOVB    S.CON(R2),R2    ;GET CONTROLLER INDEX
        MOV     DGIWD(R2),R2    ;GET DIGITAL INPUT WORD LAST SYNCHRONOUS

        .IFF

        MOV     DGIWD,R2        ;GET DIGITAL INPUT OF LAST SYNCH SAMPLE

        .ENDC


        TSTB    U.STS(R5)       ;UNIT BUSY?
        BMI     10$             ;IF MI YES
        MOV     12(R4),R2       ;READ DIGITAL INPUT REGISTER
        MOV     R2,12(R4)       ;CLEAR BITS IN DIGITAL INPUT REGISTER
10$:    COM     (R1)            ;COMPLEMENT MASK WORD
        BIC     (R1),R2         ;CLEAR UNWANTED BITS IN DATA WORD
        MOV     R2,R1           ;SET SECOND I/O STATUS WORD
        BR      LSSUC1          ;TAKE COMMON EXIT

;
; **-WRDOT-WRITE DIGITAL OUTPUT REGISTER
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- DIGITAL OUTPUT MASK WORD.
;       WD. 13 -- DIGITAL OUTPUT VALUE.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

WRDOT:  BIT     (R1),U.CNT+2(R5) ;DIGITAL OUTPUT BITS IN USE?
        BNE     LSRSU           ;IF NE YES
        ADD     #14,R4          ;POINT TO DIGITAL OUTPUT REGISTER
        COM     (R1)            ;COMPLEMENT MASK WORD
        BIC     (R1)+,(R1)      ;CLEAR EXCESS BITS IN DATA WORD
        BIS     (R1),(R4)       ;SET BITS IN DIGITAL OUTPUT REGISTER
        COM     (R1)            ;COMPLEMENT DATA WORD
        BIC     -2(R1),(R1)     ;CLEAR EXCESS BITS IN DATA WORD
        BIC     (R1),(R4)       ;CLEAR BITS IN DIGITAL OUTPUT REGISTER
        MOV     (R4),R1         ;SET SECOND I/O STATUS WORD
        BR      LSSUC1          ;TAKE COMMON EXIT

        .ENDC


;
; **-WRLED-WRITE LED DISPLAY LIGHTS
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- 16 BIT SIGNED BINARY NUMBER TO BE DISPLAYED IN LED LIGHTS.
;       WD. 13 -- LED DIGIT NUMBER OF DECIMAL POINT.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

WRLED:  TST     (R4)+           ;POINT TO LED DISPLAY REGISTER
        MOV     R1,R2           ;COPY ADDRESS OF FIRST PARAMETER WORD
        MOV     #16,-(SP)       ;ASSUME POSITIVE NUMBER
        MOV     (R2)+,R0        ;GET NUMBER TO BE DISPLAYED
        BPL     10$             ;IF PL POSITIVE NUMBER
        DEC     (SP)            ;SET MINUS SIGN AS LAST DIGIT
        NEG     R0              ;CONVERT TO POSITIVE NUMBER
10$:    CLR     -(SP)           ;CLEAR DIGIT COUNTER
        DEC     (R2)            ;CALCULATE ACTUAL DIGIT POSITION
        SWAB    (R2)            ;SWAP POSITION INTO LEFT BYTE
        CLRB    (R2)            ;CLEAR LOW BYTE OF POSITION
20$:    MOV     #10.,R1         ;SET DIVISOR
        CALL    $DIV            ;CONVERT DIGIT
        BIS     (SP),R1         ;MERGE DIGIT AND DIGIT COUNTER
        CMP     (SP),(R2)       ;DIGIT POSITION MATCH?
        BNE     30$             ;IF NE NO
        BIS     #20,R1          ;SET TO DISPLAY DECIMAL POINT
30$:    MOV     R1,(R4)         ;OUTPUT DISPLAY DIGIT
        ADD     #1*400,(SP)     ;INCREMENT DIGIT COUNTER
        CMP     #5*400,(SP)     ;NUMBER CONVERTED?
        BGT     20$             ;IF GT NO
        BIS     (SP)+,(SP)      ;MERGE LAST DIGIT WITH DIGIT COUNTER
        MOV     (SP)+,(R4)      ;OUTPUT LAST DIGIT (MINUS OR BLANK)


        .IF DF  L$$SDR

        BR      LSSUC           ;TAKE COMMON EXIT

;
; **-WRRLY-WRITE RELAY
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- RELAY NUMBER (0 OR 1).
;       WD. 13 -- POLARITY DESIRED (ZERO=OPEN, NONZERO=CLOSED).
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

WRRLY:                          ;REF LABEL
        BITB    #20,U.CW2+1(R5) ;LPSDR-A PRESENT?
        BEQ     LSONP           ;IF EQ NO
        ADD     #10,R4          ;POINT TO RELAY 1
        ASR     (R1)+           ;TEST RELAY NUMBER
        BNE     LSBAD           ;IF NE ILLEGAL RELAY NUMBER
        BCC     10$             ;IF CC RELAY 1
        INC     R4              ;POINT TO  RELAY 2
10$:    TST     (R1)            ;ZERO POLARITY?
        BEQ     20$             ;IF EQ YES
        BISB    #1,(R4)         ;SET POLARITY TO ONE
        BR      LSSUC           ;
20$:    BICB    #1,(R4)         ;SET POLARITY TO ZERO

        .IFTF

;
; SUCCESS COMPLETION OF FUNCTION
;

LSSUC:  CLR     R1              ;CLEAR SECOND I/O STATUS WORD
LSSUC1: MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS CODE
        BR      LSCMN1          ;

;
; BAD PARAMETER
;

LSBAD:  MOV     #IE.BAD&377,R0  ;SET BAD PARAMETER STATUS CODE
        BR      LSCMN           ;

        .IFT

;
; RESOURCE IN USE
;

LSRSU:  MOV     #IE.RSU&377,R0  ;SET RESOURCE IN USE STATUS CODE
        BR      LSCMN           ;

        .ENDC


;
; PRIVILEGE VIOLATION
;

LSPRI:  MOV     #IE.PRI&377,R0  ;SET PRIVILEGE VIOLATION STATUS
        BR      LSCMN           ;

;
; OPTION NOT PRESENT
;

LSONP:  MOV     #IE.ONP&377,R0  ;SET OPTION NOT PRESENT STATUS
        BR      LSCMN           ;

;
; DYNAMIC MEMORY NOT AVAILABLE
;

LSNOD:  MOV     #IE.NOD&377,R0  ;SET MEMORY NOT AVAILABLE STATUS

;
; COMMON STATUS EXIT
;

LSCMN:  CLR     R1              ;CLEAR SECOND I/O STATUS WORD
LSCMN1: TST     (SP)+           ;REMOVE FUNCTION CODE FROM STACK
        CLR     I.PRM+16(R3)    ;CLEAR BLOCK LOCKING WORD FOR $IOFIN
        CALLR   $IOFIN          ;FINISH I/O OPERATION

;
; ALL REMAINING FUNCTIONS REQUIRE THE REQUESTING TASK TO BE EITHER FIXED
; IN MEMORY OR NOT CHECKPOINTABLE AND AN I/O STATUS DOUBLEWORD TO BE
; SPECIFIED.
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF BUFFER.
;       WD. 13 -- BUFFER ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 14 -- BUFFER SIZE IN BYTES.
;       WD. 15 -- DIGITAL INPUT/OUTPUT POINT NUMBERS.
;       WD. 16 -- LPS CLOCK TICKS BETWEEN SAMPLES.
;       WD. 17 -- NUMBER OF BUFFERS.
;       WD. 20 -- FUNCTION DEPENDENT DATA WORD.
;

LSFCN:  MOV     I.TCB(R3),R2    ;GET REQUESTING TASK TCB ADDRESS
        BIT     #T2.CHK!T2.FXD,T.ST2(R2) ;TASK FXD OR NOT CHKPOINTABLE?
        BEQ     LSPRI           ;IF EQ NO
        TST     I.IOSB+4(R3)    ;I/O STATUS DOUBLEWORD SPECIFIED?
        BEQ     LSBAD           ;IF EQ NO
        ADD     #6,R1           ;POINT TO DIGITAL POINT NUMBERS
        BITB    #340,I.FCN(R3)  ;DIGITAL I/O SUB-FUNCTION REQUESTED?


        .IF DF  L$$SDR

        BEQ     35$             ;IF EQ NO
        BITB    #20,U.CW2+1(R5) ;LPSDR-A PRESENT?
        BEQ     LSONP           ;IF EQ NO
        MOVB    I.FCN(R3),R2    ;GET SUBFUNCTION MODIFIER BITS
        BPL     10$             ;IF PL START IMMEDIATELY
        CMPB    (R1),#16.       ;LEGAL DIGITAL POINT NUMBER?
        BHIS    LSBAD           ;IF HIS NO
10$:    ASLB    R2              ;SET DIGITAL OUTPUT ON START?
        BPL     20$             ;IF PL NO
        CMPB    (R1),#16.       ;LEGAL DIGITAL POINT NUMBER?
        BHIS    LSBAD           ;IF HIS NO
        MOVB    (R1),R4         ;GET DIGITAL OUTPUT POINT NUMBER
        ASL     R4              ;CONVERT TO WORD INDEX
        BIT     $BTMSK(R4),U.CNT+2(R5) ;DIGITAL OUTPUT BIT IN USE?
        BNE     LSRSU           ;IF NE YES
20$:    ASLB    R2              ;STOP ON DIGITAL INPUT?
        BPL     30$             ;IF PL NO
        CMPB    1(R1),#16.      ;LEGAL DIGITAL POINT NUMBER?
        BHIS    LSBAD           ;IF HIS NO
30$:    ASL     (R1)            ;CONVERT BOTH POINT NUMBERS TO WORD INDICES

        .IFF

        BNE     LSONP           ;IF NE YES

        .IFTF

35$:                            ;REF LABEL
        ADD     #8.,R1          ;POINT TO LAST WORD IN I/O PACKET
        CMPB    (SP),(R0)+      ;SYNCHRONOUS HISTOGRAM SAMPLING?
        BEQ     40$             ;IF EQ YES
        CMPB    (SP),(R0)+      ;SYNCHRONOUS DIGITAL OUTPUT?

        .IFT

        BEQ     50$             ;IF EQ YES

        .IFF

        BEQ     LSONP           ;IF EQ YES

        .IFTF

        CMPB    (SP),(R0)+      ;SYNCHRONOUS A/D SAMPLING?
        BEQ     60$             ;IF EQ YES
        CMPB    (SP),(R0)+      ;SYNCHRONOUS D/A OUTPUT?

        .IFT

        BNE     100$            ;IF NE NO

        .IFF

        BNE     LSONP           ;IF NE NO (NO DIGITAL INPUT)

        .ENDC


        .IF DF  L$$SDA

;
; SYNCHRONOUS D/A OUTPUT
;

        MOV     #SYNDA,(R1)     ;SET SYNCHRONOUS D/A OUTPUT STATE
        MOVB    U.CW2+1(R5),R0  ;GET OPTION FLAGS AND NUMBER OF D/A'S
        BIT     #100,R0         ;D/A OPTION PRESENT?
        BEQ     LSONP           ;IF EQ NO
        BIC     #^C<37>,R0      ;CLEAR ALL BUT NUMBER OF D/A'S
        MOVB    -(R1),R2        ;GET NUMBER OF OUTPUT D/A'S
        MOVB    -(R1),R4        ;GET STARTING D/A NUMBER
        BR      90$             ;FINISH IN COMMON CODE

        .IFF

        BR      LSONP           ;D/A OPTION NOT PRESENT

        .ENDC


;
; SYNCHRONOUS HISTOGRAM SAMPLING
;

40$:    MOV     #SYNHS,(R1)     ;SET SYNCHRONOUS HISTOGRAM SAMPLING STATE
        CLR     -(R1)           ;CLEAR DATA WORD
        BR      120$            ;


        .IF DF  L$$SDR

;
; SYNCHRONOUS DIGITAL OUTPUT
;

50$:    MOV     #SYNDO,(R1)     ;SET SYNCHRONOUS DIGITAL OUTPUT STATE
        BIT     -(R1),U.CNT+2(R5) ;ANY DIGITAL OUTPUT BITS IN USE?
        BR      110$            ;FINISH IN COMMON CODE

        .IFTF

;
; SYNCHRONOUS A/D SAMPLING
;

60$:    MOV     #SYNAD,(R1)     ;SET SYNCHRONOUS A/D SAMPLING STATE
        MOVB    -(R1),R2        ;GET NUMBER OF CHANNELS
        MOVB    -(R1),R4        ;GET STARTING CHANNEL AND GAIN
        BITB    #GAINR,I.FCN(R3) ;AUTOGAIN RANGING SPECIFIED?
        BNE     70$             ;IF NE YES
        BIT     #60,R4          ;GAIN OTHER THAN 1 SPECIFIED?
        BEQ     80$             ;IF EQ NO
        TST     U.CW2(R5)       ;GAIN OPTION PRESENT?
        BPL     80$             ;IF PL NO
        BIC     #60,R4          ;CLEAR GAIN CODE BITS
70$:    TST     U.CW2(R5)       ;GAIN OPTION PRESENT?
        BPL     LSONP           ;IF PL NO
80$:    MOVB    U.CW2(R5),R0    ;GET NUMBER OF A/D CHANNELS
        BIC     #^C<177>,R0     ;
90$:    DEC     R2              ;REDUCE NUMBER OF CHANNELS
        ADD     R2,R4           ;CALCULATE HIGHEST CHANNEL
        BCS     LSBAD           ;IF CS BAD RANGE
        CMP     R4,R0           ;LEGAL CHANNEL?
        BHIS    LSBAD           ;IF HIS NO

        .IFT

        BR      120$            ;FINISH IN COMMON CODE

;
; SYNCHRONOUS DIGITAL INPUT
;

100$:   MOV     #SYNDI,(R1)     ;SET SYNCHRONOUS DIGITAL INPUT STATE
        BIT     -(R1),U.CNT(R5) ;ANY DIGITAL INPUT BITS IN USE?
110$:   BNE     LSRSU           ;IF NE YES

        .IFTF

120$:   MOV     R3,R4           ;SAVE I/O PACKET ADDRESS
        MOV     #SLGTH,R1       ;SET LENGTH OF SECONDARY CONTROL BLOCK
        CALL    $ALOCB          ;ALLOCATE SECONDARY CONTROL BLOCK
        MOV     R4,R3           ;RESTORE I/O PACKET ADDRESS
        BCS     LSNOD           ;IF CS NO MEMORY AVAILABLE
        MOV     R0,R1           ;COPY SECONDARY CONTROL BLOCK ADDRESS
        CLR     (R1)+           ;CLEAR LINK WORD
        MOV     R3,(R1)+        ;INSERT I/O PACKET ADDRESS
        ADD     #I.FCN,R3       ;POINT TO SUBFUNCTION MODIFIER BITS

        .IFT

        MOV     #SDOUT,(R1)+    ;SET INITIAL STATE TO DIGITAL OUTPUT

        .IFF

        MOV     I.PRM+14.(R4),(R1)+  ;SET INITIAL SAMPLING STATE

        .IFTF

        MOV     (R3),(R1)       ;INSERT SUBFUNCTION MODIFIER BITS
        BIC     #^C<STROT!STPIN!STPBR!GAINR>,(R1)+ ;CLEAR EXTRANEOUS BITS
        ADD     #I.IOSB+2,R4    ;POINT TO I/O STATUS DOUBLEWORD ADDRESS
        MOV     (R4)+,(R1)+     ;INSERT RELOCATION BIAS
        MOV     (R4)+,(R1)      ;INSERT DISPLACEMENT ADDRESS
        ADD     #2,(R1)+        ;CALCULATE ADDRESS OF SECOND I/O STATUS
        TST     (R4)+           ;BYPASS AST ADDRESS AND CLEAR CARRY
        MOV     (R4),(R1)+      ;INSERT BUFFER RELOCATION BIAS
        MOV     (R4)+,(R1)+     ;
        MOV     (R4),(R1)+      ;INSERT BUFFER DISPLACEMENT ADDRESS
        MOV     (R4)+,(R1)+     ;
        MOV     (R4)+,(R1)      ;INSERT SIZE OF BUFFER IN BYTES
        ROR     (R1)            ;CONVERT TO SIZE IN WORDS
        MOV     (R1)+,(R1)      ;INSERT SIZE OF BUFFER IN WORDS
        MOV     (R1)+,(R1)      ;INSERT SIZE OF BUFFER IN WORDS
        ASR     (R1)+           ;CONVERT TO SIZE IN DOUBLEWORDS

        .IFT

        MOVB    (R4)+,R2        ;GET DIGITAL INPUT/OUTPUT POINT INDEX
        CLR     (R1)            ;ASSUME NO DIGITAL INPUT/OUTPUT POINT
        ASLB    (R3)            ;START ON DIGITAL INPUT POINT?
        BCC     130$            ;IF CC NO
        MOV     #SWAIT,STATE(R0) ;ALTER STATE TO WAIT ON DIGITAL INPUT
        BR      140$            ;
130$:   BPL     150$            ;IF PL NO DIGITAL OUTPUT ON START
140$:   MOV     $BTMSK(R2),(R1) ;INSERT DIGITAL INPUT/OUTPUT POINT MASK
        TSTB    (R3)            ;SET DIGITAL OUTPUT POINT AT START?
        BPL     150$            ;IF PL NO
        BIS     (R1),U.CNT+2(R5) ;SET DIGITAL OUTPUT POINT IN USE
150$:   TST     (R1)+           ;ADVANCE TO NEXT WORD
        CLR     (R1)            ;ASSUME NO DIGITAL INPUT POINT
        MOVB    (R4)+,R2        ;GET DIGITAL INPUT POINT INDEX
        ASLB    (R3)            ;STOP ON DIGITAL INPUT POINT?
        BPL     160$            ;IF PL NO
        MOV     $BTMSK(R2),(R1) ;INSERT DIGITAL INPUT POINT MASK
160$:   CMP     (R1)+,(SP)+     ;ADVANCE TO NEXT WORD AND CLEAN STACK

        .IFF

        CMP     (R4)+,(SP)+     ;SKIP DIGITAL I/O WORD AND CLEAN STACK

        .IFTF

        MOV     #1,(R1)+        ;INSERT INITIAL CLOCK TICKS TO NEXT SAMPLE
        MOV     (R4)+,(R1)+     ;INSERT CLOCK TICKS RESET VALUE
        MOV     (R4)+,(R1)+     ;INSERT NUMBER OF BUFFERS TO COLLECT
        MOV     (R4)+,(R1)+     ;INSERT FUNCTION DEPENDENT DATA WORD
        MOV     (R4),(R1)       ;INSERT STARTING SAMPLE STATE

        .IFT

        CMP     #SYNDO,(R1)     ;SYNCHRONOUS DIGITAL OUTPUT?
        BEQ     170$            ;IF EQ YES
        CMP     #SYNDI,(R1)     ;SYNCHRONOUS DIGITAL INPUT?
        BNE     190$            ;IF NE NO
        BIS     -(R1),U.CNT(R5) ;SET DIGITAL INPUT BITS IN USE
        BR      180$            ;
170$:   BIS     -(R1),U.CNT+2(R5) ;SET DIGITAL OUTPUT BITS IN USE
180$:   COM     (R1)            ;COMPLEMENT MASK WORD

        .ENDC


190$:   MOV     U.BUF(R5),(R0)  ;INSERT REQUEST IN SAMPLE QUEUE
        MOV     R0,U.BUF(R5)    ;
        MOVB    I.EFN-<I.PRM+16>(R4),R0 ;GET SPECIFIED EVENT FLAG NUMBER
        MOV     R5,-(SP)        ;SAVE UCB ADDRESS
        MOV     I.TCB-<I.PRM+16>(R4),R5 ;GET TCB ADDRESS OF REQUESTOR TASK
        CALL    $CEFI           ;CONVERT EFN TO MASK AND ADDRESS
        MOV     R1,(R4)         ;INSERT EFN MASK ADDRESS
        MOV     R0,-(R4)        ;INSERT EFN MASK WORD
        MOV     (SP)+,R5        ;RETRIEVE UCB ADDRESS
        MOV     U.SCB(R5),R3    ;GET ADDRESS OF SCB
        TSTB    U.STS(R5)       ;UNIT BUSY?
        BMI     200$            ;IF MI YES


        .IF DF  L$$SBF

        TSTB    U.CW2(R5)       ;BANDWIDTH FILTERS IN USE?
        BPL     198$            ;IF PL NO
        MOV     U.BUF+2(R5),R0  ;GET DELAY COUNTDOWN FOR 10KHZ
        MOV     U.CW4(R5),R1    ;GET CLOCK INTERRUPT COUNTDOWN
        CALL    $DIV            ;CALCULATE INTERRUPT COUNT
        TST     R1              ;WAS THERE A REMAINDER?
        BEQ     195$            ;IF EQ NO
        INC     R0              ;ELSE, INCREMENT COUNT
195$:                           ;REF LABEL


        .IF GT  L$$PS1-1

        MOVB    S.CON(R3),R1    ;GET CONTROLLER INDEX
        MOV     R0,DLYCNT(R1)   ;STORE DELAY COUNT

        .IFF

        MOV     R0,DLYCNT       ;STORE DELAY COUNT

        .ENDC

198$:                           ;REF LABEL

        .ENDC


        MOV     S.CSR(R3),R2    ;GET ADDRESS OF CONTROL STATUS REGISTER
        CMP     (R2)+,(R2)+     ;POINT TO CLOCK STATUS REGISTER
        MOV     #506,(R2)+      ;SET REPEAT MODE, 10KHZ, AND ENABLE INT
        MOV     U.CW4(R5),(R2)  ;LOAD COUNTER PRESET REGISTER
        NEG     (R2)            ;NEGATE PRESET VALUE
        INC     -(R2)           ;START CLOCK RUNNING
200$:   BISB    #US.BSY,U.STS(R5) ;SET UNIT BUSY
        MOVB    #1,S.STS(R3)    ;SET CONTROLLER BUSY
        MOVB    S.ITM(R3),S.CTM(R3) ;SET CURRENT TIMEOUT COUNT
        RETURN                  ;

;+
; **-$LSCLK-LPS11 LABORATORY PERIPHERAL SYSTEM CLOCK INTERRUPT
;-

$LSCLK::                        ;;;REF LABEL
$LSINT::                        ;;;REF LABEL
        INTSV$  LS,PR6,L$$PS1   ;;;GENERATE INTERRUPT SAVE CODE
        MOV     R3,-(SP)        ;;;SAVE R3 AND R2
        MOV     R2,-(SP)        ;;;


        .IF GT  L$$PS1-1

        MOV     R1,-(SP)        ;;;SAVE R1
        MOV     R4,R1           ;;;PUT CONTROLLER INDEX IN R1

        .ENDC


        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET TIMEOUT COUNT
        MOV     S.CSR(R4),R4    ;;;GET ADDRESS OF CONTROL STATUS REGISTER


        .IF DF  L$$SDR


        .IF GT  L$$PS1-1

        BITB    #20,U.CW2+1(R5) ;;;LPSDR-A PRESENT?
        BEQ     10$             ;;;IF EQ NO

        .IFTF

        MOV     12(R4),R3       ;;;READ DIGITAL INPUT REGISTER

        .IFT

        MOV     R3,DGIWD(R1)    ;;;SAVE DIGITAL INPUT WORD

        .IFF

        MOV     R3,DGIWD        ;;;SAVE DIGITAL INPUT WORD

        .ENDC


        MOV     R3,TEMP         ;;;SAVE COMPLEMENT OF DIGITAL INPUT WORD
        COM     TEMP            ;;;
        MOV     R3,12(R4)       ;;;CLEAR BITS IN DIGITAL INPUT REGISTER         ;**-1
10$:                            ;;;REF LABEL

        .ENDC


        MOV     R5,R3           ;;;CALCULATE ADDRESS OF SAMPLE QUEUE LISTHEAD
        ADD     #U.BUF,R3       ;;;


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;;;SAVE CURRENT APR6 MAPPING

        .ENDC


;
; GET NEXT REQUEST FROM SAMPLE QUEUE AND PROCESS
;

        .ENABL  LSB
NXTRQ:  MOV     (R3),R3         ;;;GET ADDRESS OF NEXT SAMPLE REQUEST
        BEQ     20$             ;;;IF EQ END OF REQUEST QUEUE
        DEC     CYCNT(R3)       ;;;TIME TO SAMPLE?
        BNE     NXTRQ           ;;;IF NE NO
10$:    MOV     CRSET(R3),CYCNT(R3) ;;;RESET SAMPLE CYCLE COUNT
        JMP     @STATE(R3)      ;;;PROCESS SAMPLE REQUEST
20$:    JMP     ENDRQ           ;;;


        .IF DF  L$$SDR

;
; START SAMPLING IF DIGITAL INPUT BIT SET
;

SWAIT:  MOV     #1,CYCNT(R3)    ;;;SET TO REPEAT TEST AT NEXT INTERVAL
        BIT     DBMSK(R3),TEMP  ;;;START SAMPLING?
        BNE     NXTRQ           ;;;IF NE NO
        BITB    #STROT,RSTAT(R3) ;;;SET DIGITAL OUTPUT BIT AT START?
        BEQ     30$             ;;;IF EQ NO

;
; SET DIGITAL OUTPUT BIT
;

SDOUT:  BIS     DBMSK(R3),14(R4) ;;;SET DIGITAL OUTPUT BIT
30$:    MOV     STRST(R3),STATE(R3) ;;;CHANGE STATE TO STARTING VALUE
        BR      10$             ;;;DISPATCH ON NEW STATE

        .IFTF

        .DSABL  LSB

;
; SYNCHRONOUS HISTOGRAM SAMPLING
;

SYNHS:  INC     DATAW(R3)       ;;;INCREMENT EVENT COUNTER
        BEQ     10$             ;;;IF EQ COUNTER OVERFLOW
        TST     4(R4)           ;;;SCHMITT TRIGGER 1 FIRE?
        BPL     NXTRQ           ;;;IF PL NO
10$:    BIC     #100000,4(R4)   ;;;CLEAR SCHMITT TRIGGER 1 FLAG
        MOV     DATAW(R3),R2    ;;;GET EVENT COUNTER
        CLR     DATAW(R3)       ;;;CLEAR EVENT COUNTER
        CALL    WRWRD           ;;;WRITE WORD INTO USER BUFFER
        BR      NXTRQ           ;;;CONTINUE SCAN

        .IFT


;
; SYNCHRONOUS DIGITAL OUTPUT
;

SYNDO:                          ;;;REF LABEL
        CALL    RDWRD           ;;;READ WORD FROM USER BUFFER
        BCS     NXTRQ           ;;;IF CS BUFFER OVERRUN
        MOV     14(R4),-(SP)    ;;;READ DIGITAL OUTPUT REGISTER
        MOV     DATAW(R3),-(SP) ;;;GET OUTPUT MASK WORD
        BIC     (SP),R2         ;;;CLEAR EXCESS BITS IN DATA WORD
        COM     (SP)            ;;;COMPLEMENT MASK WORD
        BIC     (SP)+,(SP)      ;;;CLEAR FIELD BITS IN OUTPUT WORD
        BIS     (SP)+,R2        ;;;MERGE DATA AND OUTPUT WORD
        MOV     R2,14(R4)       ;;;WRITE VALUE INTO DIGITAL OUTPUT REGISTER
        BR      NXTRQ           ;;;CONTINUE SCAN

        .ENDC


;
; SYNCHRONOUS A/D SAMPLING
;

SYNAD:                          ;;;REF LABEL


        .IF DF  L$$SBF


        .IF GT  L$$PS1-1

        TSTB    ADFLG(R1)       ;;;A/D CONVERSIONS DISABLED?

        .IFF

        TSTB    ADFLG           ;;;A/D CONVERSIONS DISABLED?

        .ENDC


        BNE     NXTRQ           ;;;IF NE YES -- IGNORE REQUEST

        .ENDC


        MOV     DATAW(R3),-(SP) ;;;SET COUNT & STARTING CHANNEL
ADSLCT:                         ;;;REF LABEL


        .IF DF  L$$SBF


        .IF GT  L$$PS1-1

        TSTB    U.CW2(R5)       ;;;BANDWIDTH FILTERING ENABLED?
        BPL     10$             ;;;IF PL NO
        CMPB    (SP),ADCHN(R1)  ;;;IS A/D CHANNEL SELECTED?

        .IFF

        CMPB    (SP),ADCHN      ;;;IS A/D CHANNEL SELECTED?

        .ENDC


        BEQ     ADSMPL          ;;;IF EQ YES
        JMP     SDELAY          ;;;SELECT CHANNEL AND DELAY

        .ENDC


10$:    MOVB    (SP),1(R4)      ;;;SET NUMBER OF CHANNEL TO CONVERT
ADSMPL:                         ;;;REF LABEL
        MOVB    #1,(R4)         ;;;START CONVERSION
        MOV     #TMOCNT,R2      ;;;SET TIMEOUT LOOP COUNT
20$:    BIT     #100200,(R4)    ;;;ERROR OR DONE?
        BMI     80$             ;;;IF MI ERROR


        .IF DF  L$$SGR

        BNE     30$             ;;;IF NE DONE

        .IFF

        BNE     90$             ;;;IF NE DONE

        .IFTF

        DEC     R2              ;;;TIMEOUT?
        BGT     20$             ;;;IF GT NO

        .IFT

        BR      70$             ;;;TIMEOUT
30$:    BITB    #GAINR,RSTAT(R3) ;;;GAIN RANGING REQUESTED?
        BEQ     90$             ;;;IF EQ NO
        MOVB    (SP),R2         ;;;GET A/D CHANNEL NUMBER
        ASL     R2              ;;;CONVERT TO WORD INDEX
        MOV     2(R4),-(SP)     ;;;READ CONVERTED VALUE
        BIT     $BTMSK(R2),U.CW3(R5) ;;;UNIPOLAR CHANNEL?
        BNE     40$             ;;;IF NE YES
        SUB     #4000,(SP)      ;;;SUBTRACT OUT OFFSET BIAS
        BPL     35$             ;;;IF PL OKAY
        NEG     (SP)            ;;;NEGATE RESULT
35$:    ASL     (SP)            ;;;NORMALIZE RESULT
40$:    MOV     (SP)+,R2        ;;;COPY NORMALIZED VALUE
        BIT     #6000,R2        ;;;SAMPLE AT GAIN 1?
        BNE     90$             ;;;IF NE YES
        ADD     #<1*20>*400,(R4) ;;;SET TO SAMPLE AT GAIN 4
        BIT     #1400,R2        ;;;SAMPLE AT GAIN 4?
        BNE     50$             ;;;IF NE YES
        ADD     #<1*20>*400,(R4) ;;;SET TO SAMPLE AT GAIN 16.
        BIT     #300,R2         ;;;SAMPLE AT GAIN 16.?
        BNE     50$             ;;;IF NE YES
        ADD     #<1*20>*400,(R4) ;;;SET TO SAMPLE AT GAIN 64.
50$:    INC     (R4)            ;;;START CONVERSION
        MOV     #TMOCNT,R2      ;;;SET TIMEOUT LOOP COUNT
60$:    BIT     #100200,(R4)    ;;;ERROR OR DONE?
        BMI     80$             ;;;IF MI ERROR
        BNE     90$             ;;;IF NE DONE
        DEC     R2              ;;;TIMEOUT?
        BGT     60$             ;;;IF GT NO

        .IFTF

70$:    MOV     #177777,R2      ;;;SET TIMEOUT ERROR VALUE
        BR      100$            ;;;
80$:    MOV     #177776,R2      ;;;SET CONVERSION ERROR VALUE
        BR      100$            ;;;
90$:    MOV     2(R4),R2        ;;;READ CONVERTED VALUE

        .IFT

        BIC     #147777,(R4)    ;;;CLEAR ALL BUT GAIN BITS
        BIS     (R4),R2         ;;;INSERT GAIN CODE

        .ENDC


100$:   CALL    WRWRD           ;;;WRITE WORD INTO USER BUFFER
        BCS     110$            ;;;IF CS BUFFER OVERRUN
        INCB    (SP)            ;;;INCREMENT CHANNEL NUMBER
        DECB    1(SP)           ;;;ANY MORE CHANNELS TO SAMPLE?
        BGT     ADSLCT          ;;;IF GT YES
110$:   TST     (SP)+           ;;;CLEAN STACK
        JMP     NXTRQ           ;;;CONTINUE SCAN


        .IF DF  L$$SDA

;
; SYNCHRONOUS D/A OUTPUT
;

SYNDA:                          ;;;REF LABEL
        MOV     DATAW(R3),-(SP) ;;;SET COUNT AND STARTING D/A NUMBER
10$:    CALL    RDWRD           ;;;READ WORD FROM USER BUFFER
        BCS     60$             ;;;IF CS BUFFER OVERRUN
        BIC     #170000,R2      ;;;CLEAR D/A NUMBER FIELD
        MOVB    (SP),-(SP)      ;;;COPY D/A NUMBER
        DECB    (SP)            ;;;D/A 0 OR 1?
        BMI     20$             ;;;IF MI D/A 0 (X-REG)
        BEQ     30$             ;;;IF EQ D/A 1 (Y-REG)
        DECB    (SP)            ;;;NORMALIZE EXTERNAL D/A NUMBER
        RORB    (SP)            ;;;ROTATE D/A NUMBER INTO PLACE
        RORB    (SP)            ;;;
        RORB    (SP)            ;;;
        RORB    (SP)            ;;;
        SWAB    R2              ;;;SWAP DATA BYTES
        BISB    (SP)+,R2        ;;;MERGE D/A NUMBER WITH DATA
        SWAB    R2              ;;;SWAP BACK DATA BYTES
        MOV     R2,24(R4)       ;;;OUTPUT DATA TO PROPER D/A
        BR      50$             ;;;
20$:    MOV     R2,20(R4)       ;;;OUTPUT TO X-REG D/A
        BR      40$             ;;;
30$:    MOV     R2,22(R4)       ;;;OUTPUT TO Y-REG D/A
40$:    TST     (SP)+           ;;;CLEAN STACK
50$:    INC     (SP)            ;;;INCREMENT D/A NUMBER
        DECB    1(SP)           ;;;ANY MORE TO GO?
        BGT     10$             ;;;IF GT YES
60$:    TST     (SP)+           ;;;CLEAN STACK
        JMP     NXTRQ           ;;;CONTINUE SCAN

        .ENDC


        .IF DF  L$$SDR

;
; SYNCHRONOUS DIGITAL INPUT SAMPLING
;

SYNDI:                          ;;;REF LABEL


        .IF GT  L$$PS1-1

        MOV     DGIWD(R1),R2    ;;;GET SAVED DIGITAL INPUT WORD

        .IFF

        MOV     DGIWD,R2        ;;;GET SAVED DIGITAL INPUT WORD

        .ENDC


        MOV     DATAW(R3),-(SP) ;;;GET INPUT MASK WORD
        BIC     (SP)+,R2        ;;;CLEAR EXCESS BITS IN DATA WORD               ;BS049
        CALL    WRWRD           ;;;WRITE WORD INTO USER BUFFER                  ;**-3
        JMP     NXTRQ           ;;;CONTINUE SCAN

        .ENDC


;
; END OF REQUEST QUEUE-CHECK IF FORK REQUIRED
;

ENDRQ:                          ;;;REF LABEL


        .IF DF M$$MGE

        MOV     (SP)+,KISAR6    ;;;RESTORE APR6 MAPPING

        .ENDC


        .IF GT  L$$PS1-1

        MOV     (SP)+,R1        ;;;RESTORE R1

        .ENDC


        MOV     (SP)+,R2        ;;;RESTORE R2 AND R3
        MOV     (SP)+,R3        ;;;
        TST     FKFLG           ;;;FORK REQUESTED?
        BEQ     10$             ;;;IF EQ NO
        CLR     FKFLG           ;;;CLEAR FORK REQUESTED FLAG
        BITB    #US.FRK,U.STS(R5) ;;;FORK ALREADY IN PROGRESS?
        BEQ     ENDRQ1          ;;;IF EQ NO
10$:    JMP     $INTXT          ;;;EXIT INTERRUPT

;+
; **-LSCAN-CANCEL I/O REQUESTS
;
; THIS ROUTINE IS ENTERED TO CANCEL ALL I/O REQUESTS THAT ARE IN PROGRESS FOR
; THE CURRENT TASK. THE SAMPLE QUEUE IS SCANNED AND ALL REQUESTS FOR THE CURRENT
; TASK ARE MARKED FOR TERMINATION WITH A FINAL REQUEST STATUS OF 'IE.ABO'.
;
; INPUTS:
;
;       R0=ADDRESS OF THE CURRENT I/O PACKET (MEANINGLESS).
;       R1=ADDRESS OF THE TCB OF THE CURRENT TASK.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       ALL REQUESTS FOR THE CURRENT TASK ARE MARKED FOR TERMINATION WITH
;       A FINAL STATUS OF 'IE.ABO'.
;-

        .ENABL  LSB
LSCAN:  MOV     #IE.ABO&377,R0  ;;;SET FINAL STATUS CODE TO ABORT
        BR      10$             ;;;FINISH IN COMMON CODE

;+
; **-LSOUT-DEVICE TIMEOUT
;
; THIS ROUTINE IS ENTERED WHEN AN LPS11 OPERATION TIMES OUT. ALL REQUESTS IN THE
; SAMPLE QUEUE ARE MARKED FOR TERMINATION WITH A FINAL STATUS OF 'IE.DNR'.
; TIMEOUTS ARE USUALLY CAUSED BY A POWERFAILURE BUT MAY ALSO BE THE RESULT
; OF A HARDWARE FAILURE.
;
; INPUTS:
;
;       R0=DEVICE TIMEOUT STATUS 'IE.DNR'.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       ALL REQUESTS ARE MARKED FOR TERMINATION WITH A FINAL STATUS OF
;       'IE.DNR'.
;-

LSOUT:  MOV     S.CSR(R4),R2    ;;;GET ADDRESS OF CONTROL STATUS REGISTER
        CLR     (R2)            ;;;CLEAR A/D INTERRUPTS
        CLR     4(R2)           ;;;CLEAR CLOCK INTERRUPTS
10$:    MOV     R5,R2           ;;;CALCULATE ADDRESS OF SAMPLE QUEUE LISTHEAD
        ADD     #U.BUF,R2       ;;;
20$:    MOV     (R2),R2         ;;;GET ADDRESS OF NEXT ENTRY
        BEQ     40$             ;;;IF EQ NONE
        CMPB    #IE.ABO,R0      ;;;CANCEL I/O?
        BNE     30$             ;;;IF NE NO
        MOV     RQPKT(R2),R3    ;;;GET ADDRESS OF I/O PACKET
        CMP     R1,I.TCB(R3)    ;;;REQUEST FOR CURRENT TASK?
        BNE     20$             ;;;IF NE NO
30$:    BISB    #STPRQ,RSTAT(R2) ;;;SET TO TERMINATE SAMPLE REQUEST
        MOVB    R0,FINST(R2)    ;;;SET FINAL REQUEST STATUS
        MOV     #NXTRQ,STATE(R2) ;;;SET STATE TO TERMINATION IN PROGRESS
        BR      20$             ;;;
40$:    CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        BR      ENDRQ2          ;FINISH IN COMMON CODE
        .DSABL  LSB

;+
; **-LSPWF-POWERFAIL
;
; THIS ROUTINE IS ENTERED AS THE RESULT OF A POWERFAILURE. POWERFAIL IS HANDLED
; VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES NO IMMEDIATE ACTION ON
; THE DEVICE. THE UNIT CONTROL BLOCK ADDRESS IS STORED IN THE DRIVER CONTROLLER
; TABLE.
;
; INPUTS:
;
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       THE UNIT CONTROL BLOCK ADDRESS IS STORED IN THE DRIVER CONTROLLER TABLE.
;-

LSPWF:  MOV     R5,CNTBL(R3)    ;SET ADDRESS OF UNIT CONTROL BLOCK
        RETURN                  ;

;
; FORK REQUESTED AND NO FORK IN PROGRESS
;

ENDRQ1: BISB    #US.FRK,U.STS(R5) ;;;SET FORK IN PROGRESS FLAG
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        BICB    #US.FRK,U.STS(R5) ;CLEAR FORK IN PROGRESS FLAG

;
; SCAN SAMPLE QUEUE FOR EVENT FLAG AND TERMINATION REQUESTS
;

ENDRQ2: MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOVB    S.PRI(R4),PS    ;;;LOCK OUT DEVICE INTERRUPTS
        MOV     R5,R4           ;;;CALCULATE ADDRESS OF SAMPLE QUEUE LISTHEAD
        ADD     #U.BUF,R4       ;;;
10$:    MOV     R4,R3           ;;;SAVE ADDRESS OF PREVIOUS ENTRY
        MOV     (R3),R4         ;;;GET ADDRESS OF NEXT ENTRY
        BEQ     70$             ;;;IF EQ NONE
        BITB    #STPRQ,RSTAT(R4) ;;;TERMINATE REQUEST?
        BNE     20$             ;;;IF NE YES
        BITB    #RQEFN,RSTAT(R4) ;;;REQUEST EFN SETTING?
        BEQ     10$             ;;;IF EQ NO
        BICB    #RQEFN,RSTAT(R4) ;;;CLEAR EFN REQUEST FLAG
        CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        MOV     RQPKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        MOV     I.TCB(R3),R0    ;GET TCB ADDRESS OF REQUESTING TASK
        BIT     #T2.ABO,T.ST2(R0) ;TASK BEING ABORTED?
        BNE     ENDRQ2          ;IF NE YES
        BIS     I.PRM+14(R3),@I.PRM+16(R3) ;SET SPECIFIED EVENT FLAG
        CALL    $SETCR          ;SET A CONDITIONAL SCHEDULE REQUEST
        BR      ENDRQ2          ;TRY AGAIN
20$:    MOV     (R4),(R3)       ;;;REMOVE ENTRY FROM QUEUE
30$:    CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS


        .IF DF  L$$SDR

        MOV     DATAW(R4),R3    ;GET DATA MASK WORD
        COM     R3              ;CONVERT MASK TO IN USE BITS
        CMP     #SYNDO,STRST(R4) ;SYNCRHONOUS DIGITAL OUTPUT?
        BEQ     40$             ;IF EQ YES
        CMP     #SYNDI,STRST(R4) ;SYNCHRONOUS DIGITAL INPUT
        BNE     50$             ;IF NE NO
        BIC     R3,U.CNT(R5)    ;CLEAR INPUT BITS IN USE MASK
        BR      50$             ;
40$:    BIC     R3,U.CNT+2(R5)  ;CLEAR OUTPUT BITS IN USE MASK
50$:    BITB    #STROT,RSTAT(R4) ;SET DIGITAL OUTPUT BIT ON START?
        BEQ     60$             ;IF EQ NO
        BIC     DBMSK(R4),U.CNT+2(R5) ;CLEAR OUTPUT BIT IN USE MASK

        .ENDC


60$:    CLR     R0              ;PICKUP FINAL I/O STATUS
        BISB    FINST(R4),R0    ;


        .IF DF  M$$MGE

        MOV     KISAR6,-(SP)    ;SAVE CURRENT APR6 MAPPING
        MOV     IOSB2(R4),KISAR6  ;MAP TO SECOND I/O STATUS WORD

        .IFTF

        MOV     @IOSB2+2(R4),R1 ;RETRIEVE CONTENTS OF SECOND I/O STATUS WORD

        .IFT

        MOV     (SP)+,KISAR6    ;RESTORE APR6

        .ENDC


        MOV     RQPKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        MOV     R4,-(SP)        ;SAVE ADDRESS OF SECONDARY CONTROL BLOCK
        CLR     I.PRM+16(R3)    ;CLEAR BLOCK LOCKING WORD FOR $IOFIN
        CALL    $IOFIN          ;FINISH I/O OPERATION
        MOV     (SP)+,R0        ;RETRIEVE ADDRESS OF SECONDARY CONTROL BLOCK
        MOV     #SLGTH,R1       ;SET LENGTH OF SECONDARY CONTROL BLOCK
        CALL    $DEACB          ;RELEASE SECONDARY CONTROL BLOCK
        BR      ENDRQ2          ;GO AGAIN

;
; SCAN OF SAMPLE QUEUE COMPLETE-CHECK IF ANYTHING IS STILL ACTIVE
;

70$:    MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET DEVICE TIMEOUT COUNT
        TST     U.BUF(R5)       ;;;ANY REQUESTS IN SAMPLE QUEUE
        BNE     80$             ;;;IF NE YES
        MOV     S.CSR(R4),R3    ;;;GET ADDRESS OF CONTROL STATUS REGISTER
        CLR     (R3)            ;;;CLEAR A/D INTERRUPTS
        CLR     4(R3)           ;;;CLEAR CLOCK INTERRUPTS
        BICB    #US.BSY,U.STS(R5) ;;;CLEAR UNIT BUSY
        CLRB    S.STS(R4)       ;;;CLEAR CONTROLLER BUSY


        .IF DF  L$$SBF


        .IF GT  L$$PS1-1

        MOVB    S.CON(R4),R1    ;;;GET CONTROLLER INDEX
        MOV     #377,ADCHN(R1)  ;;;INVALIDATE A/D CHANNEL INFO

        .IFF

        MOV     #377,ADCHN      ;;;INVALIDATE A/D CHANNEL INFO

        .ENDC

        .ENDC


80$:    CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        RETURN                  ;

;
; SUBROUTINE TO READ A VALUE FROM USER BUFFER
;

        .ENABL  LSB

RDWRD:                          ;;;REF LABEL


        .IF DF  M$$MGE

        MOV     IOSB2(R3),KISAR6  ;;;MAP TO SECOND I/O STATUS WORD

        .IFTF

        INC     @IOSB2+2(R3)    ;;;INCREMENT FREE POSITIONS IN BUFFER
        CMP     FULBF(R3),@IOSB2+2(R3) ;;;BUFFER OVERRUN?
        BLO     70$             ;;;IF LO YES

        .IFT

        MOV     CURBF(R3),KISAR6  ;;;MAP TO USER BUFFER

        .IFTF

        MOV     @CURBF+4(R3),R2 ;;;READ VALUE FROM USER BUFFER
        BR      10$             ;;;FINISH IN COMMON CODE

;
; SUBROUTINE TO WRITE A VALUE INTO USER BUFFER
;

WRWRD:                          ;;;REF LABEL

        .IFT

        MOV     IOSB2(R3),KISAR6  ;;;MAP TO SECOND I/O STATUS WORD

        .IFTF

        INC     @IOSB2+2(R3)    ;;;INCREMENT NUMBER OF ENTRIES IN BUFFER
        CMP     FULBF(R3),@IOSB2+2(R3) ;;;BUFFER OVERRUN?
        BLO     70$             ;;;IF LO YES

        .IFT

        MOV     CURBF(R3),KISAR6  ;;;MAP TO USER BUFFER

        .IFTF

        MOV     R2,@CURBF+4(R3) ;;;WRITE VALUE INTO USER BUFFER
10$:    ADD     #2,CURBF+4(R3)  ;;;UPDATE USER BUFFER ADDRESS

        .IFT

        BIT     #20000,CURBF+4(R3) ;;;OVERFLOW 4K BOUNDRY?
        BEQ     20$             ;;;IF EQ NO
        BIC     #20000,CURBF+4(R3) ;;;CLEAR OVERFLOW BIT
        ADD     #200,CURBF(R3)  ;;;ADVANCE TO NEXT 4K BOUNDRY

        .IFTF

20$:    DEC     SMCNT(R3)       ;;;END OF BUFFER?
        BNE     30$             ;;;IF NE NO

        .IFT

        MOV     STRBF(R3),CURBF(R3) ;;;RESET RELOCATION BIAS

        .ENDC


        MOV     STRBF+4(R3),CURBF+4(R3) ;;;RESET BUFFER ADDRESS
        MOV     FULBF(R3),SMCNT(R3) ;;;RESET SAMPLE BUFFER COUNT
        BITB    #STPBR,RSTAT(R3) ;;;STOP ON BUFFER RUNOUT?
        BEQ     40$             ;;;IF EQ NO
        DEC     SAMCT(R3)       ;;;DECREMENT BUFFER COUNT
        BEQ     60$             ;;;IF EQ BUFFER RUNOUT
        BR      40$             ;;;
30$:    CMP     SMCNT(R3),HAFBF(R3) ;;;EXACTLY AT HALF BUFFER?
        BNE     50$             ;;;IF NE NO
40$:    BISB    #RQEFN,RSTAT(R3) ;;;REQUEST EFN SETTING
        INC     FKFLG           ;;;SET FORK REQUEST
50$:    CLC                     ;;;CLEAR OVERRUN INDICATOR


        .IF DF  L$$SDR

        BIT     DSMSK(R3),TEMP  ;;;STOP BIT CLEAR?
        BEQ     90$             ;;;IF EQ NO

        .IFF

        BR      90$             ;;;RETURN

        .ENDC


60$:    MOVB    #IS.SUC,FINST(R3) ;;;SET SUCCESSFUL COMPLETION STATUS
        BR      TERMS           ;;;
70$:    MOVB    #IE.DAO,FINST(R3) ;;;SET FINAL STATUS TO BUFFER OVERRUN
        DEC     @IOSB2+2(R3)    ;;;READJUST BUFFER FREE COUNT
TERMS:  BISB    #STPRQ,RSTAT(R3) ;;;SET TO TERMINATE SAMPLE REQUEST
        MOV     #NXTRQ,STATE(R3) ;;;SET STATE TO TERMINATION IN PROGRESS
        INC     FKFLG           ;;;SET FORK REQUEST
        SEC                     ;;;SET OVERRUN/TERMINATION INDICATOR
90$:    RETURN                  ;;;
        .DSABL  LSB


;
; SELECT A/D CHANNEL AND SETUP A DELAY
;


        .IF DF  L$$SBF

SDELAY: MOVB    (SP),1(R4)      ;;;SELECT THE A/D CHANNEL
        MOV     (SP),STKSAV(R3) ;;;SAVE CHANNEL (DATAW) INFO
        MOV     #ENDLAY,STATE(R3)  ;;;SET NEW DISPATCH ADDRESS


        .IF GT  L$$PS1-1

        MOV     DLYCNT(R1),CYCNT(R3)  ;;;SET DELAY COUNT
        MOV     (SP)+,ADCHN(R1) ;;;STORE A/D CHANNEL NUMBER AND
                                ;;;   DISABLE A/D CONVERSIONS

        .IFF

        MOV     DLYCNT,CYCNT(R3)  ;;;SET DELAY COUNT
        MOV     (SP)+,ADCHN     ;;;STORE A/D CHANNEL NUMBER AND
                                ;;;   DISABLE A/D CONVERSIONS

        .ENDC


        JMP     NXTRQ           ;;;DEQUEUE NEXT REQUEST

;
; END OF CHANNEL SELECT DELAY PERIOD
;

ENDLAY: MOV     STKSAV(R3),-(SP)  ;;;PUT CHANNEL INFO ON STACK
        MOV     #SYNAD,STATE(R3)  ;;;RESTORE A/D DISPATCH ADDR


        .IF GT  L$$PS1-1

        CLRB    ADFLG(R1)       ;;;ENABLE A/D SAMPLING

        .IFF

        CLRB    ADFLG           ;;;ENABLE A/D SAMPLING

        .ENDC


        JMP     ADSMPL          ;;;CONTINUE A/D SAMPLING


        .ENDC



        .END
        .TITLE  MMDRV
        .IDENT  /5.04/
 
;
; COPYRIGHT (C) 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 05.04
;
; JANICE CLEARY 15-SEP-75
;
;       J. CLEARY       27-DEC-78
;
;               JC026 -- ADD CHECK FOR IQ.X IN SELERR
;
;       J. CLEARY       27-DEC-78
;
;               JC027 -- CLEAN UP TIMEOUT FOR CASE WHERE DRIVE HANGS CNTRLR
;
;       J. CLEARY       23-JAN-79
;
;               JC028 -- ADD SUPPORT FOR MULTI-CONTROLLERS
;
;       J. CLEARY       23-JAN-79
;
;               JC029 -- ADD RH11 SUPPORT FOR 22-BIT ADDRESSING
;
;       J. CLEARY       9-FEB-79
;
;               JC030 -- INCLUDE POWERFAIL CODE
;
;       J. CLEARY       10-MAR-79
;
;               JC033 -- FIX PROBLEM IN CHKEOV
;
;       J. CLEARY       4-APR-79
;
;               JC038 -- FIX DENSITY SELECTION ON TM03
;
;       E. BAATZ        21-APR-79
;
;               EB205 -- INCREASE SIMILARITY WITH M-PLUS MMDRV
;
;       J. CLEARY       24-MAY-79
;
;               JC040 -- FIX PROBLEM WITH EXTRA TAPE MARK COUNT WHEN
;                        EOT ENCOUNTERED ON SPACE FILES
;
; RH11/RH70 TM02/TM03 MAGNETIC TAPE CONTROLLER DRIVER
.PAGE
;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$,PKTDF$,ABODF$
        HWDDF$
        PKTDF$
        ABODF$


        .IF DF  D$$IAG

        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS

        .ENDC


;
; EQUATED SYMBOLS
;


US.ABO=1                        ;ABORT IN PROGRESS - U.STS
US.SUP=2                        ;SUPRESS ERROR RECOVERY
US.PWF=10                       ;POWER FAIL STATUS
RETRY=12                        ;RETRY COUNT
RQFLAG=76                       ;USED TO SEE WHETHER $RLCH SHOULD BE CALLED
MINREC=14.                      ;MINIMUM RECORD SIZE
REV   = 2                       ;REVERSE BIT FOR SPACE OPERATIONS
TIMOUT = 8.                     ;INITIAL TIMPOUT COUNT
.PAGE

;
;       REGISTER DEFINITION AND OFFSETS
;
;
RHCS1   = +0                    ;RH CONTROL AND STATUS
C1.GO=1                         ;GO
C1.IE=100                       ;INTERRUPT ENABLE
C1.RDY=200                      ;CONTROLLER READY BIT
C1.PSL=2000                     ;PORT SELECT
C1.DVA=4000                     ;DEVICE AVAILABLE
C1.TRE=40000                    ;TRANSFER ERROR
C1.CPE=20000                    ;CONTROL PARITY ERROR
C1.SC=100000                    ;SPECIAL CONDITION


FC.RWU=103                      ;REWIND, OFF-LINE
FC.RWD=107                      ;REWIND
FC.ERS=125                      ;ERASE COMMAND
FC.WEF=127                      ;WRITE EOF (TAPE MARK)
FC.SPF=131                      ;SPACE FORWARD
FC.SPR=133                      ;SPACE REVERSE COMMAND
FC.WRT=161                      ;WRITE
FC.RED=171                      ;READ
FC.REV=177                      ;READ REVERSE
FC.CLR=11                       ;DRIVE CLEAR

RHWC    = +2                    ;RH WORD COUNT REGISTER
RHBA    = +4                    ;RH BUS ADDRESS REGISTER (LOW ORDER 16 BITS)
MTFC    = +6                    ;TM02/TM03 FRAME COUNT REGISTER
RHCS2   = +10                   ;RH CONTROL AND STATUS REGISTER 2
 
C2.CLR= 40                      ;CONTROLLER CLEAR
C2.DPE= 400                     ;CONTOLLER DATA PARITY ERROR
C2.OR=200                       ;OUTPUT READY
C2.IR=100                       ;INPUT READY
C2.MXF= 1000                    ;MISSED TRANSFER
C2.PGE= 2000                    ;PROGRAM ERROR
C2.NEM= 4000                    ;NON-EXISTENT MEMORY
C2.NED= 10000                   ;NON-EXISTENT DRIVE
C2.UPE= 20000                   ;UNIBUS PARITY ERROR
C2.WCE= 40000                   ;WRITE CHECK ERROR
C2.DLT= 100000                  ;DATA LATE
 
FTLRH = C2.UPE!C2.NED!C2.NEM!C2.PGE!C2.MXF      ;FATAL RH ERRORS
MTDS    = +12                   ;TM02/TM03 DRIVE STATUS REGISTER
DS.SLA=1                        ;SLAVE ATTENTION
DS.BOT=2                        ;BEGINNING OF TAPE
DS.TM=4                         ;TAPE MARK DETECTED
DS.IDB=10                       ;IDENTIFICATION BURST
DS.SDN=20                       ;SETTLE DOWN
DS.PES=40                       ;PHASE ENCODED STATUS
DS.SSC=100                      ;SLAVE STATUS CHANGE
DS.DRY=200                      ;DRIVE READY
DS.DPR=400                      ;DRIVE PRESENT
DS.EOT=2000                     ;END OF TAPE DETECTED
DS.WRL=4000                     ;WRITE LOCK
DS.MOL=10000                    ;MEDIUM ON LINE
DS.PIP=20000                    ;POSITIONING IN PROGRESS
DS.ERR=40000                    ;ERROR COMPOSITE
DS.ATA=100000                   ;ATTENTION

MTER    = +14                   ;TM02/TM03 ERROR REGISTER
ER.ILF=1                        ;ILLEGAL FUNCTION
ER.ILR=2                        ;ILLEGAL REGISTER
ER.RMR=4                        ;REGISTER MODIFICATION REFUSED
ER.CPR=10                       ;CONTROL BUS PARITY ERROR
ER.FMT=20                       ;FORMAT ERROR
ER.DPR=40                       ;DATA PARITY ERROR
ER.INC=100                      ;INCORRECTABLE DATA (PE ONLY)
ER.VPE=ER.INC                   ;VERTICAL PARITY ERROR (NRZI ONLY)
ER.PEF=200                      ;FORMAT ERROR (PE ONLY)
ER.LRC=ER.PEF                   ;LRCC ERROR (NRZI ONLY)
ER.NSG=400                      ;NON-STANDARD GAP
ER.FCE=1000                     ;FRAME COUNT ERROR
ER.CS=2000                      ;CORRECTABLE SKEW -- PE MODE
ER.ITM=ER.CS                    ;ILLEGAL TAPE MARK -- NRZI MODE
ER.NEF=4000                     ;NON-EXECUTABLE FUNCTION
ER.DTE=10000                    ;DRIVE TIMING ERROR
ER.OPI=20000                    ;OPERATION INCOMPLETE
ER.UNS=40000                    ;DRIVE UNSAFE
ER.COR=100000                   ;CORRECTABLE DATA (PE ONLY)
ER.CRC=ER.COR                   ;CRC ERROR (NRZI ONLY)

ER.FTL=ER.ILF!ER.ILR!ER.RMR!ER.CPR!ER.FMT!ER.NEF!ER.OPI!ER.UNS  ;FATAL ERRORS

RHAS    = +16                   ;RH ATTENTION SUMMARY REGISTER
MTCK    = +20                   ;TM02/TM03 CRC OR DEAD TRACK REGISTER
MTDB    = +22                   ;TM02/TM03 DATA BUFFER
MTMR    = +24                   ;TM02/TM03 MAINTENANCE REGISTER
MTDT    = +26                   ;TM02/TM03 DRIVE TYPE REGISTER
 
DT.SPR=200                      ;SLAVE PRESENT
DT.DRQ=4000                     ;DRIVE REGISTER REQUEST
DT.7CH=10000                    ;SEVEN CHANNEL DRIVE
DT.MOH=20000                    ;MOVING HEAD DEVICE
DT.TAP=40000                    ;TAPE
DT.NSA=100000                   ;NOT SECTOR ADDRESSED
 
MTSN    = +30                   ;TM02/TM03 SERIEL NUMBER
MTTC    = +32                   ;TM02/TM03 TAPE CONTROL REGISTER

TC.1600=2000                    ;1600 BPI
TC.800=1000                     ;800 BPI
TC.FMT=300                      ;FORMATTING BITS - PDP-11 NORMAL
TC.EVN=10                       ;EVEN PARITY


        .IF DF  M$$IXD

RHBAE=  74                      ;MIXED MASSBUS ADDRESS EXT. REGISTER
                                ;THIS CANNOT BE=74 IF CSR=XXXXXX40

        .IFF

RHBAE=  34                      ;BUS ADDRESS EXTENSION REGISTER

        .ENDC


;
; THE FOLLOWING DEFINITIONS ARE THE BIT POSITIONS IN THE MAG TAPE STATUS
; REGISTER.  UNFORTUNATELY, THEY WERE DEFINED ORIGINALLY FOR A TM11 DRIVER,
; SO THAT SOME OF THE BIT POSITIONS REFLECT THE HARDWARE REGISTERS FOR
; THAT CONTROLLER
;

M.PEOV=100000                   ;TAPE PAST LOGICAL END OF VOLUME
M.AEOV=40000                    ;TAPE AT LOGICAL END OF VOLUME
M.BOT=20000                     ;TAPE AT BOT
M.1600=4000                     ;1600 BPI PHASE ENCODED (9 CHANNEL ONLY)
M.HWL=2000                      ;HARDWARE WRITE LOCK
M.RWD=1000                      ;UNIT IS REWINDING
M.SER=400                       ;SELECT ERROR HAS OCCURRED
M.IXG=200                       ;INHIBIT WRITE WITH EXTENDED INTERRECORD
M.SWL=100                       ;SOFTWARE WRITE LOCK
M.EOF=40                        ;LAST COMMAND ENCOUNTERED TAPE MARK
M.EOT=20                        ;LAST COMMAND ENCOUNTERED EOT
M.EVN=10                        ;EVEN PARITY

USRBTS=4310                     ;STATUS BITS CONTROLLED BY THE USER
NEWBTS=M.PEOV!M.BOT!M.EOF!M.EOT ;BITS TO BE SET BEFORE $IODON CALLED
;
;       UCB EXTENSION BITS FOR MAGTAPE DRIVER
;
.PAGE

;
; LOCAL MACROS
;
;
;
;
;       SETRTY - MACRO TO SETUP RETURN ADDRESS AND REPOSITIONING COMMAND
;               FOR ERROR RECOVERY PROCEEDURES
;
.MACRO  SETRTY  RETADR,FCCDE,CNT
        MOV     #FRTRY,R1               ;SET RETRY INDEX
        MOV     #'RETADR,DONTBL(R1)     ;SET RETURN ADDRESS
        MOV     #FC.'FCCDE,U.BUF(R5)    ;SET FUNCTION CODE IN U.BUF
        MOV     #-'CNT,U.CNT(R5)        ;SET COMMAND COUNT
.ENDM   SETRTY
        
;
;
;       DFENT - MACRO TO DEFINE ENTRIES IN FUNCTION TABLE
;
;
;
.MACRO  DFENT   FUNC,INDX,CODE
        .WORD   FUNC            ;QIO FUNCTION CODE
        .BYTE   INDX            ;FUNCTION INDEX
        .BYTE   CODE            ;HARDWARE FUNCTION CODE
.ENDM   DFENT
.PAGE
;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;
; DIAGNOSTIC FUNCTIONS USE BIT 15 OF RTTBL AS A FLAG FOR INTERRUPT
; SERVICING.

CNTBL:  .BLKW   T$$J16          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   T$$J16          ;ERROR RETRY COUNT
SPTBL:  .BLKW   T$$J16          ;FOR SPACE CHECKING
FMTBL:  .BLKW   T$$J16          ;FORMAT CODE SAVE AREA
FCCDE:  .BLKW   T$$J16          ;FUNCTION CODE SAVE AREA
CMDCNT: .BLKW   T$$J16          ;COMMAND COUNT SAVE AREA
BUFADR: .BLKW   T$$J16          ;U.BUF SAVE AREA


        .IF GT  T$$J16-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC


;
;       FUNCTION CODE INDEX TABLE
;
;
FREAD   =       0               ;READ LOGICAL BLOCK
FWRTE   =       2               ;WRITE LOGICAL BLOCK
FRREV   =       4               ;READ LOGICAL BLOCK REVERSE
FWEOF   =       6               ;WRITE TAPE MARK
FERSE   =       10              ;ERASE TAPE
FRWND   =       12              ;REWIND TAPE
FRWDU   =       14              ;REWIND AND UNLOAD
FSPCR   =       16              ;SPACE RECORDS
FSPCF   =       20              ;SPACE FILES
FSETC   =       22              ;SET TAPE CHARACTERISTICS
FSENC   =       24              ;SENSE TAPE CHARACTERISTICS
FSMOU   =       26              ;SET AND MOUNT CHARACTERISTICS
FRTRY   =       30              ;RETRY IN PROGRESS
FSPRR   =       22              ;SPACE RECORD REVERSE
FSPFR   =       24              ;SPACE FILE REVERSE
.PAGE

LGFCN:
        DFENT   IO.RLB,FREAD,FC.RED     ;READ LOGICAL BLOCK
        DFENT   IO.WLB,FWRTE,FC.WRT     ;WRITE LOGICAL BLOCK
        DFENT   IO.RLV,FRREV,FC.REV     ;READ REVERSE 
        DFENT   IO.EOF,FWEOF,FC.WEF     ;WRITE TAPE MARK
        DFENT   IO.ERS,FERSE,FC.ERS     ;ERASE
        DFENT   IO.RWD,FRWND,FC.RWD     ;REWIND
        DFENT   IO.RWU,FRWDU,FC.RWU     ;REWIND AND OFF-LINE
        DFENT   IO.SPB,FSPCR,FC.SPF     ;SPACE RECORDS
        DFENT   IO.SPF,FSPCF,FC.SPF     ;SPACE FILES (TAPEMARKS)
        DFENT   IO.STC,FSETC,0          ;SET CHARACTERISTICS
        DFENT   IO.SEC,FSENC,0          ;SENSE CHARACTERISTICS
        DFENT   IO.SMO,FSMOU,0          ;MOUNT AND SET CHARACTERISTICS
ENDFCN=.                                ;END OF FUNCTION TABLE
.PAGE
;
;
;       PRE-INITIATION PROCESSING ROUTINES
;
;
PRETBL:
        .WORD   PRERED          ;READ
        .WORD   PREWRT          ;WRITE PRE-INITIATION ENTRY
        .WORD   PREREV          ;READ REVERSE PRE-INITIATION ROUTINE
        .WORD   PREEOF          ;WRITE TAPEMARK PRE-INITIATION ENTRY
        .WORD   PREERS          ;ERASE PRE-INITIATION ENTRY
        .WORD   PRECOM          ;REWIND PRE-INITIATION ENTRY
        .WORD   PRECOM          ;REWIND AND UNLOAD PRE-INITIATION ENTRY
        .WORD   PRESPC          ;SPACE RECORDS INITIATION
        .WORD   PRESPC          ;SPACE FILES INITIATION ENTRY
        .WORD   PRESTC          ;SET CHARACTERISTICS FUNCTION ROUTINE
        .WORD   PRESEC          ;SENSE CHARACTERISTICS FUNCTION ROUTINE
        .WORD   PRESMO          ;MOUNT AND SET CHARACTERISTICS FUNCTION
;
;
;       SUCCESFUL COMPLETION TABLE
;
;
DONTBL:
        .WORD   REDDON          ;READ FORWARD COMPLETION
        .WORD   WRTDON          ;WRITE FORWARD COMPLETION
        .WORD   REVDON          ;READ REVERSE COMPLETION
        .WORD   EOFDON          ;WRITE TAPE MARK COMPLETION
        .WORD   EXTNST          ;ERASE COMPLETION
        .WORD   RWDDON          ;REWIND COMPLETION
        .WORD   RWDDON          ;REWIND AND UNLOAD COMPLETION
        .WORD   SPFEXT          ;SPACE RECORD FORWARD COMPLETION
        .WORD   SPFEXT          ;SPACE FILE FORWARD COMPLETION
        .WORD   SPFEXT          ;SPACE RECORD REVERSE COMPLETION
        .WORD   SPFEXT          ;SPACE FILE REVERSE COMPLETION
        .WORD   FATAL           ;NO FUNCTION
        .WORD   FATAL           ;COMPLETION ROUTINE FOR RECOVERY
.PAGE
;
;
;       ERROR MASK TABLE
;       ER.FTL=ILF!ILR!RMR!CPR!FMT!NEF!OPI!UNS
;
ERRMSK:
        .WORD   ER.FTL!ER.DTE           ;FATAL ERROR MASK READ FUNCTION
        .WORD   ER.FTL!ER.FCE           ;FATAL ERROR MASK WRITE FUNCTION
        .WORD   ER.FTL!ER.DTE-ER.NEF-ER.OPI ;FATAL ERROR MASK READ REVERSE
        .WORD   ER.FTL!ER.FCE           ;FATAL ERROR MASK EOF FUNCTION
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.FCE!ER.CS!ER.DTE!ER.COR ;ERASE
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.FCE!ER.CS!ER.DTE!ER.COR ;REWIND
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.FCE!ER.CS!ER.DTE!ER.COR-ER.ILF ;RWD OFF
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.DTE!ER.COR ;SPACE RECORD FORWARD
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.DTE!ER.COR ;SPACE FILE FORWARD
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.DTE!ER.COR-ER.NEF-ER.OPI ;SPACE RECORD REVERSE
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.DTE!ER.COR-ER.NEF-ER.OPI ;SPACE FILE REVERSE
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.FCE!ER.CS!ER.DTE!ER.COR ;NO FUNCTION
        .WORD   ER.FTL!ER.DPR!ER.INC!ER.PEF!ER.NSG!ER.CS!ER.DTE!ER.COR ;RETRY
;
;
;       RETRY TABLE
;
;
RTYTBL:
        .WORD   REDRTY          ;READ FORWARD RETRY ENTRY POINT
        .WORD   WRTRTY          ;WRITE RETRY ENTRY POINT
        .WORD   REVRTY          ;READ REVERSE RETRY ENTRY POINT
        .WORD   WRTRTY          ;WRITE TAPE MARK RETRY ENTRY POINT
        .WORD   FATAL           ;ERASE - NOT RETRIABLE
        .WORD   FATAL           ;REWIND - NOT RETRIABLE
        .WORD   RWURTY          ;REWIND AND UNLOAD RETRY ENTRY POINT
        .WORD   SPRRTY          ;SPACE RECORD RETRY ENTRY POINT
        .WORD   SPFRTY          ;SPACE FILE FORWARD RETRY ENTRY POINT
        .WORD   SPRRTY          ;SPACE RECORD REVERSE RETRY ENTRY POINT
        .WORD   SPFRTY          ;SPACE FILE REVERSE RETRY ENTRY POINT
        .WORD   FATAL           ;NOT AN IMPLEMENTED FUNCTION
        .WORD   FATAL           ;RETRY NOT APPLICABLE ON ERROR
;
;
;       FUNCTION SPECIFIC ERROR CHECK TABLE OF ENTRY POINTS
;
;
CHKTBL:
        .WORD   REDERR          ;READ FORWARD ERROR CHECKING
        .WORD   COMRTY          ;WRITE FORWARD ERROR CHECKING
        .WORD   REVERR          ;READ REVERSE ERROR CHECKING
        .WORD   COMRTY          ;WRITE TAPE MARK ERROR CHECKING
        .WORD   FATAL           ;ERASE - ALL ERRORS FATAL
        .WORD   FATAL           ;REWIND ALL ERRORS FATAL
        .WORD   RWUERR          ;REWIND AND OFF-LINE ERROR CHECKING
        .WORD   SPFEXT          ;SPACE FORWARD ERROR CHECKING
        .WORD   SPFEXT          ;SPACE FORWARD ERROR CHECKING
        .WORD   SPRERR          ;SPACE REVERSE ERROR CHECKING
        .WORD   SPRERR          ;SPACE REVERSE ERROR CHECKING
        .WORD   FATAL           ;NOT AN IMPLEMENTED FUNCTION
        .WORD   RTYCON          ;CONTINUE RETRY ON FRAME COUNT ERRORS
.PAGE
;
; DRIVER DISPATCH TABLE
;

$MMTBL::.WORD   MMINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   MMCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   MMOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   MMPWF           ;POWERFAIL ENTRY POINT

;+
; **-MMINI-RH11/RH70 TM02/TM03 MAGNETIC TAPE CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
MMINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCC     10$             ;IF CC PROCESS REQUEST
        RETURN                  ;NOTHING TO DO OR CONTROLLER BUSY

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; RH11/RH70 TM02/TM03 MAGNETIC TAPE FUNCTION INDEPENDENT I/O REQUEST
;       PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB/IO.RWD/IO.SPB/IO.SPF/IO.EOF).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;

10$:
        MOV     R5,CNTBL(R3)            ;SAVE UCB ADDRESS
        MOV     #LGFCN,R2               ;RETRIEVE ADDRESS OF LEGAL FUNC TABLE
        MOV     I.FCN(R1),R0            ;RETREIVE FUNCTION CODE
        BICB    #US.SUP,U.STS(R5)       ;CLEAR RETRY SUPPRESS

        .IF DF  D$$IAG
 
        CLRB    RTTBL+1(R3)             ;CLEAR DIAGNOSTIC FLAG
        BITB    #IQ.UMD,R0              ;DIAGNOSTIC FUNCTION?
        BEQ     20$                     ;IF EQ NO
        MOV     #100000,RTTBL(R3)       ;STOP RETRIES AND SET DIAG. FLAG
        BICB    #IQ.UMD,R0              ;CLEAR DIAGNOSTIC BIT
        BISB    #US.SUP,U.STS(R5)       ;SUPRESS RETRIES
 
        .IFTF
 
20$:
        BITB    #IQ.X,R0                ;SUPPRESS ERROR RECOVERY?
        BEQ     30$                     ;IF EQ NO
        BISB    #US.SUP,U.STS(R5)       ;SUPPRESS ERROR RECOVERY
        BICB    #IQ.X,R0                ;CLEAR BIT
30$:    CMP     R0,(R2)+                ;FUNCTION CODE MATCH?
 
        .ENDC
 
        BEQ     50$                     ;IF EQ YES
        ADD     #2,R2                   ;POINT TO NEXT ENTRY
        CMP     R2,#ENDFCN              ;END OF TABLE?
        BLO     30$                     ;NO CHECK NEXT ENTRY
40$:    MOV     #IE.IFC&377,R0          ;YES - ILLEGAL FUNCTION
        JMP     EXTNST                  ;EXIT
.PAGE
;
; FUNCTION CODE MATCH FOUND
;
;       REGISTERS ON ENTRY:
;               R0 - QIO FUNCTION CODE
;               R1 - I/O PACKET ADDRESS
;               R2 - ENTRY IN LEGAL FUNCTION TABLE
;               R3 - CONTROLLER INDEX
;               R4 - SCB ADDRESS
;               R5 - UCB ADDRESS
;
;       R0 AND R2 MODIFIED 
;               R0 - WILL CONTAIN FUNCTION INDEX
;               R2 - WILL CONTAIN CSR
;

50$:                            ;REF LABEL


        .IF DF  P$$RFL

        BITB    #US.PWF,U.STS(R5) ;POWER FAIL OCCUR?
        BEQ     70$             ;IF EQ NO
60$:    BICB    #US.PWF,U.STS(R5)       ;ALLOW ALL FUNCTIONS

        .ENDC


70$:    MOV     (R2),U.FCDE(R5) ;SAVE FUNCTION INDEX
        MOVB    #TIMOUT,S.ITM(R4) ;SET INITIAL TIMOUT COUNT
        MOVB    U.FCDE(R5),R0   ;SET FUNCTION INDEX IN R0
        CLR     SPTBL(R3)       ;CLEAR OUT SPACING INDICATOR
        
        .IF DF  D$$IAG
        
        TST     RTTBL(R3)       ;DIAGNOSTIC FUNCTION?
        BMI     80$             ;IF MI YES - NO RETRIES
 
        .ENDC
 
        MOV     #RETRY,RTTBL(R3) ;SET RETRY COUNT
80$:    CALL    SELECT          ;GET TAPE UNIT STATUS
        CALLR   @PRETBL(R0)     ;JMP TO PRE-INITIATION ROUTINE

;
.PAGE
;+
; **-PRESPC - INITIATION ROUTINE FOR SPACE FUNCTIONS
;
;       THIS ROUTINE DOES ALL PRE-PROCESSING FOR SPACE FUNCTIONS.
;       STATUS CONDITIONS ARE CHECKED TO SEE IF SPACEING SHOULD OCCUR
;       IF NOT THE DRIVER EXITS WITH STATUS RETURN IN R0.
;
;       IF SPACING TO OCCUR U.CNT(R5),I.PRM+4(R1),SPTBL(R3) AND
;       U.CW3(R5) (IF SPACE FILES) ARE SET WITH THE SPACE COUNT/.
;       THE FUNCTION CODE IS SET IN U.BUF(R5) AND THE FUNCTION INDEX
;       SET APPROPRIATLY IN U.FCDE(R5). A BRANCH TO FNCEX IS THEN MADE.
;
; SPACING FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- SPACING COUNT (POSITIVE=FORWARD, NEGATIVE=BACKWARD).
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- RELOCATION BIAS OF DIAGNOSTIC REG. BUFFER ADDRESS
;       WD. 20 -- DIAG. REG. BUFFER ADDRESS (REAL OR DISPL. + 140000)
;-
        .DSABL  LSB

PRESPC: MOV     #IS.SUC&377,R0  ;ASSUME 0 SPACE COUNT
        MOV     U.BUF(R5),-(SP) ;RETRIEVE SPACE COUNT
        BEQ     40$             ;ZER0 - DONE
        BMI     10$             ;IF MI REVERSE SPACE
        CLR     U.BUF(R5)       ;CLEAR FOR FUNCTION CODE
        MOV     #IE.EOV&377,R0  ;MAY BE AT EOV
        BIT     #M.PEOV,U.CW2(R5) ;AT EOV?
        BNE     40$             ;YES CAN'T SPACE FORWARD FROM HERE
        NEG     (SP)            ;NEED 2'S COMPLEMENT FOR FUNCTION
        BR      20$             ;CONTINUE
10$:    CLR     U.BUF(R5)       ;CLEAR TO TAKE ON FUNCTION CODE
        BIS     #REV,U.BUF(R5)  ;SET FOR REVERSE FUNCTION
        ADD     #4,U.FCDE(R5)   ;RESET FUNCTION INDEX
20$:    CMP     #IO.SPF,I.FCN(R1) ;SPACE FILES?
        BNE     30$             ;IF NE NO
        MOV     (SP),U.CW3(R5)  ;YES SAVE REQUESTED COUNT
        MOV     (SP),I.PRM+4(R1) ;SAVE FOR LATER CALCULATIONS
        MOV     #1,(SP)         ;SET FOR MAX SPACE COUNT
30$:    MOV     (SP),U.CNT(R5)  ;SET U.CNT
        MOV     (SP)+,SPTBL(R3) ;SAVE FOR TIMEOUT SITUATION
        BIS     #FC.SPF,U.BUF(R5) ;SET FUNCTION CODE
        CALL    SETNDT          ;SET FORMAT
        BR      FNCEX           ;INITIATE FUNCTION

40$:    TST     (SP)+           ;CLEAN UP STACK FOR RETURN
        JMP     EXTNST          ;EXIT
.PAGE
        .ENABL  LSB
;+
; STATUS FUNCTION PROCESSING
;       THREE ROUTINES ARE PROVIDED TO HANDLE STATUS FUNCTION PROCESSING
;       THESE ARE MOUNT AND SET CHARACTERISTICS; SET CHARACTERISTICS AND
;       SENSE CHARAACTERISTCS. THESE FUNCTIONS PROVIDE THE USER THE ABILITY
;       TO DETERMINE THE CURRENT STATE OF A TAPE DRIVE AND TO SELECT THE
;       DESIRED ATTRIBUTES (I.E. DENSITY SELECTION)
;
;       ON EXIT FROM THESE ROUTINES R1 CONTAINS THE CHARACTERISTICS OF
;       THE SELECTED DRIVE AND R0 CONTAINS IS.SUC THE ONE EXCEPTION
;       TO THIS IS ON AN ERROR. IN THIS CASE R0 CONTAINS THE ERROR
;       CODE AND R1 IS NOT DEFINED.
;
;-
;
;+
; **-PRESMO - SET CHARACTERISTICS ON NEWLY MOUNTED TAPE
;
;       CHECKS FOR BOT IF YES SET CHARACTERISTICS OTHERWISE
;       RETURNS IE.FHE
;-
PRESMO:                                                                 ;JC030
                                                                        ;JC030
        .IF DF  P$$RFL                                                  ;JC030
                                                                        ;JC030
        BICB    #US.PWF,U.STS(R5)       ;CLEAR POWERFAIL STATUS         ;JC030
                                                                        ;JC030
        .ENDC                                                           ;JC030
                                                                        ;JC030
        BIT     #M.BOT,U.CW2(R5)        ;TAPE AT BOT?                   ;JC030
        BNE     PRESTC                  ;YES SET CHARACTERISTICS        ;**-1
        MOV     #IE.FHE&377,R0          ;NO FATAL ERROR
        BR      20$
;+
;
; **-PRESTC - SET CHARACTERISTICS COMMAND
;       SETS THE CHARACTERISTICS DEFINED BY THE USER IN U.CW2(R5)
;
;-
PRESTC: BIC     #USRBTS!7,U.CW2(R5)     ;CLEAR USER BITS
        BIC     #^C<USRBTS>,U.BUF(R5)   ;CLEAR ALL BUT USER BITS
        BIS     U.BUF(R5),U.CW2(R5)     ;SET NEW CHARACTERISTICS
;+
;
; **-PRESEC - SENSE CHARACTERISTICS COMMAND
;       RETURNS CONTENTS OF U.CW2(R5) IN R1
;       IF TAPE CONTROLLER IS A TM03 AND THE DRIVE NOT AT BOT OR
;       REWINDING THE HARDWARE STATUS REGISTER IS TESTED FOR THE
;       APPROPRIATE DENSITY.
;
;-
PRESEC: BIT     #40,MTDT(R2)            ;IS TAPE A TM03?
        BEQ     10$                     ;IF EQ NO
        BIT     #M.BOT!M.RWD,U.CW2(R5)  ;TAPE AT BOT OR REWINDING?
        BNE     10$                     ;IF NE YES
        BIC     #M.1600,U.CW2(R5)       ;CLEAR PE BIT
        BIT     #DS.PES,MTDS(R2)        ; IS THIS TAPE PE?              ;JC038
        BEQ     10$                     ;IF EQ NO                       ;**-1
        BIS     #M.1600,U.CW2(R5)       ;YES SET THE BIT
10$:    MOV     U.CW2(R5),R1
        MOV     #IS.SUC&377,R0          ;SET SUCCESS
20$:    JMP     EXIT                    ;RETRUN
.PAGE
;
; READ/WRITE LOGICAL FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER.
;       WD. 13 -- DATA BUFFER ADDRESS.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- RELOCATION BIAS OF DIAGNOSTIC REG. BUFFER ADDRESS
;       WD. 21 -- DIAG. REG. BUFFER ADDRESS (REAL OR DISPL. + 140000)
;
; NO FUNCTION DEPENDENT PARAMETERS ARE REQUIRED FOR REWIND OR WRITE EOF
;
;
;+
; **-PREREV - INITIATION ROUTINE FOR READ REVERSE
;       PRE-PROCESSING FOR A READ REVERSE FUNCTION CONSISTS
;       OF SETTING THE USER BUFFER TO POINT TO THE LAST WORD.
;       THIS IS REQUIRED BY THE MASSBUS AS THE HARDWARE DECREMENTS
;       THE MEMORY ADDRESS AS IT TRANSFERS THE DATA TO MEMORY.
;
;-
        .ENABL  LSB
PREREV: CALL    SETFMT                  ;SET FORMAT AND BUF ADDRESS
        SUB     #2,U.CNT(R5)            ;HARDWARE REQUIRES END OF
        ADD     U.CNT(R5),2(R1)         ;BUFFER FOR REVERSE READ
        BCC     10$                     ;IF CC NO CARRY
        ADCB    1(R1)                   ;PROPOGATE TO EX MEM BITS (RH70)
10$:    ADD     #2,U.CNT(R5)            ;RESET BYTE COUNT
        BR      PRECOM                  ;GO INITIATE DATA TRANSFER
;+
;
; **-PREWRT - INITIATION ROUTINE FOR WRITE
;       PRE-PROCESSING FOR A WRITS COMMAND CONSISTS OF
;       CHECKING THE USER REQUESTED COUNT FOR A SHORT RECORD,
;       AND ALSO TESTS FOR HARDWARE WRITE-LOCKED OR SOFTWARE
;       WRITE LOCKED STATUS ANY OF THESE CONDITIONS RESULTS IN THE
;       REQUEST BEING TERMINATED AND AN ERROR STATUS RETURNED IN R0.
;
;-
PREWRT: MOV     #IE.SPC&377,R0          ;ASSUME PARAMETER PROBLEMS
        TST     I.PRM+4(R1)             ;MAX LENGTH?
        BEQ     20$                     ;YES - CONTINUE
        CMP     #MINREC,I.PRM+4(R1)     ;MINIMUM RECORD SIZE?
        BHI     30$                     ;IF HI RECORD TOO SMALL
;+
;
; **-PREEOF - INITIATION ROUTINE FOR WRITE TAPE MARK
; **-PREERS - INITIATION ROUTINE FOR ERASE
;
;       PRE-PROCESSING FOR WRITE TAPE MARK AND ERASE CONSISTS OF
;       CHECKING THE HARDWARE AND SOFTWARE WRITE LOCKED STATUS
;       IF WRITE-LOCKED THE REQUEST IS TERMINATED.
;-
PREEOF:
PREERS:
20$:    MOV     #IE.WLK&377,R0          ;ASSUME WRITE LOCKED
        BIT     #M.SWL!M.HWL,U.CW2(R5)  ;WRITE LOCKED?
        BNE     30$                     ;IF EQ YES - EXIT               ;JC030
                                                                        ;**-2
;+
;
; **-PRERED - INITIATION FOR READ FORWARD
;       PRE-PROCESSING FOR A READ COMMAND CONSISTS ONLY OF
;       SETTING THE BUFFER POINTER APPROPRIATELY.
;       IT SHOULD BE NOTED THAT THE WRITE ROUTINE FALSS THROUGH THIS
;       CODE AS THIS IS ALSO REQUIRED FOR WRITE FUNCTIONS.
;       ALSO, THE WRITE TAPE MARK AND ERASE FUNCTIONS ALSO
;       FALL THROUGH HERE THIS IS NOT NECESSARY BUT DONE
;       FOR CONVEINCE IN THIS CODE.
;-
PRERED:
        CALL    SETFMT                  ;SET FORMAT
        MOV     #IE.IFC&377,R0          ;SET ILLEGAL FUNCTION           ;JC030
        BITB    #US.PWF,U.STS(R5)       ;POWER FAIL OCCUR?              ;EB205
        BEQ     PRECOM                  ;IF EQ NO - CONTINUE            ;JC030
30$:    JMP     EXTNST                  ;EXIT                           ;JC030
;+
;
; **-PRECOM - COMMON PREPROCESSING ENTRY
;       AT THIS POINT ALL COMMANDS WHICH REQUIRE HARDWARE
;       PROCESSING AND HAVE SUCCESSFULLY PASSED ALL THE PRE-SCREENING
;       ARE JOINED. A CALL TO SETNDT IS MADE TO SET THE FORMAT,THE
;       FUNCTION CODE IS THEN MOVED TO U.BUF AND WE FALL THROUGH
;       TO FNCEX - FUNCTION EXECUTION.
;-
PRECOM: CALL    SETNDT          ;SET FORMAT
                                                                        ;JC030
        .IF DF  P$$RFL                                                  ;JC030
                                                                        ;JC030
        BICB    #US.PWF,U.STS(R5)       ;CLEAR POWERFAIL STATUS         ;JC030
                                                                        ;JC030
        .ENDC                                                           ;JC030
                                                                        ;JC030
        MOVB    U.FCDE+1(R5),U.BUF(R5)  ;RETRIEVE FUNCTION
.PAGE
;+
;
; **-FNCEX - FUNCTION EXECUTION
;
;       THIS SUBROUTINE WILL DETERMINE WHETHER THE
;       FUNCTION ISSUED IS A DATA TRANSFER FUNCTION
;       OR A NON-DATA TRANSFER
;       INPUT:  R2 = CSR ADDRESS
;               R3 = CONTROLLER NUMBER
;               R4 = SCB ADDRESS
;               R5 = UCB ADDRESS
;
;-
FNCEX:  BIT     #M.SER,U.CW2(R5)        ;SELECT ERROR?
        BNE     SELERR                  ;IF NE YES SELECT ERROR
        BIT     #M.RWD,U.CW2(R5)        ;UNIT REWINDING?
        BNE     TIMER                   ;IF NE YES - WAIT
        MOV     U.VCB+2(R5),RHCS2(R2)   ;SELECT FORMATTER               ;JC028
        MOV     FMTBL(R3),MTTC(R2)      ;SET FORMAT AND SELECT UNIT     ;JC028
        MOV     #C1.TRE!FC.CLR,RHCS1(R2)        ;CLEAR DRIVE AND CONTROL;JC028
        MOV     U.CNT(R5),MTFC(R2)      ;SET COMMAND COUNT              ;**-3
        CMPB    #FRREV,U.FCDE(R5)       ;DATA TRANSFER?
        BLT     NDATIO                  ;IF LE NO
.PAGE
;+
;
; **-DATAIO - DATA TRANSFER I/O INITIATION ROUTINE
;
;
;       INPUTS: R2 = CSR ADDRESS
;               R3 = CONTROLLER INDEX
;               R4 = SCB ADDRESS
;               R5 = UCB ADDRESS
;-
        .DSABL  LSB

DATAIO:

        .IF DF  M$$EXT                                                  ;JC029
                                                                        ;JC029
        BIT     #DV.MBC,U.CW1(R5)       ;RH11?                          ;JC029
        BNE     10$                     ;IF SET NO RH70                 ;JC029
        CALL    $STMAP                  ;SET FOR UNIBUS TRANSFER        ;**-2
        MOV     R2,-(SP)                ;SAVE R2
        CALL    $MPUBM                  ;MAP UNIBUS TO TRANSFER
        MOV     (SP)+,R2                ;RESTORE R2

        .ENDC
                                                                        ;JC029
10$:    NEG     MTFC(R2)                ;NEGATE BYTE COUNT              ;JC029
        MOV     MTFC(R2),RHWC(R2)       ;MOVE BYTE COUNT TO RHWC        ;**-1
        ROR     RHWC(R2)                ;AND MAKE IT A WORD COUNT
        MOV     U.BUF+2(R5),RHBA(R2)    ;SET LOW ORDER 16 BIT ADDRESS
        MOVB    S.ITM(R4),S.CTM(R4)     ;START TIMER
        BIC     #M.AEOV!M.SER!M.RWD,U.CW2(R5) ;CLEAR STATUS BITS

        .IF DF  E$$DVC

        CALL    $BMSET

        .ENDC

        .IF DF  M$$EXT                                                  ;JC029
                                                                        ;JC029
        BIT     #DV.MBC,U.CW1(R5)       ;RH11?                          ;JC029
        BEQ     20$                     ;IF EQ YES                      ;JC029
        MOVB    U.BUF+1(R5),RHBAE(R2)   ;SET EX MEM BITS                ;JC029
        MOVB    U.BUF(R5),RHCS1(R2)     ;INITIATE COMMAND               ;JC029
        RETURN                                                          ;JC029
                                                                        ;JC029
        .IFTF                                                           ;JC029
                                                                        ;JC029
20$:    MOV     U.BUF(R5),RHCS1(R2)     ;INITIATE COMMAND               ;JC029
        RETURN                                                          ;JC029
                                                                        ;JC029
        .ENDC                                                           ;JC029
.PAGE                                                                   ;**-20
;+
;
; **-NDATIO - NON-DATA TRANSFER ENTRY POINT
;
;       INPUTS: R2 = CSR
;               R3 = CONTROLLER INDEX
;               R4 = SCB ADDRESS
;               R5 = UCB ADDRESS
;
;-
NDATIO: MOVB    S.ITM(R4),S.CTM(R4)     ;START TIMER
        BIC     #M.AEOV!M.SER!M.RWD,U.CW2(R5) ;CLEAR STATUS BITS

        .IF DF  E$$DVC

        CALL    $BMSET

        .ENDC
        MOV     U.BUF(R5),RHCS1(R2)     ;INITIATE COMMAND
        RETURN

.PAGE
        .ENABL  LSB                                                     ;JC026
;+
;
; **-SELERR - SELECT ERROR HAS OCCURED THIS ROUTINE WILL ISSUE
;               A SLECT ERROR MESSAGE TO THE CONSOLE TERMINAL EVERY
;               15 SECODS. THE UNIT IS CHECKED ONCE A SECOND
;               UNTIL IT COMESREADY OR AN ABORT IS DONE.
;
;-
SELERR:

        MOV     #IE.DNR&377,R0          ;INSURE DNR IS SET              ;JC026
        BITB    #US.SUP,U.STS(R5)       ;USER MODE OR IQ.X?             ;JC026
        BNE     10$                     ;IF NE YES EXIT                 ;JC026
        TST     U.ACP(R5)               ; ACP WANTS RETURN?             ;JC026
        BNE     10$                     ; IF NE YES                     ;JC026
        BIS     #M.SER,U.CW2(R5)        ; SET SELECT ERROR              ;JC026
        DECB    S.STS(R4)               ;TIME FOR A MSG?                ;**-9
        BNE     TIMER                   ;IF NE NO
        MOV     #T.NDSE,R0              ;ERROR MESSAGE CODE
        MOVB    #15.,S.STS(R4)          ;SET UP TIMEOUT
        CALL    $DVMSG                  ;SEND THE MESSAGE
TIMER:  MOVB    #1,S.CTM(R4)            ;SET UP A TIMEOUT
        RETURN                          ;THAT IS ALL FOR NOW
10$:    JMP     EXTNST                  ; EXIT                          ;JC026
        .DSABL  LSB                                                     ;JC026
.PAGE
;+
; **-MMOUT - DEIVE TIMEOUT ENTRY POINT
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING TERMINATED.
; IF THE OPERATION WAS DIAGNOSTIC, THE QIO REQUEST IS TERMINATED.
; TIMEOUTS ARE USUALLY CAUSED BY POWERFAILURE BUT MAY ALSO BE THE
; RESULT OF HARDWARE CONSIDERATIONS.
;
;       INPUTS: R0 = I/O COMPLETION CODE IE.DNR
;               R2 = CSR ADDRESS
;               R3 = CONTROLLER INDEX
;               R4 = SCB ADDRESS
;               R5 = UCB ADDRESS
;-

MMOUT:  BITB    #US.ABO,U.STS(R5)       ;;;ABORTING?
        BNE     40$                     ;;;IF NE YES
        BIT     #M.RWD,U.CW2(R5)        ;;;REWIND IN PROGRESS
        BEQ     10$                     ;;;IF EQ NO
        BIT     #DS.MOL,MTDS(R2)        ;;;UNIT ONLINE?
        BEQ     SELERR                  ;;;IF EQ NO SELECT ERROR
        BIT     #DS.PIP,MTDS(R2)        ;;;POSITIONING IN PROGRESS?
        BNE     TIMER                   ;;;IF NE YES - RESET TIMER
        BIT     #DS.BOT,MTDS(R2)        ;;;TAPE AT BOT
        BEQ     TIMER                   ;;;IF EQ NO RESET TIMER
        BIS     #M.BOT,U.CW2(R5)        ;;;SET BOT STATUS
        BIC     #M.RWD,U.CW2(R5)        ;;;CLEAR REWINDING BIT
        BIS     #M.SER,U.CW2(R5)        ;;;FORCE A RETRY
        BR      30$                     ;;;ISSUE COMMAND
10$:    MOV     SPTBL(R3),R1            ;;;SPACING?
        BEQ     20$                     ;;;IF EQ NO
        CMP     R1,MTFC(R2)             ;;;BLANK TAPE
        BEQ     20$                     ;;;IF EQ YES EXIT
        MOV     MTFC(R2),SPTBL(R3)      ;;;SAVE FOR LATER USE
        MOVB    S.ITM(R4),S.CTM(R4)     ;;;RESET TIMEOUT COUNT
        RETURN
20$:    CALL    $DTOER                  ;;;LOG DEVICE ERROR

        .IF DF D$$IAG

        BCS     40$                     ;;;IF C-SETABORT DIAGNOSTIC FUNCTION

        .ENDC

30$:    MTPS    #0                      ;;;ALLOW INTERRUPTS             ;EB205
        BIT     #M.SER,U.CW2(R5)        ;SELECT ERROR?                  ;**-1
        BEQ     50$                     ;IF EQ NO - ERROR
        CALL    SELECT                  ;SEE IF RDY YET
        BCS     SELERR                  ;IF C-SET NO SELECT ERROR
        CALLR   FNCEX                   ;ALL'S WELL GO EXECUTE FUNCTION
40$:                                    ;;;REFERENCE LABEL

        .IF DF D$$IAG

        CALL    MMDINT                  ;;;PASS DIAGNOSTIC DEVICE REGISTERS

        .ENDC

        MOV     #C1.TRE!FC.CLR,RHCS1(R2) ;CLEAR DRIVE AND CONTROLLER ERR;JC027
        BICB    #US.ABO,U.STS(R5)       ;;;CLEAR ABORT FLAG             ;**-1

        .IF DF D$$IAG

        MOV     S.PKT(R4),R1            ;;;GET I/O PACKET ADDRESS
        BITB    #IQ.UMD,I.FCN(R1)       ;;;USER MODE FUNCTION?
        BEQ     FATAL                   ;;;IF EQ NO

        .ENDC

50$:    BIS     #C2.CLR,RHCS2(R2)       ;INSURE CONTROLLER CLEARED AND  ;JC027
                                        ;ABLE TO ACCEPT A NEW COMMAND   ;JC027
        JMP     EXTNST                  ;EXIT NO STATUS                 ;JC027
.PAGE                                                                   ;**-1
;+
; **-MMCAN - CANCEL I/O ENTRY POINT
; CANCEL I/O OPERATION
;
;       INPUTS: R0 = I/O PACKET ADDRESS
;               R1 = TCB ADDRESS
;               R3 = CONTROLLER INDEX
;               R4 = SCB ADDRESS
;               R5 = UCB ADDRESS
;-

MMCAN:  BISB    #US.ABO,U.STS(R5) ;FLAG THE ABORT CONDITION
        RETURN
;+
; **-MMPWF - POWER FAIL RECOVERY ENTRY
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE. THIS IS DONE TO AVOID A RACE CONDITION
; THAT COULD EXIST IN RESTARTING THE I/O OPERATION.
;-

MMPWF:                          ;POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        BISB    #US.PWF,U.STS(R5)  ;SET POWER FAIL INDICATOR

        .ENDC


        RETURN                  ;


.PAGE
;+
; **-$MMINT-RH11/RH70 TM02/TM03 MAGNETIC TAPE CONTROLLER INTERRUPTS
;-

        INTSE$  MM,PR5,T$$J16   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,R3           ;COPY CONTROLLER INDEX
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MOVB    S.ITM(R4),S.CTM(R4) ;RESET TIMOUT COUNT
        MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESS
        MOVB    U.FCDE(R5),R1   ;RETRIEVE FUNCTION INDEX
        BIT     #M.EOF!M.BOT,U.CW2(R5) ;TAPE MARK SEEN LAST TIME?
        BEQ     10$             ;IF EQ NO
        BIS     #M.AEOV,U.CW2(R5) ;YES SET FOR EOV CHECK
10$:    BIC     #NEWBTS,U.CW2(R5) ;CLEAR STATUS BITS TO DETERMINE
        BICB    #US.ABO!US.PWF,U.STS(R5) ;CLEAR ABORT AND POWERFAIL STAT;JC030
        BIT     #C1.TRE,RHCS1(R2) ;TRANSFER TYPE ERROR?
        BNE     20$             ;IF NE YES
        BIT     #DS.ERR,MTDS(R2) ;DRIVE ERROR?
        BNE     30$             ;IF NE YES
        CALLR   @DONTBL(R1)     ;NO ERRORS FUNCTION COMPLETE

;
;       TRANSFER ERROR OCCURED
;
;
20$:    MOV     RHCS2(R2),R0    ;RETREIVE CS2
        BIT     #FTLRH,R0       ;FATAL RH ERROR?
        BNE     FATAL           ;IFNE YES
        BIC     #FTLRH!377,R0   ;CLEAR FATAL RH ERRORS
        BEQ     30$             ;CHECK FOR DRIVE ERRORS
        CALLR   @COMRTY         ;RETRY CONTROLLER ERROR
;
;
;       DRIVE ERROR OCCURED  CHECK FOR FATAL CONDITION
;
30$:    MOV     MTER(R2),R0     ;RETREIVE ERROR REGISTER
        BIT     ERRMSK(R1),R0   ;FATAL ERROR OCCUR?
        BNE     FATAL           ;IF NE FATAL ERROR OCCURED
        BIT     #DS.MOL,MTDS(R2) ;DRIVE STILL ONLINE?
        BEQ     FATAL           ;IF EQ NO FATAL ERROR
        CALLR   @CHKTBL(R1)     ;GO CHECK COMMAND SPECIFIC ERRORS
 
;
;       FATAL HARDWARE ERRORS
;
FATAL:  
        
        .IF DF  E$$DVC
        
        CALL    LOGERR
        
        .ENDC
        
        MOV     #IE.FHE&377,R0  ;FATAL HARDWARE ERROR
        JMP     EXTNST          ;EXIT
        
.PAGE

;+
; **-REVERR - READ REVERSE SPECIAL ERROR CHEKING
;
;       SPECIAL TESTS ARE MADE ON READ REVERSE FOR CASE WHERE
;       THE READ READ INTO BOT. SUCCESS IS RETURNED AND A ZERO
;       BYTE COUNT.
;
;-
 
        .ENABL  LSB
REVERR: BIT     #ER.NEF!ER.OPI,R0 ;NON-EXECUTABLE OR OPERATION INCOMPLETE?
        BEQ     REDERR          ;IF EQ NO THEREFORE NOT A BOT CONDITION
        BIT     #DS.BOT,MTDS(R2) ;TAPE AT BOT?
        BEQ     FATAL           ;IF EQ NOT AT BOT IN THAT CASE THESE ERRORS
                                ;ARE FATAL!
        BIS     #M.BOT,U.CW2(R5) ;SET BOT STATUS
        CLR     MTFC(R2)        ;CLEAR OUT FRAME COUNT FOR RETURN
        BR      50$             ;RETURN SUCCESS

;+
; **-REDERR - READ ERROR CHECKING
; READ LOGICAL FUNCTION
;
;       R0 = DRIVE ERROR REGISTER FATAL ERROR BITS HAVE BEEN CLEARED
;-
REDERR: BIT     #ER.DPR!ER.INC!ER.PEF!ER.NSG,R0 ;RETRY NEEDED?
        BNE     20$             ;IF NE YES
        BIT     #ER.FCE,R0      ;FRAME COUNT ERROR
        BNE     30$             ;IF NE YES
10$:    BIT     #DS.PES,MTDS(R2) ;PE TAPE?
        BNE     50$             ;IF PE SUCCESS
20$:    CALLR   COMRTY          ;JMP TO RETRY ENTRY
30$:    BIT     #DS.TM,MTDS(R2) ;TAPE MARK?
        BEQ     50$             ;IF EQ NO
        MOV     #IE.EOF&377,R0  ;SET EOF STATUS
        BIS     #M.EOF,U.CW2(R5) ;SET IN CHARACTERISTICS WORD
        CLR     MTFC(R2)        ;RESET FRAME COUNT FOR RETURN
        BR      60$             ;GO TO COMPLETION ROUTINE
50$:    MOV     #IS.SUC&377,R0  ;SHORT RECORD IS SUCESS
60$:    CALLR   @DONTBL(R1)     ;EXIT
.PAGE

;+
; **-RWUERR - REWIND AND UNLOAD ERROR AND RETRY
;-
        .DSABL  LSB
RWUERR:
RWURTY:
        
        .IF DF  E$$DVC
        
        CALL    LOGERR          ;LOG THE ERROR
        
        .ENDC
        
        BIC     #M.1600,U.CW2(R5)       ;CLEAR DENSITY BIT
        BIT     #TC.1600,FMTBL(R3)      ;LAST REQUEST AT 1600?
        BNE     10$                     ;IF NE YES TRY 800
        BIS     #M.1600,U.CW2(R5)       ;SET TO TRY AT 1600
10$:    CALLR   FNCEX                   ;RETRY COMMAND
.PAGE
;+
;
; **-SPRERR - SPACE REVERSE - ERROR HANDLING
;
;-
        .ENABL  LSB
SPRERR: BIT     #DS.BOT,MTDS(R2) ;BOT ENCOUNTERED?
        BEQ     SPFEXT          ;IF EQ NO NOT BOT
        BIS     #M.BOT,U.CW2(R5) ;SET STATUS BIT
        MOV     #IS.SUC&377,R0  ;SET SUCCESS
        BR      30$             ;DONE
;+
; **-SPFERR - SPACE FUNCTIONS FORWARD COMPLETION ROUTINES
;-
SPFEXT: BIT     #ER.OPI!ER.NEF,R0       ;FATAL ERROR?
        BNE     FATAL                   ;IF NE YES FATAL ERROR
        BIT     #DS.EOT,MTDS(R2)        ;EOT SEEN?
        BEQ     10$                     ;IF EQ NO
        MOV     #IE.EOT&377,R0          ;SET EOT STATUS
        BIS     #M.EOT,U.CW2(R5)        ;SET EOT STATUS
10$:    BIT     #DS.TM,MTDS(R2)         ;TAPEMARK SEEN?
        BEQ     30$                     ;IF EQ NO
        MOV     #IE.EOF&377,R0          ;SET TAPEMARK STATUS
        CALL    CHKEOV                  ;CHECK FOR END OF VOLUME
        BCC     40$                     ;IF CC NOT EOV
        MOV     #FRTRY,U.FCDE(R5)       ;SET FOR BACKSPACE
        MOV     U.CNT(R5),CMDCNT(R3)    ;SAVE FOR CALCULATION
        SETRTY  20$,SPR,1               ;SET BACKSPACE
        BR      70$                     ;ISSUE BACKSPACE COMMAND
20$:    MOV     CMDCNT(R3),U.CNT(R5)    ;RESET REQUEST COUNT
        MOV     #IE.EOV&377,R0          ;SET EOV STATUS
        BIS     #M.PEOV,U.CW2(R5)       ;SET AT EOV IN CHARACTERISTICS
30$:    MOV     S.PKT(R4),R1            ;GET I/O PACKET ADDRESS
        CMPB    #IO.SPF,I.FCN(R1)       ;SPACE FILES?
        BEQ     SPFDON                  ;YES DO FILES COMPLETION
SPRRTY:
SPRDON: MOV     U.CNT(R5),R1            ;RETRIEVE REQUESTED COUNT
        SUB     MTFC(R2),R1             ;CALCULATE ACTUAL NO. SPACED
        BR      60$                     ;EXIT
40$:    CALLR   @RTYTBL(R1)             ;CHECK FOR MORE FILES
;+
;
; **-SPFRTY - SPACE FILES FORWARD
;
;
;-
SPFRTY: INC     U.CW3(R5)               ;DONE?
        BNE     70$                     ;IF NE NO - CONTINUE
        MOV     #IS.SUC&377,R0          ;YES - SUCCESS
        BR      50$                     ;FIX POSITION AND EXIT
SPFDON: CMP     #IE.EOT&377,R0          ; EOT ENCOUNTERED?              ;JC040
        BEQ     50$                     ; YES SKIP TAPE MARK COUNT      ;JC040
        INC     U.CW3(R5)               ; INCREMENT TAPE MARK COUNT     ;JC040
50$:    MOV     S.PKT(R4),R1            ;GET I/O PACKET ADDRESS
        MOV     I.PRM+4(R1),R1          ;RETREIVE COUNT REQUESTED
        SUB     U.CW3(R5),R1            ;SUBTRACT NUMBER REMAING
60$:    NEG     R1                      ;SET FOR POSITIVE RETURN VALUE
        JMP     EXIT                    ;EXIT
70$:    CALLR   FNCEX
.PAGE
;+
; **-COMRTY - COMMON RETRY ROUTINE
;
;       THIS ROUTINE CHECKS FOR RETRIES BEING SUPPRESSED
;       IF SO EXIT RETURN STATUS IE.VER. OTHERWISE,
;       SAVE THE REQUEST AND CALL THE FUNCTION SPECIFIC RETRY
;       ROUTINE.
;
;-
        .ENABL  LSB
COMRTY:
        
        .IF DF  E$$DVC
        
        CALL    LOGERR                  ;LOG THE ERROR
        
        .ENDC
        
        BITB    #US.SUP,U.STS(R5)       ;RETRIES ENABLED?
        BNE     10$                     ;IF NE NO EXIT
        DECB    RTTBL(R3)               ;RETRIES EXHAUSTED?
        BEQ     10$                     ;IF EQ YES EXIT
        MOV     U.FCDE(R5),FCCDE(R3)    ;SAVE FUNCTION INDEX
        MOV     U.CNT(R5),CMDCNT(R3)    ;SAVE COMMAND COUNT
        MOV     U.BUF(R5),BUFADR(R3)    ;SAVE BUFFER ADDRESS
        MOV     #FRTRY,U.FCDE(R5)       ;SET RETRY COMMAND
        CALLR   @RTYTBL(R1)             ;BR TO FUNCTION SPECIFIC RETRY
        
10$:    MOV     #IE.VER&377,R0          ;RETURN ERROR IN R0
RTYCON: CALLR   @DONTBL(R1)             ;EXIT
.PAGE
;+
;
; **-REDRTY - READ FORWARD RETRY
;
;-
REDRTY: SETRTY  RTYCMD,SPR,1    ;SET RETRY COMMAND
        BR      20$             ;EXECUTE FUNCTION
;+
;
; **-REVRTY - READ REVERSE RETRY
;
;-
REVRTY: SETRTY  RTYCMD,SPF,1    ;SET RETRY COMMAND
        BR      20$             ;EXECUTE FUNCTION
;+
;
; **-WRTRTY - WRITE AND WRITE TAPE MARK RETRY
;       DOES A SPACE REVERSE THEN CHECKS FOR USER
;       SUPPRESSION OF EXTENDED GAP.
;
;-
WRTRTY: SETRTY  RTYWRT,SPR,1    ;SET RETRY COMMAND
        BR      20$             ;ISSUE BACKSPACE
RTYWRT: BIT     #M.IXG,U.CW2(R5) ;USER SUPPRESS EXTENDED GAP?
        BNE     RTYCMD          ;IF NE YES
        SETRTY  RTYCMD,ERS,1    ;SET ERASE COMMAND
        BR      20$             ;ISSUE ERASE
;+
;
; **-RTYCMD - RETRY ORIGINAL OPERATION
;
;       THIS ROUTINE RESTORES THE REQUESTED I/O FUNCTION
;       AND BRANCHES TO THE DATAIO INITIATION ROUTINE.
;
;       READ FORWARD, READ REVERSE, AND WRITE LOGICAL BLOCK
;       FUNCTIONS ARE RE-INITIATED FROM HERE AFTER TAPE HAS BEEN
;       RE-POSITIONED PROPERLY.
;-
RTYCMD: MOV     FCCDE(R3),U.FCDE(R5)    ;RESTORE FUNCTION INDEX
        MOV     CMDCNT(R3),U.CNT(R5)    ;RESTORE COMMAND COUNT
        MOV     BUFADR(R3),U.BUF(R5)    ;RESTORE BUFFER ADDRESS
20$:    CALLR   FNCEX                   ;EXECUTE FUNCTION
.PAGE
;+
; **-REDDON - READ FORWARD COMPLETION ROUTINE
;
;       THIS ROUTINE LOADS R1 WITH THE NUMBER OF BYTES ACTUALLY
;       READ, INCREMENTS THE RECORD POSITION AND THEN EXITS.
;-
        .DSABL  LSB
REVDON: BIC     #M.EOF,U.CW2(R5) ;CLEAR OUT INTERNAL STATUS FOR REVERSE
REDDON: MOV     MTFC(R2),R1     ;SET FRAME COUNT FOR REQUESTER
        TSTB    R0              ;ALREADY RETURNING ERROR?
        BMI     EXIT            ;YES MUST BE MORE IMPORTANT
        CMP     R1,U.CNT(R5)    ;RECORD LONG
        BLOS    EXIT            ;NO EXIT SUCCESS
        MOV     #IE.DAO&377,R0  ;YES INFORM THE USER
        BR      EXIT            ;EXIT
;+
; **-EOFDON - WRITE TAPE MARK COMPLETION ROUTINE
; **-WRTDON - WRITE LOGICAL BLOCK COMPLETION ROUTINE
;
;       R1 IS LOADED WITH THE ACTUAL NUMBER OF BYTES
;       -
EOFDON: BIS     #M.EOF,U.CW2(R5) ;SET TM STATUS
WRTDON: MOV     U.CNT(R5),R1    ;RETREIVE REQUESTED COUNT
        ADD     MTFC(R2),R1     ;CALCULATE ACTUAL LENGTH
        BIT     #DS.EOT,MTDS(R2) ;AT EOT?
        BEQ     EXIT            ;IF EQ NO
        MOV     #IE.EOT&377,R0  ;SET EOT STATUS
        BIS     #M.EOT,U.CW2(R5) ;SET EOT IN CHARACTERISTICS WORD
        BR      EXIT            ;EXIT
RWDDON: BIS     #M.RWD,U.CW2(R5) ;SET REWIND IN PROGRESS

EXTNST: CLR     R1                      ;NO STATUS TO RETURN
EXIT:

        .IF DF  D$$IAG

        CALL    MMDINT

        .ENDC

        .IF DF  E$$DVC

        MOVB    RTTBL(R3),R2            ;SET RETRY COUNT
        BIS     #RETRY*256.,R2          ;SET ORIGINAL COUNT

        .ENDC

        BIC     #M.AEOV,U.CW2(R5) ;CLEAR EOV STATUS
        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     MMINI           ;GO AGAIN
.PAGE

;+
; **-CHKEOV - CHECK FOR LOGICAL END OF VOLUME
; THIS SUBROUTINE CHECKS FOR THE LOGICAL END-OF-VOLUME CONDITION
;
; RETURNS WITH CC IF NOT EOV.
; RETURNS WITH CS IF EOV.
;-

CHKEOV: CLC                     ;CLEAR CARRY FOR RETURN                 ;JC033
        BIT     #REV,RHCS1(R2)  ; READ REVERSE OPERATION?               ;JC033
        BNE     20$             ; IF NE YES CAN'T BE EOV                ;JC033
                                ; AND DON'T SET EOF                     ;JC033
        MOV     MTFC(R2),-(SP)  ; RETRIEVE FRAME COUNT                  ;JC033
        SUB     U.CNT(R5),(SP)  ;GET NUMBER ACTUALLY SPACED             ;**-1
        CMP     (SP)+,#1        ;EXACTLY ONE? (STARTED WITH 1)
        CLC                     ;ASSUME NOT EOV
        BNE     10$             ;IF NE NO, NOT EOV
        BITB    #US.LAB,U.STS(R5) ;MOUNTED ANSII MAGTAPE?
        BNE     10$             ;IF NE YES, DO NOT REPORT EOV
        BIT     #M.AEOV,U.CW2(R5) ;AT EOV?                              ;**-2
        BEQ     10$             ;IF EQ NO - EXIT WITH CC
        SEC                     ;EOV DETECTED
10$:    BIS     #M.EOF,U.CW2(R5) ;SET EOF STATUS
20$:    RETURN                  ;


.PAGE

;+
;
; **-SELECT - TAPE UNIT SELECT ROUTINE
; THIS ROUTINE ATTEMPTS TO SELECT A DRIVE.  IT SETS UP
; THE BOT AND HWL BITS IN THE CHARACTERISTICS WORD.
;
; ON RETURN:    CC==>GOOD SELECT
;               CS==>BAD SELECT
;

SELECT: MOV     S.CSR(R4),R2    ;PICK UP CSR ADDRESS
        MOV     U.VCB+2(R5),RHCS2(R2) ;SET FORMATTER NO.
        MOV     MTTC(R2),-(SP)  ;SAVE UNIT SELECT REGISTER
        MOVB    U.UNIT(R5),(SP) ;SELECT DESIRED UNIT
        MOV     (SP)+,MTTC(R2)  ; ...
        BIC     #M.BOT!M.HWL!M.SER,U.CW2(R5) ;CLEAR STATUS BITS
        SEC                     ;ASSUME BAD SELECT
        BIT     #DS.MOL,MTDS(R2) ;IS THE DRIVE READY?
        BNE     10$             ;IF NE YES
        BIS     #M.SER,U.CW2(R5) ;SET SELECT ERROR BIT
        BR      40$             ;
10$:    BIT     #DS.PIP,MTDS(R2) ;POSITIONING IN PROGRESS?
        BNE     20$             ;IF NE NO
        BIT     #DS.BOT,MTDS(R2) ;IS DRIVE AT BOT?
        BEQ     20$             ;IF EQ NO
        BIS     #M.BOT,U.CW2(R5) ;SET THE BIT
        BIC     #M.RWD,U.CW2(R5) ;IF AT BOT RWD DONE
20$:    BIT     #DS.WRL,MTDS(R2) ;IS DRIVE WRITE-LOCKED?
        BEQ     30$             ;IF EQ NO
        BIS     #M.HWL,U.CW2(R5) ;SET THE BIT
30$:    CLC                     ;GOOD SELECT
40$:    RETURN
.PAGE

        .DSABL  LSB

;+
; **-SETFMT - SUBROUTINE TO SETUP TAPE CONTROL REGISTER INFO
;
;-
SETFMT:

        MOV     R5,R1           ;SET UCB ADDRESS IN R1
        ADD     #U.BUF,R1       ;POINT TO U.BUF
        .IF NDF M$$EXT

        .IF DF M$$MGE

        ROL     (R1)
        ROL     (R1)
        ROL     (R1)
        ROL     (R1)

        .ENDC

        .ENDC

        RETURN

;+
; **-SETNDT - SET TAPE CONTROL PARAMETERS
;
;-
SETNDT: MOVB    U.UNIT(R5),R0   ;SET UNIT NUMBER
        BIS     #TC.1600,R0     ;SET FOR 1600 BPI
        BIT     #M.1600,U.CW2(R5) ;1600 BPI REQUESTED?
        BNE     10$             ;IF NE YES
        BIC     #TC.1600,R0     ;CLEAR 1600
        BIS     #TC.800,R0      ;SET FOR 800 BPI
        BIT     #M.EVN,U.CW2(R5) ;EVEN PARITY REQUESTED?
        BEQ     10$             ;IF EQ NO
        BIS     #TC.EVN,R0      ;SET FOR EVEN PARITY
10$:    BIS     #TC.FMT,R0      ;SET 11-NORMAL FORMAT
        MOV     R0,FMTBL(R3)    ;STORE TAPE CONTROL
        RETURN
.PAGE                                                                   ;JC033

;+
;
; **-LOGERR  - SUBROUTINE TO LOG DEVICE ERRORS
;
;-
LOGERR:

        .IF DF E$$DVC

        .IF DF  D$$IAG

        TST     RTTBL(R3)               ;USER MODE FUNCTION?
        BMI     10$                     ;IF NE YES

        .ENDC

        CALL    $DVERR                  ;LOG THE ERROR

10$:    RETURN

        .ENDC
.PAGE
        .IF DF  D$$IAG
;
; **-MMDINT-TU16 DIAGNOSTIC INTERRUPT AND TIMEOUT HANDLER
;
; IF ENTRY WAS FROM A DIAGNOSTIC CONTROL FUNCTION THEN MOVE I/O
; PACKET WORDS 17-20 TO WORDS 20-21 FOR $CRPAS ROUTINE.
; FOR ANY DIAGNOSTIC FUNCTION PASS THE UNIBUS DEVICE REGISTERS VIA
; THE $CRPAS ROUTINE.
;
; INPUTS
;       R2= CSR ADDRESS
;       R4= SCB ADDRESS
;
; OUTPUTS
;       R1= IO PACKET ADDRESS
;-

MMDINT: MOV     R1,-(SP)        ;SAVE R1
        MOV     S.PKT(R4),R1    ;GET IO PACKET ADDRESS
        BITB    #IQ.UMD,I.FCN(R1) ;DIAGNOSTIC FUNCTION CALL?
        BEQ     3$              ;IF EQ NO
        MOV     R1,-(SP)        ;SAVE IO PACKET ADDRESS
        CMPB    #IO.EOF/256.,I.FCN+1(R1) ;WRITE EOF CONTROL FUNCTION?
        BEQ     1$                      ;IF EQ YES
        CMPB    #IO.RWD/256.,I.FCN+1(R1) ; CNTRL OTHER THAN IO.EOF?
        BEQ     1$                      ;IF EQ YES
        CALL    $CRPAS          ;PASS DEVICE REGISTERS TO DIAGNOSTIC
        MOV     (SP)+,R1        ;RESTORE IO PACKET ADDRESS
        MOV     (SP)+,R1
        RETURN
1$:     MOV     I.PRM+14(R1),I.PRM+16(R1) ;MOVE WD20 TO WD21
        MOV     I.PRM+12(R1),I.PRM+14(R1) ;MOVE WD17 TO WD20
2$:     CALL    $CRPAS          ;PASS DEVICE REGISTERS TO DIAGNOSTIC
        MOV     (SP)+,R1        ;RESTORE IO PACKET ADDRESS
        MOV     I.PRM+14(R1),I.PRM+12(R1) ;MOVE WD20 BACK TO WD17
        MOV     I.PRM+16(R1),I.PRM+14(R1) ;MOVE WD21 BACK TO WD20
3$:     MOV     (SP)+,R1
        RETURN

        .ENDC

        .END
        .TITLE  MSDRV
        .IDENT  /04.13/
        .SBTTL  PREFACE

;
; COPYRIGHT (C) 1977
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE  FOR USE ONLY ON  A
; SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION
; OF THE ABOVE  COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR ANY  OTHER
; COPIES THEREOF,  MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE
; TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO
; AGREES TO THESE  LICENSE TERMS.   TITLE TO AND  OWNERSHIP OF THE
; SOFTWARE SHALL AT ALL TIMES REMAIN IN DEC.
;
; THE  INFORMATION IN THIS  DOCUMENT IS SUBJECT TO CHANGE  WITHOUT
; NOTICE AND SHOULD  NOT BE CONSTRUED AS  A COMMITMENT  BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC  ASSUMES NO  RESPONSIBILITY  FOR THE  USE OR  RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; VERSION 04.13
;
; A. W. PROTIN, JR  13-FEB-78
;
;       MODIFIED:
;
;
;       A. PROTIN 
;
;       09-FEB-79       AP012 -- FIX PROBLEM WITH DOUBLE BUFFR RELSE
;       08-FEB-79       AP011 -- MADE TIMEOUTS LOGGED AS SUCH.
;       19-DEC-78       AP010 -- SIMPLIFIED CONDITIONALS ON I/O INIT.
;       06-FEB-79       AP007 -- FIXED TREATMENT OF RLS & PEOV
;       19-JAN-79       AP006 -- PUT OUT MORE REGISTERS TO ERRLOG.
;       21-DEC-78       AP005 -- FIXED PROBLEM SHOWN BY AP003 CHANGE.
;       19-DEC-78       AP004 -- REMOVED "CLEAN", FIXED RETRY BUG.
;       18-DEC-78       AP003 -- ADD CODE TO HANDLE SPECIAL OFFLINE CONDITIONS.
;                       AP002 -- MOVED "REL", REMOVED TEMPORARY CODE.
;       14-DEC-78       AP001 -- CORRECT TYPO IN ERROR RECOVERY.
;       1-DEC-78        AP000 -- CORRECTED AND/OR ADDED DOCUMENTATION.
;
;
;       J. CLEARY       4-MAR-78
;
;               JC032 -- CLEANUP TIMEOUT AND INTERRUPT SERVICE
;
;
;
; TS11 MAGNETIC TAPE CONTROLLER DRIVER
;
;
;
        .PAGE
        .SBTTL  *********  NOTICES  ******************************
;
;
;                       N O T I C E
;                       = = = = = =
;
; THE FOLLOWING ASSUMPTIONS HAVE BEEN MADE FOR THIS VERSION OF
; THE DRIVER:
;
;       1) THE FIRST FIVE UNIBUS MAP REGISTERS ON 22-BIT CPU'S ARE
;          MAPPED TO THE EXECUTIVE'S MEMORY SPACE (FIRST 20K WORDS
;          OF ABSOLUTE MEMORY).
;
;       2) THE DRIVER'S DATA BASE, SPECIFICALLY THE UCB'S, WILL
;          ALWAYS BE LOCATED IN THE FRST 20K WORDS OF ABSOLUTE
;          MEMORY ON CPU'S USING THE UNIBUS MAP.
;
;       3) THE DEVICE SPECIFIC ENTRIES IN THE DEVICE DATA TABLES,
;          MOST NOTABLY IN THE UNIT CONTROL BLOCK (UCB), ARE NOT
;          RELOCATABLE.
;
;
;       IF THE DRIVERS DATA BASE (UCB AND SCB) ARE NO LONGER IN THE
;       FIRST 32K WORDS OF MEMORY ( IE. WITH 16 BIT REAL ADDRESSES)
;       THEN THE ROUTINES  "GCR"  AND  "LDPNTR"  WILL HAVE TO BE
;       REWRITTEN.  (LOOK FOR THE SYMBOL "#" IN COMMENTS.)
;
;       IF AND WHEN THE DRIVER SPECIFIC AREA OF THE "UCB" IS
;       MADE RELOCATABLE, THEN THE LOCATION  "UMSGBN"+16.
;       SHOULD BE RELOCATED AND THE SYMBOL  "RELUCB"  SHOULD
;       BE DEFINED BOTH HERE AND IN THE DATABASE (MSTAB.MAC).
;

        .PAGE
;
;                       N O T I C E
;                       = = = = = =
;
;
; THIS DRIVER FOR THE TS04 VIOLATES CORPORATE PACKET PROTOCOL!!!!!
;
;
; THE DRIVER MAY RELEASE A MESSAGE BUFFER IT DOESN'T OWN.  THIS
; CAN HAPPEN FREQUENTLY, BECAUSE THE BUFFER IS RELEASED:
;       1) WITH EVERY COMMAND PACKET ISSUED,
;       2) WHEN ITS CONTENTS ARE NO LONGER NEEDED AND THE DRIVER
;       IS GOING TO SUSPEND ACTIVITY FOR A WHILE.
;
        .PAGE
        .SBTTL  SYMBOL DEFINITIONS
;
; MACRO LIBRARY CALLS
;
        .MCALL  ABODF$,CLKDF$,HWDDF$,PKTDF$,UCBDF$
        ABODF$                  ;TASK ABORT CODES
        CLKDF$                  ;CLOCK QUEUE CONTROL BLOCK OFFSETS
        HWDDF$                  ;HARDWARE REGISTERS
        PKTDF$                  ;I/O PACKET OFFSETS
        UCBDF$                  ;UNIT CONTROL BLOCK OFFSETS.

        .IF DF D$$IAG           ;%%% 1 %%%
        .MCALL  UMDIO$
        UMDIO$                  ;USER MODE DIAGNOSITIC DEFINITIONS
        .ENDC                   ;%%% 1 %%%

;
; EQUATED SYMBOLS
;

RETRY=  24.                     ;TOTAL RETRY COUNT (3 GROUPS OF 8)
MODUL4= 3                       ;MODULO 4 BOUNDARY BIT CLEAR MASK
STATWD= 5.                      ;NUMBER OF EXTENDED STATUS WORDS

;
; TS11 UNIBUS DEVICE REGISTER OFFSETS
;

TSBA=   0                       ;BUS ADDRESS REGISTER
TSDB=   0                       ;DATA BUFFER REGISTER
TSSR=   2                       ;STATUS REGISTER

;
; UCB EXTENSION AREA OFFSETS AND FORMATS
;

U.CBP=  U.VCB+2                 ;COMMAND BUFFER POINTER.
U.CRP=  U.CBP+2                 ;CHARACTERISTICS POINTER.
U.MSGB= U.CRP+2                 ;MESSAGE BUFFER OFFSET
                                ;MESSAGE HEADER WORD
                                ;DATA FIELD LENGTH WORD
                                ;RBPCR
                                ;XSTAT0
                                ;XSTAT1
                                ;XSTAT2
                                ;XSTAT3
                                ;TSSR COPY.
THRES1= 16.                     ; FIRST THRESHOLD FOR RETRIES
THRES2= 8.                      ; SECOND THRESHOLD FOR RETRIES
U.CMDB= U.MSGB+TSSRC+2          ;COMMAND BUFFER
                                ;MODULO 4 ALIGNMENT PAD WORD
                                ;COMMAND HEADER WORD
                                ;BUS ADDRESS BITS 0-15 OR COUNT
                                ;BUS ADDRESS BITS 16-17
                                ;COUNT
U.CDAT= U.CMDB+10.              ;WRITE CHARACTERISTICS DATA
                                ;MESSAGE BUFFER ADDRESS (2 WORDS)
                                ;MESSAGE BUFFER LENGTH (ALWAYS 14.)
U.CHAR= U.CDAT+6                ;CHARACTERISTIC WORD
        .PAGE
;
; BIT DEFINITIONS FOR UCB CHARACTERISTICS WORD # 2 (U.CW2)
;

M.PEOV= 100000                  ;TAPE PAST LOGICAL END OF VOLUME
M.AEOV= 40000                   ;TAPE AT LOGICAL END OF VOLUME
M.BOT=  20000                   ;TAPE IS AT BOT
M.1600= 4000                    ;UNIT IS 1600 BPI PHASE ENCODED
M.HWL=  2000                    ;HARDWARE WRITE LOCK
M.RWD=  1000                    ;UNIT IS REWINDING
M.SER=  400                     ;SELECT ERROR HAS OCCURRED
M.IWR=  200                     ;*INHIBIT WRITE RETRIES
M.SWL=  100                     ;*SOFTWARE WRITE LOCKED
M.TMK=  40                      ; LAST 
M.EOT=  20                      ;LAST CMND ENCOUNTERED END OF TAPE
M.SWAP= 2                       ;*SWAP BYTES FOR COMPATIBILITY MODE
M.FEF=  1                       ;TAPE IS PAST ONE TAPE MARK.

USRBTS= M.IWR!M.SWL!M.SWAP      ;STATUS BITS CONTROLLED BY THE USER
NEWBTS= M.PEOV!M.BOT!M.EOT!M.SER!M.HWL!M.RWD    ; STATUS BITS TO BE DETERMINED
MOVBTS= M.TMK!M.AEOV                    ; BITS SET BY TAPE MOTION

;
; FLAG BIT DEFINITIONS FOR UCB CHARACTERISTICS WORD # 3 (U.CW3)
;

U3.ERR= 100000                  ;ERROR DETECTED DOING REQUEST.
U3.EOF= 40000                   ;TAPE POSITIONED PAST TAPE MARK.
U3.NIP= 20000                   ;IGNORE INTERRUPT FLAG.
U3.TMO= 10000                   ;THIS OPERATION HAS TIMED OUT.          ; AP011
U3.CVC= 4000                    ;VOLUME CHECK BEING CLEARED             ; AP011
U3.NER= 2000                    ;NO ERROR RECOVERY.                     ;**-2
U3.ABO= 1000                    ;ABORT IN PROGRESS
U3.STK= 400                     ;INTERNAL OPERATION - ORIGINAL STACKED.
U3.UMD= 200                     ;USER MODE DIAGNOSTIC REQUEST
U3.RSP= 40                      ;REWIND/SPACE IN PROGRESS
U3.LBA= 20                      ;LOADING MSG BUFFER ADDRESS INTO TS04
;U3.GST=16                      ;DOING GET STATUS
;U3.BPK=4                       ;BUILDING PACKET FLAG
;U3.SAK=2                       ;SEND ACK BIT FLAG
U3.CIP= 1                       ;COMMAND IN PROGRESS FLAG
        .PAGE
;
; EXTENDED STATUS REGISTER OFFSETS
;

TSRBPC= 4                       ;RESIDUAL BYTE/POSITION COUNT
TSXSR0= 6                       ;EXTENDED STATUS REGISTER 0
TSXSR1= 10                      ;EXTENDED STATUS REGISTER 1
TSXSR2= 12                      ;EXTENDED STATUS REGISTER 2
TSXSR3= 14                      ;EXTENDED STATUS REGISTER 3
TSSRC = 16                      ;DEVICE STATUS REGISTER COPY.

;
; MSGHDR BIT DEFINITIONS
;

MG.ACK= 100000                  ;MESSAGES'S ACKNOWLEDGE BIT
;       70000                   ;RESERVED BITS
;       7400                    ;CLASS CODE BITS (NOT USED)
MG.FMT= 340                     ;MESSAGE FORMAT BITS
MG.COD= 37                      ;MESSAGE CODE BITS

;
; MESSAGE CODES
;

MC.END= 020                     ;END
MC.FAL= 021                     ;FAIL
MC.ERR= 022                     ;ERROR
MC.ATN= 023                     ;ATTENTION
MC.LOG= 024                     ;LOG (NOT USED)

;
; TSXSR0 BIT DEFINITIONS
;

X0.TMK= 100000                  ;TAPE MARK DETECTED
X0.RLS= 40000                   ;RECORD LENGTH SHORT
X0.LET= 20000                   ;LOGICAL END OF TAPE
X0.RLL= 10000                   ;RECORD LENGTH LONG
X0.WLE= 4000                    ;WRITE LOCK ERROR
X0.NEF= 2000                    ;NON-EXECUTABLE FUNCTION
X0.ILC= 1000                    ;ILLEGAL COMMAND
X0.ILA= 400                     ;ILLEGAL ADDRESS
X0.MOT= 200                     ;TAPE MOTION ON LAST COMMAND.
X0.ONL= 100                     ;ON LINE
X0.IE=  40                      ;INTERRUPT ENABLE
X0.VCK= 20                      ;VOLUME CHECK
X0.PED= 10                      ;PHASE ENCODED DRIVE
X0.WLK= 4                       ;WRITE LOCK
X0.BOT= 2                       ;BEGINNING OF TAPE
X0.EOT= 1                       ;END OF TAPE DETECTED
        .PAGE
;
; TSXSR1 BIT DEFINITIONS
;

X1.DLT= 100000                  ;DATA LATE
;       40000                   ;NOT USED.
X1.COR= 20000                   ;CORRECTABLE DATA
X1.CRS= 10000                   ;CREASE DETECTED
X1.TIG= 4000                    ;TRASH IN GAP
X1.DBF= 2000                    ;(PE)  DESKEW BUFFER FAIL.
X1.NZO= 2000                    ;(NRZ) NRZ BOARD FIFO OVERFLOW.
X1.SCK= 1000                    ;SPEED CHECK
;       400                     ;NOT USED
X1.IPR= 200                     ;(PE)  INVALID PREAMBLE
X1.SYN= 100                     ;(PE)  SYNCH ERROR
X1.DRP= 100                     ;(NRZ) FRAME DROPOUT.
X1.IPO= 40                      ;(PE)  INVALID POSTAMBLE
X1.ITM= 40                      ;(NRZ) ILLEGAL TAPE MARK
X1.IED= 20                      ;(PE)  INVALID END DATA
X1.LC0= 20                      ;(NRZ) LRC WAS ZERO (0).
X1.POS= 10                      ;(PE)  POSTAMBLE SHORT
X1.NZN= 10                      ;(NRZ) NOISE RECORD.
X1.POL= 4                       ;(PE)  POSTAMBLE LONG
X1.LRC= 4                       ;(NRZ) LONGITUDINAL REDUNDANCY CHECK ERR
X1.UNC= 2                       ;(PE)  UNCORRECTABLE DATA ERROR
X1.CRC= 2                       ;(NRZ) CYCLIC REDUNDANCY CHECK ERROR
X1.MTE= 1                       ;(PE)  MULTI-TRACK ERROR
X1.VPE= 1                       ;(NRZ) VERTICAL PARITY ERROR

;
; TSXSR2 BIT DEFINITIONS
;

X2.OPM= 100000                  ;OPERATION IN PROGRESS
X2.SIP= 40000                   ;SILO PARITY ERROR.
X2.BPE= 20000                   ;SERIAL BUS PARITY ERROR AT DRIVE
X2.CAF= 10000                   ;CAPSTAN ACCELERATION FAIL
;       4000                    ;NOT USED.
X2.WCF= 2000                    ;WRITE CLOCK FAIL.
X2.XSK= 1000                    ;EXCESSIVE SKEW
X2.DTK= 777                     ;DEAD TRACKS P,7-0.

;
; TSXSR3 BIT DEFINITIONS
;

X3.FEC= 177400                  ;FATAL ERROR CODE BITS
X3.LMX= 200                     ;TAPE LIMIT EXCEEDED.
X3.OPI= 100                     ;OPERATION INCOMPLETE
X3.REV= 40                      ;TAPE MOVED BACKWARDS.
X3.CRF= 20                      ;CAPSTAN RESPONSE FAIL
X3.DCK= 10                      ;DENSITY CHECK
X3.NOI= 4                       ;NOISE RECORD
X3.SGP= 2                       ;SHORT GAP
X3.RIB= 1                       ;REVERSE INTO BOT
        .PAGE
;
; TSSR BIT DEFINITIONS
;

SR.SC=  100000                  ;SPECIAL CONDITION
SR.UPE= 40000                   ;UNIBUS PARITY ERROR
SR.SPE= 20000                   ;SERIAL BUS PARITY ERROR
SR.RMR= 10000                   ;REGISTER MODIFICATION REFUSED
SR.NXM= 4000                    ;NON-EXISTENT MEMORY
SR.NBA= 2000                    ;NEED BUFFER ADDRESS
SR.A17= 1000                    ;BA 17
SR.A16= 400                     ;BA 16
SR.SSR= 200                     ;SUB-SYSTEM READY
SR.OFL= 100                     ;DEVICE IS OFF LINE
SR.FC1= 40                      ;FATAL ERROR CLASS BIT 1
SR.FC0= 20                      ;FATAL ERROR CLASS BIT 0
SR.TC2= 10                      ;TERMINATION CLASS BIT 2
SR.TC1= 4                       ;TERMINATION CLASS BIT 1
SR.TC0= 2                       ;TERMINATION CLASS BIT 0
SR.TCN= SR.TC2!SR.TC1!SR.TC0    ;TERMINATION CLASS NUMBER.

SR.BAD= SR.UPE!SR.SPE!SR.NXM!SR.NBA     ;FATAL ERROR CODITIONS.

;
; CHARACTERISTICS FLAG DEFINITIONS
;

CH.ESS= 200                     ;ENABLE SPACE STOP ON EOF,EOF
CH.EAI= 40                      ;ENABLE ATTENTION INTERRUPTS.
CH.ERI= 20                      ;ENABLE (BUFFER) RELEASE INTERRUPTS.
        .PAGE
;
; CMDHDR BIT DEFINITIONS
;

CM.ACK= 100000                  ;ACKNOWLEDGE BIT
CM.CVC= 40000                   ;CLEAR VOLUME CHECK
CM.OPP= 20000                   ;OPPOSITE BIT
CM.SWB= 10000                   ;SWAP BYTES
CM.MOD= 7400                    ;COMMAND MODE BITS
CM.RTY= 1000                    ;RETRY MODE BIT.
CM.RVS= 400                     ;REVERSE DIRECTION MODE BIT.
CM.IE=  200                     ;INTERRUPT ENABLE
CM.COD= 37                      ;COMMAND CODE BITS
CM.LOW= 3                       ;LOW HALF OF CODE BITS.
CM.NML= CM.IE!CM.ACK            ;NORMAL COMBO. OF FLAGS.

;
; TS04 COMMAND MODES/CODES
;

CC.RDN= 0001!CM.NML             ;* READ NEXT (FORWARD)
CC.RDP= 0401!CM.NML             ;* READ PREVIOUS (REVERSE)
CC.RRP= 1001!CM.NML             ;* REREAD PREVIOUS (SPACE REV,READ FWD)
CC.RRN= 1401!CM.NML             ;* REREAD NEXT (SPACE FWD, READ REV)
CC.WRC= 0004!CM.NML             ;+ WRITE CHARACTERISTICS
CC.WRD= 0005!CM.NML             ;* WRITE DATA
CC.WDR= 1005!CM.NML             ;* WRITE DATA RETRY (SPACE REV, ERASE,
                                ; WRITE DATA)
CC.WSM= 0006!CM.NML             ;* WRITE SUBSYSTEM MEMORY
CC.SRF= 0010!CM.NML             ;$ SPACE RECORDS FORWARD
CC.SRR= 0410!CM.NML             ;$ SPACE RECORDS REVERSE
CC.STF= 1010!CM.NML             ;$ SKIP TAPE MARKS FORWARD
CC.STR= 1410!CM.NML             ;$ SKIP TAPE MARKS REVERSE
CC.RWD= 2010!CM.NML!CM.CVC      ;- REWIND
CC.WTM= 0011!CM.NML             ;- WRITE TAPE MARK
CC.ERS= 0411!CM.NML             ;- ERASE
CC.WTR= 1011!CM.NML             ;- WRITE TAPE MARK RETRY (SPACE REV,
                                ; ERASE, WRITE TAPE MARK)
CC.BRL= 0012!CM.NML             ;- MESSAGE BUFFER RELEASE
CC.UNL= 0412!CM.NML!CM.CVC      ;- REWIND AND UNLOAD
CC.CLN= 1012!CM.NML             ;- CLEAN
CC.DRI= 0013!CM.NML             ;- DRIVE INITIALIZE
CC.GST= 0017!CM.NML             ;- GET STATUS IMMEDIATE

CC.MST=CC.GST!CM.CVC            ;MOUNT & SET CHARACTERISTICS            ;AP012
        .PAGE                                                           ;**-1
        .SBTTL  LOCAL STORAGE AND DISPATCH TABLES.
;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   T$$S11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   T$$S11          ;CURRENT ERROR RETRY COUNT (LOW BYTE)
                                ;  15 SECOND T/O COUNTER (HIGH BYTE)
INTADD: .BLKW   T$$S11          ; INTERRUPT ADDRESS STORAGE             ;JC032
STATS:  .BLKW   T$$S11          ; STATUS SAVE WORD                      ;JC032
RTYINT: .BLKW   T$$S11          ; SAVE AREA FOR INTERRUPT ADDRESS       ;JC032
CMDHDR: .BLKW   T$$S11          ; COMMAND HEADER SAVE AREA              ;JC032
                                                                        ;**-3
        .IF GT  T$$S11-1        ;%%% 1 %%%
TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER
        .ENDC                   ;%%% 1 %%%
;
; DISPATCH TABLES
;
; DRIVER DISPATCH TABLE
;

$MSTBL::.WORD   MSINI           ;I/O OPERATION INITIATION ENTRY POINT
        .WORD   MSCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   MSOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   MSPWF           ;POWERFAIL ENTRY POINT


;
; TERMINATION CODE DISPATCH TABLE
;

ERJTBL: .IRPC   X,<01234567>
        .WORD   TCL'X'ER
        .ENDM

;                                                                       ;JC032
;+                                                                      ;JC032
; SETRTY - SETUP RETRY COMMAND FOR COMMANDS OTHER THAN FUNCTION IN PROGR;JC032
;                                                                       ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
        .MACRO  SETRTY  FCDE,ADR,CNT                                    ;JC032
                                                                        ;JC032
        MOV     (R2),CMDHDR(R3) ; SAVE COMMAND HEADER                   ;JC032
        MOV     #CC.'FCDE,(R2)  ; SET NEW COMMAND                       ;JC032
        MOVB    #60.,S.ITM(R4)  ; SET 1 MINUTE TIMEOUT                  ;JC032
        MOV     INTADD(R3),RTYINT(R3) ;SAVE INTERRUPT ADDRESS           ;JC032
        MOV     #'ADR,INTADD(R3) ; SET INTERMEDIATE INT ADDR            ;JC032
;                                                                       ;JC032
; NOTE:                                                                 ;JC032
;       LOCATION OF CNT IS SECOND WORD OF COMMAND PACKET. THIS IS USED  ;JC032
;       FOR POSITIONING COMMANDS ONLY.                                  ;JC032
;                                                                       ;JC032
        .IF NB  CNT                                                     ;JC032
                                                                        ;JC032
        MOV     #'CNT,2(R2)     ; SET NEW COUNT                         ;JC032
                                                                        ;JC032
        .ENDC                                                           ;JC032
                                                                        ;JC032
        .ENDM                                                           ;JC032
        .PAGE
        .SBTTL  DATA TABLES
;
; VALID TS11/TS04 FUNCTION TABLE
;
; FORMAT OF EACH TABLE ENTRY:
;       FCN=I/O FUNCTION CODE
;       HCC=EQUIVALENT HARDWARE COMMAND CODE
;       TMO=COMMAND'S TIMEOUT VALUE IN SECONDS
;       ADR=INITIATION PROCESSING ADDRESS OR I/O COMMON ADDRESS
;
        .MACRO  FUNCT   FCN,HCC,TMO,INT,ADR                             ;JC032
        .WORD   IO.'FCN                                                 ;**-1
        .WORD   CC.'HCC
        .BYTE   0,TMO                                                   ;JC032
        .WORD   I'INT                                                   ;JC032
        .WORD   P'ADR                                                   ;JC032
.ENDM   FUNCT                                                           ;**-2

VFTBL:  FUNCT   RLB,RDN,12.,OCOM,IOCOM  ; READ LOGICAL BLOCK FORWARD    ;JC032
        FUNCT   WLB,WRD,12.,OCOM,WRITE  ; WRITE LOGICAL BLOCK           ;JC032
        FUNCT   RLV,RDP,12.,RREV,IOCOM  ; READ LOGICAL BLOCK REVERSE    ;JC032
        FUNCT   EOF,WTM,4.,WRMK,WRTMK   ; WRITE TAPE MARK               ;JC032
        FUNCT   RWD,RWD,2.,OEXT,REWND   ; REWIND                        ;JC032
        FUNCT   RWU,UNL,2.,OEXT,UNLOD   ; REWIND AND UNLOAD             ;JC032
        FUNCT   SPB,SRF,60.,SPCB,SPACE  ; SPACE BLOCKS                  ;JC032
        FUNCT   SPF,STF,60.,SPCF,SPACE  ; SPACE FILES                   ;JC032
        FUNCT   STC,MST,2.,STAT,SET     ; SET CHARACTERISTICS           ;JC032
        FUNCT   SEC,GST,2.,STAT,GSTAT   ; SENSE CHARACTERISTICS         ;JC032
        FUNCT   SMO,MST,2.,STAT,MOSE    ; MOUNT AND SET CHARACTERISTICS ;JC032
        FUNCT   ERS,ERS,12.,OEXT,WRTMK  ; ERASE TAPE                    ;JC032
;       FUNCT   CLN,CLN,60.,CLN,CLN     ; CLEAN TAPE - (NOT IMPLEMENTED);JC032
                                                                        ;**-13
EVFTBL:

;
; MESSAGE HEADER TABLE
;

MESSAG: .WORD   MC.END,MC.ATN,MC.END,MC.FAL
        .WORD   MC.ERR,MC.ERR,MC.ERR,MC.ERR
.PAGE
        .SBTTL  MSINI - I/O INITIATOR
;+
; **-MSINI-TS11/TS04 MAGNETIC TAPE CONTROLLER I/O INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O
; REQUEST IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO
; PROPAGATE THE EXECUTION OF THE DRIVER.  IF THE SPECIFIED CONTROLLER
; IS NOT BUSY, THEN AN ATTEMPT IS MADE TO DEQUEUE THE NEXT I/O
; REQUEST.  ELSE A RETURN TO THE CALLER IS EXECUTED.  IF THE
; DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPERATION IS
; INITIATED.  A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5 = ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST
;       IS WAITING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED
;       AND THE I/O OPERATION IS INITIATED.
;-
;+
; THE FOLLOWING REGISTERS CONTENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB
;       R3=CONTROLLER INDEX
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED
;
; TS11 MAGNETIC TAPE FUNCTION INDEPENDENT I/O REQUEST PACKET FORMAT:
;
;I.LNK  WD. 00 = I/O QUEUE THREAD WORD.
;I.PRI  WD. 01 = REQUEST PRIORITY (LOW BYTE).
;I.EFN  WD. 01 = EVENT FLAG NUMBER (HIGH BYTE).
;I.TCB  WD. 02 = ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;I.LN2  WD. 03 = POINTER TO 2ND LUN WORD IN REQUESTOR TASK HEADER.
;I.UCB  WD. 04 = CONTENTS OF 1ST LUN WORD IN REQUESTOR TASK HEADER (UCB)
;I.FCN  WD. 05 = I/O FUNCTION CODE (IO.RLB/IO.RWD/IO.SPB/ETC.).
;I.IOSB WD. 06 = VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;IOSB+2 WD. 07 = RELOCATION BIAS OF I/O STATUS BLOCK.
;IOSB+4 WD. 10 = I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT+140000).
;I.AST  WD. 11 = VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;
;
; READ/WRITE LOGICAL FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;I.PRM  WD. 12 = HIGH 2 BITS (BITS 4 & 5) OF 18 BIT DATA BUFFER ADDRESS.
;PRM+2  WD. 13 = LOW 16 BITS OF 18 BIT DATA BUFFER ADDRESS.
;PRM+4  WD. 14 = NUMBER OF BYTES TO BE TRANSFERRED.
;PRM+6  WD. 15 = NOT USED.
;PRM+10 WD. 16 = NOT USED.
;PRM+12 WD. 17 = NOT USED.
;PRM+14 WD. 20 = RELOCATION BIAS OF DIAGNOSTIC REGISTER BLOCK ADDRESS.
;PRM+16 WD. 21 = DIAG. REG. BUFFER ADDRESS (REAL/DISPLACEMENT+140000).
;
;
; BLOCK AND FILE SPACING FUNCTIONS DEPENDENT I/O PACKET FORMAT:
;
;I.PRM  WD. 12 = SPACING COUNT (POSITIVE=FORWARD, NEGATIVE=BACKWARD).
;PRM+2  WD. 13 = NOT USED.
;PRM+4  WD. 14 = NOT USED.
;PRM+6  WD. 15 = NOT USED.
;PRM+10 WD. 16 = NOT USED.
;PRM+12 WD. 17 = RELOCATION BIAS OF DIAGNOSTIC REGISTER BLOCK ADDRESS.
;PRM+14 WD. 20 = DIAG. REG. BUFFER ADDRESS (REAL/DISPLACEMENT+140000).
;PRM+16 WD. 21 = NOT USED.
;
;
; (MOUNT AND) SET CHARACTERISTICS FUNCTION DEPENDENT I/O PACKET FORMAT.
; FOR SENSE CHARACTERISTICS, I.PRM (WD. 12) IS NOT USED:
;
;I.PRM  WD. 12 = NEW CHARACTERISTICS WORD.
;PRM+2  WD. 13 = NOT USED.
;PRM+4  WD. 14 = NOT USED.
;PRM+6  WD. 15 = NOT USED.
;PRM+10 WD. 16 = NOT USED.
;PRM+12 WD. 17 = NOT USED.
;PRM+14 WD. 20 = NOT USED.
;PRM+16 WD. 21 = NOT USED.
;
;
; WREOF, REWIND, AND UNLOAD FUNCTIONS DEPENDENT I/O PACKET FORMAT:
;
;I.PRM  WD. 12 = NOT USED.
;PRM+2  WD. 13 = NOT USED.
;PRM+4  WD. 14 = NOT USED.
;PRM+6  WD. 15 = NOT USED.
;PRM+10 WD. 16 = NOT USED.
;PRM+12 WD. 17 = RELOCATION BIAS OF DIAGNOSTIC REGISTER BLOCK ADDRESS.
;PRM+14 WD. 20 = DIAG. REG. BUFFER ADDRESS (REAL/DISPLACEMENT+140000).
;PRM+16 WD. 21 = NOT USED.
;-
        .PAGE

        .ENABL  LSB
MSINI:  CALL    $GTPKT          ;ATTEMPT TO GET AN I/O PACKET
        BCC     10$     ; IF CC WE HAVE A PACKET                        ;JC032
        RETURN          ; ELSE RETURN                                   ;JC032
                                                                        ;JC032
10$:    MOV     R5,CNTBL(R3)    ; SAVE ADDRESS OF CURRENT UCB           ;JC032
        MOV     U.CHAR(R5),R0   ; RETRIEVE CHARACTERISTICS WORD         ;JC032
        BIC     #CH.ESS,R0      ; CLEAR LET FLAG                        ;JC032
                                                                        ;JC032
        .IF DF  A$$NSI                                                  ;JC032
                                                                        ;JC032
        BITB    #US.LAB,U.STS(R5) ; MOUNTED ANSII TAPE?                 ;JC032
        BNE     20$             ; IF NE YES - DON'T STOP ON DOUBLE TMK  ;JC032
                                                                        ;JC032
        .ENDC                                                           ;JC032
        BIS     #CH.ESS,R0      ; NOT ANSII - ENABLE STOP ON LEOT       ;JC032
20$:    CMP     R0,U.CHAR(R5)   ; CHARACTERISTICS WORD SET CORRECTLY?   ;JC032
        BEQ     40$             ; IF EQ YES, ELSE...                    ;JC032
        JMP     GCR             ; ...GO WRITE CHARACTERISTICS           ;JC032
                                                                        ; AP003
40$:    BIT     #SR.NBA,@S.CSR(R4)      ;IS THE TS04 TALKING ?          ; AP003
        BEQ     45$                     ;YES=> PROCEED; ELSE            ; AP003
        JMP     GCR             ; GO START DIALOG (GIVE BUFFER ADDRESS) ; AP003
        .PAGE                                                           ; AP003
ILDBA:  MOV     S.PKT(R4),R1    ;RELOAD PACKET POINTER.                 ; AP003
45$:    CLR     U.CW3(R5)       ;RESET DRIVER FLAGS                     ; AP003
        MOV     #VFTBL,R2       ;POINT AT VALID FUNCTIONS TABLE         ;**-41
        MOV     I.FCN(R1),R0    ;GET FUNCTION CODE FROM PACKET
        BIT     #IQ.X,R0        ;ERROR RECOVERY PROHIBITED ?
        BEQ     50$             ;NO=> SKIP AHEAD; ELSE SET
        BIS     #U3.NER,U.CW3(R5)       ; CORRESPONDING FLAG
        BIC     #IQ.X,R0        ; AND CLEAR BIT FOR COMPARE.
50$:                            ;REFERENCE LABEL.

        .IF DF  D$$IAG          ;%%% 1 %%%
        CLRB    RTTBL+1(R3)     ; CLEAR USER MODE FLAG                  ;JC032
        BITB    #IQ.UMD,R0      ;DIAGNOSTIC FUNCTION CALL?
        BEQ     60$             ;IF EQ NO
        BIS     #100000,RTTBL(R3) ; SET DIAGNOSTIC FLAG                 ;JC032
        BIS     #U3.UMD,U.CW3(R5)  ;COPY DIAGNOSTIC FLAG
        BIC     #IQ.UMD,R0      ;CLEAR BIT FOR FUNCTION CHECK
        .ENDC                   ;%%% 1 %%%

60$:    CMP     R0,(R2)+        ;FUNCTION CODES MATCH?
        BEQ     70$             ;IF EQ YES
        ADD     #10,R2          ; POINT TO NEXT TABLE ENTRY             ;JC032
        BNE     60$             ;IF NE NO                               ;**-2
        MOV     #IE.IFC&377,R0  ;SET UP ILLEGAL FUNCTION CODE
        BR      ALT             ;GO TO EXIT



70$:    MOVB    #RETRY,RTTBL(R3) ;SET RETRY COUNT                       ;JC032
        MOV     (R2)+,R1        ; RETRIEVE HARDWARE COMMAND CODE        ;JC032
        MOV     (R2)+,S.CTM(R4) ; SET INITIAL TIMEOUT VALUE             ;JC032
        MOV     (R2)+,INTADD(R3)        ; STORE INTERRUPT ADDRESS       ;JC032
        JMP     @(R2)+          ;GO TO PRE-PROCESSING FOR THIS FUNCTION ;**-3

        .PAGE
        .SBTTL  SPECIALIZED PRE-PROCESSING OF USER REQUESTS.
        .ENABL  LSB
;-
;  PRE-PROCESSING ROUTINES FOR I/O OPERATIONS
;
; INPUTS:
;       R1 = HARDWARE FUNCTION CODE
;       R3 = CONTROLLER INDEX
;       R4 = SCB ADDRESS
;       R5 = UCB ADDRESS
;-

;
; WRITE DATA
;

PWRITE: CMP     U.CNT(R5),#14.  ;ENOUGH BYTES FOR WRITE?
        BHIS    75$             ;IF HIS YES
        TST     U.CNT(R5)       ;IS IT MAX COUNT?
        BEQ     75$             ;IF EQ YES
        MOV     #IE.SPC&377,R0  ;SET UP PARAMETER ERROR CODE
        BR      ALT             ;GO TO EXIT

;
; WRITE TAPE MARK
;

PWRTMK: CLR     U.CNT(R5)       ;INSURE COUNT IS 0
75$:    BIT     #M.SWL,U.CW2(R5) ;SOFTWARE WRITE LOCK IN EFFECT?
        BEQ     PIOCOM          ;IF EQ NO
        MOV     #IE.WLK&377,R0  ;SET UP WRITE LOCK ERROR CODE
        BR      ALT             ;GO TO EXIT

;
; SPACE BLOCKS AND SPACE FILES
;

PSPACE: MOV     #IS.SUC&377,R0  ;ASSUME 0 SPACING COUNT
        MOV     U.BUF(R5),U.CNT(R5) ;PUT SPACING COUNT IN PLACE
        BEQ     ALT             ;IF EQ NO I/O NEEDED (U.BUF=0)
        BMI     90$             ;IF MI SPACE REVERSE (U.BUF=NEGATIVE)
        BIT     #M.PEOV,U.CW2(R5)       ; ALREADY AT EOV?               ;JC032
        BEQ     100$            ;IF EQ NO                               ;**-1
        MOV     #IE.EOV&377,R0  ;SET UP END OF VOLUME CODE
ALT:    CALL    $IOALT          ;TERMINATE THIS REQUEST
        JMP     MSINI           ;GO CHECK FOR ANOTHER PACKET



90$:    BIS     #CC.SRR-CC.SRF,R1 ;MAKE CMND SPACE/SKIP REVERSE
        NEG     U.CNT(R5)       ;MAKE COUNT POSITIVE
100$:   BIS     #U3.RSP,U.CW3(R5) ;SET "REWIND/SPACE IN PROGRESS" FLAG
        BR      PIOCOM          ;GO TO COMMON PROCESSING
        .PAGE
;
; MOUNT AND SET CHARACTERISTICS
;

PMOSE:  BIT     #SR.OFL,@S.CSR(R4)      ;IS UNIT OFFLINE ?
        BNE     110$            ;YES=> FAILED ALREADY; ELSE
        BIT     #M.BOT,U.CW2(R5)        ;IS TAPE POSITIONED RIGHT ?
        BEQ     110$            ;NO=> OTHER FAILURE; ELSE ...
        ;BR     PSET            ;CONTINUE WITH THE "SET ..." PART.

;
; SET CHARACTERISTICS
;

PSET:   BIC     #USRBTS,U.CW2(R5) ;CLEAR USER SETTABLE BITS             ;AP012
        BIC     #^C<USRBTS>,U.BUF(R5)   ;REMOVE NON-SETABLE BITS.       ;**-3
        BIS     U.BUF(R5),U.CW2(R5)     ;UPDATE USER SETABLE BITS.
        BR      PUNLOD          ;CONTINUE                               ;AP012
110$:   MOV     #IE.FHE&377,R0  ;SET FATAL ERROR STATUS                 ;AP012
        BR      ALT             ; EXIT                                  ;AP012
;                                                                       ;AP012
; GET STATUS (FOR SENSE, (MOUNT AND) SET CHARACTERISTICS)               ;AP012
;                                                                       ;AP012
PGSTAT: MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL RETURN                  ;AP012
        JMP     @INTADD(R3)     ;EXIT                                   ;AP012
                                                                        ;**-19
;
; REWIND TAPE
;

PREWND: BIS     #M.RWD,U.CW2(R5)        ;SET TAPE REWINDING FLAG.
        ;BR     PUNLOD          ;FALL INTO ANOTHER FUNCTION.

;
; MOVE TAPE UNDER CLEAN HEADS AND RETURN TO PRESENT POSITION.
;

;PCLN:  ;BR     PUNLOD          ;PREPERATION REQUIRES NOTHING.          ; AP000
                                                                        ;**-1
;
; UNLOAD TAPE
;

PUNLOD: CLR     U.CNT(R5)       ;INSURE COUNT IS 0
        ;BR     PIOCOM          ;DO COMMON IO PRE-PROCESSING.
        .PAGE
        .SBTTL  COMMON PRE-PROCESSING OF USER REQUESTS.
        .ENABLE LSB
;
;  I/O OPERATION COMMON PRE-PROCESSING
;

PIOCOM: MOV     U.CBP(R5),R2    ; GET COMMAND BUFFER POINTER            ;JC032
        MOV     R1,(R2)+        ; LOAD COMMAND HEADER IN BUFFER         ;JC032
        BIC     #^C<CM.COD>,R1  ;ISOLATE COMMAND CODE BITS              ;**-2
        CMP     R1,#CC.SRF&CM.COD ;COMMAND NEED AN ADDRESS?
        BHIS    130$            ;IF HIS NO
        BIT     #M.SWAP,U.CW2(R5)  ;SWAP BYTES ON DATA?
        BEQ     120$            ;IF EQ NO
        BIS     #CM.SWB,-2(R2)  ; SET SWAP BITS BYTE IN HEADER WORD     ;JC032
120$:                           ;REF LABEL                              ;**-1

        .IF DF  M$$EXT&M$$MGE   ;%%% 1 %%%
        CALL    $STMAP          ; SET UP UNIBUS MAPPING                 ;JC032
        MOV     R2,-(SP)        ; SAVE R2                               ;JC032
        CALL    $MPUBM          ; MAP UNIBUS TO TRANSFER                ;JC032
        MOV     (SP)+,R2        ; RESTORE R2                            ;JC032
        .ENDC                   ;%%% 1 %%%                              ;**-4

        MOV     U.BUF+2(R5),(R2)+       ; PUT LOW ORDER 16 BITS IN BUFFE;JC032
                                                                        ;**-1
        .IF DF  M$$MGE          ;%%% 1 %%%
        MOV     U.BUF(R5),(R2)  ; LOAD HIGH 2 BITS OF ADDRESS           ;JC032
        ASR     (R2)            ; AND MOVE FROM                         ;JC032
        ASR     (R2)            ; BITS 4 AND 5                          ;JC032
        ASR     (R2)            ;     TO                                ;JC032
        ASR     (R2)+           ; BITS 0 AND 1                          ;JC032
                                                                        ;JC032
        .IFF                                                            ;JC032
                                                                        ;JC032
        CLR     (R2)+           ; CLEAR HIGH BITS                       ;JC032
                                                                        ;JC032
        .ENDC                                                           ;JC032
                                                                        ;JC032
130$:   MOV     U.CNT(R5),(R2)  ; LOAD BYTE/RECORD/FILE COUNT           ;JC032
        ;BR     INITIO          ;FALL INTO INITIATE I/O                 ;**-11
        .PAGE
        .SBTTL  INITIO - COMMAND TS04 TO DO ITS THING.
        .ENABL  LSB
;+
; INITIATE I/O OPERATION
;
; INPUTS:
;       R4 = SCB ADDRESS
;       R5 = UCB ADDRESS
;-

INITIO: MOVB    S.ITM(R4),S.CTM(R4) ;START THE TIMER
                                                                        ;**-1
        .IF DF  E$$DVC          ;%%% 1 %%%
        CALL    $BMSET          ;;;SET BIT IN I/O ACTIVE MAP

        .IFF                    ;%%% 1 %%%
        MTPS    #PR7            ;;;INHIBIT INTERRUPTS
                                                                        ; AP010
        .IFTF                           ;%%% 1 %%%                      ; AP010
        CALL    LDPNTR                  ;;;LOAD COMMAND POINTER INTO TS1; AP010
        BIS     #U3.CIP!U3.NIP,U.CW3(R5)        ;;;SET "COMMAND IN PROGR; AP010
                                                ;;;& INTERRUPT IGNORE.  ; AP010
                                                                        ; AP010
        .IFF                            ;%%% 1 %%%                      ; AP010
        MTPS    #0                      ;;;ALLOW INTERRUPTS             ; AP010
        .ENDC                           ;%%% 1 %%%                      ; AP010
                                                                        ; AP010
        RETURN                  ;EXIT WHILE I/O IN PROGRESS             ;**-6
        .PAGE
        .SBTTL  MSCAN,MSPWF - CANCEL & POWERFAIL ENTRIES
        .ENABL  LSB
;+
; **-MSCAN-TS11/TS04 CANCEL I/O ENTRY POINT
;
; THE CANCEL I/O OPERATION IS BASICALLY A NOP FOR TS11
; MAGNETIC TAPES.  HOWEVER, IF A "NOT READY" MESSAGE IS
; BEING ISSUED DUE TO A SELECT ERROR, THE CANCEL I/O WILL
; CAUSE THE MESSAGES TO BE TERMINATED AND THE I/O ABORTED.
;
; INPUTS:
;       R0 = ACTIVE I/O PACKET ADDRESS
;       R1 = CURRENT TCB ADDRESS
;       R3 = CONTROLLER INDEX
;       R4 = SCB ADDRESS
;       R5 = UCB ADDRESS
;-

MSCAN:  BIS     #U3.ABO,U.CW3(R5)  ;;;INDICATE AN ABORT CONDITION
        RETURN                          ;;; RETURN TO MONITOR.

;+
; **-MSPWF-TS11/TS04 POWERFAIL ENTRY POINT
;
; POWERFAIL IS THE SAME AS INITIALIZE.  OUTSTANDING REQUESTS ARE
; HANDLED VIA THE DEVICE TIMEOUT FACILITY. THIS IS DONE TO AVOID
; A RACE CONDITION THAT COULD EXIST IN RESTARTING THE I/O OPERATION.
; THIS IS A GOOD TIME TO CALCULATE ALL SEMI-STATIC POINTERS.
;
; INPUTS:
;       R3 = CONTROLLER INDEX
;       R4 = SCB ADDRESS
;       R5 = UCB ADDRESS
;-

MSPWF:  MOV     R5,R0           ;;;COPY UCB BASE ADDRESS.
        ADD     #U.CDAT,R0      ;;;ADD OFFSET TO PRODUCE VIRTUAL
        MOV     R0,U.CRP(R5)    ;;; ADDRESS OF CHARACTERISTICS DATA.
        ADD     #U.MSGB-U.CDAT,R0       ;;;ADD OFFSET FROM OFFSET
        MOV     R0,U.CDAT(R5)           ;;;# TO COMPUTE POINTER TO MESSAGE.
        CLR     U.CDAT+2(R5)            ;;;# CLEAR HIGH ORDER BITS.
        ADD     #U.CMDB+2-U.MSGB,R0     ;;;ADD OFFSET FROM OFFSET
        BIC     #MODUL4,R0      ;;; AND ALIGN ON DOUBLE WORD BOUNDARY
        MOV     R0,U.CBP(R5)    ;;; TO MAKE POINTER TO COMMAND BUFFER.
        RETURN                  ;;;EXIT TO CALLER

        .PAGE
        .SBTTL  MSOUT - TIME OUT ENTRY POINT
        .ENABL  LSB
;+
; **-MSOUT-TS11/TS04 TIMEOUT ENTRY POINT                                ; AP000
;                                                                       ;**-1
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING TERMINATED.
; IF THE OPERATION WAS DIAGNOSTIC, THE QIO REQUEST IS TERMINATED.
; TIMEOUTS ARE USUALLY CAUSED BY POWER FAILURE BUT MAY ALSO BE THE
; RESULT OF HARDWARE CONSIDERATIONS.  IN PARTICULAR, A LENGTHY
; SPACING OPERATION OR A REWIND ON THIS MODEL TAPE DRIVE MAY
; RESULT IN A TIMEOUT WHICH WILL BE IGNORED.
;
; INPUTS:
;       R0 = LITERAL CONSTANT IE.DNR
;       R2 = CSR ADDRESS
;       R3 = CONTROLLER INDEX
;       R4 = SCB ADDRESS
;       R5 = UCB ADDRESS
;-

MSOUT:  BIT     #U3.ABO,U.CW3(R5)       ;;;BEEN TOLD TO ABORT?
        BNE     10$             ;;; IF NE YES - ABORT                   ;JC032
        BIT     #M.SER,U.CW2(R5) ;;; SELECT ERROR IN PROGRESS?          ;JC032
        BNE     NORDY           ;;; YES INFORM OPERATOR                 ;JC032
        BIT     #M.RWD,U.CW2(R5) ;;;REWIND TIMEOUT?                     ;JC032
        BNE     20$             ;;; IF NE YES - EXIT                    ;JC032
        BIT     #U3.RSP,U.CW3(R5) ;;; SPACE IN PROGRESS?                ;JC032
        BNE     20$             ;;; RESET TIMEOUT                       ;JC032
10$:    MTPS    #0              ;LOWER PRIORITY                         ;JC032
        CLR     @S.CSR(R4)      ; CLEAR SUBSYSTEM                       ;JC032
        JMP     IOEXT           ; AND EXIT                              ;JC032
20$:    MOVB    S.ITM(R4),S.CTM(R4) ;RESET TIMER                        ;JC032
        RETURN                                                          ;JC032
                                                                        ;JC032
;                                                                       ;JC032
; NORDY - TAPE UNIT IS NOT READY                                        ;JC032
;       SEND OPERATOR MESSAGE                                           ;JC032
;                                                                       ;JC032
NORDY:  BIT     #U3.NER!U3.UMD,U.CW3(R5) ; RETURN TO REQUESTOR?         ;JC032
        BNE     30$             ; IF NE YES - EXIT                      ;JC032
        TST     U.ACP(R5)       ; ACP ALSO WANTS RETURN                 ;JC032
        BNE     30$             ; YES - EXIT                            ;JC032
        MOV     #T.NDSE,R0      ; SET MESSAGE                           ;JC032
        CALL    $DVMSG          ; SEND OPERATOR MESSAGE                 ;JC032
        MOVB    #15.,S.CTM(R4)  ; SET 15 SECOND TIMER                   ;JC032
        RETURN                                                          ;JC032
                                                                        ;JC032
30$:    MOV     #IE.DNR&377,R0  ; INSURE PROPER MSG RETURNED            ;JC032
        JMP     IODON           ; EXIT MSG BUFFER ALREADY RELEASED      ;JC032
                                                                        ;**-40


GCR:    MOVB    #2,S.ITM(R4)    ; SET TIMEOUT                           ;JC032
        BIS     #U3.LBA,U.CW3(R5) ;SET WRITE CHARACTERISTICS FLAG       ;JC032
        MOV     U.CBP(R5),R2    ; RETRIEVE COMMAND BUFFER POINTER       ;JC032
        MOV     #CC.WRC,(R2)+   ; SET WRITE CHARACTERISTICS FUNCTION    ;JC032
        MOV     U.CRP(R5),(R2)+ ; LOAD LOW ORDER 16 BITS                ;JC032
        CLR     (R2)+           ; AND HIGH                              ;JC032
        MOV     #10,(R2)        ; LOAD BYTE COUNT                       ;JC032
        JMP     INITIO          ;GO INITIATE I/O                        ;**-12


;#
;# FOR MAPPED DATABASE (POOL &/OR EXEC)
;# THE MOV-CLR PAIRS ABOVE MUST BE REPLACED WITH CODE TO
;# CONVERT THE ADRESSES (OF THE CHARACTERISTICS DATA AND
;# MESSAGE BUFFER RESPECTIVELY) AND STORE THEIR TRUE 18
;# BIT VALUES (LOW 16 FOLLOWED BY HIGH 2).
;#
        .PAGE
        .SBTTL  MSINT - INTERRUPT HANDLING
        .ENABL  LSB
;+
; **-$MSINT-TS11/TS04 MAGNETIC TAPE CONTROLLER INTERRUPTS
;-

        INTSE$  MS,PR5,T$$S11           ;;;SAVE REGISTERS & SET PRIORITY; AP000
        BIC     #U3.NIP,U.CW3(R5)       ;;; CLEAR NO ITERRUPT PROCESSING; AP000
        CALL    $FORK                   ;;;CREATE A SYSTEM PROCESS      ; AP000
        BIT     #U3.NIP,U.CW3(R5)       ;;; PROCESS INTERRUPT?          ; AP000
        BNE     30$                     ;;; IF NE NO JUST EXIT          ; AP000
        MOV     U.SCB(R5),R4    ;PICK UP SCB ADDRESS                    ;**-5
        MOVB    S.CON(R4),R3    ;GET CONTROLLER INDEX.
        MOV     @S.CSR(R4),R1   ;SAVE DEVICE STATUS.
        MOV     R1,U.MSGB+TSSRC(R5)     ;SAVE DEVICE STATUS.
        BIT     #SR.NBA,R1              ; TSO4 NEED A BUFFER ADDRESS?   ;JC032
        BNE     GCR                     ; IF NE YES - WRITE CHARACTERIST;JC032
        MOV     U.CW2(R5),STATS(R3)     ; SAVE CURRENT STATUS           ;JC032
10$:    BIC     #NEWBTS,U.CW2(R5)       ; CLEAR STATUS BITS TO BE DETERM;JC032
        MOV     #IS.SUC&377,R0  ; SET SUCCUSS                           ;JC032
        BIC     #^C<SR.TCN>,R1  ; CLEAR ALL BUT TERMINATION CODE        ;JC032
        CMPB    U.MSGB(R5),MESSAG(R1) ;DOES MESSAGE MATCH TC?           ;JC032
        BEQ     20$             ; IF EQ YES                             ;JC032
        MOV     #14,R1          ; NO, FATAL ERROR                       ;JC032
20$:    JMP     @ERJTBL(R1)     ; GO PROCCESS INTERUPT                  ;JC032
                                                                        ;JC032
30$:    RETURN                                                          ;JC032
        .PAGE                                                           ;**-88
        .SBTTL  TERMINATION CODES TREATMENT CENTER
        .ENABL  LSB
;+
; CODE FOR THE TREATMENT OF THE EIGHT (10) TERMINATION CODES
; RETURNED WITH FAIL, ERROR, AND ATTENTION MESSAGES.
;
; INPUTS:
;       R1 = CHARACTERISTICS WORD 2 =(U.CW2)
;       R3 = CONTROLLER INDEX
;       R4 = SCB ADDRESS
;       R5 = UCB ADDRESS
;
; TERMINATION CLASS 0 (AN END MSG)
;
;-

TCL0ER: BIT     #X0.BOT,U.MSGB+TSXSR0(R5) ; TAPE AT BOT?                ;JC032
        BEQ     10$             ; IF EQ NO                              ;JC032
        BIS     #M.BOT,U.CW2(R5) ;YES SET STATUS BIT                    ;JC032
10$:    BIT     #U3.LBA,U.CW3(R5) ;WRITTEN CHARACTERISTICS??            ;JC032
        BNE     1700$           ; IF NE YES - GO ISSUE COMMAND          ;JC032
        JMP     @INTADD(R3)     ; FINISH PROCESSING REQUEST             ;JC032
                                                                        ;**-7

                                                                        ;**-11


;
; TERMINATION CLASS CODE 1 (ATTENTION CONDITION)
;


TCL1ER: BIT     #X0.BOT,U.MSGB+TSXSR0(R5) ;TAPE AT BOT?                 ;AP012
        BEQ     20$             ; IF EQ NO CONTINUE                     ;AP012
        BIS     #M.BOT,U.CW2(R5) ;SET STATUS BIT                        ;AP012
20$:    BIT     #U3.CIP,U.CW3(R5) ;COMMAND IN PROGRESS?                 ;AP012
        BNE     1700$           ; IF NE YES - GO ISSUE                  ;AP012
        CALLR   REL             ; ELSE RELEASE AND EXIT                 ;AP012
                                                                        ;**-3

1700$:  JMP     ILDBA           ;REDO START THE USER REQUEST.
        .PAGE
        .DSABL  LSB                                                     ;JC032
;
; TERMINATION CLASS 2 (TAPE STATUS ALERT)
;

TCL2ER: BIT     #X0.EOT,U.MSGB+TSXSR0(R5) ; EOT DETECTED?               ;JC032
        BEQ     10$             ; IF EQ NO                              ;JC032
        BIS     #M.EOT,U.CW2(R5) ; SET STATUS BIT                       ;JC032
        MOV     #IE.EOT&377,R0  ; SET EOT FOR RETURN                    ;JC032
10$:    BIT     #X0.TMK,U.MSGB+TSXSR0(R5) ; TAPE MARK DETECTED?         ;JC032
        BEQ     20$             ; IF EQ NO                              ;JC032
        BIS     #M.TMK,U.CW2(R5) ; SET STATUS BIT                       ;JC032
        MOV     #IE.EOF&377,R0  ; RETURN TO USER NOTE: EOF OVERRIDES    ;JC032
                                ; EOT IF OCCURING ON THE SAME COMMAND   ;JC032
20$:    BIT     #X0.RLL,U.MSGB+TSXSR0(R5) ; RECORD LENGTH LONG?         ;JC032
        BEQ     30$             ; IF EQ NO                              ;JC032
        MOV     #IE.DAO&377,R0  ; SET RECORD LONG                       ;JC032
30$:    JMP     @INTADD(R3)     ; GO PROCESS COMPLETION                 ;JC032
        .PAGE                                                           ;**-43
;
; TERMINATION CLASS CODE 3 (FUNCTION REJECT)
;

TCL3ER: MOV     STATS(R3),U.CW2(R5) ;RESTORE ORIGINAL STATUS            ;JC032
        BIT     #SR.OFL,U.MSGB+TSSRC(R5) ;UNIT GO OFFLINE?              ;JC032
        BEQ     10$             ; IF EQ NO                              ;JC032
        BIS     #M.SER,U.CW2(R5)        ; YES SET SELECT ERROR BIT      ;JC032
        CALL    REL             ; RELEASE THE BUFFER                    ;JC032
        JMP     NORDY           ; GO TO SELECT MSG                      ;JC032
10$:    BIT     #X0.VCK!X0.ILC!X0.ILA,U.MSGB+TSXSR0(R5) ;HARD ERROR?    ;JC032
        BNE     FATAL           ; IF NE YES FATAL                       ;JC032
        BIT     #X0.WLE,U.MSGB+TSXSR0(R5) ; WRITE LOCK?                 ;JC032
        BEQ     20$             ; IF EQ NO                              ;JC032
        BIS     #M.HWL,U.CW2(R5) ; SET WRITE LOCK STATUS                ;JC032
        MOV     #IE.WLK&377,R0  ; SET WRITE LOCK                        ;JC032
20$:    BIT     #X0.BOT,U.MSGB+TSXSR0(R5) ; TAPE AT BOT?                ;JC032
        BEQ     30$             ; IF EQ NO                              ;JC032
        BIS     #M.BOT,U.CW2(R5) ; YES SET STATUS                       ;JC032
30$:    JMP     @INTADD(R3)     ; RETURN                                ;JC032
        .ENABL  LSB                                                     ;JC032
        .PAGE                                                           ;**-45
;
; TERMINATION CLASS CODE 4 (RECOVERABLE ERROR - 1 BLOCK DOWN)
;

TCL4ER: .IIF DF E$$DVC, CALL    DVER    ; IF ERROR LOGGING LOG ERROR    ;JC032
        MOV     #IE.VER&377,R0  ; SET ERROR - UNRECOVERABLE             ;JC032
        BIT     #U3.NER!US.UMD,U.CW3(R5) ;RETRIES PROHIBITED?           ;JC032
        BNE     50$             ; IF NE YES - EXIT                      ;JC032
        MOV     U.CBP(R5),R2    ; RETRIEVE COMMAND BUFFER POINTER       ;JC032
        MOV     (R2),R0         ; RETRIEVE COMMAND HEADER WORD          ;JC032
        CMP     #CC.WRD,R0      ; WRITE COMMAND?                        ;JC032
        BNE     10$             ; IF NE NO SKIP CHECK                   ;JC032
        BIT     #M.IWR,U.CW2(R5) ;WRITE EXTEND PROHIBITED?              ;JC032
        BNE     50$             ; IF NE YES - EXIT                      ;JC032
10$:    BIC     #^C<CM.LOW>,R0  ; CLEAR ALL BUT LOW 2 BITS              ;JC032
        CMP     #1,R0           ; RETRYABLE COMMAND?                    ;JC032
        BNE     FATAL           ; NO FATAL HARDWARE ERROR               ;JC032
        DECB    RTTBL(R3)       ; DECREMENT RETRY COUNT                 ;JC032
        BEQ     50$             ; IF EQ RETRIES EXHAUSTED               ;JC032
        CMPB    #THRES1,RTTBL(R3) ; REACHED FIRST THRESHOLD?            ;JC032
        BHIS    20$             ; YES TIME FOR OPPOSITE RETRY           ;JC032
        BIS     #CM.RTY,(R2)    ; SET RETRY COMMAND BIT                 ;JC032
        JMP     INITIO          ; AND ISSUE IT                          ;JC032
;                                                                       ;JC032
; AN OPPOSITE RETRY CAN ONLY OCCUR FOR READ OPERATIONS. ALL OTHER       ;JC032
; COMMANDS WILL SKIP THIS RETRY SET AND PROCEED IMMEDIATLY TO THE       ;JC032
; NEXT STEP WHICH CONSISTS OF DOING A CLEAN OPERATION BEFORE ISSUANCE   ;JC032
; OF THE COMMAND. READ OPERATIONS WHICH INDICATE THAT THE ACTUAL RECORD ;JC032
; SIZE ON TAPE DOES NOT EQUAL THE BUFFER SIZE SPECIFIED MUST ALSO SKIP T;JC032
; STEP.                                                                 ;JC032
;                                                                       ;JC032
20$:    CMPB    #THRES2,RTTBL(R3) ; TIME FOR CLEAN ?                    ;JC032
        BHIS    30$             ; YES GO TO ALTERNATE RCOVERY           ;JC032
        BIT     #X0.RLL!X0.RLS,U.MSGB+TSXSR0(R5) ; RECORD LENGTH OFF?   ;JC032
        BNE     30$             ; YES CAN'T DO OPPOSITE                 ;JC032
        MOV     (R2),R0         ; RETRIEVE COMMAND HEADER               ;JC032
        BIC     #^C<CM.COD>,R0  ; CLEAR ALL BUT COMMAND CODE            ;JC032
        CMP     #CC.RDN,R0      ; IS IT A READ OPERATION?               ;JC032
        BNE     30$             ; IF NE NO GO DO CLEAN                  ;JC032
        BIS     #CM.OPP,(R2)    ; ALLS WELL SET OPPOSITE                ;JC032
        JMP     INITIO          ; ISSUSE OPPOSITE COMMAND               ;JC032
                                                                        ;JC032
30$:    SETRTY  CLN,RTNCLN      ; SETUP FOR CLEAN FUNCTION              ;JC032
        JMP     INITIO          ; ISSUE CLEAN                           ;JC032
                                                                        ;**-29
;
; TERMINATION CLASS CODE 5 (RECOVERABLE ERROR - TAPE NOT MOVED)
;

TCL5ER: .IIF DF E$$DVC, CALL    DVER    ; IF ERRORLOG ENABLE LOG ERROR  ;JC032
        MOV     #IE.VER&377,R0  ; SET UNRECOVERABLE ERROR               ;JC032
        DECB    RTTBL(R3)       ; DECREMENT RETRY COUNT                 ;JC032
        BEQ     50$             ; IF EQ EXIT                            ;JC032
        MOV     STATS(R3),U.CW2(R5) ; RESTORE ORIGINAL STATUS           ;JC032
        JMP     INITIO          ; ISSUE COMMAND                         ;JC032
50$:    JMP     @INTADD(R3)     ; EXIT                                  ;JC032
                                                                        ;**-2
;                                                                       ;JC032
; TERMINATION CLAS CODE 7 (FATAL CONTROLLER ERROR)                      ;JC032
;                                                                       ;JC032
TCL7ER: CLR     @S.CSR(R4)      ; INIT CONTROLLER                       ;JC032
        MOV     STATS(R3),U.CW2(R5) ; RESTORE ORIGINAL STATUS           ;JC032
;       BR      TCL6ER                                                  ;JC032
;
; TERMINATION CLASS CODE 6 (UNRECOVERABLE ERROR)
;

FATAL:                                                                  ;JC032
TCL6ER: MOV     #IE.FHE&377,R0  ; SET FATAL ERROR STATUS                ;JC032
        .IIF DF E$$DVC, CALL    DVER    ; LOG THE ERROR                 ;JC032
        JMP     @INTADD(R3)     ; RETURN                                ;JC032
        .PAGE                                                           ;JC032
        .DSABL  LSB                                                     ;JC032
        .SBTTL  COMMAND COMPLETION ROUTINES                             ;JC032
;+                                                                      ;JC032
; **- IRREV - READ REVERSE COMPLETION                                   ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
IRREV:  BIC     #M.TMK,U.CW2(R5)        ; DON'T SET FOR REVERSE OPERATIO;JC032
        BR      IOCOM           ; DO COMMON COMPLETION FOR TRANSFER     ;JC032
                                                                        ;JC032
;                                                                       ;JC032
;+                                                                      ;JC032
; **- IWRMK - WRITE TAPE MARK COMPLETION                                ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
IWRMK:  BIS     #M.TMK,U.CW2(R5) ; SET TAPE MARK STATUS                 ;JC032
        BR      IOCOM           ; AND GO TO COMMON EXIT                 ;JC032
                                                                        ;JC032
;                                                                       ;JC032
;+                                                                      ;JC032
; **- ISTAT - STATUS EXIT FOR SET, SENSE, AND MOUNT AND SET             ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
ISTAT:  BIC     #M.1600,U.CW2(R5) ;CLEAR STATUS BIT                     ;JC032
        BIT     #X0.PED,U.MSGB+TSXSR0(R5) ;IS THIS A PE DRIVE?          ;JC032
        BEQ     20$             ; IF EQ NO                              ;JC032
        BIS     #M.1600,U.CW2(R5) ;YES SET STATUS                       ;JC032
20$:    MOV     U.CW2(R5),R1    ; SET STATUS WORD IN R1                 ;JC032
        BR      IOEXT           ; AND EXIT                              ;JC032
;                                                                       ;JC032
;+                                                                      ;JC032
; **-RTNCLN - RETRY COMMAND AFTER CLEAN                                 ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
RTNCLN: MOV     RTYINT(R3),INTADD(R3)   ; RESTORE INTERRUPT ADDRES      ;JC032
        TSTB    R0              ; ERROR ON CLEAN?                       ;JC032
        BMI     FATAL           ; YES - TAPE POSITION LOST EXIT         ;JC032
        MOV     U.CBP(R5),R2    ; RETRIEVE COMMAND BUFFER POINTER       ;JC032
        MOV     CMDHDR(R3),(R2) ; RESTORE ORIGINAL COMMAND              ;JC032
        MOVB    #8.,S.ITM(R4)   ; RESET TIMEOUT COUNT                   ;JC032
        JMP     INITIO          ; REISSUE COMMAND                       ;JC032
        .PAGE                                                           ;JC032
;                                                                       ;JC032
;-                                                                      ;JC032
; **- ISPCB - SPACE BLOCKS COMPLETION                                   ;JC032
;+                                                                      ;JC032
;                                                                       ;JC032
ISPCB:  BIT     #CC.SRR-CC.SRF,@U.CBP(R5) ;SPACE REVERSE FUNCTION?      ;JC032
        BEQ     10$             ; IF EQ NO - CHECK FOR EOV              ;JC032
        BIC     #M.TMK,U.CW2(R5) ; CLEAR TAPE MARK ON REVERSE           ;JC032
        BR      IOCOM           ; GO TO COMMON EXIT                     ;JC032
10$:                            ; REFERENCE LABEL                       ;JC032
        .IF DF  A$$NSI                                                  ;JC032
                                                                        ;JC032
        BITB    #US.LAB,U.STS(R5) ;ANSII LABELED TAPE?                  ;JC032
        BNE     IOCOM           ; IF NE YES CAN'T BE EOV                ;JC032
                                                                        ;JC032
        .ENDC                                                           ;JC032
                                                                        ;JC032
        BIT     #M.TMK!M.BOT,STATS(R3) ;TAPE MARK OR BOT SEEN LAST TIME?;JC032
        BEQ     IOCOM           ; IF EQ NO - CAN'T BE EOV               ;JC032
        BIT     #M.TMK,U.CW2(R5)        ; TAPE MARK SEEN THIS TIME?     ;JC032
        BEQ     IOCOM           ; IF EQ NO - CAN'T BE EOV               ;JC032
        MOV     U.CNT(R5),R1    ; RETRIEVE REQUESTED COUNT              ;JC032
        SUB     U.MSGB+TSRBPC(R5),R1 ; LESS RESIDUAL                    ;JC032
        CMP     #1,R1           ; ONLY ONE SPACED?                      ;JC032
        BNE     IOCOM           ; IF NE NO - NOT EOV                    ;JC032
;                                                                       ;JC032
; AT EOV - DOING SPACE BLOCKS - NEED TO REPOSITION TAPE                 ;JC032
;                                                                       ;JC032
        MOV     U.CBP(R5),R2    ; SET COMMAND BUFFER POINTER            ;JC032
        SETRTY  SRR,RTNPOS,1    ; SET OPERATION                         ;JC032
        JMP     INITIO                                                  ;JC032
;                                                                       ;JC032
;+                                                                      ;JC032
; **-RTNPOS - RETURN FROM REPOSITIONING                                 ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
RTNPOS: MOV     #IE.EOV&377,R0  ; SET EOV STATUS                        ;JC032
        CLR     R1              ; SET COUNT                             ;JC032
        BIS     #M.PEOV,U.CW2(R5) ; SET POSITION EOV                    ;JC032
        BR      IOEXT           ; AND EXIT                              ;JC032
                                                                        ;JC032
;                                                                       ;JC032
;+                                                                      ;JC032
; **- ISPCF - SPACE FILES COMPLETION                                    ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
                                                                        ;JC032
ISPCF:  BIT     #CC.STR-CC.STF,@U.CBP(R5) ;SPACE REVERSE?               ;JC032
        BEQ     10$             ; IF EQ NO - CHECKK EOV                 ;JC032
        BIC     #M.TMK,U.CW2(R5) ;CLR BIT FOR REVERSE                   ;JC032
        BR      IOCOM           ; AND EXIT                              ;JC032
10$:    BIT     #X0.LET,U.MSGB+TSXSR0(R5) ; AT LEOT?                    ;JC032
        BEQ     IOCOM           ; IF EQ NO - EXIT                       ;JC032
        MOV     #IE.EOV&377,R0  ; SET EOV STATUS                        ;JC032
        BIS     #M.PEOV,U.CW2(R5) ; AND SET IN STATUS WORD              ;JC032
        BR      IOCOM           ; AND EXIT                              ;JC032
        .PAGE                                                           ;JC032
;+                                                                      ;JC032
;                                                                       ;JC032
; **- IOCOM - COMMON EXIT ROUTINE FOR ALL ROUTINES REQUIRING STATUS     ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
IOCOM:  MOV     U.CNT(R5),R1    ; RETRIEVE REQUESTED COUNT              ;JC032
        SUB     U.MSGB+TSRBPC(R5),R1 ; LESS RESIDUAL COUNT              ;JC032
                                                                        ;JC032
;                                                                       ;JC032
;+                                                                      ;JC032
; **- IOEXT - COMMON EXIT FOR ALL FUNCTIONS                             ;JC032
;-                                                                      ;JC032
;                                                                       ;JC032
IOEXT:  CALL    REL             ; RELEASE MESSAGE BUFFER                ;JC032
                                                                        ;JC032
IODON:                                                                  ;JC032
        .IF DF  D$$IAG                                                  ;JC032
                                                                        ;JC032
        CALL    MSDINT          ; CALL DIAGNOSTIC COMPLETION            ;JC032
                                                                        ;JC032
        .ENDC                                                           ;JC032
                                                                        ;JC032
        .IF DF  E$$DVC                                                  ;JC032
                                                                        ;JC032
        MOV     RTTBL(R3),R2    ; SET REMAINING RETRY COUNT             ;JC032
        MOV     #RETRY*256.,R2  ; ADD IN ORIGINAL COUNT                 ;JC032
                                                                        ;JC032
        .ENDC                                                           ;JC032
                                                                        ;JC032
        BIC     #U3.CIP,U.CW3(R5) ;CLEAR COMMAND IN PROGRESS            ;JC032
        CALL    $IODON          ; CALL COMPLETION                       ;JC032
        JMP     MSINI           ; GO CHECK FOR ANOTHER REQUEST          ;JC032
        .PAGE                                                           ;**-7
        .SBTTL  REL,LDPNTR - BUFFER RELEASE, LOAD COMMAND POINTER INTO T; AP002
        .DSABL  LSB                                                     ; AP002
                                                                        ; AP002
;+                                                                      ; AP002
; **-REL-A SIMPLE ROUTINE TO RELEASE THE MESSAGE BUFFER.                ; AP002
;                                                                       ; AP002
; THE MESSAGE BUFFER NEEDS TO BE RELEASED WHENEVER WE ARE FINISHED      ; AP002
; WITH IT.                                                              ; AP002
;                                                                       ; AP002
; OUTPUTS:                                                              ; AP002
;       R2 = TSDB UNIBUS ADDRESS                                        ; AP002
;       TSDB REGISTER LOADED WITH PACKET POINTER.                       ; AP002
;                                                                       ; AP002
;-                                                                      ; AP002
                                                                        ; AP002
REL:    MOV     #CC.BRL,@U.CBP(R5)      ;MARK IT AS MESSAGE RELEASE.    ; AP002
        ;CALLR  LDPNTR                  ;ISSUE COMMAND & EXIT.          ; AP002
                                                                        ; AP002
                                                                        ; AP002
;+                                                                      ;**-2
; **-LDPNTR-LOAD COMMAND POINTER IN TSDB
;
; THIS SUBROUTINE WILL LOAD THE MODULO 4 COMMAND PACKET POINTER
; IN THE TSDB REGISTER.
;
; INPUTS:
;       R5 = UCB ADDRESS
;       U.CBP(R5) = ADDRESS OF COMMAND PACKET.
;
; OUTPUTS:
;       R1 = TSDB UNIBUS ADDRESS
;       TSDB REGISTER LOADED WITH COMMAND POINTER
;
;-

LDPNTR: MOV     S.CSR(R4),R2    ; RETREIVE CSR ADDRESS                  ;JC032
        MOV     U.CBP(R5),-(R2) ; LOAD COMMAND POINTER                  ;JC032
                                                                        ;JC032
        RETURN                  ;                                       ;**-2



;#
;# FOR MAPPED DATABASE (POOL AND/OR EXEC)
;# THE ADDRESS IN U.CBP(R5) MUST BE CONVERTED TO ITS TRUE 18 BIT
;# ADDRESS WITH THE TWO HIGH BITS REPOSITIONED TO BITS 0 & 1.
;#
        .PAGE
        .SBTTL  DVER - ERROR LOG CALL INTERFACE.                        ; AP002
        .IF DF  E$$DVC          ;%%% 1 %%%                              ; AP002
;+                                                                      ; AP002
; **-DVER-TO INTERFACE WITH THE ERROR LOGGER.                           ; AP002
;                                                                       ;**-22
; THE ERROR LOGGER ASSUMES (ERRONEOUSLY) THAT THE REGISTERS OF
; INTEREST ARE THE HARDWARE REGISTERS IN THE I/O PAGE POINTED TO
; BY S.CSR.  MOST OF THE STATUS INFORMATION FOR THE TS04 IS FOUND
; IN THE MESSAGE BUFFER ("EXTENDED STATUS REGISTERS") IN THE UCB.
; WE MUST, THEREFORE, CORRUPT OUR SCB TO MAKE S.CSR CONTAIN THE
; ADDRESS OF THE MESSAGE BUFFER AND THEN RESTORE IT ON RETURN.
; "TSSR", THE ONLY REAL HARDWARE REGISTER, IS COPIED INTO A SLOT IN
; THE MESSAGE BUFFER NORMALLY WHEN WE LOOK AT IT.
;
; INPUT:
;       R4 = SCB ADDRESS
;       R5 = UCB ADDRESS
;
; OUTPUTS:
;       ERROR MESSAGE BUFFER (EMB) FILLED "CORRECTLY".
;
;-

DVER:   BIT     #U3.UMD,U.CW3(R5)       ;USER MODE DIAGNOSTIC IN PROGESS ?
        BNE     10$                     ;YES=> SKIP THIS REPORT; ELSE
        MOV     S.CSR(R4),-(SP)         ;PUSH (SAVE) CSR ADDRESS.
        MOV     #15.,S.RCNT(R4)         ;DUMMY UP THE COUNT.            ; AP006
        MOV     #U.CBP,S.CSR(R4)        ;USE DRIVER SPECIFIC DDB        ; AP006
        ADD     R5,S.CSR(R4)    ; ADDRESS TO FOOL ERR LOG.              ;**-1
        BIT     #U3.TMO,U.CW3(R5)       ;TIMEOUT TO LOG ?               ; AP011
        BEQ     3$                      ;NO=>PLAIN LOG; ELSE            ; AP011
        CALL    $DTOER          ;LOG THE ERROR WITH TIMEOUT.            ; AP011
        BR      7$              ;RESTORE THE DATA BASE.                 ; AP011
3$:     CALL    $DVERR          ;LOG THE ERROR                          ; AP011
7$:     MOV     (SP)+,S.CSR(R4) ;RESTORE THE CSR ADDRESS.               ; AP011
10$:    RETURN                  ;RETURN TO CALLER.                      ;**-2
        .ENDC                   ;%%% 1 %%%
        .PAGE
        .SBTTL  MSDINT - DIAGNOSTIC INTERRUPT & TIMEOUT HANDLER

        .IF DF  D$$IAG          ;%%% 1 %%%

;+
; **-MSDINT-TS11 DIAGNOSTIC INTERRUPT AND TIMEOUT HANDLER
;
; IF ENTRY WAS FROM A DIAGNOSTIC CONTROL FUNCTION, THEN MOVE THE
; I/O PACKET WORDS 17 & 20 TO WORDS 20 & 21 FOR THE $CRPAS ROUTINE.
; FOR ANY DIAGNOSTIC FUNCTION, PASS THE UNIBUS DEVICE REGISTERS
; AND THE EXTENDED STATUS REGISTERS VIA THE $CRPAS ROUTINE.
;
; INPUTS:
;
;       R4 = SCB ADDRESS
;
; OUTPUTS:
;       CARRY BIT CLEAR = NON-DIAGNOSTIC FUNCTION
;       CARRY BIT SET = DIAGNOSTIC FUNCTION
;
;-

MSDINT: CLC                     ;ASSUME NON-DIAGNOSTIC FUNCTION.
        BIT     #U3.UMD,U.CW3(R5)       ;TEST THAT ASSUMPTION ?
        BEQ     30$             ;TRUE=> FINISHED; ELSE DO THINGS ...
        MOV     R1,-(SP)        ;SAVE R1
        MOV     R2,-(SP)        ;SAVE R2
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        MOV     #U.MSGB,R2      ;LOAD MESSAGE BUFFER OFFSET.
        ADD     R5,R2           ;ADD IN UCB ADDRESS.
        MOV     R1,-(SP)        ;SAVE I/O PACKET ADDRESS
        CMPB    #IO.EOF/256.,I.FCN+1(R1) ;WRITE EOF FUNCTION?
        BEQ     10$             ;IF EQ YES
        CMPB    #IO.RWD/256.,I.FCN+1(R1) ;REWIND FUNCTION?
        BEQ     10$             ;IF EQ YES
        CALL    $CRPAS          ;PASS DEVICE REGISTERS TO DIAGNOSTIC
        MOV     (SP)+,R1        ;RESTORE I/O PACKET ADDRESS
        BR      20$             ;GO TO EXIT
10$:    MOV     I.PRM+14(R1),I.PRM+16(R1) ;MOVE PACKET WD20 TO WD21
        MOV     I.PRM+12(R1),I.PRM+14(R1) ;MOVE PACKET WD17 TO WD20
        CALL    $CRPAS          ;PASS DEVICE REGISTERS TO DIAGNOSTIC
        MOV     (SP)+,R1        ;RESTORE I/O PACKET ADDRESS
        MOV     I.PRM+14(R1),I.PRM+12(R1) ;MOVE WD20 BACK TO WD 17
        MOV     I.PRM+16(R1),I.PRM+14(R1) ;MOVE WD21 BACK TO WD20
20$:    SEC                     ;INDICATE A DIAGNOSTIC FUNCTION
        MOV     (SP)+,R2        ;RESTORE R2.
        MOV     (SP)+,R1        ;RESTORE R1.
30$:    RETURN                  ;EXIT TO CALLER

        .ENDC                   ;%%% 1 %%%

        .END
        .TITLE  MTDRV
        .IDENT  /04.06/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 04.06
;
; SCOTT G. DAVIS 9-JUL-74
;
; PREVIOUSLY MODIFIED BY:
;
;       P. J. BEZEREDI
;       D. N. CUTLER
;       S. G. DAVIS
;       C. A. D'ELIA
;       B. LYONS
;       T. J. MILLER
;       F. L. STRAIGHT
;
; MODIFIED BY:
;
;       J. CLEARY 26-APR-77
;
;               JC001 -- POWERFAIL SUPPORT FOR TE10.
;
;       P. J. BEZEREDI 04-MAY-77
;
;               PB027 -- TIGHTEN UP DOUBLE INTERRUPT TIMING WINDOW.
;
;       P. J. BEZEREDI 06-MAY-77
;
;               PB028 -- CLEAN UP SPACE FUNCTION EXECUTION.
;
;       J. CLEARY 20-SEP-77
;
;               JC006 -- INSURE INTERRUPT ENABLE IS CLEARED.
;
;       J. CLEARY 23-MAR-78
;
;               JC011 -- CLEAN UP SPACE FUNCTION PATCH
;
;       J. CLEARY  24-APR-78
;
;               JC014 -- IGNORE EOT ON READS
;
;       J. CLEARY 21-JUN-78
;
;               JC017 -- FIX BUG IN UMR ALLOCATION
;
;       J. CLEARY 4-DEC-78
;
;               JC024 -- CLEAR US.ABO TO PREVENT UNINTENDED ABORTS
;
;       J. CLEARY 4-DEC-78
;
;               JC025 --  IMPLEMENT IQ.X SUPPRESS RETRIES
;
;       J. CLEARY 3-APR-79
;
;               JC036 -- BYPASS CALL TO ERRLOG WHEN SMO RETURNS ERROR
;
; TM11 MAGNETIC TAPE CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;
        .MCALL  HWDDF$,PKTDF$,ABODF$,CLKDF$
        HWDDF$
        PKTDF$
        ABODF$
        CLKDF$


        .IF DF  D$$IAG

        .MCALL  UMDIO$
        UMDIO$                  ;DEFINE USER-MODE DIAGNOSTIC DEFINITIONS

        .ENDC


;
; EQUATED SYMBOLS
;

US.ABO=1                        ;ABORT IN PROGRESS - U.STS
US.BSP=2                        ;INTERNAL BACKSPACE IN PROGRESS - U.STS
US.PWF=10                       ;POWER FAIL STATUS
RETRY=12                        ;RETRY COUNT

;
; REGISTER BIT SYMBOLS
;

CS.GO=1                         ;GO
CS.EXM=60                       ;EXTENDED MEMORY BITS
CS.IE=100                       ;INTERRUPT ENABLE
CS.RDY=200                      ;CONTROLLER READY BIT
CS.EVN=4000                     ;EVEN PARITY
CS.CLR=10000                    ;POWER CLEAR
CS.DN5=20000                    ;556 BPI DENSITY BIT
CS.DN8=40000                    ;800 BPI DENSITY BIT

DS.TUR=1                        ;TAPE UNIT READY
DS.RWS=2                        ;REWINDING
DS.HWL=4                        ;WRITE LOCK
DS.SDN=10                       ;SETTLE DOWN
DS.7CH=20                       ;UNIT IS 7 CHANNEL
DS.BOT=40                       ;BEGINNING OF TAPE
DS.MOL=100                      ;MEDIUM ON LINE
DS.BTE=400                      ;BAD TAPE ERROR
DS.RLE=1000                     ;RECORD LENGTH ERROR
DS.EOT=2000                     ;END OF TAPE DETECTED
DS.BGL=4000                     ;BUS GRANT LATE
DS.PAE=10000                    ;PARITY ERROR
DS.CRE=20000                    ;CYCLICAL REDUNDANCY ERROR
DS.TM=40000                     ;TAPE MARK DETECTED
DS.ILG=100000                   ;ILLEGAL COMMAND

RD.GAP=10000                    ;GAP SHUTDOWN IN PROGRESS
RD.LPC=40000                    ;READ LPC CHARACTER AND RTTBL FLAG

;
; MAG TAPE STATUS REGISTER BIT DEFINITIONS (SENSE AND SET CHARACTERISTICS)
;

M.PEOV=100000                   ;TAPE PAST LOGICAL END OF VOLUME
M.AEOV=40000                    ;TAPE AT LOGICAL END OF VOLUME
M.BOT=20000                     ;TAPE AT BOT
M.7CH=10000                     ;UNIT IS 7 CHANNEL
M.HWL=2000                      ;HARDWARE WRITE LOCK
M.RWD=1000                      ;UNIT IS REWINDING
M.SER=400                       ;SELECT ERROR HAS OCCURED
M.IXG=200                       ;INHIBIT WRITE WITH EXTENDED INTERRECORD
M.SWL=100                       ;SOFTWARE WRITE LOCK
M.EOF=40                        ;LAST COMMAND ENCOUNTERED TAPE MARK
M.EOT=20                        ;LAST COMMAND ENCOUNTERED EOT
M.EVN=10                        ;EVEN PARITY
M.CDM=4                         ;CORE DUMP MODE (7 CHANNEL ONLY)
M.200=2                         ;200 BPI (7 CHANNEL ONLY)
M.556=1                         ;556 BPI (7 CHANNEL ONLY)

USRBTS=317                      ;STATUS BITS CONTROLLED BY THE USER
NEWBTS=M.PEOV!M.BOT!M.EOF!M.EOT ;STATUS BITS TO BE SET BEFORE $IODON

;
; COMMANDS
;

RWU=101                         ;REWIND AND OFFLINE
RED=103                         ;READ
WRT=105                         ;WRITE
WEF=107                         ;WRITE END-OF-FILE
SPF=111                         ;SPACE FORWARD
SPR=113                         ;SPACE REVERSE
WTE=115                         ;WRITE WITH EXTENDED GAP
RWD=117                         ;REWIND

;
; LOCAL MACROS
;
;
; THE FOLLOWING MACRO DEFINES ENTRIES IN THE FUNCTION TABLE
;
.MACRO  DFENT   COM,TIMOUT,PWF,OPCODE,TYPE,INTADD
        .WORD   COM
        .BYTE   PWF,TIMOUT
        .BYTE   TYPE,OPCODE
        .WORD   INTADD
.ENDM   DFENT

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;
; DIAGNOSTIC FUNCTIONS USE BITS 14-15 OF RTTBL AS FLAGS FOR
; INTERRUPT AND FUNCTION HANDLING.

CNTBL:  .BLKW   T$$M11          ;ADDRESS OF CURRENT UNIT CONTROL BLOCK
RTTBL:  .BLKW   T$$M11          ;ERROR RETRY COUNT
SPTBL:  .BLKW   T$$M11          ;FOR SPACE CHECKING
INTADD: .BLKW   T$$M11          ;CURRENT INTERRUPT SERVICE ADDRESS


        .IF GT  T$$M11-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC


;
; LEGAL FUNCTION DISPATCH TABLE
;

LGFCN:  DFENT   IO.RLB,8.,0,RED,0,RDBLK ;READ LOGICAL BLOCK
        DFENT   IO.WLB,6.,0,WRT,0,WRBLK ;WRITE LOGICAL BLOCK
        DFENT   IO.EOF,2.,0,WEF,0,WREOF ;WRITE TAPE MARK
        DFENT   IO.RWD,2.,1,RWD,0,REWND ;REWIND
        DFENT   IO.RWU,2.,1,RWU,0,REWND ;REWIND THEN OFF-LINE
        DFENT   IO.SPB,8.,0,SPF,1,SPCBK ;SPACE BLOCK
        DFENT   IO.SPF,8.,0,SPF,2,SPCFL ;SPACE FILE
        DFENT   IO.STC,0,-1,0,-1,-1     ;SET CHARACTERISTICS
        DFENT   IO.SEC,0,-1,1,-1,-1     ;SENSE CHARACTERISTICS
        DFENT   IO.SMO,0,1,-1,-1,-1     ;MOUNT AND SET CHARACTERISTICS

ENDFCN=.                        ;END OF FUNCTION TABLE

;
; DRIVER DISPATCH TABLE
;

$MTTBL::.WORD   MTINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   MTCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   MTOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   MTPWF           ;POWERFAIL ENTRY POINT

;+
; **-MTINI-TM11 MAGNETIC TAPE CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
MTINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCC     10$             ;IF CC PROCESS REQUEST
        RETURN                  ;NOTHING TO DO OR CONTROLLER BUSY

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; TM11 MAGNETIC TAPE FUNCTION INDEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB/IO.RWD/IO.SPB/IO.SPF/IO.EOF).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;

10$:    MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF REQUEST UCB
        MOV     #$MTCLK,S.MTCK+C.SUB(R4)  ;SET ADDR OF CLOCK ROUTINE
        CLR     S.FRK+2(R4)     ;INIT FORK PC WORD
        MOV     #LGFCN,R2       ;POINT TO LEGAL FUNCTION TABLE
        MOV     I.FCN(R1),R0    ;GET FUNCTION CODE                      ;JC025
                                                                        ;**-1
        .IF DF  D$$IAG

        CLRB    RTTBL+1(R3)     ;CLEAR DIAGNOSTIC FLAG
        MOV     I.FCN(R1),R0    ;GET FUNCTION CODE
        BITB    #IQ.UMD,R0      ;DIAGNOSTIC FUNCTION CALL?
        BEQ     20$             ;IF EQ NO
        MOV     #100000,RTTBL(R3) ;STOP RETRIES AND SET DIAG. FLAG
        CMP     #IO.LPC!IQ.UMD,R0  ;READ LPC CHARACTER FUNCTION?
        BNE     15$             ;IF NE NO
        BIS     #RD.LPC,RTTBL(R3)  ;SET LPC READ FLAG
        MOV     #IO.RLB!IQ.UMD,R0  ;CONVERT TO READ LOGICAL
        MOV     R0,I.FCN(R1)    ;SAVE FOR LATER USE
15$:    BIC     #IQ.UMD,R0      ;CLEAR FOR FUNCTION CHECK
                                                                        ;JC025
        .IFTF                                                           ;JC025
                                                                        ;JC025
20$:    BICB    #IQ.X,R0        ;CLEAR IQ.X IT WILL BE                  ;JC025
                                ;CHECKED LATER                          ;JC025
                                                                        ;JC025
        .ENDC                                                           ;JC025
        CMP     R0,(R2)+        ;FUNCTION CODE MATCH?                   ;JC025
                                                                        ;**-8
        BEQ     35$             ;IF EQ YES
        ADD     #6,R2           ;POINT TO NEXT TABLE ENTRY
        CMP     R2,#ENDFCN      ;AT END OF TABLE?
        BNE     20$             ;IF NE NO
        BR      40$             ;ILLEGAL FUNCTION

;
; FUNCTION CODE MATCH FOUND
;



        .IF DF  P$$RFL

35$:    BITB    #US.PWF,U.STS(R5) ;POWER FAIL OCCUR?
        BEQ     45$             ;IF EQ NO
        TSTB    (R2)            ;LEGAL FUNCTION?
        BMI     45$             ;IF MI YES
        BNE     43$             ;IF NE THIS IS A BETTER ONE

        .IFTF

40$:    MOV     #IE.IFC&377,R0  ;SET ILLEGAL FUNCTION
        JMP     230$            ;INFORM THE USER

43$:    BICB    #US.PWF,U.STS(R5)   ;ALLOW ALL FUNCTIONS

        .IFF

35$:                            ;REF LABEL

        .ENDC


45$:    MOV     (R2)+,S.CTM(R4) ;SET UP FOR PROPER TIMEOUT
        CLRB    S.CTM(R4)       ;CLEAR OUT PWF INFO
        CLR     SPTBL(R3)       ;RESET SPACING FLAG
        CLR     U.CW3(R5)       ;NOT SPACING FILE
        TSTB    (R2)+           ;DETERMINE TYPE OF OPERATION
        BPL     50$             ;IF PL NOT STATUS FUNCTION
        JMP     190$            ;STATUS FUNCTION
50$:    BEQ     90$             ;IF EQ NON-SPACING FUNCTION

;
; SPACING FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- SPACING COUNT (POSITIVE=FORWARD, NEGATIVE=BACKWARD).
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- RELOCATON BIAS OF DIAGNOSTIC REG. BLK. ADDRESS
;       WD. 20 -- DIAG. REG. BUFFER ADDRESS (REAL OR DISPL. + 140000)
;

        MOV     U.BUF(R5),I.PRM+4(R1) ;MOVE SPACING COUNT TO COMMON PLACE
        CLR     U.BUF(R5)       ;RESET TO TAKE ON OPCODE BELOW
        MOV     I.PRM+4(R1),U.CNT(R5) ;MOVE SPACING COUNT TO COMMON PLACE
        BNE     60$             ;IF NE SOME SPACING REQUIRED
        JMP     220$            ;NO SPACING REQUIRED
60$:    BMI     65$             ;IF MI SPACE REVERS
        BIT     #M.AEOV,U.CW2(R5) ;AT EOV?
        BEQ     70$             ;IF EQ NO - PROCEED
        MOV     #IE.EOV&377,R0  ;STILL AT EOV
        JMP     230$            ;TELL THE USER
65$:                            ;REFERENCE LABEL
        NEG     U.CNT(R5)       ;CONVERT TO POSITIVE COUNT
        NEG     I.PRM+4(R1)     ;THIS ONE, TOO
        BIS     #2,U.BUF(R5)    ;CHANGE SPACE FORWARD TO SPACE REVERSE
70$:    CMPB    -1(R2),#1       ;SPACE FILE OR SPACE BLOCK?
        BEQ     80$             ;IF EQ SPACE BLOCK
        MOV     U.CNT(R5),U.CW3(R5) ;SAVE COUNT OF FILES TO SPACE
        NEG     U.CW3(R5)       ;SET UP FOR FINAL ACCOUNTING
        MOV     #-1,U.CNT(R5)   ;SET UP FOR BIG SPACE
80$:    MOV     U.CNT(R5),SPTBL(R3) ;SAVE SPACING COUNT
        NEG     SPTBL(R3)       ;MAKE IT MATCH REGISTER CONTENTS
        BR      110$            ;SKIP SOME CHECKS AND BIC'S

;
; READ/WRITE LOGICAL FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER.
;       WD. 13 -- DATA BUFFER ADDRESS.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- RELOCATON BIAS OF DIAGNOSTIC REG. BLK. ADDRESS
;       WD. 21 -- DIAG. REG. BUFFER ADDRESS (REAL OR DISPL. + 140000)
;
; NO FUNCTION DEPENDENT PARAMETERS ARE REQUIRED FOR REWIND OR WRITE EOF
;

90$:                            ;REF LABEL


        .IF DF  M$$EXT&M$$MGE

        CALL    $STMAP          ;SET UP UNIBUS MAPPING ADDRESS

        .ENDC


        CMPB    -2(R2),#2       ;WRITE EOF, REWIND OR REWIND & OFFLINE?
        BEQ     100$            ;IF EQ YES - SEE IF WRITELOCK SET
        CMPB    (R2),#WRT       ;WRITE?
        BNE     110$            ;IF NE NO
        MOV     #IE.SPC&377,R0  ;ASSUME PARAMETER PROBLEMS
        CMP     I.PRM+4(R1),#14. ;TOO SHORT?
        BLO     163$            ;IF LO YES
        BR      105$            ;SKIP EXMEM BIT CLEAR
100$:   CLR     U.BUF(R5)       ;NOTHING THERE FOR WEF
        CMPB    (R2),#WEF       ;WRITE EOF?
        BNE     110$            ;IF NE NO, SKIP CHECK FOR WRITE LOCK
105$:   MOV     #IE.WLK&377,R0  ;ASSUME (SOFTWARE) WRITE LOCK
        BIT     #M.SWL,U.CW2(R5) ;LOCKED?
        BNE     163$            ;IF NE YES
110$:   BISB    (R2)+,U.BUF(R5) ;PICK UP FUNCTION CODE FROM COMMAND TABLE
        MOV     (R2),INTADD(R3) ;SET INITIAL INTERRUPT ADDRESS


        .IF DF  D$$IAG

        TST     RTTBL(R3)       ;DIAGNOSTIC FUNCTION CALL?
        BMI     120$            ;IF MI YES -STOP RETRIES

        .ENDC


        MOV     #RETRY,RTTBL(R3) ;SET UP RETRY COUNTS
120$:   CALL    SELECT          ;SELECT THE REQUIRED DRIVE
        BCS     SELERR          ;IF CS SELECT ERROR OCCURRED
        MOV     U.CW2(R5),R1    ;PICK UP DRIVE'S CHARACTERISTICS
        BIT     #M.EVN,R1       ;EVEN PARITY REQUIRED?
        BEQ     140$            ;IF EQ NO
        BIS     #CS.EVN,U.BUF(R5) ;SET BIT IN STATUS REGISTER
140$:   BIS     #CS.DN5!CS.DN8,U.BUF(R5) ;ASSUME 9-CHANNEL, 800BPI
        BIT     #M.7CH,R1       ;7-CHANNEL DRIVE?
        BEQ     151$            ; IF EQ NO                              ;JC025
        BIT     #M.CDM,R1       ;CORE DUMP MODE?                        ;**-1
        BNE     151$            ; IF NE YES                             ;JC025
        BIT     #M.556,R1       ;556 BPI?                               ;**-1
        BNE     150$            ;IF NE YES
        BIC     #CS.DN5,U.BUF(R5) ;RESET BIT FOR COMMAND
        BIT     #M.200,R1       ;200 BPI?
        BEQ     151$            ; IF EQ NO                              ;JC025
150$:   BIC     #CS.DN8,U.BUF(R5) ;RESET COMMAND BIT                    ;**-1
151$:   JMP     170$            ; RETURN                                ;JC025
                                                                        ;**-1
;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING TERMINATED.
; IF THE OPERATION WAS DIAGNOSTIC, THE QIO REQUEST IS TERMINATED.
; TIMEOUTS ARE USUALLY CAUSED BY POWERFAILURE BUT MAY ALSO BE THE
; RESULT OF HARDWARE CONSIDERATIONS.  IN PARTICULAR, A LENGTHY SPACING
; OPERATION MAY RESULT IN A TIMEOUT WHICH WILL BE IGNORED.
;

MTOUT:  MOV     S.CSR(R4),R2    ;;;PICK UP ADDRESS OF CSR
        BITB    #US.ABO,U.STS(R5) ;;;ABORTING?
        BEQ     152$            ;;;IF EQ NO
        BICB    #US.ABO,U.STS(R5) ;CLEAR ABORT FLAG                     ;JC024
        BIC     #M.RWD,U.CW2(R5) ;;;REWIND NOT IN PROGRESS
        BR      162$            ;;;TERMINATE
152$:                           ;;;REFERENCE LABEL
        MOVB    S.CON(R4),R3    ;;;FETCH CONTROLLER NO.
        BIT     #M.RWD,U.CW2(R5) ;;;REWINDING?
        BNE     155$            ;;;IF NE YES
        MOV     SPTBL(R3),R0    ;;;SPACE IN PROGRESS?
        BEQ     154$            ;;; IF EQ THEN NO
        CMP     R0,2(R2)        ;;;IS THE TAPE BLANK?
        BNE     153$            ;;; IF NE THEN NO
        CALL    $DTOER          ;;; LOG DEVICE TIMEOUT
        BR      161$            ;;; EXIT WITH IE.DNR ERROR CODE
153$:                           ;;; REF. LABEL
        MOV     2(R2),SPTBL(R3) ;;;SAVE VALUE FOR NEXT COMPARISON
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESUME TIMEOUT
        RETURN                  ;;;THAT IS ALL FOR NOW
154$:   CALL    $DTOER          ;;; LOG DEVICE TIMEOUT


        .IF DF  D$$IAG

        BCS     161$            ;ABORT DIAGNOSTIC CALL

        .ENDC


155$:   BIC     #CS.IE,(R2)     ;;;CLEAR INTERRUPT ENABLE
        MTPS    #0              ;;;ALLOW INTERRUPTS
        BIT     #M.SER,U.CW2(R5) ;WAS THERE A SELECT ERROR?
        BEQ     160$            ;IF EQ NO
        BIC     #M.SER,U.CW2(R5) ;RESET STATUS BIT
        BIT     #M.RWD,U.CW2(R5) ;REWINDING?
        BEQ     120$            ;IF EQ NO - REISSUE ORIGINAL COMMAND
        BIT     #DS.MOL,-2(R2)  ;IS THE DRIVE ON-LINE NOW?
        BEQ     SELERR          ;IF EQ NO
        MOVB    #RWD-CS.IE,(R2) ;START THE REWIND AGAIN
        BR      172$            ;START UP TIMEOUT
160$:   BIT     #M.RWD,U.CW2(R5) ;REWINDING?
        BNE     164$            ;IF NE YES
161$:   MOV     #IE.DNR&377,R0  ;INDICATE DEVICE NOT READY
162$:


        .IF DF  D$$IAG

        CALL    MTDINT          ;PASS DIAGNOSTIC DEVICE REGISTERS

        .ENDC


        BIS     #CS.CLR,(R2)     ;RESET CONTROLLER
163$:   JMP     230$            ; REPORT FATAL ERROR                    ;JC025
164$:   BIT     #DS.MOL,-2(R2)  ;EVERYTHING COPASETIC?                  ;**-1
        BEQ     SELERR          ;IF EQ NO
        BIT     #DS.BOT!DS.RWS,-2(R2) ;TAPE OK?
        BNE     165$            ;IF NE OK
SELERR:


        .IF DF  D$$IAG

        TST     RTTBL(R3)       ;DIAGNOSTIC FUNCTION CALL?
        BMI     230$            ;IF MI YES - STOP SELECT MSG.

        .ENDC


        MOV     S.PKT(R4),R1    ;RETREIVE I/O PACKET ADDRESS            ;JC025
        BITB    #IQ.X,I.FCN(R1) ;RETRIES SUPPRESSED?                    ;JC025
        BNE     230$            ;IF NE YES - SKIPP SELERR               ;JC025
        TST     U.ACP(R5)       ; ACP WANTS RETURN?                     ;JC025
        BNE     230$            ; IF NE YES EXIT                        ;JC025
        BIS     #M.SER,U.CW2(R5) ;SET SELECT ERROR BIT
        DECB    S.STS(R4)       ;TIME FOR A MSG?
        BNE     172$            ;IF NE NO
        MOV     #T.NDSE,R0      ;SET UP TO DELIVER MESSAGE
        MOVB    #15.,S.STS(R4)  ;SET UP TIMEOUT
        CALL    $DVMSG          ;SEND THE MESSAGE
        BR      172$            ;SET THE TIMOUT
165$:   BIT     #DS.TUR,-2(R2)  ;REWIND COMPLETE?
        BEQ     172$            ;IF EQ NO
        BIT     #DS.BOT,-2(R2)  ;DID WE GET TO BOT?
        BNE     175$            ;IF NE YES - REWIND COMPLETE
170$:   BIT     #M.RWD,U.CW2(R5) ;REWINDING?
        BEQ     177$            ;IF EQ NO
172$:   MOVB    #1,S.CTM(R4)    ;SET UP A TIMEOUT
        RETURN                  ;THAT IS ALL FOR NOW
175$:   BIS     #M.BOT,U.CW2(R5) ;SAY AT BOT
177$:                           ;REF LABEL


        .IF DF  M$$EXT&M$$MGE

        CMPB    #SPF,U.BUF(R5)  ;SPACE FORWARD?                         ;JC017
        BEQ     178$            ;YES UMRS NOT NEEDED                    ;JC017
        CMPB    #SPR,U.BUF(R5)  ;SPACE REVERSE?                         ;JC017
        BEQ     178$            ;YES UMRS NOT NEEDED                    ;JC017
        MOV     R2,-(SP)        ;SAVE R2
        CALL    $MPUBM          ;MAP UNIBUS TO TRANSFER
        MOV     (SP)+,R2        ;RESTORE R2

        .ENDC


178$:   CMP     (R2)+,(R2)+     ;POINT TO MEMORY ADDRESS REGISTER       ;JC017
        MOV     U.BUF+2(R5),(R2) ;SET UP BUFFER ADDRESS                 ;**-1
        MOV     U.CNT(R5),-(R2) ;SET UP BYTE COUNT REGISTER
        NEG     (R2)            ;NEED 2S COMPLEMENT
180$:   MOVB    S.ITM(R4),S.CTM(R4) ;SET CURRENT DEVICE TIMEOUT COUNT
        BIC     #M.AEOV!M.SER!M.RWD,U.CW2(R5) ;RESET VARIOUS FLAGS
        BICB    #US.BSP,U.STS(R5) ;RESET FLAGS


        .IF DF  D$$IAG

        BIT     #RD.LPC,RTTBL(R3) ;READ LPC CHAR FUNCTION?
        BEQ     185$            ;IF EQ NO
        BIS     #RD.LPC,6(R2)   ;SET LPC READ IN MTRD REG.
185$:                           ;REF. LABEL

        .ENDC


        .IF DF  E$$DVC

        CALL    $BMSET          ;SET I/O ACTIVE IN BITMAP

        .ENDC


        MOV     U.BUF(R5),-(R2) ;INITIATE THE FUNCTION
        RETURN                  ;DONE

;
; CANCEL I/O OPERATION IS A NOP FOR TM11 MAGNETIC TAPES
;

MTCAN:  BISB    #US.ABO,U.STS(R5) ;FLAG THE ABORT CONDITION
        RETURN
;
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE. THIS IS DONE TO AVOID A RACE CONDITION
; THAT COULD EXIST IN RESTARTING THE I/O OPERATION.
;

MTPWF:                          ; POWERFAIL ENTRY POINT


        .IF DF  P$$RFL

        BISB    #US.PWF,U.STS(R5)  ;SET POWER FAIL INDICATOR

        .ENDC


        RETURN                  ;

;
; STATUS FUNCTION PROCESSING
;

190$:                           ;REFERENCE LABEL
        MOV     R2,-(SP)        ;SAVE TABLE POINTER
        CALL    SELECT          ;SET BOT, HWL, AND 7CH STATUS
        MOV     (SP)+,R2        ;RESTORE POINTER
        MOV     U.CW2(R5),I.PRM+4(R1) ;ASSUME SENSE CHARACTERISTICS
        TSTB    (R2)+           ;DETERMINE FUNCTION REQUIRED
        BEQ     210$            ;IF EQ SET CHARACTERISTICS
        BPL     220$            ;IF PL "SENSE CHARACTERISTICS"

;
; (MOUNT AND) SET CHARACTERISTICS FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- NEW CHARACTERISTICS WORD
;       WD. 13 -- NOT USED
;       WD. 14 -- NOT USED
;       WD. 15 -- NOT USED
;       WD. 16 -- NOT USED
;       WD. 17 -- NOT USED
;       WD. 20 -- NOT USED
;

        CLR     -(SP)           ;DUMMY THE STACK
        CALL    SELECT          ;SELECT THE DRIVE


        .IF DF  D$$IAG&E$$DVC

        BCC     200$            ;IF CC DRIVE ON LINE OK
        BR      245$            ;DRIVE NOT ON-LINE FATAL ERROR
200$:                           ;REF. LABEL

        .IFF

        BCS     245$            ;IF CS DRIVE NOT ON-LINE FATAL ERROR

        .ENDC


        BIT     #M.BOT,U.CW2(R5) ;AT BOT?
        BEQ     245$            ;IF EQ NO - FATAL ERROR
        TST     (SP)+           ;CLEAN UP THE STACK

210$:   BIC     #USRBTS,U.CW2(R5) ;PREPARE TO SET NEW BITS
        BIC     #^C<USRBTS>,U.BUF(R5) ;LEAVE ONLY USER CONTROLLED BITS
        BIS     U.BUF(R5),U.CW2(R5) ;NEW STATUS WORD

;
; NO SPACING REQUIRED
;

220$:   MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS
230$:   MOV     S.CSR(R4),R2    ;PICK UP CSR ADDRESS
        BIC     #CS.IE!CS.EXM,(R2) ;CLEAR IE AND EX. MEM. BITS
        CLR     2(R2)           ;ASSURE PROPER VALUE FOR RETURN
        JMP     540$            ;CLEAN UP AND EXIT


;+
; **-$MTINT-TM11 MAGNETIC TAPE CONTROLLER INTERRUPTS
;-

        INTSE$  MT,PR5,T$$M11   ;;;GENERATE INTERRUPT SAVE CODE
        MOV     U.SCB(R5),R4    ;;;RETRIEVE ADDRESS OF SCB
        TST     S.FRK+2(R4)     ;;;HAVE WE FORKED ALREADY?
        BNE     300$            ;;;IF NE YES, RETURN FROM INTERRUPT
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
240$:   MOV     U.SCB(R5),R4    ;GET SCB ADDRESS
        MOV     S.CSR(R4),R2    ;PICK UP COMMAND REGISTER ADDRESS
        BICB    #US.ABO,U.STS(R5) ;CLEAR ABORT FLAG                     ;JC024
        BIT     #DS.TUR!DS.RWS!DS.ILG!DS.EOT!DS.BOT,-(R2) ;UNIT DONE?
        BNE     250$            ;IF NE YES
        CMPB    U.BUF(R5),#RWU  ;WAS IT A REWIND AND OFFLINE FUNCTION?
        BEQ     220$            ;IF EQ YES, COMPLETE WITH SUCCESS
        MOV     R4,R0           ;GET ADDR OF CLOCK QUEUE BLOCK
        ADD     #S.MTCK,R0      ;
        CLR     R1              ;SET UP HIGH TICKS
        MOV     #1,R2           ;TIMEOUT UNTIL TUR
        MOV     #C.SYST,R4      ;TYPE OF CLOCK ENTRY
        CALLR   $CLINS          ;TIMEOUT

$MTCLK::                        ;REF LABEL FOR TIMEOUT

        MOV     C.TCB(R4),R5    ;RESTORE UCB ADDRESS
        BR      240$            ;SEE IF UNIT READY
245$:   MOV     #IE.FHE&377,R0  ; SET FATAL ERROR STATUS                ;JC036
        JMP     540$            ; EXIT                                  ;JC036
250$:   MOVB    S.CON(R4),R3    ;PICK UP CONTROLLER NO.                 ;**-1
        BIT     #DS.MOL,(R2)+   ;IS THE DRIVE STILL ON-LINE?
        BNE     260$            ;IF NE YES
        JMP     161$            ;ISSUE "DEVICE-NOT-READY" MSG
260$:   BIC     #CS.IE!CS.EXM,(R2)  ;CLEAR INT. ENABLE AND EX.MEM BITS
        MOVB    S.ITM(R4),S.CTM(R4)  ;RESET TIMEOUT COUNT
        CLR     S.FRK+2(R4)     ;ALLOW INTERRUPT PROCESSING
        MOV     -2(R2),R1       ;GET CONTENTS OF DRIVE STATUS REGISTER
        BITB    #US.BSP,U.STS(R5) ;INTERNAL BACKSPACE IN PROGRESS?
        BNE     280$            ;IF NE YES - CALL SERVICE ROUTINE
270$:   MOV     #IS.SUC&377,R0  ;ASSUME SUCCESS FOR VARIOUS REASONS
        TST     (R2)            ;ANY ERRORS?
        BMI     280$            ;IF MI YES
        TST     U.CW3(R5)       ;SPACING FILE?
        BNE     280$            ;IF NEW YES - TREAT AS ERROR ANYWAY
        CMPB    (R2),#RWD+CS.RDY-CS.GO-CS.IE ;WAS THAT A REWIND?
        BNE     275$            ;IF NE NO
        BIS     #M.RWD,U.CW2(R5) ;SET STATUS BIT
275$:   JMP     500$            ;SUCCESS!!
280$:                           ; REF LABEL


        .IF DF  D$$IAG&E$$DVC

        TST     RTTBL(R3)       ; DIAGNOSTIC FUNCTION CALL?
        BMI     290$            ; IF MI YES

        .ENDC


        .IF DF  E$$DVC

        BIT     #DS.ILG!DS.CRE!DS.PAE!DS.BGL!DS.RLE!DS.BTE,R1
                                ; ANY ERRORS IN STATUS REG (MTS)?
        BEQ     290$            ; IF EQ THEN NO
        CALL    $DVERR          ; LOG DEVICE ERROR

        .ENDC


290$:                           ; REF LABEL
        CALL    @INTADD(R3)     ; CALL THE INTERRUPT ROUTINE
        MOV     (SP)+,INTADD(R3) ;SAVE INTERRUPT ADDRESS
300$:   RETURN                  ;WAIT FOR END OF NEXT COMMAND STEP

;
; WRITE LOGICAL FUNCTION
;

WRBLK:  BIT     #DS.TM,R1       ;DID WRITE SEE EOF?
        BNE     320$            ;IF NE YES

;
; WRITE TAPE MARK FUNCTION
;

WREOF:  BIT     #34404,R1       ;ANY OTHER ERRORS?
        BEQ     490$            ;IF EQ NO - REALLY SUCCESSFUL
        MOV     #IE.WLK&377,R0  ;ASSUME WRITE-LOCK
        BIT     #DS.HWL,R1      ;WRITE LOCK?
        BNE     490$            ;IF NE YES
        BIT     #34400,R1       ;RECOVERABLE ERROR?
        BNE     320$            ;IF NE YES

;
; REWIND FUNCTIONS
;

REWND:  MOV     #IE.FHE&377,R0  ;FATAL ERROR
        BR      490$            ;THAT'S ALL, FOLKS!

320$:   MOV     #IE.BBE&377,R0  ;ASSUME BAD TAPE OR EQUIVALENT
        TSTB    U.CW2(R5)       ;SHOULD WE REWRITE?
        BMI     490$            ;IF MI USER SAID "NO"
        BIT     #2,@R2          ;IS THIS A WRITE EOF?
        BNE     420$            ;IF NE YES
        BIS     #WTE-WRT,U.BUF(R5) ;DO WRITE WITH EXTENDED GAP FROM NOW ON
        BR      420$            ;DO THE OPERATION
;
; SPACE FILE FUNCTION
;

SPCFL:  BIT     #DS.TM,R1       ;TAPE MARK ENCOUNTERED?
        BNE     350$            ;IF NE YES
        MOV     U.CW3(R5),2(R2) ;SOMETHING ELSE STOPPED US

;
; SPACE BLOCK FUNCTION
;

SPCBK:  BIT     #DS.BOT,R1      ;AT BOT?
        BNE     490$            ;IF NE YES, NOT AN ERROR, BUT NEED STACK CLEAR
        BIT     #DS.TM,R1       ;EOF?
        BEQ     340$            ;IF EQ NO
        CALL    CHKEOV          ;SEE IF AT END OF VOLUME
        BCC     410$            ;IF CC NOT FOUND
        BR      360$            ;POSITION TAPE AT EOV
340$:   BIT     #DS.BTE!DS.EOT,R1 ;BAD TAPE ERROR OR EOT?
        BNE     RDBLK           ;IF NE YES - NOT RECOVERABLE
        BR      REWND           ;FATAL

350$:   CALL    CHKEOV          ;DID TAPE REACH LOGICAL END OF VOLUME?
        BCC     370$            ;IF CC NO, TRY NEXT FILE
360$:   CALL    BSPACE          ;BACKSPACE THE TAPE
        CALL    @(SP)+          ;WAIT FOR COMPLETION
        MOV     #IE.EOV&377,R0  ;INFORM USER THAT EOV HAS BEEN DETECTED
        BIS     #M.AEOV,U.CW2(R5) ;SET STATUS BIT
        BR      380$            ;FIX COUNT AND RETURN
370$:   INC     U.CW3(R5)       ;ANOTHER TAPE MARK DETECTED
        BNE     390$            ;IF NE NOT DONE
380$:   MOV     U.CW3(R5),2(R2) ;SET UP FINAL COUNT
385$:   BR      490$            ;RETURN TO USER
390$:   BIS     #M.EOF,U.CW2(R5) ;I SAW AN EOF
        MOV     #1,2(R2)        ;SET RECORD COUNT FOR SPACING
        MOV     2(R2),SPTBL(R3) ;SAVE RECORD COUNT                      ;JC011
        ADD     #-CS.RDY+CS.GO+CS.IE,(R2)  ;REISSUE SPACING COMMAND     ;**-1
        CALL    @(SP)+          ;WAIT FOR COMPLETION
        BR      SPCFL           ;SEE WHAT HAPPENED

;
; READ LOGICAL FUNCTION
;

RDBLK:  MOV     #IE.BBE&377,R0  ;ASSUME BAD TAPE
        BIT     #DS.BTE,R1      ;BAD TAPE?
        BNE     490$            ;IF NE YES
        MOV     #IE.DAO&377,R0  ;ASSUME RECORD LENGTH ERROR
        BIT     #DS.RLE,R1      ;RECORD LTH ERROR?
        BNE     490$            ;IF NE YES
410$:   MOV     #IE.EOF&377,R0  ;TRY EOF
        BIT     #DS.TM,R1       ;EOF DETECTED?
        BNE     490$            ;IF NE YES
        MOV     #IS.SUC&377,R0  ; EOT ON READ IS SUCCESS                ;JC014
        BIT     #DS.EOT,R1      ;EOT?                                   ;**-1
        BNE     490$            ;IF NE NO
        MOV     #IE.VER&377,R0  ;ASSUME DATA ERROR
420$:   MOV     R1,-(SP)        ;SAVE R1                                ;JC025
        MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS                 ;JC025
        BITB    #IQ.X,I.FCN(R1) ;RETRIES SUPPRESSED?                    ;JC025
        BEQ     430$            ;IF EQ NO                               ;JC025
        MOV     (SP)+,R1        ;RESTORE R1                             ;JC025
        BR      490$            ;AND EXIT                               ;JC025
430$:   MOV     (SP)+,R1        ;RESTORE R1 AND CONTINUE                ;JC025
        DECB    RTTBL(R3)       ;ANY MORE RETRIES?                      ;JC025
        BLE     490$            ; IF LE NO                              ;**-1
        MOV     INTADD(R3),U.CW3(R5) ;SAVE ORIGINAL ADDRESS
        CALL    BSPACE          ;BACKSPACE THE TAPE
        CALL    @(SP)+          ;WAIT FOR BACKSPACE
        MOV     U.CW3(R5),INTADD(R3) ;RESTORE INT ADDRESS
        CLR     U.CW3(R5)       ;RESET TO INDICATE NOT SPACING FILE     ;SD009
        TST     (SP)+           ;CLEAN UP THE STACK
        JMP     177$            ;RETRY

;
; END OF INTERRUPT SERVICE ROUTINE PROCESSING
;

490$:   TST     (SP)+           ;CLEAN UP THE STACK
500$:   MOV     R5,R3           ;MAKE A COPY OF UCB BASE
        ADD     #U.CW2,R3       ;COMPUTE OFFSET TO MAG TAPE STATUS
        MOV     (R3),-(SP)      ;SAVE CURRENT STATUS
        BIC     #NEWBTS,(R3)    ;CLEAR STATUS BITS TO BE DETERMINED
        BIT     #DS.BOT,R1      ;AT BOT?
        BEQ     510$            ;IF EQ NO
        BIS     #M.BOT,(R3)     ;SET STATUS BIT
510$:   BIT     #DS.TM,R1       ;TAPE MARK?
        BEQ     520$            ;IF EQ NOT TAPE MARK
        CMPB    (R2),#SPR+CS.RDY-CS.IE-CS.GO ;WAS THAT A BACKSPACE?
        BEQ     520$            ;IF EQ YES - DON'T SET INTERNAL EOF BIT
        BIS     #M.EOF,(R3)     ;SET STATUS BIT
520$:


        .IF DF  D$$IAG

        MOV     R1,-(SP)        ;SAVE R1
        CALL    MTDINT          ;PASS DIAGNOSTIC DEVICE REGISTERS
        MOV     (SP)+,R1        ;RESTORE R1 AND CLEAN STACK

        .ENDC


        .IF DF  D$$IAG&E$$DVC

        BCS     530$            ;

        .ENDC


        .IF DF  E$$DVC

        BIT     #DS.ILG!DS.CRE!DS.PAE!DS.BGL!DS.RLE!DS.BTE,R1
                                ; ANY ERRORS IN STATUS REG (MTS)?
        BEQ     530$            ; IF EQ THEN NO
        CALL    $DVERR          ; LOG DEVICE ERROR

        .ENDC


530$:                           ; REF LABEL
        CMPB    (R2),#RED+CS.RDY-CS.IE-CS.GO ;WAS THAT A READ?          ;JC014
        BEQ     539$            ;YES IGNORE EOT                         ;JC014
        BIT     #DS.EOT,R1      ;EOT?
        BEQ     539$            ;IF EQ NO
        BIT     #M.EOT,(SP)     ;LAST COMMAND ENCOUNTER EOT?
        BEQ     535$            ;IF EQ NO
        TSTB    R0              ;ALREADY RETURNING AN ERROR?
        BMI     538$            ;IF MI YES
535$:   MOV     #IE.EOT&377,R0  ;SET FOR EOT STATUS
538$:   BIS     #M.EOT,(R3)     ;REMEMBER EOT FOR NEXT COMMAND
        MOV     2(R2),-(SP)     ;PRESERVE THE COUNT REGISTER
        BIS     #CS.CLR,@R2     ;STOP THE DRIVE IF RUNNING AWAY
        MOV     (SP)+,2(R2)     ;RESTORE THE COUNT REGISTER
539$:   TST     (SP)+           ;CLEAN STACK
540$:   MOV     S.PKT(R4),R1    ;RETRIEVE ADDRESS OF I/O PACKET
        MOV     I.PRM+4(R1),R1  ;GET ORIGINAL COUNT VALUE
        ADD     2(R2),R1        ;FIX COUNT REMAINING


        .IF DF  E$$DVC

        MOVB    S.CON(R4),R3    ; RETRIEVE CONTROLLER INDEX
        MOVB    RTTBL(R3),R2    ; GET FINAL RETRY COUNT
        BIS     #RETRY*256.,R2  ; MERGE STARTING RETRY COUNT

        .ENDC


        CALL    $IODON          ;FINISH I/O OPERATION
        JMP     MTINI           ;GO AGAIN
        .DSABL  LSB

;
; THIS SUBROUTINE CHECKS FOR THE LOGICAL END-OF-VOLUME CONDITION
;
; RETURNS WITH CC IF NOT EOV.
; RETURNS WITH CS IF EOV.
;

CHKEOV: MOV     2(R2),-(SP)     ;SAVE FRAME COUNT
        ADD     U.CNT(R5),(SP)  ;GET NUMBER ACTUALLY SPACED
        CMP     (SP)+,#1        ;EXACTLY ONE? (COUNT STARTED WITH 1)
        CLC                     ;ASSUME NOT EOV
        BNE     30$             ;IF NE NO, NOT EOV


        .IF DF  A$$NSI

        BITB    #US.LAB,U.STS(R5) ;MOUNTED ANSII TAPE?
        BNE     30$             ;IF NE YES - EXIT WITH CC

        .ENDC


        BIT     #2,(R2)         ;FORWARD SPACE?
        BNE     30$             ;IF NE NO - CANNOT BE EOV
        BIT     #M.EOF!M.BOT,U.CW2(R5) ;AT EOV?
        BEQ     30$             ;IF EQ NO - EXIT WITH CC
        SEC                     ;EOV DETECTED
30$:    RETURN                  ;

;
; THIS SUBROUTINE ISSUES A COMMAND TO BACKSPACE ONE RECORD
;

BSPACE: BISB    #US.BSP,U.STS(R5)  ;SET INTERNAL BACKSPACE IN PROGRESS
        MOV     #-1,2(R2)       ;BACKSPACE ONE RECORD
        MOVB    #SPR,(R2)       ;ISSUE BACKSPACE FUNCTION
        RETURN

;
; THIS ROUTINE ATTEMPTS TO SELECT A TAPE DRIVE.
; THE CURRENT STATUS OF THE DRIVE WITH REGARD TO 7CH,
; BOT, AND HWL IS SET AT THIS TIME.
;
; ON RETURN:    CC==>GOOD SELECT
;               CS==>BAD SELECT
;

SELECT: MOV     S.CSR(R4),R2    ;PICK UP CSR ADDRESS
        MOVB    U.UNIT(R5),1(R2) ;FETCH THE PHYSICAL UNIT NO.
        MOV     #50.,-(SP)      ;SET UP FOR SELECT TIMEOUT
5$:     DEC     (SP)            ;TWIDDLE YOUR THUMBS
        BNE     5$              ;
        MOVB    1(R2),U.BUF+1(R5) ;SET UP FOR COMMAND
        MOV     -2(R2),(SP)     ;SAVE THE SYSTEM STATUS
        BIC     #<M.BOT!M.7CH!M.HWL!M.RWD!M.SER>,U.CW2(R5) ;CLEAR EXCESS
        SEC                     ;ASSUME SELECT ERROR
        BIT     #DS.MOL,(SP)    ;DID DRIVE SELECT?
        BEQ     10$             ;IF EQ NO - SELECT ERROR
        BIT     #DS.TUR!DS.RWS!DS.SDN,(SP) ;MAKE SURE DRIVE IS OK
        BNE     7$              ;IF NE OK
        BIT     #RD.GAP,10(R2)  ;LAST CHANCE
        BEQ     10$             ;IF EQ VACUUM IS GONE - FATAL
7$:     SWAB    (SP)            ;POSITION BITS CONVENIENTLY
        BIC     #^C<M.BOT!M.7CH!M.HWL!M.RWD>,(SP) ;CLEAR EXTRA BITS
        BIS     (SP),U.CW2(R5)  ;
        BICB    #US.ABO,U.STS(R5) ;NOT ABORTING
        CLC                     ;GOOD SELECT
10$:    INC     (SP)+           ;CLEAN UP STACK WITHOUT AFFECTING CARRY
        BCC     20$             ;IF CC GOOD SELECT
        BIS     #M.SER,U.CW2(R5) ;SET SELECT ERROR BIT
20$:    RETURN                  ;


        .IF DF  D$$IAG

;+
; **-MTDINT-TM11 DIAGNOSTIC INTERRUPT AND TIMEOUT HANDLER
;
; IF ENTRY WAS FROM A DIAGNOSTIC CONTROL FUNCTION THEN MOVE I/O
; PACKET WORDS 17-20 TO WORDS 20-21 FOR $CRPAS ROUTINE.
; FOR ANY DIAGNOSTIC FUNCTION PASS THE UNIBUS DEVICE REGISTERS VIA
; THE $CRPAS ROUTINE.
;
; INPUTS
;       R2= CSR ADDRESS
;       R4= SCB ADDRESS
;
; OUTPUTS
;       R1= IO PACKET ADDRESS
;-

MTDINT: MOV     S.PKT(R4),R1    ;GET I/O PACKET ADDRESS
        CLC                     ;
        BITB    #IQ.UMD,I.FCN(R1) ;DIAGNOSTIC FUNCTION CALL?
        BEQ     4$                      ;IF EQ NO
        MOV     R1,-(SP)        ;SAVE IO PACKET ADDRESS
        CMPB    #IO.EOF/256.,I.FCN+1(R1) ;WRITE EOF FUNCTION?
        BEQ     1$                      ;IF EQ YES
        CMPB    #IO.RWD/256.,I.FCN+1(R1) ;CNTRL FUNCT.OTHER THAN IO.EOF?
        BEQ     1$                      ;IF EQ YES
        CALL    $CRPAS          ;PASS DEVICE REGISTERS TO DIAGNOSTIC
        MOV     (SP)+,R1        ;RESTORE IO PACKET ADDRESS
        BR      3$              ;RETURN
1$:     MOV     I.PRM+14(R1),I.PRM+16(R1) ;MOVE WD20 TO WD21
        MOV     I.PRM+12(R1),I.PRM+14(R1) ;MOVE WD17 TO WD20
2$:     CALL    $CRPAS          ;PASS DEVICE REGISTERS TO DIAGNOSTIC
        MOV     (SP)+,R1        ;RESTORE IO PACKET ADDRESS
        MOV     I.PRM+14(R1),I.PRM+12(R1) ;MOVE WD20 BACK TO WD17
        MOV     I.PRM+16(R1),I.PRM+14(R1) ;MOVE WD21 BACK TO WD20
3$:     BIC     #RD.LPC,10(R2)  ;CLEAR LPC MODE BIT IN MTRD REG.
        SEC                     ;SET DIAGNOSTIC FUNCTION CALL RETURN
4$:     RETURN

        .ENDC

        .END
        .TITLE  NLDRV
        .IDENT  /03/
 
;
; COPYRIGHT (C) 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; E. L. BAATZ 22-JUL-76
;
; NULL DEVICE DRIVER.
;
; MACRO LIBRARY CALLS
;
; EQUATED SYMBOLS
;
; LOCAL DATA
;
; NO CONTROLLER IMPURE DATA TABLES (THERE IS NO DEVICE TO
;       CAUSE INTERRUPTS)
;
; DRIVER DISPATCH TABLE
;
$NLTBL::
        .WORD   NLINI           ;INITIATION
        .WORD   $INTXT          ;CANCEL ($INTXT IS A "RETURN")
        .WORD   $INTXT          ;TIMEOUT
        .WORD   $INTXT          ;POWERFAIL
;+
; NLDRV AND DRQIO IMPLEMENT A DEVICE NL:, WHICH ACTS AS
;   1)  A SINK FOR ALL INFORMATION SEND TO IT (IO.WLB)
;   2)  A SOURCE FOR AN INFINITE NUMBER OF END OF FILES (IO.RLB)
;   3)  A SOURCE FOR AN INFINITE NUMBER OF NULL RECORDS (IO.RLB)
;       IF "IE.EOF" IS CHANGED TO "IS.SUC"
;-
;
; DRQIO (BECAUSE THE UC.QUE BIT IS SET IN THE UCB) SETS THE REGISTERS
; TO THE FOLLOWING:
;
;       R1 = ADDRESS OF I/O PACKET
;       R4 = ADDRESS OF SCB
;       R5 = ADDRESS OF UCB
;
; ONLY TWO FIELDS OF AN I/O PACKET MATTER
;       I.FCN+1 = THE I/O FUNCTION CODE.  ONLY IO.WLB
;                 AND IO.RLB MAKE IT TO NLDRV
;       I.PRM+4 = IF I.FCN+1 IS IO.WLB, THIS IS THE 
;                 NUMBER OF BYTES THE CALLER WANTS TO WRITE
;
NLINI:  MOV     R1,R3           ;POINT AT PACKET FOR $IOFIN
        MOV     #IS.SUC&377,R0  ;A WRITE ALWAYS SUCCEEDS
        MOV     I.PRM+4(R1),R1  ;SAY EVERYTHING WAS WRITTEN
        CMPB    #IO.WLB/400,I.FCN+1(R3) ;WANTS TO WRITE?
        BEQ     10$             ;IF EQ YES
        MOV     #IE.EOF&377,R0  ;IT IS A READ
        CLR     R1              ;READ NO CHARACTERS
10$:    CALLR   $IOFIN          ;FINISH OFF PACKET
 
        .END
        .TITLE  NTDRV
        .IDENT  /03/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; J. M. GILBERT 9-MAY-75
;
; LG005 - MODIFIED 8-SEP-76 FOR LOADABLE DRIVER SUPPORT
;
; RSX-11M NETWORK DEVICE DRIVER
;
; MACRO LIBRARY CALLS
;
        .MCALL  PKTDF$,DEVDF$
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        DEVDF$                  ;DEFINE DEVICE TABLE OFFSETS
        .MCALL  PCBDF$
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
;
; DRIVER DISPATCH TABLE
;
 
 
        .IF DF  M$$NET
 
$NTTBL::.WORD   NTINIT          ;INITIALIZATION
        .WORD   NTCANC          ;I/O CANCELLATION
        .WORD   NTTMO           ;TIMEOUT
        .WORD   NTPWRF          ;POWER FAIL
        .WORD   NTRCV           ;UNSOLICITED RECEIVE ENTRY
        .WORD   NTRXER          ;RECEIVER ERROR CLEAR
 
;+
;**- NTINIT - NT DEVICE SERVICE.  PROVIDED SO
; THAT STAND-ALONE TESTING OF NETWORKS CAN TAKE PLACE
; ON A SYSTEM WITHOUT NETWORK COMMUNICATION DEVICES.
; PRIMARY FUNCTION OF INITIATOR IS TO CALL $GTPKT, FORCING
; DISPATCH OF PACKET TO ACP.  ONLY ACP FUNCTIONS ARE
; LEGAL ON THIS DEVICE.  HOWEVER, THE FUNCTION IO.LOV IS ALSO
; ACCEPTED AND IS MAPPED INTO A FUNCTION CODE 30.  THE PACKET
; IS THEN REQUEUED TO NT:;  HOWEVER, NOW THAT THE FUNCTION IS
; AN ACP FUNCTION, THE PACKET IS QUEUED TO THE ACP.
;
;       INPUTS:
;
;               R1 = PACKET ADDRESS
;               R4 = STATUS CONTROL BLOCK ADDRESS
;               R5 = ADDRESS OF THE UCB OF THE NT DEVICES
;
;       OUTPUTS:
;
;               THE PACKET WILL BE QUEUED TO THE ACP.
;-
 
NTINIT: CALL    $GTPKT          ;QUEUE PACKET TO ACP
        BCS     10$             ;IF CS, NO PACKETS
;
; R1 NOW CONTAINS PACKET ADDRESS
; R5 CONTAINS UCB ADDRESS
; FUNCTION MUST BE IO.RLB,
; SPECIFICALLY IO.LOV
;
        CLRB    S.STS(R4)       ;CLEAR CONTROLLER STATUS
        BICB    #US.BSY,U.STS(R5) ;MARK UNIT IDLE
        MOV     #30*256.,I.FCN(R1) ;SET FUNCTION TO 30
        CALL    $DRQRQ          ;QUEUE PACKET TO ACP
 
10$:                            ;REFERENCE LABEL
 
;+
;**- NTCANC,NTTMO,NTPWRF,NTRCV,NTRXER ARE ALL
; NO-OP'D, SINCE THIS IS A LOGICAL DEVICE.
;-
 
NTCANC:                         ;I/O CANCELLATION
NTTMO:                          ;DEVICE TIMEOUT
NTPWRF:                         ;POWER FAILURE
NTRCV:                          ;RECEIVE INITIATION
NTRXER:                         ;RECEIVER RESET
        RETURN
 
        .IF     DF      M$$MGE&L$$DRV
 
;+
; **-$MLDC-MAP LOADABLE DRIVER TO APR5 AND CALL DRIVER
; **-$MLDCS-ENTRY POINT IF ALREADY ON SYSTEM STACK
;
; INPUTS:
;       R0=DISPLACEMENT IN DISPATCH TABLE OF ENTRY POINT
;       R5=UCB ADDRESS
;
; OUTPUTS:
;       DRIVER CALLED WITH ALL REGISTERS EXCEPT R0 UNCHANGED
;       R0=DESTROYED
;-
$MLDC:: SWSTK$  EXIT            ;GO TO SYSTEM STATE
$MLDCS::MOV     KISAR5,-(SP)    ;SAVE APR5
        MOV     R0,-(SP)        ;DISPATCH TABLE DISPLACEMENT
        MOV     (R5),R0         ;DCB ADDRESS
        ADD     D.DSP(R0),(SP)  ;DISPATCH TABLE ADDRESS
        MOV     D.PCB(R0),R0    ;DRIVER PCB ADDRESS
        BEQ     10$             ;IF EQ, DRIVER IS PART OF EXEC
        MOV     P.REL(R0),KISAR5 ;MAP THE DRIVER
10$:    MOV     @(SP)+,R0       ;DRIVER ENTRY POINT
        CALL    (R0)            ;CALL THE DRIVER
        MOV     (SP)+,KISAR5    ;RESTORE APR5
EXIT:   RETURN
 
        .ENDC
 
        .ENDC
 
 
 
        .END
        .TITLE PANIC
        .IDENT  /05.04/
 
;
; COPYRIGHT (C) 1974,1976,1977
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; VERSION 05.04
;
; D. N. CUTLER 4-AUG-73
;
; MODIFIED BY:
;
;       J. M. GILBERT 22-APR-74
;
;       D. N. CUTLER 11-MAY-75
;
;               DC062 -- REFERENCE PROCESSOR STATUS WORD VIA MFPS/MTPS
;                       INSTRUCTIONS FOR THE LSI-11.
;
;       K. E. KINNEAR 16-DEC-76
;
;               KK002 -- ADDITION OF SUPPORT FOR PROCESSORS
;                       WITH NO SWITCH REGISTERS.
;
;       P. J. BEZEREDI 18-AUG-77
;
;               PB031 -- ADDITION OF SUPPORT FOR NEW CRASH DUMP
;                       MODULE.
;
;       M. S. HARVEY    2-FEB-79
;
;               MSH024 -- ALLOW USER TO SPECIFY LOWER BOUND
;
;
; PANIC DUMP ROUTINE
;


        .IF DF  P$$NIC

;
; MACRO LIBRARY CALLS
;

        .MCALL  HWDDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS

;
; LOCAL DATA
;


        .IF NDF C$$RSH

$CRPBF::.BLKW   18.             ;PANIC'S REGISTER BUFFER AND STACK
$CRPST::                        ;TOP OF PANIC'S TEMPORARY STACK

        .ENDC


        .ENDC


;+
; **-$PANIC-PANIC DUMP
;
; THIS ROUTINE IS ENTERED WHEN THE SYSTEM CRASHES OR BY FORCING AN
; ENTRY VIA THE CONSOLE SWITCHES. ON ENTRY THE PROCESSOR STATUS AND
; REGISTERS ARE SAVED IN A TEMPORARY STORAGE AREA. PANIC THEN HALTS
; AWAITING A SET OF DUMP LIMITS TO BE ENTERED IN THE SWITCH REGISTER.
; THE FOLLOWING PROCEDURE IS USED TO OBTAIN A DUMP:
;
;       1-WITH THE PROCESSOR HALTED ENTER THE LOW DUMP LIMIT IN THE
;               SWITCH REGISTER.
;       2-DEPRESS CONTINUE. THE PROCESSOR WILL AGAIN HALT.
;       3-WITH THE PROCESSOR HALTED ENTER THE HIGH DUMP LIMIT IN THE
;               SWITCH REGISTER.
;       4-DEPRESS CONTINUE. THE DUMP WILL BE OUTPUT ON THE DEVICE
;               'P$$NIC'.
;
; THE FIRST LINE OF OUTPUT IS THE DUMP OF PS,R0,R1,R2,R3,R4,R5, AND SP.
; SUCCEEDING LINES OF OUTPUT ARE THE ACTUAL DUMP. WHEN THE DUMP IS
; FINISHED, PANIC AGAIN HALTS AWAITING A NEW SET OF DUMP LIMITS TO
; BE INPUT.
;-

        .ENABL  LSB
$PANIC::                        ;PANIC DUMP ROUTINE


        .IF NDF P$$NIC

        JMP     $BTSTP          ;RE-BOOT SYSTEM IF NO PANIC DUMP

        .IFF

                                                                        ;**-1

        .IF DF  M$$MGE

        MOV     PS,$CRPBF       ;SAVE PS WORD

        .IFF

        MFPS    $CRPBF          ;SAVE PS WORD

        .ENDC


        MTPS    #PR7            ;LOCK OUT INTERRUPTS
        MOV     R0,$CRPBF+2     ;;;SAVE RR0
        MOV     #$CRPBF+4,R0    ;;;POINT TO SAVE AREA
        MOV     R1,(R0)+        ;SAVE REGISTER R1 TO SP
        MOV     R2,(R0)+        ;
        MOV     R3,(R0)+        ;
        MOV     R4,(R0)+        ;
        MOV     R5,(R0)+        ;
        MOV     SP,(R0)         ;
10$:    HALT                    ;GET LOWER DUMP LIMIT                   ;MSH024
        MOV     #$CRPST,SP      ;SET NEW STACK POINTER                  ;MSH024
                                                                        ;**-1

        .IF NDF S$$WRG

        MOV     @#0,-(SP)       ;

        .IFF

        MOV     SWR,-(SP)       ;

        .IFTF

        HALT                    ;GET ENDING DUMP LIMIT
        MOV     #$CRPBF,R0      ;ALWAYS DUMP REGISTERS FIRST
        MOV     #$CRPBF+16,R1   ;
        CALL    $PDMP           ;DUMP REGISTERS

        .IFT

        MOV     @#0,R1          ;GET LAST WORD ADDRESS

        .IFF

        MOV     SWR,R1          ;GET LAST WORD ADDRESS

        .ENDC


        MOV     (SP)+,R0        ;AND FIRST WORD ADDRESS
        BIC     #1,R0           ;MAKE SURE START IS EVEN
        CALL    20$             ;DUMP MEMORY
        BR      10$             ;GO AGAIN

;
; DUMP SELECTED BLOCK OF MEMORY
;

$PDMP:: MOV     #P$$NIC,R5      ;SET OUTPUT DEVICE CSR
        MOV     #14,R2          ;OUTPUT A FORM FEED
        CALL    $OUT            ;
20$:    MOV     R0,-(SP)        ;SAVE FOR RELATIVE ADDRESS
30$:    MOV     R0,-(SP)        ;SAVE START OF LINE ADDRESS
        MOV     R0,R2           ;SAVE CURRENT LINE
40$:    MOV     #8.,R4          ;COUNT FOR 1 LINE
50$:    CMP     (R0)+,@(SP)     ;ARE WORDS EQUAL?
        BNE     60$             ;IF NOT, PRINT LINE
        DEC     R4              ;COUNT THROUGH LINE
        BGT     50$             ;IF GT, NOT THROUGH YET
        MOV     R0,R2           ;UPDATE LINE STARTING ADDRESS
        CMP     R0,R1           ;AT END OF DUMP?
        BLOS    40$             ;IF NOT, CHECK NEXT LINE
60$:    CMP     R2,(SP)         ;ANY LINES SUPPRESSED?
        BEQ     70$             ;NO, IF STARTING ADDRESS SAME
        MOV     (SP),R3         ;EDIT OUT OLD STARTING ADDRESS
        MOV     @(SP),R0        ;GET MASTER WORD
        MOV     R2,(SP)         ;NOW HAVE NEW STARTING ADDRESS
        CALL    $EDIT           ;WORD EDIT
        MOV     #'-,R2          ;SEPARATE ADDRESSES WITH MINUS
        CALL    $OUT            ;OUTPUT MINUS
        CALL    $OUTB           ;AND NOW A BLANK
        MOV     (SP),R3         ;NOW OUTPUT LAST SUPPRESSED WORD ADDRESS
        TST     -(R3)           ;2 LESS THAN NEW START OF LINE
        CALL    $EDIT           ;OUTPUT LAST WORD OF IDENTICAL BLOCK
        CALL    $OUTB           ;ISSUE ANOTHER BLANK
        MOV     R0,R3           ;NOW GET REPEATED WORD
        CALL    $EDIT           ;OUTPUT REPEATED WORD
        CALL    $CRLF           ;ISSUE CARRIAGE RETURN/LINE FEED
        CALL    $OUT            ;OUTPUT ANOTHER LINE FEED
        MOV     (SP)+,R0        ;PUT START OF LINE IN R0
        CMP     R0,R1           ;AT END OF DUMP?
        BHI     110$            ;IF HI, AT END
        MOV     R0,-(SP)        ;GET BACK IN SYNC WITH NEXT ROUTINE
70$:    MOV     (SP),R0         ;RECAPTURE NEW START OF LINE
        CALL    WORD            ;EDIT WORDS
        MOV     (SP),R0         ;RETRIEVE STARTING ADDRESS
        CALL    BYTE            ;EDIT BYTES
        MOV     (SP)+,R0        ;RETRIEVE STARTING ADDRESS
        MOV     #5,R4           ;SET LOOP COUNT
80$:    CALL    $OUTB           ;OUTPUT A BLANK
        DEC     R4              ;ANY MORE?
        BGT     80$             ;IF GT YES
        MOV     #8.,R4          ;SET REPEAT COUNT
90$:    MOV     (R0)+,R3        ;GET NEXT WORD
        CALL    120$            ;OUTPUT LOW BYTE
        SWAB    R3              ;SWAP BYTES
        CALL    120$            ;OUTPUT HIGH BYTE
        DEC     R4              ;ANY MORE THIS LINE?
        BGT     90$             ;IF GT YES
100$:   CALL    $CRLF           ;OUTPUT A CR-LF
        CALL    $OUT            ;OUTPUT ANOTHER LF
        CMP     R0,R1           ;END OF EDIT YET?
        BLOS    30$             ;IF NOT, GO AGAIN
110$:   TST     (SP)+           ;REMOVE START FOR RELATIVE ADDRESS
        CALL    $OUT            ;OUTPUT 2 MORE LINE FEEDS
        BR      $OUT            ;AND DON'T RETURN HERE
120$:   CALL    $OUTB           ;OUTPUT TWO BLANKS
        CALL    $OUTB           ;
        BICB    #200,R3         ;CLEAR PARITY BIT
        CMPB    R2,R3           ;CONTROL CHARACTER?
        BLOS    130$            ;IF LOS NO
        BISB    #100,R3         ;CONVERT TO CHARACTER
        MOVB    #136,R2         ;SET TO OUTPUT CARET
130$:   CALL    $OUT            ;OUTPUT BLANK OR CARET
        MOVB    R3,R2           ;SET BYTE TO OUTPUT
        INCB    R3              ;CHARACTER A RUBOUT?
        BMI     $OUTB           ;IF MI YES OUTPUT A BLANK
        BR      $OUT            ;OUTPUT CHARACTER
        .DSABL  LSB

;
; WORD EDIT
;

WORD:   MOV     R0,R3           ;EDIT LINE ADDRESS
        MOV     #9.,R4          ;SET LOOP COUNT
        BR      20$             ;
10$:    MOV     (R0)+,R3        ;GET NEXT WORD
20$:    CALL    $EDIT           ;EDIT WORD
        CALL    $OUTB           ;OUTPUT ANOTHER BLANK
        DEC     R4              ;ANY MORE THIS LINE?
        BGT     10$             ;IF GT YES
        BR      $CRLF           ;

;
; BYTE EDIT
;

BYTE:   MOV     R0,R3           ;COPY ADDRESS OF LINE
        SUB     4(SP),R3        ;CALCULATE BLOCK OFFSET
        CALL    $EDIT           ;EDIT OFFSET FROM START OF BLOCK
        MOV     #8.,R4          ;SET LOOP COUNT
10$:    MOV     (R0)+,R3        ;GET NEXT WORD
        CALL    EBYT            ;EDIT HIGH BYTE
        CALL    EBYT            ;EDIT LOW BYTE
        DEC     R4              ;ANY MORE THIS LINE?
        BGT     10$             ;IF GT YES

        .ENDC


        .IF DF  C$$TTY!P$$NIC


;
; SUBROUTINE TO OUTPUT CR-LF
;

$CRLF:: MOVB    #15,R2          ;OUTPUT CR
        CALL    $OUT            ;
        MOVB    #12,R2          ;OUTPUT A LF
        BR      $OUT            ;

;
; SUBROUTINE TO EDIT ONE BYTE
;

EBYT:   CLR     R2              ;CLEAR CHARACTER ACCUMULATOR
        MOV     #3,-(SP)        ;SET CHARACTER COUNT
        BR      EDT2            ;COLLECT HIGH ORDER 2 BITS

;
; SUBROUTINE TO EDIT ONE WORD
;

$EDIT:: CLR     R2              ;CLEAR CHARACTER ACCUMULATOR
        MOV     #6,-(SP)        ;SET CHARACTER COUNT
        BR      EDT3            ;COLLECT HIGH ORDER BIT
EDT1:   CLR     R2              ;COLLECT NEXT 3 BITS
        ASL     R3              ;
        ROL     R2              ;
EDT2:   ASL     R3              ;
        ROL     R2              ;
EDT3:   ASL     R3              ;
        ROL     R2              ;
        ADD     #'0,R2          ;ADD DIGIT BIAS
        CALL    $OUT            ;OUTPUT CHARACTER
        DEC     (SP)            ;ANY MORE?
        BGT     EDT1            ;IF GT YES
        TST     (SP)+           ;CLEAR STACK

;
; OUTPUT SUBROUTINES
;

$OUTB:: MOVB    #40,R2          ;SET TO OUTPUT BLANK

        .ENDC


        .IF DF  C$$RSH!P$$NIC

$OUT::  TSTB    (R5)            ;DEVICE READY?
        BPL     $OUT            ;IF PL NO
        MOVB    R2,2(R5)        ;OUTPUT CHARACTER
        CMPB    #15,R2          ;CARRIAGE RETURN?
        BNE     20$             ;IF NE NO
        CMP     #177514,R5      ;OUTPUT DEVICE LINE PRINTER?
        BEQ     20$             ;IF EQ YES
        CLR     R2              ;SET ZERO FILL CHARACTER
        MOV     #5,-(SP)        ;SET FILL COUNT
10$:    CALL    $OUT            ;OUTPUT A FILL CHARACTER
        DEC     (SP)            ;ANY MORE TO FILL?
        BGT     10$             ;IF GT YES
        TST     (SP)+           ;CLEAN STACK
20$:    RETURN                  ;

        .ENDC


        .END
        .TITLE  PARTY
        .IDENT  /09.3/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 09.3
;
; D. N. CUTLER  14-FEB-74
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 21-SEP-77
;
;               TM108 -- MODIFY TO PROPERLY HANDLE MK11 ECC MEMORY FOR
;                       THE 11/70.
;
;       CHUCK SPITZ 7-NOV-78
;               CS018 -- ADD PARENT OFFSPRING TASKING
;
;       CHUCK SPITZ 13-MAR-79
;               CS038 -- CORRECT BUG IN MK11 PARITY SUPPORT
;
;       M. S. HARVEY    8-MAY-79
;               MSH018 -- DISABLE CACHE IMMEDIATELY FOLLOWING
;                         MEMORY PARITY ERROR. ALSO, DON'T CLEAR
;                         MEMORY PARITY REGISTER BEFORE HALTING
;                         FOR PARITY ERROR.
;
;
; MEMORY PARITY INTERRUPT HANDLING
;
; MACRO LIBRARY CALLS
;


        .IF DF  P$$RTY

        .MCALL  ABODF$,HWDDF$,PCBDF$,TCBDF$
        ABODF$                  ;DEFINE TASK ABORT CODES
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;
; LOCAL DATA
;
; EXEC PARITY ERROR MESSAGE
;

EXMSG:  .ASCIZ  <15><12>/***EXEC PARITY ERROR STOP***/<15><12><12> ;

;
; INTERRUPT RECURSION LEVEL COUNTER
;

PARLV:  .WORD   -1              ;

;
; PARITY CONTROL STATUS REGISTER ADDRESS TABLE
;

        .BLKW   1               ;DUMMY STORAGE FOR MEMORY ERROR REGISTER
$PARTB::.WORD   1               ;DUMMY CSR FOR NONEXISTANT REGISTERS
        .BLKW   16.             ;MEMORY PARITY CSR TABLE
        .WORD   $MPCSR          ;POINT TO 11/70 CSR TABLE

;
; PDP-11/70 CACHE PARITY STATUS TABLE
;


        .IF DF  P$$D70


        .IF DF  E$$PER

MSTAT:  .BLKW   2               ;FIRST TWO PARITY CSR'S
STAT:   .BLKW   1               ;MEMORY STATUS REGISTER
        .BLKW   3               ;LAST THREE PARITY CSR'S

        .IFF

STAT:   .BLKW   1               ;MEMORY STATUS REGISTER

        .ENDC


ERTRK:  .BYTE   44,120          ;ADDRESS/DATA GROUP 0
        .WORD   0               ;TIME OF LAST ERROR
        .BYTE   30,240          ;ADDRESS/DATA GROUP 1
        .WORD   0               ;TIME OF LAST ERROR
        .WORD   0               ;END OF TABLE

;
; NEW CACHE PARITY CSR CONTENTS
;

$MPCTL::.BLKW   1               ;

        .ENDC


;
; VECTOR OF CACHE CSR ADDRESSES
;

$MPCSR::.BLKW   6               ;ALL SIX REGISTERS
        .WORD   0               ;TERMINATOR LINK FOR INITL AND SAVE


;
; PARITY VECTOR
;

        .ASECT
.=114
        .WORD   $PARER                                                  ; CS018
        .WORD   PR7             ;                                       ;**-1
        .PSECT

;+
; **-$PARER-MEMORY PARITY ERROR INTERRUPT                               ; CS018
;                                                                       ;**-1
; THIS ROUTINE IS ENTERED AS THE RESULT OF A MEMORY PARITY ERROR INTERRUPT. IF
; THE ERROR OCCURED IN THE EXECUTIVE OR WHILE ON THE SYSTEM STACK, THEN A
; MESSAGE IS PRINTED ON THE CONSOLE TERMINAL AND THE SYSTEM IS HALTED.
; ELSE A SWITCH TO THE SYSTEM STACK IS EXECUTED AND THE TASK IN WHICH
; THE PARITY ERROR OCCURED IS LOCKED IN MEMORY.
;-

        .ENABL  LSB
RECURS: JMP     60$             ;;;JUMP TO HALT PROCESSOR
$PARER::                        ;;;REF LABEL                            ; CS018
                                                                        ;MSH018
        .IF DF P$$D70                                                   ;MSH018
                                                                        ;MSH018
        BIS     #3,@$MPCSR+6    ;;;TURN CACHE TRAPS OFF                 ;MSH018
                                                                        ;MSH018
        .ENDC                                                           ;MSH018
                                                                        ;MSH018
        INC     PARLV           ;;;INTERRUPT RECURSION?                 ;MSH018
        BNE     RECURS          ;;;IF NE YES                            ;**-1


        .IF DF  P$$D70

        MOV     R0,-(SP)        ;;;SAVE R0
        MOV     R1,-(SP)        ;;;SAVE R1


        .IF DF  E$$PER

        MOV     #$MPCSR,R0      ;POINT TO PARITY CSR TABLE
        MOV     #MSTAT,R1       ;POINT TO PARITY CSR SAVE AREA
        MOV     @(R0)+,(R1)+    ;SAVE LOW ADDRESS REGISTER
        MOV     @(R0)+,(R1)+    ;SAVE HIGH ADDRESS REGISTER

        .IFF

        MOV     #$MPCSR+4,R0    ;POINT INTO PARITY CSR TABLE
        MOV     #STAT,R1        ;POINT TO STATUS WORD SAVE AREA

        .IFTF

        MOV     #-1,(R1)        ;ASSUME MEM PARITY ON NONCACHE MACHINE
        CMP     (R0)+,#MPCSR-2  ;RUNNING ON CACHE MACHINE?
        BNE     2$              ;IF NE NO
        MOV     @-(R0),(R1)+    ;SAVE MEMORY ERROR REGISTER             ;MSH018
        TST     (R0)+           ;POINT TO ADDRESS OF MEM CTRL REG       ;MSH018
                                                                        ;**-4
        .IFT

        MOV     @(R0)+,(R1)+    ;SAVE MEMORY CONTROL REGISTER
        MOV     @(R0)+,(R1)+    ;SAVE MAINTENANCE REGISTER              ;**-7
        MOV     @(R0)+,(R1)+    ;SAVE CACHE HIT REGISTER

        .ENDC


2$:     MOV     (SP)+,R1        ;;;RESTORE R1
        MOV     (SP)+,R0        ;;;RESTORE R0

        .IFTF


        .IF DF  M$$MGE

        BIT     #CMODE,2(SP)    ;;;PREVIOUS MODE USER?
        BNE     4$              ;;;IF NE YES

        .IFF

        CMP     (SP),$EXSIZ     ;;;PARITY ERROR PC IN EXEC?
        BLO     3$              ;;;IF LO YES
        TST     $STKDP          ;;;PARITY ERROR ON SYSTEM STACK?
        BGT     4$              ;;;IF LE YES

        .ENDC


        .IFT

3$:     TST     STAT            ;;;FATAL MEMORY ERROR?
        BLE     20$             ;;;IF LE YES
        MOV     R0,-(SP)        ;;;SAVE REGISTERS
        MOV     R1,-(SP)        ;;;
        MOV     #ERTRK,R1       ;;;POINT TO ERROR TRACKING TABLE
        CALL    14$             ;;;EXECUTE CACHE ALGORITHM
        MOV     (SP)+,R1        ;;;RESTORE REGISTERS
        MOV     (SP)+,R0        ;;;
        RTI                     ;;;RETURN FROM TRAP

        .IFF

3$:     BR      20$             ;;;FATAL MEMORY PARITY ERROR

        .IFTF


4$:     DIRSV$                  ;;;SAVE REGISTERS AND SET PRIORITY

;
; LOG PARITY ERROR IN TASK
;
; THE FORMAT OF THE EMB FOR CACHE PARITY IS AS FOLLOWS:
;
;       WD. 00 - LINK WORD
;       WD. 01 - SIZE=37.*2
;       WD. 02 - PROCESSOR TYPE / ENTRY CODE=002
;       WD. 03 - MINUTE / SECOND
;       WD. 04 - DAY / HOUR
;       WD. 05 - YEAR / MONTH
;       WD. 06 - ERROR SEQUENCE NUMBER
;       WD. 07 - TRAP PC
;       WD. 08 - TRAP PS
;       WD. 09 - FIRST WORD OF TASK NAME
;       WD. 10 - SECOND WORD OF TASK NAME
;       WD. 11 - FIRST WORD OF PARTITION NAME
;       WD. 12 - SECOND WORD OF PARTITION NAME
;       WD. 13 - PARTITION BASE ADDRESS
;       WD. 14 - PARTITION SIZE
;       WD. 15 - WD. 30 - MEMORY PARITY CSR'S
;       WD. 31 - WD. 36 - CACHE PARITY CSR'S
;


        .IF DF  E$$PER

        MOV     #37.*2,R1       ;SET SIZE OF EMB TO ALLOCATE
        MOV     #2+<1*256.>,-(SP) ;PUSH PARITY ERROR CODE AND TYPE=11/45
        CALL    $ALEMB          ;ALLOCATE EMB
        BCS     8$              ;IF CS ALLOCATION FAILURE


        .IF DF  P$$D70

        CMP     $MPCSR+6,#MPCSR ;IS THE PROCESSOR A CACHE PROCESSOR?
        BNE     5$              ;IF NE NO
        INCB    5(R1)           ;ADVANCE PROCESSOR NUMBER
        CMP     $MPCSR+2,#MPCSR-4 ;IS IT AN 11/70?
        BEQ     5$              ;IF EQ YES
        INCB    5(R1)           ;ADVANCE PROCESSOR NUMBER

        .IFTF

5$:     MOV     @$HEADR,R2      ;PICK UP SAVED STACK POINTER
        CMP     (R2)+,(R2)+     ;SKIP OVER SAVED R4 AND R5
        MOV     (R2)+,(R0)+     ;STORE TRAP PC
        MOV     (R2)+,(R0)+     ;STORE TRAP PS
        MOV     $TKTCB,R2       ;PICK UP CURRENT TASK TCB ADDRESS
        MOV     T.NAM(R2),(R0)+ ;STORE TASK NAME
        MOV     T.NAM+2(R2),(R0)+ ;
        MOV     T.PCB(R2),R2    ;PICK UP TASK PCB ADDRESS
        MOV     P.NAM(R2),(R0)+ ;STORE PARTITION NAME
        MOV     P.NAM+2(R2),(R0)+ ;
        MOV     P.REL(R2),(R0)+ ;STORE PARTITION BASE ADDRESS
        MOV     P.SIZE(R2),(R0)+ ;STORE PARTITION SIZE
        MOV     #$PARTB+2,R2    ;POINT TO MEMORY PARITY CSR TABLE
6$:     MOV     @(R2)+,(R0)+    ;STORE MEMORY PARITY CSR CONTENTS
        CMP     R2,#$PARTB+2+<16.*2> ;DONE YET?
        BLO     6$              ;IF LO NO

        .IFT

        TST     (R2)+           ;POINT TO CACHE PARITY CSR'S
7$:     MOV     (R2)+,(R0)+     ;STORE SAVED CACHE CSR CONTENTS
        CMP     R2,#MSTAT+14    ;DONE YET?
        BLO     7$              ;IF LO NO

        .ENDC


        CALL    $QEMB           ;QUEUE ERROR MESSAGE BLOCK
8$:                             ;REF LABEL

        .ENDC


        .IFT

        MOV     #ERTRK,R1       ;POINT TO ERROR TRACKING TABLE
        TST     STAT            ;WAS IT ONLY A CACHE ERROR?
        BGT     14$             ;IF GT YES
        BEQ     11$             ;

        .IFTF

;
; CLEAR ALL PARITY REGISTERS AND REENABLE FOR PARITY ERRORS
;

        CALL    $CLPAR          ;RESET ALL PARITY CSR'S

;
; FREEZE CURRENT TASK IN MEMORY AND THEN ABORT TASK
;

        MOV     $TKTCB,R1       ;GET TCB ADDRESS OF CURRENT TASK
        BIS     #T2.FXD,T.ST2(R1) ;FIX TASK IN MEMORY
        BIC     #T3.REM,T.ST3(R1) ;CLEAR REMOVE ON EXIT BIT


        .IF DF  D$$SHF

        MOV     T.PCB(R1),R0    ;GET ADDRESS OF TASK PCB
        BIT     #PS.SYS,P.STAT(R0) ;SYSTEM CONTROLLED PARTITION?
        BEQ     11$             ;IF EQ NO
        BIS     #PS.NSF,P.STAT(R0) ;FREEZE PARTITION FOR SHUFFLER

        .ENDC


11$:    MOV     #S.PRTY,R0      ;SET REASON FOR ABORT
        CALL    $ABTSK          ;ABORT TASK

        .IFT

        BR      16$             ;

;
; PDP-11/70 CACHE TRAP
;

12$:    MOV     $TTNS-4,-(R1)   ;;;SAVE TIME OF LAST ERROR
13$:    TST     (R1)+           ;;;POINT TO NEXT GROUP
14$:    MOVB    (R1)+,R0        ;;;GET CACHE DISABLE BITS
        BEQ     16$             ;;;IF EQ END OF TABLE
        BITB    (R1)+,STAT      ;;;ERROR IN THIS GROUP?
        BEQ     13$             ;;;IF EQ NO
        CMP     (R1)+,$TTNS-4   ;;;OCCUR IN SAME MINUTE?
        BNE     12$             ;;;IF NE NO
        BIS     R0,$MPCTL       ;;;DISABLE THAT PART OF CACHE
        BR      14$             ;;;PROCESS NEXT GROUP
16$:    MOV     $MPCTL,@$MPCSR+6 ;RELOAD 11/70 PARTIY CSR
        CALL    MECLR           ;CLEAR MEMORY ERROR REGISTER            ;MSH018

        .ENDC


;
; AT THIS POINT EVERYTHING HAS BEEN CLEANED UP AND THE USER MAY
; INSERT CODE SPECIFIC TO HIS APPLICATION.
;
;***************
; INSERT CODE HERE-ALL REGISTERS ARE AVAILABLE
;***************
;
; EXIT SYSTEM
;

        DEC     PARLV           ;RESET RECURSION LEVEL
        RETURN                  ;EXIT FROM TRAP

;
; PARITY ERROR OCCURED WHILE IN EXEC CODE. THIS IS A FATAL SITUATION
; AND THE SYSTEM IS SHUT DOWN. THE USER MAY INSERT CODE SPECIFIC
; TO HIS APPLICATION AT THIS POINT.
;

20$:                            ;;;REF LABEL

;;;***************
;;; INSERT CODE HERE-ALL REGISTERS HAVE NOT BEEN SAVED
;;;***************

        MOV     #60$,@#4        ;;;PLUG NONEX MEMORY VECTOR
        MOV     R0,-(SP)        ;;;SAVE R0
        MOV     #EXMSG,R0       ;;;GET ADDRESS OF PARITY STOP MESSAGE
30$:    MOVB    (R0)+,TPS+2     ;;;OUTPUT NEXT BYTE
        BEQ     50$             ;;;IF EQ DONE
40$:    TSTB    TPS             ;;;OUTPUT DONE?
        BPL     40$             ;;;IF PL NO
        BR      30$             ;;;GO AGAIN
50$:    MOV     (SP)+,R0        ;;;RESTORE R0
60$:    HALT                    ;;;HALT SYSTEM
        BR      60$             ;;;IF CONTINUED HALT AGAIN
        .DSABL  LSB

;+
; **-$CLPAR-CLEAR PARITY REGISTERS
;
; THIS ROUTINE CLEARS OUT ALL PARITY ERRORS IN THE MEMORY PARITY ERROR
; REGISTERS AND ENABLES PARITY ERROR NOTIFICATION.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       NONE.
;
;       NOTE:   IF THE SYMBOL M$$K11 IS DEFINED (11/70 TYPE ECC MEMORY),
;               THIS ROUTINE WILL NOT PROPERLY HANDLE UNIBUS ECC MEMORY
;               (SUCH AS MF11S-K) SINCE THE ROUTINE ASSUMES THAT ANY
;               OTHER MEMORY ON THE SYSTEM MUST BE PARITY MEMORY AND
;               THAT AN ATTEMPT TO SET THE SINGLE-BIT ECC ERROR BIT ON
;               SUCH A MEMORY WILL FAIL.  THIS ASSUMPTION IS USED TO
;               DISTINGUISH MK11 ECC MEMORY FROM PARITY MEMORY.
;-

$CLPAR::MOV     #$PARTB+2,R0    ;POINT TO PARITY CSR VECTOR
10$:                            ;REF LABEL


        .IF DF  M$$K11

        TST     (R0)            ;EVEN WORD CSR PRESENT?
        BPL     20$             ;IF PL NO
        MOV     #21,@(R0)+      ;SET ENABLE AND SINGLE-BIT ECC ERROR    ; CS038
        BIT     #20,@-(R0)      ;SINGLE-BIT ECC ERROR BIT SET (MK11)?   ; CS038
        BEQ     20$             ;IF EQ NO                               ;**-2
        MOV     #1,@(R0)+       ;SET ENABLE BIT AND CLR REST IN 1ST WORD
        BIC     #100000,@(R0)+  ;CLEAR ERROR BIT IN SECOND WORD
        BR      30$             ;
20$:    MOV     #1,@(R0)+       ;ENABLE PARITY ERROR NOTIFICATION

        .ENDC


        MOV     #1,@(R0)+       ;ENABLE PARITY (OR UNIBUS MEM ECC) NOTIF
30$:    CMP     R0,#$PARTB+2+<16.*2> ;DONE YET?
        BLO     10$             ;IF LO NO
                                                                        ;MSH018
        .IF DF P$$D70                                                   ;MSH018
                                                                        ;MSH018
MECLR:  MOV     @$MPCSR+4,-(SP) ;CLEAR MEMORY SYSTEM ERROR REGISTER     ;MSH018
        MOV     (SP)+,@$MPCSR+4                                         ;MSH018
                                                                        ;MSH018
        .ENDC                                                           ;MSH018
                                                                        ;MSH018
        RETURN                  ;
        .ENDC


        .END
        .TITLE  PLSUB
        .IDENT  /00/
 
;
; COPYRIGHT (C) 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 00
;
; T. J. MILLER 8-MAR-76
;
; PROGRAM LOGICAL ADDRESS SPACE (PLAS) COMMON SUBROUTINES
;
; MACRO LIBRARY CALLS
;
 
 
        .IF DF  P$$LAS
 
        .MCALL  HDRDF$,HWDDF$,PCBDF$,TCBDF$
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
 
;+
; **-$SRNAM-SEARCH FOR NAMED PARTITION
;
; THIS ROUTINE SEARCHES FOR A NAMED PARTITION AND RETURNS A SUCCESS/
; FAILURE INDICATION AND A POINTER TO THE PCB IF FOUND.
;
; INPUTS:
;
;       R3=POINTER TO DOUBLE-WORD RAD50 NAME
;
; OUTPUTS:
;
;       C=1 IF NO MATCH ON NAME
;
;       C=0 IF NAMED PARTITION FOUND
;               R2=PCB ADDRESS
;-
 
$SRNAM::MOV     $PARHD,R2       ;POINT TO FIRST PCB IN THE LIST
10$:    CMP     P.NAM(R2),(R3)  ;MATCH ON FIRST WORD OF NAME?
        BNE     20$             ;IF NE NO
        CMP     P.NAM+2(R2),2(R3) ;MATCH ON SECOND WORD OF NAME?
        BEQ     50$             ;IF EQ YES
20$:                            ;REF LABEL
 
 
        .IF DF  D$$YNM&M$$MGE
 
        BIT     #PS.SYS,P.STAT(R2) ;SYSTEM CONTROLLED PARTITION?
        BEQ     40$             ;IF EQ NO
        TST     P.SUB(R2)       ;IS THERE ANOTHER SUBPARTITION?
        BEQ     30$             ;IF EQ NO
        MOV     P.SUB(R2),R2    ;POINT TO NEXT SYS SUBPARTITION
        BR      10$             ;
30$:    MOV     P.MAIN(R2),R2   ;POINT BACK TO MAIN PCB
 
        .ENDC
 
 
40$:    MOV     (R2),R2         ;POINT TO NEXT PCB (P.LNK)
        BNE     10$             ;IF NE THERE IS ONE
        SEC                     ;RETURN C=1
50$:    RETURN                  ;
 
;+
; **-$CKACC-CHECK DESIRED ACCESS
;
; THIS ROUTINE CHECKS IF THE DESIRED ACCESS OF A TASK TO A REGION
; IS ALLOWED.  THE BITS IN THE PROTECTION WORD ARE ARRANGED IN THE
; FOLLOWING ORDER:
;
;       [WORLD,GROUP,OWNER,SYSTEM]
;        15                     0
;
; THE BITS WITHIN EACH CATEGORY IN THE PROTECTION WORD ARE ARRANGED
; IN THE FOLLOWING ORDER:
;
;       DELETE  EXTEND  WRITE  READ
;       3       2       1      0
;
; A BIT SET MEANS THE CORRESPONDING ACCESS IS NOT ALLOWED.
;
; INPUTS:
;
;       R0=DESIRED ACCESS MASK IN LOW FOUR BITS
;       R1=CURRENT UIC OF TASK
;       R2=PCB ADDRESS OF REGION
;
; OUTPUTS:
;
;       R0,R1 ARE MODIFIED
;
;       DIRECTIVE STATUS OF D.RS16 RETURNED IF ACCESS DENIED.
;-
 
$CKACC::MOV     #30$,-(SP)      ;PUSH COROUTINE ADDRESS
        BIC     #^C17,R0        ;CLEAR ALL BUT DESIRED ACCESS MASK
10$:    SWAB    R1              ;REVERSE GROUP AND OWNER IN UIC WORD
        CALL    @(SP)+          ;CHECK IF QUALIFIED IN NEXT CATEGORY
        BNE     20$             ;IF NE NO
        BIT     R0,P.PRO(R2)    ;ALLOWED ACCESS IN THIS CATEGORY?
        BNE     20$             ;IF NE NO
        TST     (SP)+           ;POP COROUTINE ADDRESS
        RETURN                  ;RETURN TO CALLER
20$:    ASL     R0              ;SHIFT MASK TO NEXT CATEGORY
        ASL     R0              ;
        ASL     R0              ;
        ASL     R0              ;
        BR      10$             ;CHECK ACCESS IN THIS CATEGORY
30$:    CMPB    R1,#10          ;SYSTEM UIC?
        BHI     40$             ;IF HI NO
        SEZ                     ;SET FLAG FOR ACCESS CHECK
40$:    CALL    @(SP)+          ;CHECK ACCESS AND SHIFT MASK
        CMP     R1,P.OWN(R2)    ;OWNER UIC?
        CALL    @(SP)+          ;CHECK ACCESS AND SHIFT MASK
        CMPB    R1,P.OWN+1(R2)  ;SAME GROUP?
        CALL    @(SP)+          ;CHECK ACCESS AND SHIFT MASK
        SEZ                     ;INSURE CHECK FOR WORLD ACCESS
        CALL    @(SP)+          ;CHECK ACCESS
        DRSTS   D.RS16          ;ACCESS DENIED IF WE GET HERE
 
;+
; **-$CRATT-CREATE ATTACHMENT DESCRIPTOR
;
; THIS ROUTINE CREATES AN ATTACHMENT DESCRIPTOR AND INSERTS IT IN THE
; NECESSARY QUEUES.
;
; INPUTS:
;
;       R2=PCB ADDRESS OF REGION BEING ATTACHED TO
;       R4=ACCESS CODE
;       R5=TCB ADDRESS OF ATTACHING TASK
;
; OUTPUTS:
;
;       C=0 IF SUCCESSFUL
;               R1=ADDRESS OF ATTACHMENT DESCRIPTOR
;               R0 IS MODIFIED
;       C=1 IF AN ATTACHMENT DESCRIPTOR COULD NOT BE ALLOCATED
;               R0,R1 ARE MODIFIED
;-
 
$CRATT::MOV     R3,-(SP)        ;SAVE R3
        MOV     R2,-(SP)        ;SAVE PCB ADDRESS
        MOV     #A.LGTH,R1      ;PICK UP ATTACHMENT DESCRIPTOR SIZE
        CALL    $ALOCB          ;ALLOCATE THE ATTACHMENT DESCRIPTOR
        BCS     10$             ;IF CS ALLOCATION FAILURE
        ADD     R0,R1           ;POINT PAST END OF ATTACHMENT DESCRIPTOR
        MOV     (SP),-(R1)      ;SET PCB ADDRESS (A.PCB)
        MOV     R4,-(R1)        ;INIT STATUS AND MAP COUNT (A.STS)
        BIC     #^C17,(R1)      ;CLEAR ALL BUT ACCESS BITS (A.STS)
        TST     -(R1)           ;POINT TO TCBL THREAD WORD (A.TCBL)
        MOV     R5,R0           ;POINT TO TCB ATTACHMENT LISTHEAD
        ADD     #T.ATT,R0       ;
        CALL    $QINSF          ;INSERT DESCRIPTOR AT END OF QUEUE
        MOV     R5,-(R1)        ;SET TCB ADDRESS (A.TCB)
        CLRB    -(R1)           ;ZERO I/O COUNT (A.IOC)
        MOVB    T.PRI(R5),-(R1) ;INIT PRIORITY TO TASK PRIORITY (A.PRI)
        TST     -(R1)           ;POINT TO PCBL THREAD (A.PCBL)
        MOV     (SP),R0         ;POINT TO PCB ATTACHMENT LISTHEAD
        ADD     #P.ATT,R0       ;
        CALL    $QINSP          ;INSERT IN QUEUE BY PRIORITY
        CLC                     ;INDICATE SUCCESS
10$:    MOV     (SP)+,R2        ;RESTORE PCB ADDRESS
        MOV     (SP)+,R3        ;RESTORE R3
        RETURN                  ;
 
;+
; **-$SRATT-SEARCH FOR ATTACHMENT DESCRIPTOR
;
; THIS ROUTINE VERFIES IF A VALID REGION ID WAS PASSED IN A PLAS DIRECTIVE
; BY SEARCHING FOR THE CORRESPONDING ATTACHMENT DESCRIPTOR IN THE TCB'S
; ATTACHMENT QUEUE.
;
; INPUTS:
;
;       (R3)=REGION ID TO VERIFY (OR 0 TO IMPLY TASK REGION)
;       R5=TCB ADDRESS OF CURRENT TASK
;
; OUTPUTS:
;
;       R5=ADDRESS OF ATTACHMENT DESCRIPTOR
;
;       D.RS86 IS RETURNED IF THE ATTACHMENT DESCRIPTOR CANNOT BE FOUND.
;-
 
$SRATT::MOV     T.ATT(R5),R5    ;POINT TO FIRST ATTACHMENT DESCRIPTOR
        MOV     (R3),-(SP)      ;DEFAULT TO TASK REGION?
        BEQ     20$             ;IF EQ YES
        ADD     #A.TCBL,(SP)    ;ADD BIAS TO LINK WORD
10$:    CMP     R5,(SP)         ;MATCH ON THIS DESCRIPTOR?
        BEQ     20$             ;IF EQ YES
        MOV     (R5),R5         ;ELSE POINT TO NEXT DESCRIPTOR (A.TCBL)
        BNE     10$             ;IF NE THERE IS ONE
        DRSTS   D.RS86          ;INVALID REGION ID
20$:    SUB     #A.TCBL,R5      ;POINT TO START OF ATTACHMENT DESCRIPTOR
        TST     (SP)+           ;CLEAN STACK
        RETURN                  ;
 
;+
; **-$SRWND-SEARCH FOR SPECIFIED ADDRESS WINDOW
;
; THIS ROUTINE VERIFIES THAT THE SPECIFIED ADDRESS WINDOW ID CORRESPONDS
; TO A VALID ESTABLISHED ADDRESS WINDOW.
;
; INPUTS:
;
;       (R3)=ADDRESS WINDOW ID
;       R4=ADDRESS OF CURRENT TASK HEADER
;
; OUTPUTS:
;
;       R4=POINTER TO SPECIFIED WINDOW BLOCK
;       R0 IS MODIFIED.
;
;       D.RS87 IS RETURNED IF THE SPECIFIED ADDRESS WINDOW IS INVALID
;-
 
$SRWND::MOV     H.WND(R4),R4    ;POINT TO NUMBER OF WINDOWS
        MOVB    (R3),R0         ;PICK UP ADDRESS WINDOW ID (W.NID)
        BEQ     10$             ;IF EQ ILLEGAL
        CMP     R0,(R4)+        ;WINDOW ID TOO LARGE?
        BHIS    10$             ;IF HIS YES
        ASL     R0              ;CONVERT WINDOW ID TO 8 WORD OFFSET
        ASL     R0              ;
        ASL     R0              ;
        ASL     R0              ;
        ADD     R0,R4           ;POINT TO ADDRESS WINDOW
        TST     W.BSIZ(R4)      ;IS IT AN ESTABLISHED ADDRESS WINDOW?
        BEQ     10$             ;IF EQ NO
        RETURN                  ;
10$:    DRSTS   D.RS87          ;INVALID ADDRESS WINDOW
 
;+
; **-$UNMAP-UNMAP ADDRESS WINDOW
;
; THIS ROUTINE SEARCHES FOR AND CONDITIONALLY UNMAPS THE SPECIFIED
; ADDRESS WINDOW.
;
; INPUTS:
;
;       R4=ADDRESS OF WINDOW TO BE UNMAPPED
;
; OUTPUTS:
;
;       R0 IS MODIFIED
;
;       C=1 IF UNMAPPING WAS PERFORMED
;-
 
        .ENABL  LSB
$UNMAP::TST     (R4)            ;IS WINDOW MAPPED? (W.BPCB)
        BEQ     20$             ;IF EQ IT IS NOT MAPPED
        MOV     R1,-(SP)        ;SAVE R1
        CLR     (R4)            ;UNMAP ADDRESS WINDOW (W.BPCB)
        MOV     W.BATT(R4),R0   ;PICK UP ADDRESS OF ATTACHMENT DESCRIPTOR
        CLR     W.BATT(R4)      ;CLEAR ATTACHMENT DESCRIPTOR POINTER
        DECB    A.MPCT(R0)      ;DECREMENT MAPPING COUNT
        MOV     A.TCB(R0),R1    ;POINT TO TASK TCB ADDRESS
        MOVB    W.BFPD(R4),R0   ;POINT TO FIRST USER PDR
10$:    BIT     #T3.PRV,T.ST3(R1) ;IS THE TASK PRIVILEGED?
        BEQ     14$             ;IF EQ NO
        MOV     KISAR0-UISDR0(R0),UISAR0-UISDR0(R0) ;RESTORE PRV MAPPING
        MOV     #77406,(R0)+    ;
        BR      15$             ;
14$:    CLR     (R0)+           ;CLEAR NEXT USER PDR
15$:    DECB    W.BNPD(R4)      ;DONE YET?
        BGT     10$             ;IF GT NO
        MOV     (SP)+,R1        ;RESTORE R1
        SEC                     ;RETURN CS FOR WINDOW UNMAPPED
20$:    RETURN                  ;
 
        .ENDC
 
 
        .END
        .TITLE  POWER
        .IDENT  /08.04/
 
;
;COPYRIGHT (C)   1974,1978,1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 08.04
;
; D. N. CUTLER 1-OCT-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 1-JUL-77
;
;               TM093 -- FIX BUG IN POWERFAIL SUPPORT FOR 11/34 AND
;                       11/60 PROCESSORS WITH FLOATING POINT SUPPORT.
;
;               TM094 -- QUEUE AN ERROR MESSAGE BLOCK TO THE ERROR
;                       LOGGER ON POWERFAIL.
;
;       T. J. MILLER 14-SEP-77
;
;               TM101 -- CHANGE TO NOT ATTEMPT TO QUEUE A POWERFAIL AST
;                       TO NULL TASK.
;
;               TM104 -- SAVE PIRQ REGISTER IF IT EXISTS FOR FLOATING
;                       POINT SUPPORT.
;
;               TM105 -- ADDITION OF CALL TO USER-WRITTEN ROUTINE AT
;                       POWER DOWN TRAP.
;
;               TM108 -- CALL COMMON ROUTINE TO CLEAR MEMORY PARITY CSR'S.
;
;       T. J. MILLER 2-NOV-77
;
;               TM103 -- USE NEW LITERAL TO RENABLE CLOCK.
;
;       CHUCK SPITZ 31-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES AND USE TCB FOR ALL
;                       AST LISTHEADS.
;
;       M. S. HARVEY    21-FEB-79
;               MSH026 -- GET POWER-DOWN ROUTINE FOR IPDRV IF THAT
;                         DRIVER IS LOADABLE
;
;       R.R.ADAMS     13-APR-79
;               RA019 -- BUG FIX CALL THE ENTRY IN ERROR.MAC THAT
;                        DOES NOT INCREMENT ERROR SEQ NO. ON POWER FAIL
;
;       M. S. HARVEY    8-MAY-79
;               MSH018 -- PRESERVE CACHE FORCE MISS BITS
;
;       CHUCK SPITZ     15-MAY-79
;               CS051 -- HANDLE KW11-L ON LSI-11
; POWERFAIL RECOVERY
;
; MACRO LIBRARY CALLS
;

        .MCALL  EMBDF$,HDRDF$,HWDDF$,PCBDF$,TCBDF$
        EMBDF$                  ;DEFINE ERROR MESSAGE BLOCK OFFSETS
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;
; LOCAL DATA
;
; VOLATILE REGISTER STORAGE
;


        .IF DF  P$$RFL

PWBTM:  .BLKW   7               ;R0 THRU R5 AND SP


        .IF DF  M$$MGE


        .IF DF  M$$EXT

        .BLKW   <31.-5.>*2      ;UNIBUS MAPPING REGISTERS

        .ENDC


        .BLKW   25.             ;MEMORY MANAGEMENT REGISTERS

        .IFF


        .IF DF  E$$EAE

        .BLKW   3               ;EAE REGISTERS

        .ENDC


        .ENDC


        .IF DF  F$$LPP

        .BLKW   27.             ;FLOATING POINT REGISTERS

        .ENDC


PWSTK=.-2                       ;REF LABEL

;
; POWERFAIL VECTOR
;

        .IFTF

        .ASECT
.=24
PWVCT:  .WORD   PDOWN           ;
        .WORD   PR7             ;
        .PSECT

;+
; **-PDOWN-POWERFAIL INTERRUPT (DOWN)
;
; THIS ROUTINE IS ENTERED AS A RESULT OF A POWER DOWN INTERRUPT. ALL
; VOLATILE MACHINE REGISTERS ARE SAVED, THE POWERFAIL VECTOR IS SWITCHED
; TO THE POWER UP ROUTINE, AND THE PROCESSOR IS HALTED TO AWAIT THE
; POWER UP INTERRUPT.
;-

PDOWN:                          ;REF LABEL

        .IFT

        MOV     SP,PWSTK        ;;;SAVE CURRENT STACK POINTER
        MOV     #PWSTK,SP       ;;;SET ADDRESS OF REGISTER SAVE AREA
        MOV     R5,-(SP)        ;;;SAVE REGISTERS R5 THRU R0
        MOV     R4,-(SP)        ;;;
        MOV     R3,-(SP)        ;;;
        MOV     R2,-(SP)        ;;;
        MOV     R1,-(SP)        ;;;
        MOV     R0,-(SP)        ;;;


        .IF DF  M$$MGE


        .IF DF  M$$EXT

        MOV     #UBMPR+<31.*4>,R0 ;;;POINT PAST LAST MAP REGISTER
        MOV     #31.-5.,R1      ;;;SET COUNT OF REGISTERS TO SAVE
20$:    MOV     -(R0),-(SP)     ;;;SAVE HIGH 6 BITS OF ADDRESS
        MOV     -(R0),-(SP)     ;;;SAVE LOW 16 BITS OF ADDRESS
        DEC     R1              ;;;ANY MORE TO SAVE?
        BGT     20$             ;;;IF GT YES

        .ENDC



        BIS     #PMODE,PS       ;;;MAKE SURE PREVIOUS MODE IS USER
        MFPI    SP              ;;;SAVE USER STACK POINTER
        MOV     #KISAR0+16.,R0  ;;;POINT TO KERNEL ADDRESS REGISTER 7+2
        MOV     #UISAR0+16.,R1  ;;;POINT TO USER ADDRESS REGISTER 7+2
        MOV     #UISDR0+16.,R2  ;;;POINT TO USER DESCRIPTOR REGISTER 7+2
        MOV     #8.,R3          ;;;SET LOOP COUNT
10$:    MOV     -(R0),-(SP)     ;;;SAVE KERNEL ADDRESS REGISTER
        MOV     -(R1),-(SP)     ;;;SAVE USER ADDRESS REGISTER
        MOV     -(R2),-(SP)     ;;;SAVE USER DESCRIPTOR REGISTER
        DEC     R3              ;;;ANYMORE TO SAVE?
        BGT     10$             ;;;IF GT YES

        .IFF


        .IF DF  E$$EAE

        MOV     SC,-(SP)        ;;;SAVE EAE SHIFT COUNT
        MOV     AC,-(SP)        ;;;SAVE EAE ACCUMULATOR
        MOV     MQ,-(SP)        ;;;SAVE EAE MULTIPLIER-QUOTIENT

        .ENDC


        .ENDC


        .IF DF  F$$LPP

        STFPS   -(SP)           ;;;STORE FLOATING POINT STATUS
        SETD                    ;;;SET FLOATING DOUBLE MODE
        STD     R0,-(SP)        ;;;SAVE FLOATING POINT REGISTERS
        STD     R1,-(SP)        ;;;
        STD     R2,-(SP)        ;;;
        STD     R3,-(SP)        ;;;
        LDD     R4,R0           ;;;
        STD     R0,-(SP)        ;;;
        LDD     R5,R0           ;;;
        STD     R0,-(SP)        ;;;
        CLR     -(SP)           ;;;PUSH AN ADDRESS OF ZERO
        CMP     @#244,#$FPPR7   ;;;IS THERE A PIRQ REGISTER TO SAVE?
        BEQ     30$             ;;;IF EQ NO, DO DUMMY SAVE OF LOCATION 0
        MOV     #PIRQ,(SP)      ;;;SET FOR SAVE OF PIRQ
30$:    MOV     @(SP),-(SP)     ;;;SAVE PIRQ REGISTER OR CONTENTS OF 0

        .ENDC


        MOV     #PUP,PWVCT      ;;;SWITCH TO POWER UP ROUTINE

        .IFTF


        .IF DF  I$$PPF

        .IF DF LD$IP                                                    ;MSH026
                                                                        ;MSH026
        MOV     #.IP0,R0        ;;;GET IP UCB                           ;MSH026
        MOV     (R0),R0         ;;;GET IP DCB                           ;MSH026
        MOV     D.DSP(R0),R1    ;;;GET IP DRIVER DISPATCH TABLE         ;MSH026
        BEQ     40$             ;;;DRIVER NOT LOADED OR RESIDENT        ;MSH026
        MOV     D.PCB(R0),R0    ;;;GET IPDRV PCB                        ;MSH026
        BEQ     40$             ;;;IF EQ, DRIVER RESIDENT (LD$IP ?)     ;MSH026
        MOV     P.REL(R0),KISAR5 ;;;MAP IPDRV                           ;MSH026
        MOV     D.VINI-2(R1),SP ;;;GET POWER-DOWN ENTRY POINT           ;MSH026
        CALL    (SP)            ;;;CALL DRIVER                          ;MSH026
40$:                                                                    ;MSH026
        .IFF                                                            ;MSH026
                                                                        ;MSH026
        MOV     #$PCSPF,SP      ;;;SET STACK POINTER
        CALL    (SP)            ;;;CALL USER POWER FAIL ROUTINE
                                                                        ;MSH026
        .ENDC                                                           ;MSH026

        .ENDC


        HALT                    ;;;WAIT FOR SOME JUICE!

        .IFT

;+
; **-PUP-POWERFAIL INTERRUPT (UP)
;
; THIS ROUTINE IS ENTERED AS A RESULT OF A POWER UP INTERRUPT. ALL VOLATILE
; MACHINE REGISTERS ARE RESTORED, A SCHEDULE REQUEST IS FORCED FOR THE
; NULL TASK, THE POWERFAIL INDICATOR IS INCREMENTED, AND AN RTI IS
; EXECUTED. AT THE APPROPRIATE TIME THE DISPATCHER WILL CALL THE POWER
; RECOVERY ROUTINE TO ACTUALLY PROCESS THE POWER FAILURE.
;-

PUP:    MOV     #PWBTM,SP       ;;;POINT TO LAST REGISTER SAVED


        .IF DF  F$$LPP

        MOV     (SP)+,@(SP)+    ;;;CONDITIONALLY RESTORE PIRQ OR LOC. 0
        SETD                    ;;;SET FLOATING DOUBLE MODE
        LDD     (SP)+,R0        ;;;RESTORE FLOATING POINT REGISTERS
        STD     R0,R5           ;;;
        LDD     (SP)+,R0        ;;;
        STD     R0,R4           ;;;
        LDD     (SP)+,R3        ;;;
        LDD     (SP)+,R2        ;;;
        LDD     (SP)+,R1        ;;;
        LDD     (SP)+,R0        ;;;
        LDFPS   (SP)+           ;;;RESTORE FLOATING POINT STATUS

        .ENDC


        .IF DF  M$$MGE

        BIS     #PMODE,PS       ;;;SET PREVIOUS MODE TO USER
        MOV     #KISAR0,R0      ;;;POINT TO KERNEL ADDRESS REGISTER 0
        MOV     #KISDR0,R1      ;;;POINT TO KERNEL DESCRIPTOR REGISTER 0
        MOV     #UISAR0,R2      ;;;POINT TO USER ADDRESS REGISTER 0
        MOV     #UISDR0,R3      ;;;POINT TO USER DESCRIPTOR REGISTER 0
        MOV     #8.,R4          ;;;SET LOOP COUNT
10$:    MOV     (SP)+,(R3)+     ;;;RESTORE USER DESCRIPTOR REGISTER
        MOV     (SP)+,(R2)+     ;;;RESTORE USER ADDRESS REGISTER
        MOV     #77406,(R1)+    ;;;RESTORE KERNEL DESCRIPTOR REGISTER
        MOV     (SP)+,(R0)+     ;;;RESTORE KERNEL ADDRESS REGISTER
        DEC     R4              ;;;ANY MORE TO RESTORE?
        BGT     10$             ;;;IF GT YES
        INC     SR0             ;;;TURN ON MEMORY MANAGEMENT
        MTPI    SP              ;;;RESTORE USER STACK POINTER


        .IF DF  M$$EXT

        MOV     #UBMPR,R0       ;;;POINT TO FIRST MAP REGISTER
        MOV     #5.,R1          ;;;SET COUNT OF EXEC REGISTERS
        CLR     R2              ;;;CLEAR STARTING ADDRESS
20$:    MOV     R2,(R0)+        ;;;LOAD LOW 16 BITS OF ADDRESS
        CLR     (R0)+           ;;;CLEAR HIGH 6 BITS OF ADDRESS
        ADD     #20000,R2       ;;;ADVANCE 8K BYTES
        DEC     R1              ;;;ANY MORE TO LOAD?
        BGT     20$             ;;;IF GT YES
        MOV     #31.-5.,R1      ;;;SET COUNT OF REGISTERS
30$:    MOV     (SP)+,(R0)+     ;;;RESTORE LOW 16 BITS OF ADDRESS
        MOV     (SP)+,(R0)+     ;;;RESTORE HIGH 6 BITS OF ADDRESS
        DEC     R1              ;;;ANY MORE REGISTERS
        BGT     30$             ;;;IF GT YES
        MOV     #60,SR3         ;;;ENABLE 22 BIT AND UNIBUS MAP

        .ENDC


        .IFF


        .IF DF  E$$EAE

        MOV     (SP)+,MQ        ;;;RESTORE EAE MULTIPLIER-QUOTIENT
        MOV     (SP)+,AC        ;;;RESTORE EAE ACCUMULATOR
        MOV     (SP)+,SC        ;;;RESTORE EAE SHIFT COUNT

        .ENDC


        .ENDC


        MOV     (SP)+,R0        ;;;RESTORE R0 THRU R5
        MOV     (SP)+,R1        ;;;
        MOV     (SP)+,R2        ;;;
        MOV     (SP)+,R3        ;;;
        MOV     (SP)+,R4        ;;;
        MOV     (SP)+,R5        ;;;
        MOV     (SP),SP         ;;;RESTORE STACK POINTER
        INC     $PWRFL          ;;;INDICATE A POWER FAILURE HAS OCCURED
        MOV     #$HEADR,$RQSCH  ;;;FORCE REDISPATCHING
        MOV     #PDOWN,PWVCT    ;;;SWITCH TO POWER DOWN ROUTINE
        MOV     #40$,-(SP)      ;;;GIVE A RETURN ADDRESS FOR $SGFIN     ; CS051
        CALL    $SGFIN          ;;;PLUG VECTORS (IF NO CLOCK)           ; CS051
        MOV     $CKLDC,@$CKCNT  ;;;RELOAD CLOCK COUNT REGISTER          ;**-4
        MOV     #K$$IEN,@$CKCSR ;;;TURN CLOCK BACK ON
        RETURN                  ;;;RETURN TO $SGFIN, WHICH WILL RETURN T; CS051
40$:    RTI                     ;;;                                     ; CS051
                                                                        ;**-5
;+
; **-$POWER-POWER FAIL RECOVERY
;
;-

        .IFTF

        .ENABL  LSB

$POWER::CLR     $PWRFL          ;CLEAR FAILURE INDICATOR
        CALL    $DRDSE          ;DECLARE A SIGNIFICANT EVENT


        .IF DF  K$$W11

        CLR     K$$W11+2        ;CLEAR CLOCK ERROR FLAGS
        MOV     #1,K$$W11+6     ;ENERGIZE OUTPUT RELAY

        .ENDC


        .IF DF  P$$RTY

        CALL    $CLPAR          ;CLEAR MEMORY PARITY CSR'S
        MOV     $MPCSR+6,R0     ;PICK UP 11/70 CACHE CSR REGISTER


        .IF DF  P$$D70

        BIC     #^C<14>,(R0)    ;PRESERVE FORCE MISS BITS               ;MSH018
        MOV     (R0),$MPCTL     ;SAVE 11/70 PARITY CONTROL REGISTER     ;MSH018
                                                                        ;**-2
        .IFF

        MOV     #3,(R0) ;DISABLE TRAPS

        .ENDC


        MOV     #177777,-(R0)   ;CLEAR MEMORY ERROR REGISTER

        .ENDC


        .IF DF  E$$DVC!E$$NSI!E$$PER

        MOV     #E.SEQ+4,R1     ;SET SIZE OF EMB TO ALLOCATE
        MOV     #EC.PWR,-(SP)   ;PUSH POWERFAIL CODE
        CALL    $ALEB1  ;ALLOCATE A POWERFAIL EMB                       ;RA019
        BCS     6$              ;IF CS COULD NOT ALLOCATE               ;**-1
        CALL    $QEMB           ;QUEUE THE EMB FOR THE ERROR LOGGER
6$:                             ;REF LABEL

        .ENDC


;
; EFFECT POWERFAIL AST'S FOR TASKS THAT ARE ACTIVE AND IN CORE
;

        .IFT


        .IF DF  A$$TRP

        MOV     $ACTHD,R5       ;GET ADDRESS OF FIRST TCB
10$:    MOV     #AS.PFA,R4      ;SET  POWERFAIL TYPE AST                ; CS017
        MOV     T.ACTL(R5),-(SP) ;SAVE POINTER TO NEXT ACTIVE TASK      ;**-1
        BEQ     15$             ;IF EQ THERE IS NONE
        CALL    $DASTT          ;DECLARE POWERFAIL AST
15$:    MOV     (SP)+,R5        ;GET ADDRESS OF NEXT ACTIVE TASK
        BNE     10$             ;IF NE NO

        .ENDC


;
; DO POWERFAIL RECOVERY FOR ALL ACTIVE DEVICES
;

        .IFTF

20$:    MOV     #$SCDVT,-(SP)   ;SET ADDRESS OF DEVICE TABLE SCANNING CO-ROUTINE
30$:    CALL    @(SP)+          ;GET NEXT UCB ADDRESS
        BCC     40$             ;IF CC GOT ONE
        RETURN                  ;
40$:    BITB    #US.OFL,U.ST2(R5) ;DEVICE IN CONFIGURATION?
        BNE     30$             ;IF NE NO
        BITB    #UC.PWF,U.CTL(R5) ;CALL DRIVER REGARDLESS OF ACTIVITY?
        BNE     50$             ;IF NE YES
        TSTB    U.STS(R5)       ;IS UNIT ACTIVE?
        BPL     30$             ;IF PL NO
50$:    MOV     D.DSP(R3),R2    ;GET ADDRESS OF DRIVER DISPATCH TABLE
        BEQ     30$             ;IF EQ DRIVER NOT LOADED


        .IF DF  L$$DRV&M$$MGE

$LDPWF::MOV     KISAR5,-(SP)    ;SAVE APR5 (REF LABEL FOR 'LOAD')
        MOV     D.PCB(R3),R3    ;GET DRIVER PCB ADDRESS
        BEQ     55$             ;IF EQ DRIVER IS PART OF EXEC
        MOV     P.REL(R3),KISAR5  ;MAP THE DRIVER
55$:                            ;

        .IFTF

        MOVB    S.CON(R4),R3    ;GET CONTROLLER INDEX

;
; CALL DRIVER AT POWERFAIL ENTRY POINT WITH THE ARGUMENTS:
;
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;

        CALL    @D.VPWF(R2)     ;ENTER DRIVER

        .IFT

        MOV     (SP)+,KISAR5    ;RESTORE APR5

        .ENDC


        BR      30$             ;GO AGAIN

        .ENDC


        .DSABL  LSB


        .END
        .TITLE  PPDRV
        .IDENT  /02.01/
 
;
; COPYRIGHT (C) 1975, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 02.01
;
; THOMAS J. MILLER 25-NOV-74
;
; PREVIOUSLY MODIFIED BY:
;
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       E. L. BAATZ 18-JUN-78
;
;               EB148 -- REMOVE EXPLICIT PS REFERENCE
;
; PC11 PAPER TAPE PUNCH DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$,HWDDF$,PKTDF$,TCBDF$
        ABODF$                  ;DEFINE TASK ABORT CODES
        HWDDF$                  ;DEFINE HARDWARE REGISTER SYMBOLS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;
; EQUATED SYMBOLS
;
; PAPER TAPE PUNCH STATUS WORD BIT DEFINITIONS (U.CW2)
;

WAIT=100000                     ;WAITING FOR DEVICE TO COME ON-LINE (1=YES)
ABORT=40000                     ;ABORT CURRENT I/O REQUEST (1=YES)
TRAIL=200                       ;CURRENTLY PUNCHING TRAILER (1=YES)

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   P$$P11          ;ADDRESS OF UNIT CONTROL BLOCK


        .IF GT  P$$P11-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC


;
; DRIVER DISPATCH TABLE
;

$PPTBL::.WORD   PPINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   PPCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   PPOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   PPPWF           ;POWERFAIL ENTRY POINT

;+
; **-PPINI-PC11 PAPER TAPE PUNCH CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
PPINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     PPPWF           ;IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; PAPER TAPE PUNCH I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.WLB, IO.ATT OR IO.DET).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF I/O BUFFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

        MOV     R5,CNTBL(R3)    ;SAVE UCB POINTER FOR INTERRUPT ROUTINE
        CLR     U.CW2(R5)       ;CLEAR ALL SWITCHES
        CMPB    I.FCN+1(R1),#IO.WLB/256. ;WRITE LOGICAL BLOCK FUNCTION?
        BEQ     10$             ;IF EQ YES
        MOV     I.TCB(R1),R0    ;GET REQUESTOR TCB ADDRESS
        BIT     #T2.ABO,T.ST2(R0) ;TASK BEING ABORTED?
        BNE     65$             ;IF NE YES - DON'T PUNCH TRAILER
        BIS     #TRAIL,U.CW2(R5) ;OTHERWISE FUNCTION IS ATTACH OR DETACH
                                 ;   SET FLAG TO PUNCH TRAILER
        MOV     #170.,U.CNT(R5) ;SET COUNT FOR 170 NULLS
10$:    BIS     #WAIT,U.CW2(R5) ;ASSUME WAIT FOR DEVICE OFF LINE
        TST     @S.CSR(R4)      ;DEVICE OFF LINE?
        BMI     80$             ;IF MI YES
20$:    BIC     #WAIT,U.CW2(R5) ;DEVICE ON LINE, CLEAR WAIT CONDITION
        MOVB    S.ITM(R4),S.CTM(R4) ;SET TIMEOUT COUNT
        MOV     #100,@S.CSR(R4) ;ENABLE INTERRUPTS

;
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE. THIS IS DONE TO AVOID A RACE CONDITION
; THAT COULD EXIST IN RESTARTING THE I/O OPERATION
;

PPPWF:  RETURN                  ;

;+
; **-$PPINT-PC11 PAPER TAPE PUNCH CONTROLLER INTERUPTS
;-

$PPINT::                        ;;;REF LABEL
        INTSV$  PP,PR4,P$$P11   ;;;GENERATE INTERRUPT SAVE CODE
        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF STATUS CONTROL BLOCK
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET TIMEOUT COUNT
        MOV     S.CSR(R4),R4    ;;;POINT R4 TO CONTROL STATUS REGISTER
        MOV     (R4)+,U.CW3(R5) ;;;SAVE STATUS
        BMI     60$             ;;;IF MI, ERROR
        SUB     #1,U.CNT(R5)    ;;;DECREMENT CHARACTER COUNT
        BCS     50$             ;;;IF CS, THEN DONE
        TSTB    U.CW2(R5)       ;;;CURRENTLY PUNCHING TRAILER?
        BPL     30$             ;;;IF PL NO
        CLRB    (R4)            ;;;LOAD NULL INTO OUTPUT REGISTER
        BR      40$             ;;;BRANCH TO LOAD IT
30$:    CALL    $GTBYT          ;;;GET NEXT BYTE FROM USER BUFFER
        MOVB    (SP)+,(R4)      ;;;LOAD BYTE INTO OUTPUT REGISTER
40$:    JMP     $INTXT          ;;;EXIT FROM INTERRUPT
50$:    INC     U.CNT(R5)       ;;;RESET BYTE COUNT
60$:    CLR     -(R4)           ;;;DISABLE PUNCH INTERRUPTS
        CALL    $FORK           ;;;CREATE SYSTEM PROCESS
        MOV     U.SCB(R5),R4    ;POINT R4 TO SCB
        MOV     S.PKT(R4),R1    ;POINT R1 TO I/O PACKET
        MOV     I.PRM+4(R1),R1  ;   AND PICK UP CHARACTER COUNT
        SUB     U.CNT(R5),R1    ;CALCULATE CHARACTERS TRANSFERRED
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        TST     U.CW3(R5)       ;DEVICE ERROR?
        BPL     70$             ;IF PL NO
65$:    MOV     #IE.VER&377,R0  ;UNRECOVERABLE HARDWARE ERROR CODE
70$:    CALL    $IODON          ;INITIATE I/O COMPLETION
        BR      PPINI           ;BRANCH BACK FOR NEXT REQUEST

;
; DEVICE TIMEOUT RESULTS IN A NOT READY MESSAGE BEING PUT OUT 4 TIMES A
; MINUTE. TIMEOUTS ARE CAUSED BY POWERFAILURE AND PUNCH FAULT CONDITIONS.
;

PPOUT:  CLRB    @S.CSR(R4)      ;;;DISABLE PUNCH INTERRUPT
        MTPS    #0              ;;;ALLOW INTERRUPTS                             ; EB148
80$:    MOV     #IE.DNR&377,R0  ;ASSUME DEVICE NOT READY ERROR                  ;**-1
        MOV     U.CW2(R5),R1    ;ARE WE WAITING FOR DEVICE READY?
        BPL     70$             ;IF PL NO, TERMINATE I/O REQUEST
        MOV     #IE.ABO&377,R0  ;ASSUME REQUEST IS TO BE ABORTED
        ASL     R1              ;ABORT REQUEST?
        BMI     70$             ;IF MI YES
        TST     @S.CSR(R4)      ;PUNCH READY?
        BPL     20$             ;IF PL YES
        MOV     #T.NDNR,R0      ;SET FOR NOT READY MESSAGE
        MOVB    #1,S.CTM(R4)    ;SET TIMEOUT FOR 1 SECOND
        DECB    S.STS(R4)       ;TIME TO OUTPUT MESSAGE?
        BNE     PPPWF           ;IF NE NO
        MOVB    #15.,S.STS(R4) ;SET TO OUTPUT NEXT MESSAGE IN 15. SECONDS
        CALLR   $DVMSG          ;OUTPUT MESSAGE
        .DSABL  LSB

;
; CANCEL I/O OPERATION-FORCE I/O TO COMPLETE IF DEVICE IS NOT READY
;

PPCAN:  CMP     R1,I.TCB(R0)    ;;;REQUEST FOR CURRENT TASK?
        BNE     10$             ;;;IF NE NO
        BIS     #ABORT,U.CW2(R5) ;;;SET FOR ABORT IF DEVICE NOT READY
10$:    RETURN                  ;;;

        .END
        .TITLE  PRDRV
        .IDENT  /02.01/
 
;
; COPYRIGHT (C) 1975, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 02.01
;
; THOMAS J. MILLER 2-DEC-74
;
; PREVIOUSLY MODIFIED BY:
;
;       C. A. D'ELIA
;
; MODIFIED BY:
;
;       E. L. BAATZ 18-JUN-78
;
;               EB148 -- REMOVE EXPLICIT PS REFERENCE
;
; PC11/PR11 PAPER TAPE READER DRIVER
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$,HWDDF$,PKTDF$
        ABODF$                  ;DEFINE TASK ABORT CODES
        HWDDF$                  ;DEFINE HARDWARE REGISTER SYMBOLS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS

;
; EQUATED SYMBOLS
;
; PAPER TAPE READER STATUS WORD BIT DEFINITIONS (U.CW2)
;

TRAIL=100000                    ;CURRENTLY READING TRAILER

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER NUMBER)
;

CNTBL:  .BLKW   P$$R11          ;ADDRESS OF UNIT CONTROL BLOCK


        .IF GT  P$$R11-1

TEMP:   .BLKW   1               ;TEMPORARY STORAGE FOR CONTROLLER NUMBER

        .ENDC


;
; DRIVER DISPATCH TABLE
;

$PRTBL::.WORD   PRINI           ;DEVICE INITIATOR ENTRY POINT
        .WORD   PRCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   PROUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   PRPWF           ;POWERFAIL ENTRY POINT

;+
; **-PRINI-PC11/PR11 PAPER TAPE READER CONTROLLER INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-

        .ENABL  LSB
PRINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     PRPWF           ;IF CS CONTROLLER BUSY OR NO REQUEST

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER TO BE INITIATED.
;
; PAPER TAPE READER I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB, IO.ATT OR IO.DET).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF I/O BUFFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;

        MOV     R5,CNTBL(R3)    ;SAVE UCB POINTER FOR INTERRUPT ROUTINE
        MOVB    I.FCN+1(R1),R2  ;MOVE FUNCTION CODE TO R2
        CMPB    R2,#IO.RLB/256. ;READ LOGICAL BLOCK FUNCTION?
        BEQ     10$             ;IF EQ YES
        MOV     #IS.SUC&377,R0  ;OTHER FUNCTIONS ALWAYS SUCCEED
        CLR     R1              ;RETURN 0 IN SECOND WORD OF STATUS BUFFER
        CMPB    R2,#IO.ATT/256. ;ATTACH FUNCTION?
        BNE     50$             ;IF NE NO, CALL $IODON
        BIS     #TRAIL,U.CW2(R5) ;SET FLAG TO READ TRAILER IF ATTACH
        BR      60$             ;CALL $IODON
10$:    MOVB    S.ITM(R4),S.CTM(R4) ;SET TIMEOUT COUNT
        TST     @S.CSR(R4)      ;ERROR BIT SET IN STATUS REGISTER?
        BPL     15$             ;IF PL NO, INITIATE IO
        TST     U.CW2(R5)       ;IS THIS THE FIRST READ FOR ATTACHED PROCESS?
        BMI     70$             ;IF MI YES, RETURN DEVICE NOT READY CODE
                                ;   (OTHERWISE HANDLE AS EOF UPON INTERRUPT)
15$:    MOV     #101,@S.CSR(R4) ;ENABLE READER WITH INTERRUPTS

;
; IN-PROGRESS TRANSFERS ARE NOT TERMINATED.
;

PRCAN:

;
; POWERFAIL IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE CAUSES
; NO IMMEDIATE ACTION ON THE DEVICE. THIS IS DONE TO AVOID A RACE CONDITION
; THAT COULD EXIST IN RESTARTING THE I/O OPERATION
;

PRPWF:  RETURN                  ;

;+
; **-$PRINT-PC11/PR11 PAPER TAPE READER CONTROLLER INTERUPTS
;-

$PRINT::                        ;;;REF LABEL
        INTSV$  PR,PR4,P$$R11   ;;;GENERATE INTERRUPT SAVE CODE
        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF STATUS CONTROL BLOCK
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET TIMEOUT COUNT
        MOV     S.CSR(R4),R4    ;;;POINT R4 TO CONTROL STATUS REGISTER
        MOV     (R4)+,U.CW3(R5) ;;;SAVE STATUS
        BMI     40$             ;;;IF MI, ERROR
        TST     U.CW2(R5)       ;;;READING TRAILER?
        BPL     20$             ;;;IF PL NO
        TSTB    (R4)            ;;;IS BYTE READ A NULL?
        BEQ     30$             ;;;IF EQ YES
        CLR     U.CW2(R5)       ;;;NO LONGER READING TRAILER
20$:    MOVB    (R4),-(SP)      ;;;PUSH BYTE READ
        CALL    $PTBYT          ;;;PLACE IT IN USER BUFFER
        DEC     U.CNT(R5)       ;;;DECREMENT BYTE COUNT
        BEQ     40$             ;;;IF EQ READ COMPLETE
30$:    INC     -(R4)           ;;;ENABLE READER
        JMP     $INTXT          ;;;EXIT FROM INTERRUPT


40$:    CLR     -(R4)           ;;;DISABLE INTERRUPTS
        CALL    $FORK           ;;;CREATE SYSTEM PROCESS
        MOV     U.SCB(R5),R4    ;POINT R4 TO SCB
        MOV     S.PKT(R4),R1    ;POINT R1 TO I/O PACKET
        MOV     I.PRM+4(R1),R1  ;   AND PICK UP CHARACTER COUNT
        SUB     U.CNT(R5),R1    ;CALCULATE CHARACTERS TRANSFERRED
        MOV     #IS.SUC&377,R0  ;ASSUME SUCCESSFUL TRANSFER
        TST     U.CW3(R5)       ;DEVICE ERROR?
        BPL     50$             ;IF PL NO
        MOV     #IE.EOF&377,R0  ;RETURN END OF FILE CODE
50$:    CLR     U.CW2(R5)       ;CLEAR FLAG WORD
60$:    CALL    $IODON          ;INITIATE I/O COMPLETION
        BR      PRINI           ;BRANCH BACK FOR NEXT REQUEST

;
; DEVICE TIMEOUT RESULTS IN THE RETURN OF A DEVICE NOT READY ERROR CODE.
;

PROUT:  CLR     @S.CSR(R4)      ;;;DISABLE READER INTERRUPTS
        MTPS    #0              ;;;ALLOW INTERRUPTS                             ; EB148
70$:    MOV     #IE.DNR&377,R0  ;DEVICE NOT READY CODE                          ;**-1
        BR      50$             ;CALL $IODON
        .DSABL  LSB

        .END
        .TITLE  QUEUE
        .IDENT  /05.1/
 
;
; COPYRIGHT (C) 1974, 1976, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 05.1
;
; D. N. CUTLER 3-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       J. A. SCHRIESHEIM 4-JAN-79
;               JS001 -- ADDED MULTIPLE CLI SUPPORT.
;
;       CHUCK SPITZ 23-FEB-79
;               CS034 -- ADD CANCEL SELECTIVE MARKTIME REQUESTS
;
; GENERAL QUEUE MANIPULATION ROUTINES
;
; MACRO LIBRARY CALLS
;

        .MCALL  CLKDF$,TCBDF$
        CLKDF$                  ;DEFINE CLOCK QUEUE CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$CLINS-CLOCK QUEUE INSERTION
;
; THIS ROUTINE IS CALLED TO MAKE AN ENTRY IN THE CLOCK QUEUE. THE ENTRY
; IS INSERTED SUCH THAT THE CLOCK QUEUE IS ORDERED IN ASCENDING TIME.
; THUS THE FRONT ENTRIES ARE MOST IMMINENT AND THE BACK LEAST.
;
; INPUTS:
;
;       R0=ADDRESS OF THE CLOCK QUEUE ENTRY CORE BLOCK.
;       R1=HIGH ORDER HALF OF DELTA TIME.
;       R2=LOW ORDER HALF OF DELTA TIME.
;       R4=REQUEST TYPE.
;       R5=ADDRESS OF REQUESTING TCB OR REQUEST IDENTIFIER.
;
; OUTPUTS:
;
;       THE CLOCK QUEUE ENTRY IS INSERTED IN THE CLOCK QUEUE ACCORDING
;       TO THE TIME THAT IT WILL COME DUE.
;-

        .ENABL  LSB
$CLINS::CLR     (R0)+           ;POINT TO TYPE FIELD AND CLEAR LINK
        MOVB    R4,(R0)+        ;SET REQUEST TYPE
        INC     R0              ;ADVANCE TO TCB ADDRESS
        MOV     R5,(R0)+        ;SET TCB OR REQUEST IDENTIFIER
        ADD     $ABTIM,R2       ;CALCULATE ABSOLUTE TIME WHEN
        ADC     R1              ;REQUEST WILL COME DUE
        MOV     R2,(R0)+        ;SET LOW ORDER PART OF TIME
        MOV     R1,(R0)         ;SET HIGH ORDER PART OF TIME
        MOV     #$CLKHD,R2      ;POINT TO CLOCK QUEUE LIST HEAD
10$:    MOV     R2,R1           ;SAVE ADDRESS OF PREVIOUS ENTRY
        MOV     (R1),R2         ;GET ADDRESS OF NEXT ENTRY
        BEQ     20$             ;IF EQ END OF LIST
        CMP     (R0),C.TIM+2(R2) ;COMPARE HIGH ORDER TIMES
        BHI     10$             ;IF HI NOT THIS ENTRY
        BLO     20$             ;IF LO ENTRY GOES HERE
        CMP     -2(R0),C.TIM(R2) ;COMPARE LOW ORDER TIMES
        BHIS    10$             ;IF HIS NOT THIS ENTRY
20$:    SUB     #8.,R0          ;BACK UP TO FRONT OF BLOCK
        MOV     R0,(R1)         ;SET NEW NEXT IN PREVIOUS ENTRY
        MOV     R2,(R0)         ;SET NEXT IN NEW ENTRY


        .IF DF  L$$DRV & M$$MGE

        CMPB    #C.SYST,R4      ;A SYSTEM ROUTINE REQUEST (DRIVER)?
        BNE     30$             ;IF NE NO
        MOV     KISAR5,C.AR5(R0)  ;SAVE APR5 MAPPING

        .ENDC


30$:    RETURN                  ;

;+
; **-$CLRMV-CLOCK QUEUE REMOVAL
; **-$CLRSM-CLOCK QUEUE REMOVAL - SELECTIVE MARK TIME                   ; CS034
;
; THIS ROUTINE IS CALLED TO REMOVE ALL ENTRIES FOR A SPECIFIED TCB ADDRESS
; AND REQUEST TYPE FROM THE CLOCK QUEUE, OR SELECTIVELY BY EFN OR AST   ; CS034
; ADDRESS IF ENTRY AT $CLRSM.                                           ; CS034
;                                                                       ;**-1
; INPUTS:
;
;       R1=EFN NUMBER OR 0 (IF ENTRY AT $CLRSM).                        ; CS034
;       R2=AST ADDRESS OR 0 (IF ENTRY AT $CLRSM).                       ; CS034
;       R4=REQUEST TYPE.
;       R5=ADDRESS OF REQUESTING TCB OR SYSTEM SUBROUTINE.
;
; OUTPUTS:
;
;       ALL OF THE MATCHING ENTRIES FOR THE SPECIFIED TCB ADDRESS ARE   ; CS034
;       REMOVED FROM THE CLOCK QUEUE. IF THE REQUEST TYPE IS NOT 'C.SYST;**-1
;       THEN THE CLOCK QUEUE ENTRY CORE BLOCK IS RELEASED.
;-

$CLRMV::                        ;REF LABEL                              ; CS034
                                                                        ; CS034
        .IF DF C$$SMT                                                   ; CS034
                                                                        ; CS034
        CLR     R1              ;MATCH ON ANY EVENT FLAG (MKTM ONLY)    ; CS034
        CLR     R2              ;MATCH ON ANY AST ADDRESS (MKTM ONLY)   ; CS034
$CLRSM::                        ;REF LABEL                              ; CS034
                                                                        ; CS034
        .IFTF   ;C$$SMT                                                 ; CS034
                                                                        ; CS034
        MOV     #$CLKHD,R0      ;POINT TO CLOCK QUEUE LISTHEAD          ; CS034
40$:    MOV     R0,R3           ;SAVE ADDRESS OF PREVIOUS ENTRY         ;**-1
        MOV     (R3),R0         ;GET ADDRESS OF NEXT ENTRY
        BEQ     30$             ;IF EQ END OF LIST
        CMPB    R4,C.RQT(R0)    ;REQUEST TYPE MATCH?
        BNE     40$             ;IF NE NO
        CMP     R5,C.TCB(R0)    ;TCB OR SYSTEM SUBROUTINE ADDRESS MATCH?
        BNE     40$             ;IF NE NO
                                                                        ; CS034
        .IFT    ;C$$SMT                                                 ; CS034
                                                                        ; CS034
        TST     R4              ;MARK TIME ENTRY?                       ; CS034
        BNE     60$             ;IF NE NO                               ; CS034
        TSTB    R1              ;EFN SPECIFIED?                         ; CS034
        BEQ     50$             ;IF EQ NO                               ; CS034
        CMPB    R1,C.EFN(R0)    ;MATCH ON EFN?                          ; CS034
        BEQ     60$             ;IF EQ YES, REMOVE ENTRY                ; CS034
        TST     R2              ;AST ADDRESS SPECIFIED?                 ; CS034
        BEQ     40$             ;IGNORE PACKET                          ; CS034
50$:    TST     R2              ;AST SPECIFIED?                         ; CS034
        BEQ     60$             ;IF EQ NO                               ; CS034
        CMP     R2,C.AST(R0)    ;MATCH ON AST?                          ; CS034
        BNE     40$             ;IF NE NO                               ; CS034
60$:                            ;REF LABEL                              ; CS034
                                                                        ; CS034
        .IFTF   ;C$$SMT                                                 ; CS034
                                                                        ; CS034
        MOV     (R0),(R3)       ;REMOVE ENTRY FROM LIST
        CMPB    #C.SYST,C.RQT(R0) ;SYSTEM SUBROUTINE REQUEST?
        BEQ     40$             ;IF EQ YES CONTINUE
                                                                        ; CS034
        .IFT    ;C$$SMT                                                 ; CS034
                                                                        ; CS034
        MOV     R2,-(SP)        ;SAVE NECESSARY REGISTERS               ; CS034
        MOV     R1,-(SP)        ;                                       ; CS034
                                                                        ; CS034
        .IFTF   ;C$$SMT                                                 ; CS034
                                                                        ; CS034
        CALL    $DECLK          ;DEALLOCATE ENTRY CORE BLOCK
                                                                        ; CS034
        .IFT    ;C$$SMT                                                 ; CS034
                                                                        ; CS034
        MOV     (SP)+,R1        ;RESTORE SAVED REGISTERS                ; CS034
        MOV     (SP)+,R2        ;                                       ; CS034
        BR      $CLRSM          ;GO AGAIN                               ; CS034
                                                                        ; CS034
        .IFF    ;C$$SMT                                                 ; CS034
                                                                        ; CS034
        BR      $CLRMV          ;GO AGAIN
                                                                        ; CS034
        .ENDC   ;C$$SMT                                                 ; CS034
                                                                        ; CS034
        .DSABL  LSB

;+
; **-$QINSF-QUEUE INSERTION AT END OF LIST (FIFO)
;
; THIS ROUTINE IS CALLED TO MAKE AN ENTRY IN A FIRST IN FIRST OUT
; LIST. THE ENTRY IS LINKED TO THE END OF THE LIST.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TWO WORD LISTHEAD.
;       R1=ADDRESS OF THE ENTRY TO BE INSERTED.
;
; OUTPUTS:
;
;       THE ENTRY IS LINKED TO THE END OF THE QUEUE.
;
;       R0 AND R1 ARE PRESERVED ACROSS CALL.
;-

        .ENABL  LSB
$QINSF::MOV     2(R0),R2        ;GET ADDRESS OF LAST ENTRY IN LIST
        BR      20$             ;FINISH IN COMMON CODE

;+
; **-$QINSP-QUEUE INSERTION BY PRIORITY
;
; THIS ROUTINE IS CALLED TO INSERT AN ENTRY IN A PRIORITY ORDERED
; LIST. THE LIST IS SEARCHED UNTIL AN ENTRY IS FOUND THAT HAS A
; LOWER PRIORITY OR THE END OF THE LIST IS REACHED. THE NEW
; ENTRY IS THEN LINKED INTO THE LIST AT THE APPROPRIATE POINT.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TWO WORD LISTHEAD.
;       R1=ADDRESS OF THE ENTRY TO BE INSERTED.
;
;
; OUTPUTS:
;
;       THE ENTRY IS LINKED INTO THE LIST BY PRIORITY.
;
;       R0 AND R1 ARE PRESERVED ACROSS CALL.
;-

$QINSP::MOV     R0,R3           ;COPY ADDRESS OF LISTHEAD
10$:    MOV     R3,R2           ;SAVE ADDRESS OF CURRENT ENTRY
        MOV     (R2),R3         ;GET ADDRESS OF NEXT ENTRY
        BEQ     20$             ;IF EQ END OF LIST
        CMPB    T.PRI(R1),T.PRI(R3) ;NEW ENTRY LOWER OR SAME PRIORITY?
        BLOS    10$             ;IF LOS YES
        MOV     R3,(R1)         ;LINK CURRENT TO NEW ENTRY
        BR      30$             ;
20$:    MOV     R1,2(R0)        ;SET ADDRESS OF NEW LAST
        CLR     (R1)            ;CLEAR LINK TO NEXT ENTRY
30$:    MOV     R1,(R2)         ;LINK NEW TO PREVIOUS ENTRY
        RETURN                  ;
        .DSABL  LSB

;+
; **-$QMCRL-QUEUE MCR COMMAND LINE
; **-$QCLIL-QUEUE A COMMAND LINE TO A SPECIFIED CLI                     ; JS001
;
; THESE ROUTINES ARE CALLED TO QUEUE A COMMAND LINE TO A COMMAND        ; JS001
; LINE INTERPRETER.                                                     ; JS001
;                                                                       ;**-1
; INPUTS:
;
;       R0=CLI TCB ADDRESS (IF ENTRY AT $QCLIL).                        ; JS001
;       R1=ADDRESS OF THE COMMAND LINE CONTROL BLOCK.
;
; OUTPUTS:
;
;       THE COMMAND LINE CONTROL BLOCK IS INSERTED INTO THE CLI'S COMMAN; JS001
;       LINE LIST AND THE CLI IS REQUESTED TO RUN.                      ; JS001
;-                                                                      ;**-2

        .IF NDF M$$CLI                                                  ; JS001
                                                                        ; JS001
$QCLIL::                        ;REF LABEL FOR MCR                      ; JS001
$QMCRL::MOV     $MCRPT,R0       ;PICK UP MCR'S TCB ADDRESS
        CALLR   $EXRQF          ;PASS LINE TO MCR
                                                                        ; JS001
        .IFF    ;NDF M$$CLI                                             ; JS001
                                                                        ; JS001
$QMCRL::MOV     2(R1),R0        ;PICK UP TERMINAL UCB ADDRESS           ; JS001
        BIC     #1,R0           ;CLEAR LOW ORDER BIT (PROMPT FLAG)      ; JS001
        CALL    $MPLND          ;FOLLOW REDIRECTION                     ; JS001
        MOV     @U.CLI(R0),R0   ;PICK UP CLI TCB ADDRESS                ; JS001
                                                                        ; JS001
$QCLIL::CALLR   $EXRQF          ;PASS LINE TO CLI                       ; JS001
                                                                        ; JS001
        .ENDC   ;NDF M$$CLI                                             ; JS001
                                                                        ; JS001

;+
; **-$QRMVF-QUEUE REMOVAL FROM FRONT OF LIST
;
; THIS ROUTINE IS CALLED TO REMOVE THE NEXT (FRONT) ENTRY FROM A
; LIST. THE LIST ORGANIZATION MAY BE EITHER FIFO OR BY PRIORITY.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TWO WORD LISTHEAD.
;
; OUTPUTS:
;
;       C=1 IF THERE ARE NO ENTRIES IN THE LIST.
;       C=0 IF THE NEXT ENTRY IS REMOVED FROM THE LIST.
;               R1=ADDRESS OF THE ENTRY REMOVED.
;
;       R0 IS PRESERVED ACROSS CALL.
;-

        .ENABL  LSB
$QRMVF::MOV     R0,R2           ;COPY ADDRESS OF LISTHEAD
        MOV     (R2),R3         ;GET ADDRESS OF NEXT ENTRY
        BNE     30$             ;IF NE LIST HAS AN ENTRY
10$:    SEC                     ;NO ENTRIES IN LIST
        RETURN                  ;

;+
; **-$QRMVT-QUEUE REMOVAL BY TCB ADDRESS
;
; THIS ROUTINE IS CALLED TO REMOVE THE NEXT ENTRY FROM A LIST THAT
; MATCHES A SPECIFIED TCB ADDRESS. THE LIST ORGANIZATION MAY BE
; EITHER FIFO OR BY PRIORITY.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TWO WORD LISTEAD.
;       R1=ADDRESS OF THE TCB TO SEARCH FOR.
;
; OUTPUTS:
;
;       C=1 IF THERE IS NO ENTRY IN THE LIST THAT MATCHES THE TCB ADDRESS.
;       C=0 IF A MATCHING ENTRY IS REMOVED FROM THE LIST.
;               R1=ADDRESS OF THE ENTRY REMOVED.
;
;       R0 IS PRESERVED ACROSS CALL.
;-

$QRMVT::MOV     R0,R3           ;COPY ADDRESS OF LISTHEAD
20$:    MOV     R3,R2           ;SAVE ADDRESS OF CURRENT ENTRY
        MOV     (R2),R3         ;GET ADDRESS OF NEXT ENTRY
        BEQ     10$             ;IF EQ END OF LIST
        CMP     R1,R3           ;MATCH ON TCB ADDRESS?
        BEQ     30$             ;IF EQ YES
        CMP     R1,C.TCB(R3)    ;MATCHING TCB ADDRESS?
        BNE     20$             ;IF NE NO
30$:    MOV     (R3),(R2)       ;CLOSE UP LIST
        BNE     40$             ;IF NE NO NEW LAST
        MOV     R2,2(R0)        ;SET ADDRESS OF NEW LAST
40$:    MOV     R3,R1           ;SET ADDRESS OF ENTRY REMOVED
        CLC                     ;SUCCESS
        RETURN                  ;
        .DSABL  LSB

        .END
        .TITLE  REQSB
        .IDENT  /12.04/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 12.04
;
; D. N. CUTLER 10-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 7-DEC-76
;
;               TM068 -- CHECK FOR TASK EXITTING IN TEST FOR
;                       CHECKPOINT.
;
;       T. J. MILLER 26-MAY-77
;
;               TM086 -- ADDITION OF COMMON EVENT FLAG SETTING ROUTINE.
;
;       P. WANNHEDEN 8-JUN-77
;
;               PW001 -- ADDITION OF ROUTINE TO QUEUE AST FROM
;                       USER INTERRUPT SERVICE ROUTINE
;                       (INTERRUPT VIA VECTOR CONNECTED TO WITH
;                       CINT$ DIRECTIVE).
;
;       T. J. MILLER 17-SEP-77
;
;               TM106 -- CORRECT ERROR IN CONDITIONALIZATION.
;
;       T. J. MILLER 31-SEP-77
;
;               TM101 -- MODIFY $SETCR FOR ELIMINATION OF NULL TASK.
;
;       T. J. MILLER 8-DEC-77
;
;               TM118 -- CORRECT ERROR IN CONDITIONALIZATION IN SYSTEMS
;                       WITH SYSTEM CONTROLLED PARTITIONS BUT NO
;                       CHECKPOINTING.
;
;       CHUCK SPITZ 14-FEB-78
;               CS011 -- CORRECT ERROR IN $MAPTK.
;
;       CHUCK SPITZ 20-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES AND MOVE ALL AST
;                       LISTHEADS TO TCB
;
;       CHUCK SPITZ 24-OCT-78
;               CS018 -- ADD PARENT OFFSPRING TASKING
;
;       CHUCK SPITZ 8-DEC-78
;               CS020 -- ADD GROUP GLOBAL EF'S
;
;       M. S. HARVEY    27-FEB-79
;               MSH027 -- STOP RECURSION IF TKTN REQUESTED AFTER A
;                         CHECKPOINT FAILED DUE TO DEPLETED POOL, AND
;                         TKTN BLOCKED FOR SAME REASON
;
;       M. S. HARVEY    20-APR-79
;               MSH008 -- CLEAN UP UNRECEIVED SREFS ON TASK REMOVAL
;
;       M. S. HARVEY    9-MAY-79
;               MSH021 -- DON'T RETURN EXIT STATUS FROM ACPS
;
;       CHUCK SPITZ     22-MAY-79
;               CS056 -- CORRECT CONDITIONAL
;
; TASK REQUEST RELATED SUBROUTINES
;
; MACRO LIBRARY CALLS
;

        .MCALL  HDRDF$,ITBDF$,PCBDF$,TCBDF$
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        ITBDF$                  ;DEFINE INTERRUPT TRANSFER BLOCK OFFSETS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;+
; **-$ABCTK-ABORT CURRENT TASK
; **-$ABTSK-ABORT TASK
;
; THIS ROUTINE IS CALLED TO MARK A TASK FOR ABORT AND TO FORCE A TASK EXIT.
; THE REASON FOR ABORT AND THE CURRENT OUTSTANDING I/O COUNT ARE STORED
; IN THE FIRST TASK EVENT FLAG WORD.
;
; INPUTS:
;
;       R0=REASON FOR ABORT.
;       R1=ADDRESS OF THE TCB OF THE TASK TO BE ABORTED (ENTRY AT $ABTSK ONLY).
;
; OUTPUTS:
;
;       THE TASK IS MARKED FOR ABORT AND A CONDITIONAL SCHEDULE REQUEST IS
;       SET.
;-

$ABCTK::MOV     $TKTCB,R1       ;SET TCB ADDRESS TO CURRENT TASK
$ABTSK::MOV     R0,T.EFLG(R1)   ;INSERT REASON FOR ABORT
        MOVB    T.IOC(R1),T.EFLG+1(R1) ;SAVE OUTSTANDING I/O COUNT
                                                                        ; CS018
        .IF DF  P$$OFF                                                  ; CS018
                                                                        ; CS018
        BIT     #T3.ACP,T.ST3(R1) ;IS THIS AN ACP?                      ;MSH021
        BNE     9$              ;IF NE YES                              ;MSH021
        MOV     #EX$SEV,T.EFLG+2(R1) ;SET SEVERE ERROR EXIT STATUS      ; CS018
9$:                             ;REF LABEL                              ;MSH021
                                                                        ; CS018
        .ENDC                                                           ; CS018
                                                                        ; CS018
        MOV     R1,R0           ;COPY TCB ADDRESS
        ADD     #T.STAT,R1      ;POINT TO FIRST TASK STATUS WORD
        BIC     #TS.CKR,(R1)+   ;CLEAR STATUS BITS
        BIC     #T2.SEF!T2.STP!T2.SPN,(R1) ;MAKE TASK RUNNABLE          ; CS020
        BIS     #T2.AST!T2.DST!T2.HLT!T2.ABO,(R1) ;DSBL AST'S & FRC EXIT;**-1
        TST     -(R1)           ;OUT FOR INITIAL LOAD OR OTHERWISE BLKD?
        BNE     10$             ;IF NE YES
        CALL    $SETCR          ;SET A CONDITIONAL SCHEDULE REQUEST
10$:    MOV     T.PCB(R0),R0    ;POINT TO TASK PCB


        .IF DF  D$$ISK

        CALLR   $NXTSK          ;REALLOCATE TASK PARTITION IF NECESSARY

        .IFF

        RETURN                  ;

        .ENDC


;+
; **-$BILDS-BUILD STACK AND INITIALIZE HEADER
;
; THIS ROUTINE SETS UP THE TASK STACK AND INITIALIZES THE HEADER. IT IS
; CALLED PRIOR TO PLACING A TASK INTO CONTENTION FOR THE PROCESSOR WHEN
; AN EXECUTION REQUEST IS MADE FOR A TASK THAT IS FIXED IN MEMORY OR
; WHEN A DISK RESIDENT TASK HAS FINISHED LOADING.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TASK TO INITIALIZE.
;
; OUTPUTS:
;
;       1-TASK LOCAL EVENT FLAGS 1.-32. ARE CLEARED.
;       2-CURRENT UIC IS SETUP IN THE HEADER.
;       3-TASK CONTEXT IS SETUP TO CAUSE THE TASK TO START EXECUTION AT ITS ENTR
;       4-REDISPATCHING OF THE PROCESSOR IS CONDITIONALLY REQUESTED.
;
;       R3 IS PRESERVED ACROSS CALL.
;-

$BILDS::MOV     T.PCB(R0),R1    ;GET ADDRESS OF TASK PCB
        MOV     P.HDR(R1),R1    ;POINT TO TASK HEADER
        MOV     T.EFLG(R0),H.CUIC(R1) ;SET SPECIFIED UIC
        BNE     10$             ;IF NE UIC WAS SPECIFIED
        MOV     H.DUIC(R1),H.CUIC(R1) ;SET DEFAULT UIC


        .IF DF  M$$MUP

        BR      15$             ;

        .IFTF

10$:                            ;REF LABEL

        .IFT

        MOV     T.ACTL(R0),H.DUIC(R1) ;SET DEFAULT UIC

        .ENDC


15$:    BIT     #T2.ABO,T.ST2(R0) ;TASK MARKED FOR ABORT?
        BNE     20$             ;IF NE YES
        CLR     T.EFLG(R0)      ;CLEAR TASK LOCAL EVENT FLAGS
        BIT     #T3.ACP,T.ST3(R0) ;TASK ACP?
        BNE     20$             ;IF NE YES
        CLR     T.EFLG+2(R0)    ;
20$:                            ;REF LABEL


        .IF DF  M$$MGE

        MOV     H.ISP(R1),(R1)  ;SET INITIAL STACK POINTER
        MOV     H.GARD(R1),R2   ;POINT TO CONTEXT SAVE AREA
        SUB     #16,R2          ;POINT TO SAVED PC
        MOV     H.IPC(R1),(R2)  ;SET INITIAL PC WORD
        MOV     H.IPS(R1),-(R2) ;SET INITIAL PS WORD

        .IFF

        MOV     H.ISP(R1),R2    ;GET INITIAL STACK POINTER
        MOV     H.IPS(R1),-(R2) ;SET INITIAL PS WORD
        MOV     H.IPC(R1),-(R2) ;SET INITIAL PC WORD
        CMP     -(R2),-(R2)     ;ADJUST TO BOTTOM OF STACK
        MOV     R2,(R1)         ;SET INITIAL STACK POINTER

        .ENDC


;+
; **-$ACTTK-PUT TASK IN ACTIVE TASK LIST
;
; THIS ROUTINE IS CALLED TO PUT AN ACTIVE TASK IN THE ACTIVE TASK LIST.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TASK TO PUT IN THE ACTIVE LIST.
;
; OUTPUTS:

;       THE SPECIFIED TASK IS MERGED INTO THE ACTIVE TASK LIST BY
;       PRIORITY.
;
;       R3 IS PRESERVED ACROSS CALL.
;-

$ACTTK::MOV     #$ACTHD-T.ACTL,R1 ;SET ADDRESS OF PREVIOUS TCB
10$:    MOV     R1,R2           ;SAVE ADDRESS OF PREVIOUS TCB
        MOV     T.ACTL(R2),R1   ;GET ADDRESS OF NEXT TCB
        CMPB    T.PRI(R1),T.PRI(R0) ;TASK HIGHER OR SAME PRIORITY?
        BHIS    10$             ;IF HIS YES
        MOV     R0,T.ACTL(R2)   ;LINK NEW TASK TO PREVIOUS
        MOV     R1,T.ACTL(R0)   ;SET LINK TO NEXT IN NEW TASK

;+
; **-$SETCR-SET CONDITIONAL SCHEDULE REQUEST
; **-$SETRQ-SET SCHEDULE REQUEST
; **-$SETRT-SET SCHEDULE REQUEST FOR CURRENT TASK
;
; THIS ROUTINE IS CALLED TO FORCE REDISPATCHING OF THE PROCESSOR
; FROM A SPECIFIED POSITION IN THE TASK LIST. IF A PREVIOUS REQUEST
; HAS BEEN SET, THEN REDISPATCHING STARTS AT WHICH EVER REQUEST
; HAS THE HIGHEST PRIORITY.
;
; INPUTS:
;
;       IF ENTRY AT $SETRT, THEN
;               R5=ADDRESS OF THE TCB OF THE CURRENT TASK.
;       IF ENTRY AT $SETRQ OR $SETCR, THEN
;               R0=ADDRESS OF THE TCB TO START DISPATCHING AT.
;
; OUTPUTS:
;
;       A SCHEDULE REQUEST IS SET WHICH WILL FORCE A REDISPATCH-
;       ING OF THE PROCESSOR WHEN A SYSTEM EXIT IS EXECUTED.
;
;       R2 AND R3 ARE PRESERVED ACROSS CALL.
;       R0 IS PRESERVED ACROSS CALL IF ENTRY IS NOT AT $SETRT.
;-

        .ENABL  LSB
$SETCR::CMP     R0,$TKTCB       ;REQUESTED TASK SAME AS CURRENT?
        BEQ     $SETRQ          ;IF EQ YES
        CMPB    $CURPR,T.PRI(R0) ;CURRENT TASK HIGHER PRIORITY?
        BHI     30$             ;IF HI YES
        BLO     $SETRQ          ;IF LO NO
10$:    CALLR   $DRDSE          ;SAME PRIORITY-DECLARE SIGNIFICANT EVENT
$SETRT::MOV     R5,R0           ;SET ADDRESS OF DISPATCH TCB
$SETRQ::MOV     $RQSCH,R1       ;GET PREVIOUS SCHEDULE REQUEST
        BEQ     20$             ;IF EQ NO PREVIOUS REQUEST
        CMP     R0,R1           ;TASK ALREADY RESCHEDULED?
        BEQ     30$             ;IF EQ YES
        CMPB    T.PRI(R1),T.PRI(R0) ;COMPARE PRIORITIES
        BHI     30$             ;IF HI PREVIOUS IS HIGHER PRIORITY
        BEQ     10$             ;IF EQ SAME PRIORITY
20$:    MOV     R0,$RQSCH       ;SET SCHEDULE REQUEST
30$:    RETURN                  ;
        .DSABL  LSB

;+
; **-$SETF/$SETM-SET EVENT FLAG
;
; THESE ROUTINES SET AN EVENT FLAG AND TAKE CARE OF THE REQUIRED
; RESCHEDULING.
;
; INPUTS:
;
;       R0=EVENT FLAG NUMBER ($SETF) OR EVENT FLAG MASK ($SETM).
;       R1=EVENT FLAG WORD ADDRESS ($SETM ONLY).
;       R5=TCB ADDRESS FOR WHICH FLAG IS BEING SET.
;
; OUTPUTS:
;
;       R0=TCB ADDRESS OF TASK WHOSE FLAG WAS SET
;       R3 IS PRESERVED.
;-

$SETF:: CALL    $CEFI           ;CONVERT EVENT FLAG TO MASK AND ADDRESS
$SETM:: BIT     #T2.ABO,T.ST2(R5) ;IS TASK MARKED FOR ABORT?
        BNE     10$             ;IF NE YES, DO NOT TOUCH EVENT FLAG WORD
        BIS     R0,(R1)         ;SET THE EVENT FLAG
10$:    MOV     R5,R0           ;COPY TCB ADDRESS FOR $SETCR
        DEC     R1              ;WRAP AROUND ON 0 TO -1
        CMP     R1,#$COMEF+2    ;IS IT A COMMON EVENT FLAG?
        BLOS    20$             ;IF LOS YES                             ; CS017
                                                                        ; CS017
        .IF DF S$$TOP                                                   ; CS017
                                                                        ; CS017
        BIT     #T2.SEF,T.ST2(R0) ;TASK STOPPED FOR EVENT FLAGS?        ; CS017
        BEQ     $SETCR          ;IF EQ NO, SET SCHEDULE REQUEST         ;**-2
        MOV     R3,-(SP)        ;SAVE CONTENTS OF R3                    ; CS017
        MOV     R0,-(SP)        ;SAVE TCB ADDRESS                       ; CS017
        CALL    $EXRQN          ;UNSTOP TASK TO INSURE ATL SCAN         ; CS017
        MOV     (SP)+,R0        ;RESTORE TCB ADDRESS                    ; CS017
        MOV     (SP)+,R3        ;RESTORE R3                             ; CS017
        RETURN                  ;                                       ; CS017
                                                                        ; CS017
        .IFF    ;S$$TOP                                                 ; CS017
                                                                        ; CS017
        BR      $SETCR          ;SET SCHEDULE REQUEST                   ; CS017
                                                                        ; CS017
        .ENDC   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
20$:    CALLR   $DRDSE          ;DECLARE SIGNIFICANT EVENT AND RETURN
                                                                        ; CS017
;+                                                                      ;**-1
; **-$DASTT-DECLARE AST TRAP
;
; THIS ROUTINE IS CALLED TO DECLARE A NON-I/O RELATED AST TRAP. THE
; TCB OF THE SPECIFIED TASK IS EXAMINED TO DETERMINE IF THE SPECIFIED   ; CS017
; AST IS ENABLED (SETUP). IF IT IS THEN THE AST IS DECLARED.            ;**-1
;
; INPUTS:
;
;       R4=AST TYPE                                                     ; CS017
;       R5=ADDRESS OF THE TCB OF THE TASK TO DECLARE THE AST FOR.       ;**-1
;
; OUTPUTS:
;
;       C=1 IF THE TASK IS NOT SETUP FOR THE SPECIFIED AST.
;       C=0 IF THE TASK IS SETUP FOR THE AST AND THE AST HAS BEEN DECLARED.
;               R1=ADDRESS OF THE AST CONTROL BLOCK.
;
;-                                                                      ;**-1


        .IF DF  A$$TRP!F$$LPP!P$$RFL!R$$SND!P$$SRF

        .ENABL  LSB
$DASTT::CALL    $SRAST          ;SEARCH FOR SPECIFIED AST BLOCK         ; CS017
        BCS     10$             ;IF CS, THERE IS NONE                   ; CS017
        MOV     (R0),(R1)       ;REMOVE THE CONTROL BLOCK FROM THE LIST ; CS017
        MOV     R0,R1           ;SAVE ADDRESS OF THE AST CONTROL BLOCK  ; CS017
        MOV     R5,R0           ;COPY TCB ADDRESS                       ; CS017
                                                                        ;**-9
        .IF DF  C$$INT&A$$TRP                                           ; CS056
                                                                        ;**-1
        BR      $QASTT          ;GO QUEUE THE AST

;+
; **-$DQAC-DEQUEUE AST BLOCK QUEUED BY $QASTC.
;       (TO BE CALLED FROM SYSXT ONLY).
;
; INPUT:
;       R0      POINTER TO AST BLOCK
;
; OUTPUT:
;       A.CBL SET TO 1 TO INDICATE AST BLOCK FREE
;       (NOT IN AST QUEUE).
;
; REGISTERS ALTERED: NONE
;-


$DQAC:: INC     A.CBL(R0)       ; SET AST BLOCK FREE
        RETURN


;+
; **-$QASTC-QUEUE AST TO TASK.
;
; THIS IS A VARIANT OF $QASTT TO BE USED BY A TASK ISR, ENTERED
; VIA A VECTOR CONNECTED TO VIA THE CINT$ DIRECTIVE.
;
; INPUT:
;       R5      POINTER TO FORK BLOCK IN ITB
;
; OUTPUT:
;       CC-C    0 IF OK, 1 IF AST ADDRESS NOT SPECIFIED IN CINT$ CALL.
;
; NOTE - IF THE AST BLOCK IS ALREADY QUEUED FOR THE TASK,
; NO ACTION IS TAKEN. RETURN CC-C = 0.
;
; REGISTERS ALTERED: R0,R1,R2,R3
;-


$QASTC::MOV     R5,R1
        ADD     #X.AST-X.FORK,R1 ;GET AST BLOCK
        TST     A.CBL(R1)       ;AST BLOCK ALREADY IN AST QUEUE?
        BEQ     10$             ;Y - EXIT WITH CC-C = 0
        TST     A.AST(R1)       ;AST ADDRESS SPECIFIED?
        SEC                     ;ASSUME NO
        BEQ     10$             ;N - EXIT WITH CC-C = 1
        CLR     A.CBL(R1)       ;INDICATE AST BLOCK IN USE
        MOV     X.TCB-X.FORK(R5),R0 ;GET TCB ADDRESS
                                ;FALL THRU TO $QASTT

        .ENDC   ;C$$INT&A$$TRP                                          ; CS056
                                                                        ;**-1


;+
; **-$QASTT-QUEUE AST TO TASK
;
; THIS ROUTINE IS USED TO QUEUE AN AST TO A TASK AND INSURE THE TASK
; WILL BE SCHEDULED AND RECONSIDERED FOR ELIGIBILITY IN THE PARTITION.
;
; INPUTS:
;
;       R0=TCB ADDRESS OF TASK TO RECEIVE AST
;       R1=ADDRESS OF AST CONTROL BLOCK TO BE USED
;
; OUTPUTS:
;
;       C=0
;       R1 IS PRESERVED
;-

$QASTT::ADD     #T.ASTL,R0      ;POINT TO TASK AST LISTHEAD
        MOV     R1,-(SP)        ;SAVE ADDRESS OF AST CONTROL BLOCK
        CALL    $QINSF          ;INSERT CONTROL BLOCK IN AST QUEUE
        SUB     #T.ASTL,R0      ;POINT BACK TO TCB ADDRESS
        CALL    $SETCR          ;SET A CONDITIONAL SCHEDULE REQUEST


        .IF DF  D$$ISK&C$$CKP

        BIT     #T2.STP,T.ST2(R0) ;IS TASK STOPPED?
        BEQ     5$              ;IF EQ NO
        MOV     T.PCB(R0),R0    ;POINT TO TASK PCB
        CALL    $NXTSK          ;REALLOCATE TASK PARTITION

        .ENDC


5$:     MOV     (SP)+,R1        ;RESTORE AST CONTROL BLOCK ADDRESS
        CLC                     ;RETURN CARRY CLEAR
10$:    RETURN                  ;
        .DSABL  LSB

;+                                                                      ; CS017
; **-$SRAST-SEARCH FOR A SPECIFIED AST BLOCK                            ; CS017
;                                                                       ; CS017
; THIS ROUTINE IS CALLED TO SEARCH FOR A SPECIFIED TYPE OF AST CONTROL  ; CS017
; BLOCK ON THE T.SAST LIST.                                             ; CS017
;                                                                       ; CS017
; INPUTS:                                                               ; CS017
;                                                                       ; CS017
;       R4=CODE INDICATING TYPE OF BLOCK TO BE SEARCHED FOR             ; CS017
;       R5=TCB ADDRESS OF TASK WHOSE SAST LIST IS TO BE SEARCHED        ; CS017
;                                                                       ; CS017
; OUTPUTS:                                                              ; CS017
;                                                                       ; CS017
;       C=1 IF SPECIFED TYPE OF AST BLOCK NOT FOUND                     ; CS017
;       C=0 IF SPECIFIED TYPE OF AST BLOCK IS FOUND                     ; CS017
;               R0=ADDRESS OF THE BLOCK                                 ; CS017
;               R1=ADDRESS OF WORD POINTING TO THE BLOCK                ; CS017
;-                                                                      ; CS017
                                                                        ; CS017
$SRAST::MOV     R5,R0           ;GET TCB ADDRESS                        ; CS017
        ADD     #T.SAST,R0      ;POINT TO SPECIFIED AST BLOCK ADDRESS   ; CS017
10$:    SEC                     ;ASSUME FAILURE                         ; CS017
        MOV     R0,R1           ;GET POINTER TO NEXT BLOCK              ; CS017
        MOV     (R0),R0         ;GET LINK WORD                          ; CS017
        BEQ     20$             ;IF EQ, END OF LIST                     ; CS017
        CMPB    R4,A.CBL+1(R0)  ;IS THIS THE BLOCK OF THE SPECIFIED TYPE; CS017
        BNE     10$             ;NO IF NE                               ; CS017
20$:    RETURN                                                          ; CS017
                                                                        ; CS017
        .ENDC


;+
; **-$SRSTD-SEARCH SYSTEM TASK DIRECTORY
;
; THIS ROUTINE IS CALLED TO SEARCH THE TASK DIRECTORY FOR A TASK OF THE
; SPECIFIED NAME.
;
; INPUTS:
;
;       R3=ADDRESS OF THE TASK NAME TO SEARCH FOR.
;
; OUTPUTS:
;
;       C=1 IF SPECIFIED TASK IS NOT FOUND.
;       C=0 IF SPECIFIED TASK IS FOUND.
;               R0=ADDRESS OF THE TCB.
;
;       R1,R2, AND R3 ARE PRESERVED ACROSS CALL.
;-

        .ENABL  LSB
$SRSTD::MOV     $TSKHD,R0       ;POINT TO FIRST TCB IN LIST
10$:    CMP     T.NAM(R0),(R3)  ;FIRST HALF OF NAME MATCH?
        BNE     20$             ;IF NE NO
        CMP     T.NAM+2(R0),2(R3) ;SECOND HALF OF NAME MATCH?
        BEQ     30$             ;IF EQ YES
20$:    MOV     T.TCBL(R0),R0   ;GET LINK TO NEXT TCB
        TST     T.TCBL(R0)      ;NULL TASK?
        BNE     10$             ;IF NE NO
25$:    SEC                     ;INDICATE FAILURE
30$:    RETURN                  ;

;+
; **-$ACTRM-REMOVE TASK FROM THE ACTIVE TASK LIST
;
; THIS ROUTINE IS CALLED TO REMOVE A TCB FROM THE ACTIVE TASK LIST.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB TO REMOVE.
;
; OUTPUTS:
;
;       C=1 IF THERE IS NO ENTRY IN THE LIST THAT MATCHES THE TCB ADDRES
;       C=0 IF A MATCHING ENTRY IS REMOVED FROM THE LIST.
;
;       R0 IS PRESERVED ACROSS THE CALL.
;
;-

$ACTRM::MOV     #$ACTHD-T.ACTL,R1 ;GET ADDR OF LISTHEAD
40$:    MOV     R1,R2           ;SAVE PREVIOUS TCB ADDR
        MOV     T.ACTL(R2),R1   ;GET NEXT TCB ADDR
        BEQ     25$             ;IF EQ END OF LIST FOUND
        CMP     R0,R1           ;DOES NEXT TCB ADDR EQ OURS?
        BNE     40$             ;IF NE NO -- KEEP LOOKING
        MOV     T.ACTL(R0),T.ACTL(R2) ;REMOVE ENTRY
        RETURN                  ;EXIT
        .DSABL  LSB

;+                                                                      ;MSH008
; **-$CLSRF-CLEAR TASK TCB ADDRESS IN ALL RECEIVE BY REF PACKETS.       ;MSH008
;                                                                       ;MSH008
; THIS ROUTINE WILL SEARCH THE ACTIVE TASK LIST FOR TCBS WITH           ;MSH008
; RECEIVE BY REFERENCE PACKETS WHICH CONTAIN A POINTER TO THE TASK      ;MSH008
; BEING REMOVED.  IF SUCH A POINTER IS FOUND IT IS CLEARED.             ;MSH008
;                                                                       ;MSH008
; INPUTS:                                                               ;MSH008
;                                                                       ;MSH008
;       R0=TCB ADDRESS OF TASK TO BE REMOVED.                           ;MSH008
;                                                                       ;MSH008
; OUTPUTS:                                                              ;MSH008
;                                                                       ;MSH008
;       NONE                                                            ;MSH008
;                                                                       ;MSH008
;-                                                                      ;MSH008
                                                                        ;MSH008
$CLSRF::                        ;REFERENCE SYMBOL                       ;MSH008
                                                                        ;MSH008
                                                                        ;MSH008
        .IF DF  P$$LAS                                                  ;MSH008
                                                                        ;MSH008
        MOV     $TSKHD,R1       ;GET FIRST TCB IN ATL                   ;MSH008
10$:    TSTB    T.SRCT(R0)      ;ANY OUTSTANDING SREFS?                 ;MSH008
        BEQ     40$             ;IF EQ NO                               ;MSH008
        MOV     T.TCBL(R1),-(SP) ;END OF LIST?                          ;MSH008
        BEQ     30$             ;IF EQ YES                              ;MSH008
        ADD     #T.RRFL,R1      ;POINT TO RECEIVE BY REFERENCE LIST     ;MSH008
20$:    MOV     (R1),R1         ;GET NEXT REC BY REF PACKET             ;MSH008
        BEQ     30$             ;IF EQ END OF LIST                      ;MSH008
        CMP     2(R1),R0        ;DOES IT POINT TO TASK BEING REMOVED?   ;MSH008
        BNE     20$             ;IF NE NO                               ;MSH008
        DECB    T.SRCT(R0)      ;DECREMENT OUTSTANDING SREF COUNT       ;MSH008
        CLR     2(R1)           ;CLEAR POINTER TO EXITTING TASK         ;MSH008
        BR      20$             ;GO AGAIN                               ;MSH008
30$:    MOV     (SP)+,R1        ;GET ADDRESS OF NEXT TCB IN LIST        ;MSH008
        BNE     10$             ;IF NE GO AGAIN                         ;MSH008
                                                                        ;MSH008
        .IFTF                                                           ;MSH008
                                                                        ;MSH008
40$:    RETURN                  ;                                       ;MSH008
                                                                        ;MSH008
        .ENDC                                                           ;MSH008
                                                                        ;MSH008
                                                                        ;MSH008
                                                                        ;MSH008
;+                                                                      ; CS018
; **-$DRTHR/$ERTHR-DIRECTIVE ERROR AND GENERAL ERROR THREADING ROUTINES ; CS018
;                                                                       ; CS018
; THESE ROUTINES ARE USED IN CONJUNCTION WITH THE FOLLOWING ERROR       ; CS018
; RECOVERY ROUTINE TO DYNAMICALLY THREAD ERROR RECOVERY INFORMATION     ; CS018
; ONTO THE STACK.  AFTER INITIALIZATION, THE INTERFACE IS VIA A         ; CS018
; COROUTINE CALL (CALL @(SP)+) FOLLOWED BY TWO ROUTINE ADDRESSES.       ; CS018
; THE FIRST ROUTINE IS CALLED AND THEN THE SECOND ROUTINE ADDRESS IS    ; CS018
; PUSHED ONTO THE STACK ALONG WITH THE CONTENTS OF R0 AND R1.  IT IS    ; CS018
; INTENDED THAT THE SECOND ROUTINE, ALONG WITH THE SAVED CONTENTS OF    ; CS018
; R0 AND R1, CAN UNDO THE ACTION OF THE FIRST ROUTINE IF AN ERROR       ; CS018
; CONDITION IS ENCOUNTERED LATER.  ANOTHER POSSIBILITY IS THAT THE FIRST; CS018
; ROUTINE IS NULL, AND THE SECOND ROUTINE CAN UNDO SOME PREVIOUS ACTION.; CS018
; $DRTHR MAY BE CALLED WHEN THE FINAL DESIRED ACTION ON ERROR WILL BE   ; CS018
; TO RETURN A DIRECTIVE STATUS PASSED IN R5 (IN THE FORM 'DRSTS D.RSX').; CS018
; $ERTHR IS A GENERAL ERROR RECOVERY THREADING ROUTINE.  EXAMPLE USES OF; CS018
; THESE ROUTINES MAY BE FOUND IN THE MODULE DRSPW.                      ; CS018
;                                                                       ; CS018
; INPUTS:                                                               ; CS018
;                                                                       ; CS018
;       AS REQUIRED FOR CALL TO FIRST ROUTINE.                          ; CS018
;                                                                       ; CS018
; OUTPUTS:                                                              ; CS018
;                                                                       ; CS018
;       C-BIT AND R0-R3 ARE PRESERVED FROM RETURN OF FIRST ROUTINE.     ; CS018
;       R4 IS DESTROYED.                                                ; CS018
;-                                                                      ; CS018
                                                                        ; CS018
                                                                        ; CS018
        .IF DF  P$$OFF                                                  ; CS018
                                                                        ; CS018
        .ENABL  LSB                                                     ; CS018
$DRTHR::MOV     (SP),R4         ;PICK UP RETURN PC                      ; CS018
        MOV     #10$,(SP)       ;SET ADDRESS OF ROUTINE TO RETURN STATUS; CS018
        CMP     -(SP),-(SP)     ;ALLOCATE WORDS FOR R0 AND R1           ; CS018
        MOV     R4,-(SP)        ;RESTORE RETURN PC ADDRESS              ; CS018
$ERTHR::MOV     (SP),R4         ;PICK UP RETURN PC                      ; CS018
        CALL    @(R4)+          ;CALL THE FIRST ROUTINE ADDRESS         ; CS018
        MOV     (R4)+,(SP)      ;SAVE THE RECOVERY ROUTINE ADDRESS      ; CS018
        MOV     R1,-(SP)        ;SAVE CURRENT CONTENTS OF R1            ; CS018
        MOV     R0,-(SP)        ;SAVE CURRENT CONTENTS OF R0            ; CS018
        CALL    (R4)            ;CALL THE CALLER BACK                   ; CS018
        BR      $ERTHR          ;DO IT AGAIN                            ; CS018
10$:    MOV     R5,-(SP)        ;PUSH DIRECTIVE STATUS TRAP INSTRUCTION ; CS018
        JMP     (SP)            ;EXECUTE TRAP                           ; CS018
        .DSABL  LSB                                                     ; CS018
                                                                        ; CS018
;+                                                                      ; CS018
; **-$ERREC-ERROR RECOVERY ROUTINE                                      ; CS018
;                                                                       ; CS018
; THIS ROUTINE IS USED IN CONJUNCTION WITH THE ABOVE ROUTINES TO        ; CS018
; EFFECT A SERIES OF SUBROUTINE CALLS STORED ON THE STACK FOR ERROR     ; CS018
; RECOVERY.  THE NORMAL CALLING SEQUENCE IS VIA A JUMP.  SUCCESSIVE     ; CS018
; R0 AND R1 CONTENTS ARE POPPED FROM THE STACK WITH CALLS TO THE        ; CS018
; SAVED ROUTINE ADDRESSES.  THE LAST ROUTINE ON THE STACK MUST FORCE    ; CS018
; THE PROCESS TO STOP.                                                  ; CS018
;                                                                       ; CS018
; INPUTS:                                                               ; CS018
;                                                                       ; CS018
;       R5=DIRECTIVE STATUS (IF INITIALIZED BY $DRTHR).                 ; CS018
;                                                                       ; CS018
; OUTPUTS:                                                              ; CS018
;                                                                       ; CS018
;       NONE.                                                           ; CS018
;-                                                                      ; CS018
                                                                        ; CS018
$ERREC::TST     (SP)+           ;POP COROUTINE ADDRESS                  ; CS018
10$:    MOV     (SP)+,R0        ;PICK UP SAVED R0                       ; CS018
        MOV     (SP)+,R1        ;PICK UP SAVED R1                       ; CS018
        CALL    @(SP)+          ;CALL THE RECOVERY ROUTINE              ; CS018
        BR      10$             ;                                       ; CS018
                                                                        ; CS018
;+                                                                      ; CS018
; **-$QUEXT-QUEUE EXIT "AST" BLOCK                                      ; CS018
;                                                                       ; CS018
; THIS ROUTINE FILLS IN THE STATUS IN AN OFFSPRING CONTROL BLOCK,       ; CS018
; AND QUEUES IT AS A SPECIAL AST BLOCK TO THE PARENT TASK TCB.          ; CS018
;                                                                       ; CS018
; INPUTS:                                                               ; CS018
;                                                                       ; CS018
;       R0=EXIT STATUS WORD.                                            ; CS018
;       R1=OCB ADDRESS.                                                 ; CS018
;                                                                       ; CS018
; OUTPUTS:                                                              ; CS018
;                                                                       ; CS018
;       R3 IS PRESERVED.                                                ; CS018
;-                                                                      ; CS018
                                                                        ; CS018
        .IFTF   ;P$$OFF                                                 ; CS018
                                                                        ; CS018
$QUEXT::                        ;ALWAYS DEFINE FOR MCR                  ; CS018
                                                                        ; CS018
        .IFT    ;P$$OFF                                                 ; CS018
                                                                        ; CS018
        MOV     O.PTCB(R1),R2   ;PICK UP PARENT TCB ADDRESS             ; CS018
        BEQ     30$             ;IF EQ PARENT HAS EXITTED               ; CS018
        DEC     T.RDCT(R2)      ;DECREMENT RUNDOWN COUNT                ; CS018
        MOV     T.ASTL(R2),(R1) ;LINK OCB TO FRONT OF AST LIST          ; CS018
        BNE     10$             ;                                       ; CS018
        MOV     R1,T.ASTL+2(R2) ;                                       ; CS018
10$:    MOV     R1,T.ASTL(R2)   ;                                       ; CS018
        MOV     #300,A.CBL(R1)  ;SET EXIT "AST" BLOCK FLAG              ; CS018
        MOV     R0,O.STAT(R1)   ;SET EXIT STATUS                        ; CS018
        MOV     R2,R0           ;COPY PARENT TCB POINTER                ; CS018
                                                                        ; CS018
        .IF DF D$$ISK&C$$CKP                                            ; CS018
                                                                        ; CS018
        CALL    $SETCR          ;SET CONDITIONAL SCHEDULE REQUEST       ; CS018
        MOV     T.PCB(R0),R0    ;POINT TO PARENT PCB                    ; CS018
        CALLR   $NXTSK          ;REALLOCATE (AST ENTRY CAN UNSTOP)      ; CS018
                                                                        ; CS018
        .IFF    ;D$$ISK&C$$CKP                                          ; CS018
                                                                        ; CS018
        CALLR   $SETCR          ;SET CONDITIONAL SCHEDULE REQUEST       ; CS018
                                                                        ; CS018
        .ENDC   ;D$$ISK&C$$CKP                                          ; CS018
                                                                        ; CS018
30$:    MOV     R1,R0           ;COPY OCB POINTER TO DEALLOCATE         ; CS018
        MOV     #O.LGTH,R1      ;SET LENGTH TO DEALLOCATE               ; CS018
        CALLR   $DEACB          ;DEALLOCATE OCB                         ; CS018
                                                                        ; CS018
        .ENDC   ;P$$OFF                                                 ; CS018
                                                                        ; CS018
;+
; **-$STPCT-STOP CURRENT TASK
; **-$STPTK-STOP TASK
;
; THESE ROUTINES ARE CALLED TO STOP A TASK AND REALLOCATE THE TASK'S
; PARTITION.
;
; INPUTS:
;
;       R0=TCB ADDRESS OF TASK TO STOP (IF ENTRY AT $STPTK)
;
; OUTPUTS:
;
;       NONE
;-

$STPCT::MOV     $TKTCB,R0       ;PICK UP ADDRESS OF CURRENT TASK TCB
$STPTK::BIS     #T2.STP,T.ST2(R0) ;SET STOP BIT IN TASK'S TCB


        .IF DF  D$$ISK

        CALL    $SETCR          ;INSURE THAT TASK WILL STOP
        MOV     T.PCB(R0),R0    ;POINT TO TASK PCB
        BR      $NXTSK          ;REALLOCATE TASK PARTITION

        .IFF

        CALLR   $SETCR          ;INSURE THAT TASK WILL STOP

        .IFT

;+
; **-$RLPAR-RELEASE TASK PARTITION
; **-$RLPR1-RELEASE PARTITION
;
; THIS ROUTINE IS CALLED TO RELEASE A PARTITION OWNED BY A TASK AND TO
; ASSIGN THE PARTITION TO THE NEXT HIGHEST PRIORITY TASK WAITING TO
; OCCUPY THE PARTITION.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE OWNER TASK (IF ENTRY AT $RLPAR)
;       R1=ADDR OF SUBPARTITION PCB TO RELEASE (IF ENTRY AT $RLPR1)
;       R3=ADDRESS OF MAIN PARTITION PCB (IF ENTRY AT $RLPR1)
;
; OUTPUTS:
;
;       THE PARTITION IS RELEASED AND ASSIGNED TO THE NEXT HIGHEST
;       PRIORITY TASK WAITING TO OCCUPY THE PARTITION.
;-

$RLPAR::MOV     T.PCB(R0),R1    ;GET ADDRESS OF PARTITION PCB
        MOV     P.MAIN(R1),R0   ;GET MAIN PCB ADDRESS
        MOV     R0,R3           ;COPY MAIN PCB ADDRESS


        .IF DF  D$$YNM&M$$MGE

        BIT     #PS.SYS,P.STAT(R0) ;SYSTEM CONTROLLED PARTITION?
        BEQ     $RLPR1          ;IF EQ NO
10$:    MOV     R0,R2           ;SAVE ADDRESS OF PREVIOUS PCB
        MOV     P.SUB(R2),R0    ;GET ADDRESS OF NEXT PCB
        CMP     R0,R1           ;TASK PCB?
        BNE     10$             ;IF NE NO
        MOV     P.SUB(R0),P.SUB(R2) ;REMOVE PCB FROM LIST

        .ENDC


$RLPR1::ADD     #P.BUSY,R1      ;POINT TO BUSY FLAG
        BICB    (R1)+,(R1)      ;CLEAR SUBPARTITION BUSY
        BICB    -(R1),P.BUSY+1(R3) ;CLEAR MAIN PARTITION BUSY

;+
; **-$NXTSK-ASSIGN NEXT TASK TO PARTITION
;
; THIS ROUTINE IS CALLED TO ASSIGN A PARTITION TO THE HIGHEST PRIORITY
; TASK WAITING TO OCCUPY THE PARTITION.
;
; INPUTS:
;
;       R0=ADDRESS OF THE PCB OF THE PARTITION TO ASSIGN.
;
; OUTPUTS:
;
;       THERE ARE FIVE POSSIBLE OUTPUTS
;
;       1-THE PARTITION IS NOT CURRENTLY BUSY AND A TASK IS WAITING TO
;               OCCUPY THE PARTITION. THE PARTITION IS ASSIGNED TO THE
;               WAITING TASK AND A REQUEST IS PLACED IN THE LOADER
;               QUEUE TO LOAD THE TASK.
;
;       2-THE PARTITION IS CURRENTLY OCCUPIED BY A TASK THAT IS EITHER OF
;               HIGHER PRIORITY THEN ALL WAITING TASKS OR IS NOT CHECK-
;               POINTABLE. THE PARTITION CANNOT BE ASSIGNED TO ANOTHER
;               TASK.
;
;       3-THE PARTITION IS CURRENTLY OCCUPIED BY A LOWER PRIORITY CHECK-
;               POINTABLE TASK. A REQUEST IS PLACED IN THE LOADER QUEUE
;               TO CHECKPOINT THE OWNER TASK.
;
;       4-THE HIGHEST PRIORITY TASK WAITING TO OCCUPY THE PARTITION
;               REQUIRES THE MAIN PARTITION WHICH IS CURRENLTY
;               OCCUPPIED BY ONE OF MORE TASKS THAT ARE EITHER OF
;               HIGHER PRIORITY OR ARE NOT CHECKPOINTABLE. THE PARTITION
;               CANNOT BE ASSIGNED.
;
;       5-THE HIGHEST PRIORITY TASK WAITING TO OCCUPY THE PARTITION
;               REQUIRES THE MAIN PARTITION WHICH IS CURRENTLY
;               OCCUPIED BY ONE OR MORE TASKS OF LOWER PRIORITY
;               THAT ARE CHECKPOINTABLE. A REQUEST IS PLACED IN THE
;               LOADER QUEUE TO CHECKPOINT EACH TASK.
;-

$NXTSK::SAVNR                   ;SAVE R4 AND R5
        MOV     P.MAIN(R0),R5   ;GET MAIN PARTITION PCB ADDRESS
10$:    MOV     P.WAIT(R5),R4   ;GET 1ST TCB IN WAIT LIST
20$:    BEQ     100$            ;IF EQ END OF LIST
        BIT     #T2.STP,T.ST2(R4) ;TASK STOPPED?


        .IF DF  A$$TRP

        BEQ     21$             ;IF EQ NO
        TST     T.ASTL(R4)      ;DOES TASK HAVE PENDING AST?
        BEQ     40$             ;IF EQ NO
21$:                            ;REF LABEL

        .IFF

        BNE     40$             ;IF NE YES

        .ENDC


        .IF DF  D$$YNM&M$$MGE

        BIT     #PS.SYS,P.STAT(R5) ;SYSTEM CONTROLLED PARTITION?
        BNE     110$            ;IF NE YES

        .ENDC


        TSTB    P.BUSY+1(R5)    ;MAIN PARTITION OCCUPIED?
        BMI     50$             ;IF MI YES
        MOV     T.PCB(R4),R2    ;GET REQUESTED PARTITION PCB ADDRESS
        TSTB    P.BUSY+1(R2)    ;REQUESTED PARTITION BUSY?
        BNE     30$             ;IF NE YES
25$:    MOV     R5,R0           ;COPY MAIN PARTITION PCB ADDRESS
        ADD     #P.WAIT,R0      ;CALCULATE PCB LISTHEAD ADDRESS
        MOV     R4,R1           ;COPY TCB ADDRESS
        CALL    $QRMVT          ;REMOVE TCB FROM LIST
        MOV     T.PCB(R4),R0    ;GET PCB ADDRESS
        MOV     R4,P.TCB(R0)    ;PUT TCB ADDRESS IN PCB
        ADD     #P.BUSY,R0      ;POINT TO BUSY FLAG
        BISB    (R0)+,(R0)      ;SET SUBPARTITION BUSY
        BISB    -(R0),P.BUSY+1(R5) ;SET MAIN PARTITION BUSY
        CALL    $LOADT          ;PUT TASK IN LOADER QUEUE
        BR      10$             ;GO AGAIN
30$:                            ;REF LABEL


        .IF DF  C$$CKP

        TSTB    P.BUSY(R2)      ;MAIN PARTITION REQUESTED
        BMI     50$             ;IF MI YES
        MOV     P.TCB(R2),R1    ;GET OWNER TASK TCB ADDRESS
        CALL    $TSTCP          ;SHOULD TASK BE CHECKPOINTED?
        BCS     40$             ;IF CS NO
        CALL    $ICHKP          ;INITIATE CHECKPOINT

        .IFTF

40$:    MOV     (R4),R4         ;POINT TO NEXT TCB
        BR      20$             ;

        .IFT

50$:    MOV     R5,R0           ;COPY MAIN PCB ADDRESS
60$:    BITB    P.BUSY(R0),P.BUSY+1(R0) ;IS THIS PARTITION BUSY?
        BEQ     70$             ;IF EQ NO
        MOV     P.TCB(R0),R1    ;GET OWNER TCB ADDRESS
        CALL    $TSTCP          ;SHOULD TASK BE CHECKPOINTED?
        BCS     100$            ;IF CS NO
70$:    MOV     P.SUB(R0),R0    ;GET NEXT PARTITION PCB ADDRESS
        BNE     60$             ;IF NE MORE TO GO
80$:    BITB    P.BUSY(R5),P.BUSY+1(R5) ;IS THIS PARTITION BUSY?
        BEQ     90$             ;IF EQ NO
        MOV     P.TCB(R5),R1    ;GET OWNER TCB ADDRESS
        CALL    $ICHKP          ;INITIATE CHECKPOINT
90$:    MOV     P.SUB(R5),R5    ;GET NEXT SUBPARTITION PCB
        BNE     80$             ;IF NE MORE TO GO

        .IFF

50$:                            ;REF LABEL

        .IFTF

100$:   RETURN                  ;EXIT


        .IF DF  D$$YNM&M$$MGE

110$:   MOV     T.PCB(R4),R4    ;POINT TO TASK PCB
        CALL    $FNDSP          ;ATTEMPT TO FIND SPACE IN PARTITION
        MOV     P.SIZE(R4),R0   ;SAVE SIZE OF PARTITION
        MOV     P.TCB(R4),R4    ;RESTORE TCB ADDRESS
        BCC     25$             ;IF CC SPACE WAS FOUND


        .IF DF  C$$CKP

150$:   MOV     P.REL(R5),R3    ;SET BASE ADDRESS OF FIRST HOLE
        MOV     R5,R2           ;SET ADDRESS OF PREVIOUS PCB
160$:   MOV     P.SUB(R2),R2    ;GET ADDRESS OF NEXT PCB
        BEQ     210$            ;IF EQ ALLOCATION FAILURE


        .IF DF  L$$DRV!P$$LAS

        BIT     #PS.DRV!PS.COM,P.STAT(R2) ;DRIVER OR COMMON PARTITION?
        BNE     165$            ;IF NE YES

        .ENDC


        MOV     P.TCB(R2),R1    ;GET TCB ADDRESS OF OWNER TASK
        CALL    $TSTCP          ;CAN TASK BE CHECKPOINTED?
        BCC     170$            ;IF CC YES
165$:   MOV     R2,R5           ;SAVE ADDRESS OF PREVIOUS PCB
        MOV     P.REL(R5),R3    ;CALCULATE NEW HOLE BASE ADDRESS
        ADD     P.SIZE(R5),R3   ;
        BR      160$            ;
170$:   CLR     -(SP)           ;INITIALIZE TOP OF HOLE
        MOV     P.SUB(R2),R1    ;GET ADDRESS OF NEXT PCB
        BNE     180$            ;IF NE ONE EXISTS
        MOV     P.MAIN(R2),R1   ;RETRIEVE ADDRESS OF MAIN PCB
        ADD     P.SIZE(R1),(SP) ;CALCULATE ADDRESS OF TOP OF HOLE
180$:   ADD     P.REL(R1),(SP)  ;
190$:   SUB     R3,(SP)         ;CALCULATE SIZE OF HOLE
        CMP     (SP)+,R0        ;HOLE BIG ENOUGH?
        BLO     160$            ;IF LO NO
        MOV     R2,R4           ;SAVE ADDRESS OF LAST PCB
200$:   MOV     P.SUB(R5),R5    ;GET ADDRESS OF NEXT PCB
        MOV     P.TCB(R5),R1    ;GET ADDRESS OF TASK TCB
        CALL    $ICHKP          ;INITIATE CHECKPOINT
        CMP     R4,R5           ;LAST PCB TO EXAMINE?
        BNE     200$            ;IF NE NO


        .IF DF  D$$SHF

205$:   RETURN                  ;
210$:   MOV     $SHFPT,R0       ;GET TCB ADDRESS OF MEMORY SHUFFLER
        BEQ     205$            ;IF EQ SHUFFLER NOT PRESENT
        JMP     $EXRQN          ;REQUEST SHUFFLER TO RUN

        .IFF

210$:   RETURN                  ;

        .ENDC


        .IFF

        RETURN                  ;

        .ENDC


        .ENDC


;+
; **-$FNDSP-FIND SPACE IN PCB LIST
;
; THIS ROUTINE IS CALLED TO FIND SPACE WITHIN A DYNAMICALLY ALLOCATED
; PCB LIST REPRESENTING THE ALLOCATION STATE OF A SYSTEM CONTROLLED
; PARTITION OR DYNAMIC CHECKPOINT FILE.
;
; INPUTS:
;
;       R4=ADDRESS OF PCB TO FIND SPACE FOR
;       R5=ADDRESS OF MAIN PCB FOR SPACE IN WHICH TO ALLOCATE
;
; OUTPUTS:
;
;       C=0 IF ALLOCATION WAS SUCCESSFUL
;               SUB PCB IS LINKED INTO ALLOCATION LIST
;       C=1 IF ALLOCATION FAILURE
;
;       R0,R1,R2 ARE MODIFIED.
;-


        .IF DF  D$$YNM&M$$MGE!D$$YNC

$FNDSP::MOV     R5,R0           ;COPY ADDRESS OF MAIN PCB
        MOV     P.REL(R5),R2    ;SET HIGHEST ADDRESS IN LAST PARTITION
10$:    MOV     P.SUB(R0),R1    ;GET ADDRESS OF NEXT PCB
        BEQ     20$             ;IF EQ END OF LIST
        MOV     P.REL(R1),-(SP) ;CALCULATE SIZE OF HOLE
        SUB     R2,(SP)         ;
        CMP     (SP)+,P.SIZE(R4) ;HOLE BIG ENOUGH?
        BHIS    30$             ;IF HIS YES
        MOV     R1,R0           ;SAVE ADDRESS OF PREVIOUS PCB
        MOV     P.REL(R1),R2    ;CALCULATE BASE ADDRESS OF NEXT HOLE
        ADD     P.SIZE(R1),R2   ;
        BR      10$             ;
20$:    MOV     P.REL(R5),-(SP) ;CALCULATE SIZE OF LAST HOLE
        ADD     P.SIZE(R5),(SP) ;
        SUB     R2,(SP)         ;
        CMP     (SP)+,P.SIZE(R4) ;HOLE BIG ENOUGH?
        BLO     40$             ;IF LO NO
30$:    MOV     R2,P.REL(R4)    ;SET ADDRESS OF TASK PARTITION
        MOV     R4,P.SUB(R0)    ;LINK ALLOCATED PARTITION TO PREVIOUS
        MOV     R1,P.SUB(R4)    ;LINK NEXT TO TASK PCB
40$:    RETURN                  ;

        .ENDC


        .IFT

;+
; **-$TSTCP-TEST IF CHECKPOINT SHOULD BE INITIATED
;
; INPUTS:
;
;       R1=ADDRESS OF THE TCB OF THE OWNER TASK.
;       R4=ADDRESS OF THE TCB OF THE REQUESTED TASK.
;
; OUTPUTS:
;
;       C=0 IF CHECKPOINT SHOULD BE INITIATED.
;       C=1 IF CHECKPOINT SHOULD NOT BE INITIATED.
;-

$TSTCP::                        ;


        .IF DF  S$$WPC&D$$ISK

        MOV     R5,-(SP)        ;SAVE R5

        .IFTF

        BIT     #T2.STP,T.ST2(R1) ;TASK STOPPED FOR TERMINAL INPUT?


        .IF DF  A$$TRP

        BEQ     3$              ;IF EQ NO
        TST     T.ASTL(R1)      ;TASK HAVE PENDING AST?
        BEQ     5$              ;IF EQ NO
3$:                             ;REF LABEL

        .IFF

        BNE     5$              ;IF NE YES

        .ENDC


        .IFT

        MOV     #S$$WPR,R5      ;PICK UP INITIAL PRIORITY DIFFERENCE
        BIT     #TS.CKP!TS.CKR!TS.OUT,T.STAT(R1) ;TASK IN MEMORY?
        BNE     4$              ;IF NE NO
        MOV     T.PCB(R1),R5    ;POINT TO TASK PCB
        MOV     P.HDR(R5),R5    ;POINT TO TASK HEADER
        MOVB    H.SPRI(R5),R5   ;PICK UP SWAPPING PRIORITY
4$:     CLR     -(SP)           ;EXTRACT TASK PRIORITY BYTE
        BISB    T.PRI(R1),(SP)  ;
        ADD     (SP)+,R5        ;CALCULATE EFFECTIVE PRIORITY
        CMP     T.PRI(R4),R5    ;REQUESTED TASK HIGHER PRIORITY?
        BLE     10$             ;IF LE NO

        .IFF

        CMPB    T.PRI(R4),T.PRI(R1) ;REQUESTED TASK HIGHER PRIORITY?
        BLOS    10$             ;IF LOS NO

        .IFTF

5$:     CLC                     ;ASSUME TASK CHECKPOINTABLE
        BIT     #T2.CKD!T2.CHK!T2.FXD!T2.HLT,T.ST2(R1) ;IS IT?
        BEQ     20$             ;IF EQ TASK CAN BE CHECKPOINTED
10$:    SEC                     ;INDICATE NO CHECKPOINT
20$:                            ;REF LABEL

        .IFT

        MOV     (SP)+,R5        ;RESTORE R5

        .ENDC


        RETURN                  ;

;+
; **-$ICHKP-INITIATE CHECKPOINT
;
; INPUTS:
;
;       R1=ADDRESS OF THE TCB OF THE TASK TO BE CHECKPOINTED.
;-

$ICHKP::BIT     #TS.OUT,T.STAT(R1) ;TASK BEING READ IN?
        BNE     20$             ;IF NE YES
        BIT     #TS.CKP,T.STAT(R1) ;TASK ALREADY BEING CHECKPOINTED?
        BNE     30$             ;IF NE YES
        MOV     R1,R0           ;SET ADDRESS OF TCB
        CALL    $SETCR          ;SET A CONDITIONAL SCHEDULE REQUEST
        MOV     R0,R1           ;RESTORE ADDRESS OF TCB
        TSTB    T.IOC(R1)       ;I/O IN PROGRESS
        BEQ     $CHKPT          ;IF EQ NO
20$:    BIS     #TS.CKR,T.STAT(R1) ;SET CHECKPOINT REQUEST
30$:    RETURN                  ;

;+
; ***-$CHKPT-CHECKPOINT TASK
;
; THIS ROUTINE IS CALLED TO CHECKPOINT A TASK.
;
; INPUTS:
;
;       R1=ADDRESS OF THE TCB OF THE TASK TO BE CHECKPOINTED.
;
; OUTPUTS:
;
;       THE CHECKPOINT FLAG IS SET IN THE TASK STATUS WORD, THE TASK
;       IS PLACED IN THE LOADER QUEUE, AND THE LOADER IS REQUESTED
;       TO CHECKPOINT THE TASK.
;-

$CHKPT::                        ;


        .IF DF  D$$YNC

        SAVNR                   ;SAVE R4 AND R5
        BIC     #T2.CAF,T.ST2(R1) ;CLEAR CHECKPOINT ALLOCATION FAILURE
        MOV     R1,R3           ;COPY TCB ADDRESS
        MOV     #P.SIZE+2,R1    ;SET SIZE OF CHECKPOINT PCB
        CALL    $ALOCB          ;ATTEMPT TO ALLOCATE PCB
        BCS     20$             ;IF CS ALLOCATION FAILURE
        MOV     R0,R4           ;COPY ADDRESS OF ALLOCATED PCB
        ADD     R1,R0           ;POINT TO END OF ALLOCATED PCB
        MOV     T.PCB(R3),R1    ;POINT TO TASK PCB
        MOV     P.SIZE(R1),-(R0) ;SET SIZE OF TASK PCB


        .IF DF  M$$MGE

        ADD     #7,(R0)         ;ROUND TO NEXT DISK BLOCK
        ROR     (R0)            ;CONVERT TO DISK BLOCKS
        ASR     (R0)            ;
        ASR     (R0)            ;

        .IFF

        ADD     #777,(R0)       ;ROUND TO NEXT BLOCK BOUNDARY
        CLRB    (R0)            ;CLEAR EXCESS BITS
        SWAB    (R0)            ;CONVERT TO 256. WORD BLOCKS
        ASR     (R0)            ;

        .ENDC


        MOV     #$CFLPT,R5      ;POINT TO FIRST CHECKPOINT FILE PTR
10$:    MOV     (R5),R5         ;GET NEXT CHECKPOINT FILE PCB ADDRESS
        BNE     30$             ;IF NE THERE IS ONE
        MOV     R4,R0           ;ELSE GET ADDRESS OF CHECKPOINT PCB
        MOV     #P.SIZE+2,R1    ;SET ITS SIZE
        MOV     R3,R5           ;SAVE TCB ADDRESS
        CALL    $DEACB          ;DEALLOCATE CHECKPOINT PCB
        MOV     R5,R3           ;RESTORE TCB ADDRESS
20$:    MOV     R3,R1           ;RESTORE TCB ADDRESS
        BIS     #T2.CAF,T.ST2(R3) ;SET CHECKPOINT ALLOCATION FAILURE
        BIT     #T3.CAL,T.ST3(R3) ;CHECKPOINT SPACE ALLOCATED WITH TASK?
        BNE     50$             ;IF NE YES
        MOV     $TKNPT,R0       ;ELSE POINT TO TKTN TCB
        BEQ     25$             ;IF EQ TKTN NOT INSTALLED
        TST     T.STAT(R0)      ;TKTN ALREADY ACTIVE?
        BMI     $EXRQN          ;IF MI NO
25$:    RETURN                  ;
30$:    TST     P.REL(R5)       ;ALLOCATION IN THIS FILE TURNED OFF?
        BNE     10$             ;IF NE YES
        CALL    $FNDSP          ;ATTEMPT TO ALLOCATE SPACE IN FILE
        BCS     10$             ;IF CS ALLOCATION FAILURE
        MOV     R5,P.MAIN(R4)   ;SET MAIN PCB POINTER
        MOV     R3,R1           ;COPY TCB POINTER
        MOV     R4,T.CPCB(R1)   ;SET ADDRESS OF CHECKPOINT PCB
50$:                            ;REF LABEL

        .ENDC


        BIS     #TS.CKP,T.STAT(R1) ;SET CHECKPOINT IN PROGRESS BIT

        .ENDC


;+
; **-$LOADT-PUT TASK IN LOADER QUEUE
;
; THIS ROUTINE PUTS A TASK IN THE LOADER QUEUE FOR AN INITIAL LOAD OR
; A CHECKPOINT OPERATION.
;
; INPUTS:
;
;       R1=ADDRESS OF TASK CONTROL BLOCK
;
; OUTPUTS:
;
;       NONE
;-

$LOADT::MOV     $LDRPT,R0       ;PICK UP TCB ADDRESS OF LOADER

        .ENDC


;+
; **-$EXRQP-EXECUTIVE REQUEST WITH QUEUE INSERT BY PRIORITY
; **-$EXRQF-EXECUTIVE REQUEST WITH QUEUE INSERT FIFO
; **-$EXRQN-EXECUTIVE REQUEST WITH NO QUEUE INSERTION
;
; THESE ROUTINES PROVIDE A STANDARD INTERFACE TO ALL TASKS REQUESTED BY
; THE EXECUTIVE.
;
; INPUTS:
;
;       R0=TCB ADDRESS OF TASK TO REQUEST
;       R1=ADDR OF PACKET TO QUEUE TO TASK (IF ENTRY AT $EXRQP/$EXRQF)
;
; OUTPUTS:
;
;       C=0 IF THE REQUEST WAS SUCCESSFULLY COMPLETED.
;       C=1 IF THE TASK WAS NOT SUCCESSFULLY REQUESTED.
;               Z=0 IF PCB ALLOCATION FAILURE.
;               Z=1 IF TASK ACTIVE, BEING REMOVED, OR BEING FIXED.
;-

        .ENABL  LSB
$EXRQP::MOV     #$QINSP,-(SP)   ;PUSH ADDR OF QUEUE INSERT BY PRIORITY
        BR      1$              ;JOIN COMMON CODE
$EXRQF::MOV     #$QINSF,-(SP)   ;PUSH ADDR OF QUEUE INSERT FIFO
1$:     ADD     #T.RCVL,R0      ;POINT TO TASK RECEIVE LIST
        CALL    @(SP)+          ;INSERT PACKET IN RECEIVE QUEUE
        SUB     #T.RCVL,R0      ;POINT BACK TO START OF TCB
$EXRQN::BIT     #T2.STP*2!T2.STP,T.ST2(R0) ;TASK STOPPED?
        BEQ     2$              ;IF EQ NO
        BIC     #T2.STP*2!T2.STP,T.ST2(R0) ;CLEAR TASK STOP BIT
        CALL    $SETCR          ;SET CONDITIONAL SCHEDULE REQUEST
2$:     CLR     R1              ;USE DEFAULT UIC
        .DSABL  LSB

;+
; **-$TSKRT-TASK REQUEST (DEFAULT UCB)
; **-$TSKRQ-TASK REQUEST (SPECIFY UCB)
; **-$TSKRP-TASK REQUEST (SPECIFY DEFAULT UIC)
;
; THIS ROUTINE IS CALLED TO REQUEST THE EXECUTION OF A TASK.
;
; INPUTS:
;
;       R0=ADDRESS OF THE TCB OF THE TASK TO BE REQUESTED.
;       R1=REQUEST UIC.
;       R2=UCB ADDRESS IF ENTRY AT $TSKRQ.
;       R3=DEFAULT UIC IF ENTRY AT $TSKRP.
;
; OUTPUTS:
;
;       C=1 IF TASK IS ALREADY ACTIVE OR IS BEING FIXED IN MEMORY.
;               Z=1 IF TASK ACTIVE OR BEING FIXED.
;               Z=0 IF PCB ALLOCATION FAILURE.
;       C=0 IF THE REQUEST IS SUCCESSFULLY COMPLETED.
;-


        .IF NDF M$$MUP

$TSKRT::MOV     $COPT,R2        ;GET ADDRESS OF COMMAND OUTPUT UCB
$TSKRP::                        ;REF LABEL
$TSKRQ::MOV     R0,R3           ;POINT TO TASK STATUS WORD
        ADD     #T.STAT,R3      ;
        MOV     #TS.EXE,-(SP)   ;ASSUME TASK IS ACTIVE OR BEING FIXED
        BIT     (SP),(R3)+      ;TASK ALREADY ACTIVE?
        BEQ     10$             ;IF EQ YES
        BIT     #T2.FXD,(R3)+   ;TASK POSSIBLY BEING FIXED?             ; CS017
        BEQ     1$              ;IF EQ NO                               ; CS017
        BIT     #TS.OUT,T.STAT(R0) ;TASK BEING FIXED?                   ; CS017
        BNE     10$             ;IF NE YES                              ;**-1
1$:     BIT     #T3.REM,(R3)    ;REMOVE ON EXIT?                        ; CS017
        BNE     10$             ;IF NE YES                              ;**-1
        CMP     -(R3),-(R3)     ;POINT BACK TO FIRST STATUS WORD

        .IFF

$TSKRT::MOV     $COPT,R2        ;GET ADDRESS OF COMMAND OUTPUT UCB
$TSKRQ::MOV     R1,R3           ;MAKE CURRENT UIC DEFAULT UIC
$TSKRP::MOV     #TS.EXE,-(SP)   ;ASSUME TASK IS ACTIVE OR BEING FIXED
        BIT     (SP),T.STAT(R0) ;TASK ALREADY ACTIVE?
        BEQ     10$             ;IF EQ YES
        BIT     #TS.OUT,T.STAT(R0) ;TASK POSSIBLY BEING FIXED?          ; CS017
        BEQ     1$              ;NO                                     ; CS017
        BIT     #T2.FXD,T.ST2(R0) ;TASK BEING FIXED?                    ; CS017
        BNE     10$             ;IF NE YES                              ; CS017
1$:     BIT     #T3.REM,T.ST3(R0) ;REMOVE TASK ON EXIT?                 ; CS017
        BNE     10$             ;IF NE YES                              ;**-3
        MOV     R3,T.ACTL(R0)   ;SET DEFAULT UIC
        MOV     R0,R3           ;POINT TO TASK STATUS WORD
        ADD     #T.STAT,R3      ;

        .ENDC


        BIC     (SP),(R3)+      ;SET TASK ACTIVE
        CLR     (SP)            ;CLEAR FAILURE INDICATOR
        MOV     R1,T.EFLG(R0)   ;SAVE REQUEST UIC
        MOV     R2,T.UCB(R0)    ;SET ADDRESS OF 'TI' UCB


        .IF DF  D$$ISK

        BIT     #T2.FXD,(R3)    ;TASK FIXED IN MEMORY?
        BNE     20$             ;IF NE YES


        .IF DF  D$$YNM&M$$MGE

        MOV     T.PCB(R0),R1    ;GET ADDRESS OF TASK PCB
        BIT     #PS.SYS,P.STAT(R1) ;SYSTEM CONTROLLED PARTITION?
        BEQ     7$              ;IF EQ NO
        MOV     R0,-(SP)        ;SAVE TASK TCB ADDRESS
        MOV     #P.LGTH,R1      ;SET LENGTH OF BLOCK NEEDED
        CALL    $ALOCB          ;ALLOCATE PCB
        MOV     R0,R2           ;SAVE ADDRESS OF ALLOCATED BLOCK
        MOV     (SP)+,R0        ;RETRIEVE TASK TCB ADDRESS
        ROR     (SP)            ;CAPTURE CARRY BIT
        BEQ     3$              ;IF EQ ALLOCATION WAS SUCCESSFUL
        BIS     (SP),T.STAT(R0) ;SET TASK INACTIVE
        INC     (SP)            ;SET ALLOCATION FAILURE
        CMP     R0,$TKNPT       ;TRYING TO BRING IN TKTN?               ;MSH027
        BEQ     30$             ;YES, EXIT RECURSIVE LOOP               ;MSH027
        BR      10$             ;
3$:     MOV     T.PCB(R0),R1    ;GET MAIN PARTITION PCB ADDRESS
        MOV     R2,T.PCB(R0)    ;SET ADDRESS OF ALLOCATED PCB
        TST     (R2)+           ;SKIP OVER LINK WORD
        MOV     T.PRI(R0),(R2)+ ;SET PRIORITY AND I/O COUNT
        MOV     P.NAM(R1),(R2)+ ;INSERT PARTITION NAME
        MOV     P.NAM+2(R1),(R2)+ ;
        CLR     (R2)+           ;CLEAR POINTER TO NEXT SUBPARTITION
        MOV     R1,(R2)+        ;SET BACK POINTER TO MAIN PARTITION PCB
        CLR     (R2)+           ;CLEAR RELOCATION BASE
        MOV     T.MXSZ(R0),(R2)+ ;SET PARTITION SIZE IN 32W BLOCKS
        CLR     (R2)+           ;CLEAR WAIT QUEUE POINTER
        MOV     T.MXSZ(R0),(R2)+ ;INITIALLIZE SWAP SIZE
        CLR     (R2)+           ;CLEAR PARTITION BUSY FLAGS
        MOV     R0,(R2)+        ;SET OWNER TCB ADDRESS
        MOV     #PS.SYS!PS.DEL,(R2)+ ;SYSTEM CONTROLLED, MARKED FOR DEL
        CLR     (R2)+           ;INITIALLY CLEAR HEADER POINTER


        .IF DF  P$$LAS

        CLR     (R2)+           ;CLEAR PROTECTION WORD
        MOV     R2,R1           ;SAVE POINTER TO ATTACHMENT LISTHEAD
        CLR     (R2)+           ;SET UP ATTACHMENT LISTHEAD
        MOV     R1,(R2)+        ;

        .ENDC


        .ENDC


7$:     MOV     R0,R1           ;COPY TASK TCB ADDRESS
        MOV     T.PCB(R0),R0    ;GET ADDRESS OF TASK PCB
        MOV     P.MAIN(R0),R0   ;GET ADDRESS OF MAIN PARTITION PCB
        ADD     #P.WAIT,R0      ;POINT TO PARTITION WAIT QUEUE LISTHEAD
        CALL    $QINSP          ;PUT TASK IN PARTITION WAIT QUEUE
        MOV     R1,R0           ;RESTORE TCB ADDRESS
10$:    MOV     T.PCB(R0),R0    ;GET ADDRESS OF TASK PARTITION PCB
        CALL    $NXTSK          ;SELECT NEXT TASK
        BR      30$             ;

        .IFTF

20$:    CALL    $BILDS          ;BUILD A STACK FOR TASK

        .IFT

30$:    ASL     (SP)+           ;SET SUCCESS/FAILURE INDICATION

        .IFF

10$:    ASL     (SP)+           ;SET SUCCESS/FAILURE INDICATION

        .ENDC


        RETURN                  ;

;+
; **-$UISET-ESTABLISH DEFAULT UIC AND CURRENT UIC
;
; THIS ROUTINE ESTABLISHES DEFAULT AND CURRENT FOR REQUESTED TASKS
; IN MULTI-USER SYSTEMS.
;
; INPUTS:
;
;       R1=REQUEST UIC
;       R2=ADDRESS OF SECOND STATUS WORD OF CURRENT TASK
;       R4=ADDRESS OF HEADER OF CURRENT TASK
;
; OUTPUTS:
;
;       R1=CURRENT UIC
;       R3=DEFAULT UIC
;               C=1 IF NONPRIVILEGED TASK IS TRYING TO CHANGE UIC
;               C=0 OTHERWISE
;-

        .IF DF  M$$MUP

$UISET::MOV     H.DUIC(R4),R3   ;PROPAGATE DEFAULT UIC
        TST     R1              ;UIC SPECIFIED?
        BEQ     10$             ;IF EQ NO
        MOV     R1,R3           ;USE SPECIFIED UIC
        BIT     #T3.PRV,2(R2)   ;CURRENT TASK PRIVILEGED?
        BNE     20$             ;IF NE YES
        CMP     R1,H.CUIC(R4)   ;NONPRIVILEGED TASK CHANGING UIC?
        BEQ     10$             ;IF EQ NO
        SEC                     ;ELSE RETURN C-BIT SET
10$:    MOV     H.CUIC(R4),R1   ;FORCE PROPAGATION OF CURRENT UIC
20$:    RETURN                  ;

        .ENDC


;+
; **-$MAPTK-MAP TASK ADDRESS WINDOW
;
; THIS ROUTINE IS CALLED TO MAP THE FIRST WINDOW BLOCK IN A TASK'S
; HEADER IN A MAPPED SYSTEM FROM ITS PCB AND TCB.
;
; INPUTS:
;
;       R1=POINTER TO NUMBER OF WINDOW BLOCKS IN THE TASK HEADER.
;       R5=ADDRESS OF THE TASK CONTROL BLOCK FOR THE TASK.
;
; OUTPUTS:
;
;       R1=ADDRESS OF LAST PDR IMAGE IN TASK HEADER.
;       R2 IS MODIFIED.
;-


        .IF DF  M$$MGE

$MAPTK::TST     (R1)+           ;POINT TO TASK WINDOW BLOCK
        MOV     T.PCB(R5),R2    ;PICK UP TASK PCB ADDRESS
        MOV     R2,(R1)+        ;SET TASK PCB ADDRESS (W.BPCB)


        .IF DF  P$$LAS

        BIT     #T3.ROV,T.ST3(R5) ;TASK HAVE RESIDENT OVERLAYS?
        BNE     20$             ;IF NE YES, DON'T CHANGE WINDOW BLOCK   ; CS011
                                                                        ;**-1
        .IFTF

        MOV     (R1)+,(R1)      ;INIT HIGH VIRT ADDR (W.BLVR)(W.BHVR)
        MOV     P.SIZE(R2),R2   ;PICK UP PARTITION SIZE

        .IFT

        SUB     T.OFF(R5),R2    ;REDUCE BY TASK OFFSET IN PARTITION

        .IFTF

        MOV     R2,-(SP)        ;PUSH REQUIRED WINDOW SIZE
        SWAB    (SP)            ;CONVERT TO BYTES
        RORB    (SP)            ;
        ROR     (SP)            ;
        ROR     (SP)            ;
        ADD     (SP)+,(R1)      ;COMPLETE HIGH VIRTUAL ADDRESS (W.BHVR)
        DEC     (R1)+           ;

        .IFT

        TST     (R1)+           ;POINT TO WINDOW SIZE (W.BATT)
        MOV     R2,(R1)+        ;SET WINDOW SIZE (W.BSIZ)
        MOV     T.OFF(R5),(R1)+ ;SET OFFSET IN PARTITION (W.BOFF)
        INC     R1              ;POINT TO NUMBER OF PDR'S

        .IFF

        ADD     #W.BNPD-W.BATT,R1 ;POINT TO NUMBER OF PDR'S BYTE

        .IFTF                                                           ; CS011
                                                                        ;**-1
        ASL     R2              ;SHIFT # PDR'S TO HIGH BYTE             ;**-1
        SWAB    R2              ;# PDR'S TO LO BYTE, LAST PDR SIZE TO HI
        SUB     #377,R2         ;INC # PDR'S & DEC LAST PDR SIZE
        SBC     R2              ;IF CS, EVEN BOUNDARY, REDUCE # PDR'S
        MOVB    R2,(R1)+        ;SET NUMBER OF PDR'S (W.BNPD)
        ROR     R2              ;ADJUST CORRECT SIZE
        MOV     R2,(R1)         ;SET SIZE FOR LAST PDR (W.BLPD)
        MOVB    #6,(R1)         ;SET FOR READ/WRITE ACCESS (W.BLPD)
10$:    RETURN                  ;

        .IFT                                                            ; CS011
                                                                        ; CS011
20$:    ADD     #W.BLPD-W.BLVR,R1 ;POINT TO LAST WORD OF WINDOW BLOCK   ; CS011
        RETURN                                                          ; CS011
                                                                        ;**-1
        .ENDC                                                           ; CS011
                                                                        ; CS011
        .ENDC                                                           ; CS011
                                                                        ; CS011
        .END                                                            ;**-1
M$$CRB=84.              ;MCR COMMAND BUFFER LENGTH
R$$11M=0                ;RSX-11M SYSTEM
;
; EXEC MACROS
;
; ASSUME MACRO FOR CHECKING ADJACENCY AND OFFSET VALUE ASSUMPTIONS
;
 
        .MACRO  ASSUME  A,B=0
        .IF NE <A>-<B>
        .ERROR                  ;EXPRESSION(S) NOT EQUAL
        .ENDC
        .ENDM
 
;
; CALL SUBROUTINE
;

        .MACRO  CALL SUBR ARG
        .IF IDN <$INTSV>,<SUBR>
        JSR     R5,$INTSV
        .IF DF  L$$SI1
        .WORD   ARG
        .IFF
        .WORD   ^C<ARG>&PR7
        .ENDC
        .IFF
        .IF IDN <$SAVNR>,<SUBR>
        JSR     R5,$SAVNR
        .IFF
        .IF IDN <$SWSTK>,<SUBR>
        EMT     376
        .WORD   ARG
        .IFF
        JSR     PC,SUBR
        .ENDC
        .ENDC
        .ENDC
        .ENDM

;
; CALL AND RETURN FROM SUBROUTINE
;

        .MACRO  CALLR SUBR
        JMP     SUBR
        .ENDM

;
; CRASH SYSTEM
;

        .MACRO  CRASH
        IOT
        .ENDM

;
; DIRECTIVE REGISTER SAVE AND SET PRIORITY
;

        .MACRO  DIRSV$
        JSR     R5,$DIRSV
        .ENDM

;
; SET DIRECTIVE STATUS
;

        .MACRO  DRSTS VALUE
        TRAP    VALUE
        .ENDM

;
; GENERATE INTERRUPT ROUTINE ENTRY POINT LABEL
;


        .IF DF  E$$DVC
        .MACRO  INTLB NUM,NAM
$'NAM'NUM'T::
        .ENDM
        .ENDC


;
; INTERRUPT SAVE GENERATION MACRO FOR ERROR LOGGING DEVICES
;

        .MACRO  INTSE$ DEV,PRI,NCTRLR,PSWSV,UCBSV,?LAB
        .IF DF  L$$DRV & LD$'DEV & M$$MGE
$'DEV'INT::
        .IF NDF E$$DVC
        .IF EQ  NCTRLR-1
        CLR     R4
        .ENDC
        .ENDC
        .IFF
        .IF NDF E$$DVC
$'DEV'INT::INTSV$       DEV,PRI,NCTRLR,PSWSV,UCBSV
        .IF EQ  NCTRLR-1
        CLR     R4
        .ENDC
        .MEXIT
        .IFF
$$$=0
        .REPT   NCTRLR
        INTLB   \$$$,DEV
        JSR     R5,$INTSE
        SCBLB   \$$$,DEV
        .IF DF  L$$SI1
        .WORD   PRI
        .IFF
        .WORD   ^C<PRI>&PR7
        .ENDC
        .IF GT  NCTRLR-$$$-1
        BR      LAB
        .ENDC
$$$=$$$+1
        .ENDR
LAB:
        .ENDC
        .ENDC
        GTUCB$  UCBSV,NCTRLR
        .ENDM


;
; INTERRUPT SAVE GENERATION FOR NON-ERROR LOGGING DEVICES
;

        .MACRO  INTSV$  DEV,PRI,NCTRLR,PSWSV,UCBSV
        .IF NDF L$$DRV ! M$$MGE ! LD$'DEV
        .IF GT  NCTRLR-1
        .IF B   <PSWSV>
        MFPS    TEMP
        .IFF
        MFPS    PSWSV
        .ENDC
        .IFTF
        JSR     R5,$INTSV
        .IF DF  L$$SI1
        .WORD   PRI
        .IFF
        .WORD   ^C<PRI>&PR7
        .ENDC
        .IFT
        .IF B   <PSWSV>
        MOV     TEMP,R4
        .IFF
        MOV     PSWSV,R4
        .ENDC
        BIC     #177760,R4
        ASL     R4
        .ENDC
        .ENDC
        GTUCB$  UCBSV,NCTRLR
        .ENDM


;
; GENERATE CODE TO LOAD UCB ADDRESS INTO R5 -- CALLED
; ONLY BY INTSE$ AND INTSV$
;

        .MACRO  GTUCB$  UCBSV,NCTRLR
        .IF NB  <UCBSV>
        .IF GT  NCTRLR-1
        MOV     UCBSV(R4),R5
        .IFF
        MOV     UCBSV,R5
        .ENDC
        .IFF
        .IF GT  NCTRLR-1
        MOV     CNTBL(R4),R5
        .IFF
        MOV     CNTBL,R5
        .ENDC
        .ENDC
        .ENDM


;
; PROCESSOR STATUS READ/WRITE
;

        .IF NDF L$$SI1
        .MACRO  MFPS DST
        MOVB    @#PS,DST
        .ENDM
        .MACRO  MTPS SRC
        .IF IDN <#0>,<SRC>
        CLRB    @#PS
        .IFF
        MOVB    SRC,@#PS
        .ENDC
        .ENDM
        .ENDC


;
; SAVE NONVOLATILE REGISTERS
;

        .MACRO  SAVNR
        JSR     R5,$SAVNR
        .ENDM

;
; GENERATE STATUS CONTROL BLOCK REFERENCE LABEL
;


        .IF DF  E$$DVC
        .MACRO  SCBLB NUM,NAM
        .WORD   $'NAM'NUM
        .ENDM
        .ENDC


;
; RETURN FROM SUBROUTINE
;

        .MACRO  RETURN
        RTS     PC
        .ENDM

;
; SOB LOOP INSTRUCTION
;


        .IF NDF R$$SOB
        .MACRO  SOB     A,B
        DEC     A
        BNE     B
        .ENDM
        .ENDC

;
; STATE SWITCHING MACRO
;

        .MACRO  SWSTK$ ARG
        CALL    $SWSTK,ARG
        .ENDM

        .IF DF  F$$LPP

;
; LOAD FLOATING DOUBLE
;

        .MACRO  LDD A,B
        .NTYPE  N,A
        .NTYPE  M,B
        .WORD   172400+<M*64.>+N
        .ENDM

;
; LOAD FLOATING POINT STATUS
;

        .MACRO  LDFPS A
        .IF IDN <A>,<@H.FPSA(R2)>
        .WORD   170100+72
        .WORD   H.FPSA
        .IFF
        .NTYPE  N,A
        .WORD   170100+N
        .ENDC
        .ENDM

;
; SET DOUBLE FLOATING MODE
;

        .MACRO  SETD
        .WORD   170011
        .ENDM

;
; STORE FLOATING DOUBLE
;

        .MACRO  STD A,B
        .NTYPE  N,A
        .NTYPE  M,B
        .WORD   174000+<N*64.>+M
        .ENDM

;
; STORE FLOATING POINT STATUS
;

        .MACRO  STFPS A
        .NTYPE  N,A
        .WORD   170200+N
        .ENDM

;
; STORE STATUS
;

        .MACRO  STST A
        .WORD   170337
        .WORD   FLSTS
        .ENDM

        .ENDC


;
; GET I/O PACKET MACRO -- USED FOR RSX-11M-PLUS COMPATIBILITY
;
        .MACRO GTPKT$ DEV,NCTRLR,ADDR,UCBSV,SUC
        CALL $GTPKT
        .IF B <ADDR>
        BCC 65535$
        RETURN
65535$:
        .IFF
        BCS ADDR
        .ENDC
        .IF B <UCBSV>
        .IFF
        .IF GT NCTRLR-1
        MOV R5,UCBSV(R3)
        .IFF
        MOV R5,UCBSV
        .ENDC
        .ENDC
        .ENDM
;
; GENERATE THE DRIVER DISPATCH TABLE -- DDT (USED FOR RSX-11M-PLUS COMPATIBILITY)
;
        .MACRO DDT$ DEV,NCTRLR,INY,INX,UCBSV,NEW
$'DEV'TBL::
        .IF B <INX>
        .WORD DEV'INI
        .IFF
        .WORD DEV'INX
        .ENDC
        .WORD DEV'CAN
        .WORD DEV'OUT
        .WORD DEV'PWF
        .IF NB NEW
        .ERR NEW        ; UNSUPPORTED RSX-11M-PLUS FEATURE
        .ENDC
        .IF NB <UCBSV>
UCBSV:  .BLKW   NCTRLR
        .ENDC
        .ENDM
        .IIF NDF S$$YDF , .LIST
        .TITLE  SSTSR
        .IDENT  /10/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 10
;
; D. N. CUTLER 27-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 15-SEP-77
;
;               TM104 -- CHANGE FLOATING POINT PROCESSOR LOGIC FOR
;                       TRANSPORTABILITY.
;
;       CHUCK SPITZ 31-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES AND USE TCB FOR ALL
;                       AST LISTHEADS.
;
;       JOHN COVERT 7-FEB-79
;               JRC001 -- ADD CHECK FOR SST VECTOR NO LONGER MAPPED
;
; SYNCHRONOUS SYSTEM TRAP (SST) SERVICE ROUTINES
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$,HDRDF$,HWDDF$,PKTDF$
        ABODF$                  ;DEFINE TASK ABORT CODES
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS

;
; LOCAL DATA
;
; FLOATING POINT EXCEPTION VECTOR (FINAL SETUP OF THIS VECTOR AND, IF
; NECESSARY, THE PIRQ VECTOR IS PERFORMED IN INITL AND THE MCR SAVE
; COMMAND.)
;


        .IF DF  F$$LPP!F$$LTP

        .ASECT
.=244
        .WORD   $FLTRP          ;
        .WORD   PR7             ;

        .PSECT

        .ENDC


;
; FLOATING POINT STATUS AND FORK BLOCK
;


        .IF DF  F$$LPP

FLSTS:  .BLKW   2               ;FLOATING POINT STATUS
FLFRK:  .BLKW   2               ;FLOATING POINT FORK BLOCK
FLTCB:  .BLKW   1               ;ADDRESS OF TCB CAUSING EXCEPTION TRAP

        .ENDC


;
; SEGMENT FAULT VECTOR
;


        .IF DF  M$$MGE

        .ASECT
.=250
        .WORD   $SGFLT          ;
        .WORD   PR7             ;
        .CSECT

        .ENDC


;+
;
; **-$EMSST-NON RSX EMT/TRAP INSTRUCTION
;
; THIS ROUTINE IS TRANSFERED TO BY THE DIRECTIVE DISPATCHER WHEN A NON RSX
; EMT OR A TRAP INSTRUCTION IS EXECUTED. THE MACHINE STATE HAS ALREADY BEEN
; SAVED. THE EMT/TRAP CODE (LOW BYTE OF INSTRUCTION) IS SETUP TO BE
; PASSED TO THE USER AND CONTROL IS TRANSFERED TO THE SST EXIT ROUTINE.
;
; INPUTS:
;
;       R5=ADDRESS OF THE EMT/TRAP INSTRUCTION.
;
; OUTPUTS:
;
;       04(SP)=EMT/TRAP CODE MULTIPLIED BY 2.
;       02(SP)=SST CODE (SCEMT=EMT, SCTRP=TRAP).
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERED TO USER STACK (6).
;-

        .ENABL  LSB
$EMSST::                        ;REF LABEL


        .IF DF  M$$MGE

        MOV     (SP),R5         ;GET EMT/TRAP INSTRUCTION
        BIC     #177400,(SP)    ;CLEAR INSTRUCTION CODE
        ASL     (SP)            ;MULTIPLY CODE BY 2
        MOV     #S.CEMT,-(SP)   ;ASSUME NON-RSX EMT INSTRUCTION
        BIT     #400,R5         ;EMT INSTRUCTION?

        .IFF

        CLR     -(SP)           ;PICKUP SST CODE
        BISB    (R5)+,(SP)      ;
        ASL     (SP)            ;MULTIPLY CODE BY 2
        MOV     #S.CEMT,-(SP)   ;ASSUME NON-RSX EMT INSTRUCTION
        BITB    #1,(R5)         ;EMT INSTRUCTION

        .ENDC


        BEQ     10$             ;IF EQ YES-SET NUMBER OF BYTES
        MOV     #S.CTRP,(SP)    ;SET FOR TRAP INSTRUCTION
10$:    MOV     #3*2,-(SP)      ;SET NUMBER OF BYTES
        BR      SSTXT           ;TAKE COMMON SST EXIT ROUTINE

;+
; **-$FLTRP-FLOATING POINT EXCEPTION (11/40)
;
; THIS ROUTINE IS TRAPPED TO WHEN AN 11/40 FLOATING POINT EXCEPTION FAULT
; OCCURS. THE CURRENT MACHINE STATE IS SAVED AND CONTROL IS TRANSFERED TO
; THE SST EXIT ROUTINE.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       02(SP)=SST CODE (SCFLT).
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERED TO USER STACK (4).
;-

$FLTRP::                        ;DEFINE UNCONDITIONALLY FOR VECTOR SETUP


        .IF DF  F$$LTP

        DIRSV$                  ;;;SAVE REGISTERS AND CLEAR PRIORITY
        MOV     #S.CFLT,-(SP)   ;SET FOR FLOATING POINT EXCEPTION FAULT
        BR      20$             ;SET NUMBER OF BYTES

        .ENDC


;+
; **-$FPPR7-$FPPR8-$FPPRQ-FLOATING POINT PROCESSOR EXCEPTION HANDLING
;
; THESE ROUTINES HANDLE EXCEPTION FAULTS FROM THE FLOATING POINT
; PROCESSOR.  THE FLOATING POINT EXCEPTION AND ADDRESS REGISTERS AND
; THE CURRENT TASK TCB ARE SAVED AND THEN AN ATTEMPT IS MADE TO QUEUE AN
; AST TO THE TASK AT FORK LEVEL.  THESE ROUTINES SUPPORT TWO MODES OF
; OPERATION DEPENDING ON WHETHER THE FPP'S EXCEPTION FAULTS CAN OCCUR
; WHILE THE PROCESSOR IS AT PRIORITY 7 OR NOT.  IF THE FPP'S EXCEPTION
; FAULT CAN OCCUR WHILE THE PROCESSOR IS AT PRIORITY 7, THEN THE
; PROCESSOR MUST HAVE A PIRQ REGISTER.  INITL AND THE MCR SAVE
; COMMAND DETERMINE WHICH MODE OF OPERATION IS TO BE USED OR NOT
; DEPENDING ON WHETHER THE PROCESSOR HAS A PROGRAM INTERRUPT REQUEST
; REGISTER (PIRQ) OR NOT, AND SET UP THE FPP AND PIRQ VECTORS
; ACCORDINGLY.  THE ROUTINES OPERATE AS FOLLOWS.
;
;    1. IF THE PROCESSOR DOES NOT HAVE A PIRQ REGISTER THEN THE FPP MUST
;       NEVER FAULT WHEN THE PROCESSOR IS AT PRIORITY 7 OR IT MUST BE
;       SYNCHRONOUS.  IN THIS CASE THE FLOATING POINT EXCEPTION VECTOR
;       POINTS TO $FPPR7, AND THE PROCESSOR SIMPLY CALLS INTERRUPT SAVE
;       AND FORK TO GET TO SYSTEM STATE.
;
;    2. IF THE PROCESSOR HAS A PIRQ REGISTER, THE FLOATING POINT EXCEP-
;       TION TRAP VECTOR POINTS TO $FPPR8 AND THE PIRQ VECTOR POINTS TO
;       $FPPRQ.  FLOATING POINT TRAPS ARE CONVERTED TO PIRQ PRIORITY 1
;       INTERRUPTS AFTER SAVING THE FLOATING POINT STATUS.  ON THE PIRQ
;       TRAP AN INT SAVE AND FORK IS USED TO GET TO SYSTEM STATE.  NOTE
;       THAT THIS STRATEGY WOULD ALSO WORK FOR PROCESSORS DESCRIBED IN 1
;       ABOVE.
;
; INPUTS:
;
;       THE FLOATING POINT EXCEPTION REGISTER CONTAINS THE REASON FOR THE
;       FAULT AND THE FLOATING POINT ADDRESS REGISTER CONTAINS THE ADDRESS
;       OF THE FAULTING INSTRUCTION.
;
; OUTPUTS:
;
;       AN ATTEMPT IS MADE TO QUEUE AN AST TO THE TASK CAUSING THE FAULT
;       WITH THE CONTENTS OF THE FLOATING POINT EXCEPTION REGISTER AND
;       AND ADDRESS REGISTER.
;-


        .IF DF  F$$LPP

$FPPR7::STST    FLSTS           ;;;STORE FLOATING POINT EXCEP AND ADDR
        BR      14$             ;;;

$FPPR8::STST    FLSTS           ;;;STORE FLOATING POINT EXCEP AND ADDR
        BIS     #<2*256.>,PIRQ  ;;;POST PROGRAMMED INTERRUPT REQUEST
        RTI                     ;;;WAIT FOR PIRQ INTERRUPT

$FPPRQ::CLR     PIRQ            ;;;DISABLE PROGRAM INTERRUPT REQUEST
14$:    MOV     $TKTCB,FLTCB    ;;;MUST SAVE FAULTING TCB NOW
        CALL    $INTSV,PR1      ;;;GO TO PRIORITY 1
        MOV     #FLFRK+4,R4     ;;;SET ADDRESS OF FORK BLOCK
        CALL    $FORK0          ;;;CREATE A SYSTEM PROCESS
        MOV     #AS.FPA,R4      ;SET FLOATING POINT TYPE AST            ; CS017
        MOV     FLTCB,R5        ;GET TCB ADDRESS OF FAULTING TASK       ;**-1
        CALL    $DASTT          ;DECLARE FLOATING POINT AST
        BCS     15$             ;IF CS NO AST DECLARED
        MOV     FLSTS,A.PRM+2(R1) ;INSERT AST PARAMETERS
        MOV     FLSTS+2,A.PRM(R1) ;
15$:    RETURN                  ;

        .IFF

$FPPR7::                        ;DEFINE LABELS FOR SAVE
$FPPR8::                        ;
$FPPRQ::                        ;

        .ENDC


;+
; **-$ILINS-ILLEGAL OR RESERVED INSTRUCTION
;
; THIS ROUTINE IS TRAPPED TO WHEN AN ILLEGAL OR RESERVED INSTRUCTION
; IS EXECUTED. THE CURRENT MACHINE STATE IS SAVED AND CONTROL IS TRANS-
; FERRED TO THE SST EXIT ROUTINE.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       02(SP)=SST CODE (SCILI).
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERED TO THE USER STACK (4).
;-

$ILINS::DIRSV$                  ;;;SAVE REGISTERS AND SET PRIORITY
        MOV     #S.CILI,-(SP)   ;SET FOR ILLEGAL OR RESERVED INSTRUCTION
        BR      20$             ;SET NUMBER OF BYTES

;+
; **-$IOTRP-IOT INSTRUCTION
;
; THIS ROUTINE IS TRAPPED TO WHEN AN IOT INSTRUCTION IS EXECUTED. IF THE
; STACK DEPTH IS NOT +1, THEN THE SYSTEM IS CRASHED VIA A JUMP TO
; $CRASH. ELSE THE CURRENT MACHINE STATE IS SAVED AND CONTROL IS TRANS-
; FERED TO THE SST EXIT ROUTINE.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       IF THE CURRENT STACK DEPTH IS NOT +1, THEN THE SYSTEM IS CRASHED.
;       ELSE THE FOLLOWING ARGUMENTS ARE SETUP ON THE CURRENT STACK:
;
;       02(SP)=SST CODE (SCIOT).
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERRED TO THE USER STACK (4).
;-

$IOTRP::TST     $STKDP          ;;;RUNNING ON SYSTEM STACK?
        BLE     30$             ;;;IF LE YES-FATAL SYSTEM ERROR
        DIRSV$                  ;;;SAVE REGISTERS AND SET PRIORITY
        MOV     #S.CIOT,-(SP)   ;SET FOR IOT INSTRUCTION
        BR      20$             ;SET NUMBER OF BYTES

;+
; **-$SGFLT-SEGMENT FAULT
;
; THIS ROUTINE IS TRAPPED TO WHEN A SEGMENT FAULT OCCURS. THE CURRENT
; MACHINE STATE IS SAVED, SR0 THRU SR2 ARE SETUP TO BE PASSED TO THE USER,
; AND CONTROL IS TRANSFERED TO THE SST EXIT ROUTINE.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       10(SP)=CONTENTS OF SR0.
;       06(SP)=CONTENTS OF SR2.
;       04(SP)=CONTENTS OF SR1.
;       02(SP)=SST CODE (SCSGF).
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERED TO THE USER STACK (10).
;-


        .IF DF  M$$MGE

$SGFLT::DIRSV$                  ;;;SAVE REGISTERS AND SET PRIORITY
        MOV     #SR0+4,R5       ;POINT SR2
        MOV     (R5),-(SP)      ;SAVE SR2
        MOV     (SP),-(SP)      ;COPY SAVED SR2
        MOV     -(R5),-(SP)     ;SAVE SR1
        MOV     -(R5),4(SP)     ;SAVE SR0
        BIC     #160000,(R5)    ;UNFREEZE MEMORY MANAGEMENT UNIT
        MOV     #S.CSGF,-(SP)   ;SET FOR SEGMENT FAULT
        MOV     #5*2,-(SP)      ;SET NUMBER OF BYTES
        BR      SSTXT           ;TAKE COMMON SST EXIT ROUTINE

        .ENDC


;+
; **-$TRACE-TRACE (T-BIT) OR BREAK POINT INSTRUCTION (BPT) TRAP
;
; THIS ROUTINE IS TRAPPED TO WHEN A TRACE TRAP (T-BIT) OCCURS OR A BREAK-
; POINT TRAP INSTRUCTION IS EXECUTED. THE CURRENT MACHINE STATE IS SAVED
; AND CONTROL IS TRANSFERED TO THE SST EXIT ROUTINE.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       02(SP)=SST CODE (SCBPT).
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERED TO THE USER STACK (4).
;-

$TRACE::DIRSV$                  ;;;SAVE REGISTERS AND SET PRIORITY
        MOV     #S.CBPT,-(SP)   ;SET FOR TRACE OR BREAKPOINT TRAP
        BR      20$             ;SET NUMBER OF BYTES

;+
; **-$TRP04-TRAPS AT 4 (ODD ADDRESS, NONEX MEM, ETC.)
;
; THIS ROUTINE IS TRAPPED TO WHEN A TRAP AT 4 OCCURS. IF A STACK VIOLATION
; HAS CAUSED THE TRAP (I.E. A STACKPOINTER OF LESS THAN 400), THEN THE
; THE SYSTEM IS CRASHED. ELSE THE CURRENT MACHINE STATE IS SAVED AND
; CONTROL IS TRANSFERED TO THE SST EXIT ROUTINE.
;
; INPUTS:
;
;       NONE.
;
; OUTPUTS:
;
;       02(SP)=SST CODE (SCOAD).
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERED TO THE USER STACK (4).
;-

$TRP04::CMP     SP,#400         ;;;STACK VIOLATION?
        BLO     30$             ;;;IF LO YES
        DIRSV$                  ;;;SAVE REGISTERS AND SET PRIORITY
        CLR     -(SP)           ;SET FOR ODD ADDRESS TRAP
20$:    MOV     #2*2,-(SP)      ;SET NUMBER OF BYTES
        BR      SSTXT           ;TAKE COMMON SST EXIT ROUTINE
30$:    JMP     $CRASH          ;;;CRASH THE SYSTEM
        .DSABL  LSB

;+
; **-SSTXT-COMMON SST EXIT ROUTINE
;
; CONTROL IS TRANSFERED TO THIS ROUTINE TO EFFECT AN SST. IF THE CURRENT
; STACK DEPTH IS NOT ZERO, THEN THE SYSTEM IS CRASHED. ELSE AN ATTEMPT IS
; MADE TO EFFECT AN SST FOR THE CURRENT TASK. IF THE TASK DOES NOT HAVE
; AN APPROPRIATE SST VECTOR ENTRY OR A PUSH OF THE SST PARAMETERS ONTO THE
; TASK STACK CANNOT BE EFFECTED, THEN THE TASK IS ABORTED. ELSE THE SST
; IS SETUP AND A DIRECTIVE EXIT IS EXECUTED.
;
; INPUTS:  (MAPPED SYSTEM)
;
;       24(SP)=PS WORD SAVED BY SST TRAP.
;       22(SP)=PC WORD SAVED BY SST TRAP.
;       20(SP)=SAVED R5.
;       16(SP)=SAVED R4.
;       14(SP)=SAVED R3.
;       12(SP)=SAVED R2.
;       10(SP)=SAVED R1.
;       06(SP)=SAVED R0.
;       04(SP)=SST PARAMETER (ZERO OR MORE PARAMETERS MAY BE SPECIFIED).
;       02(SP)=SST CODE.
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERED TO USER STACK.
;
; INPUTS: (REAL MEMORY SYSTEM)
;
;       14(SP)=SAVED R3.
;       12(SP)=SAVED R2.
;       10(SP)=SAVED R1.
;       06(SP)=SAVED R0.
;       04(SP)=SST PARAMETER (ZERO OR MORE PARAMETERS MAY BE SPECIFIED).
;       02(SP)=SST CODE.
;       00(SP)=NUMBER OF BYTES TO BE TRANSFERED TO USER STACK.
;
; OUTPUTS:
;
;       AN ATTEMPT IS MADE TO EFFECT THE SPECIFIED SST FOR THE CURRENT TASK.
;-

SSTXT:  MOV     $HEADR,R5       ;GET ADDRESS OF TASK HEADER


        .IF DF  M$$MGE

        CMP     #-1,$STKDP      ;FAULT OCCUR AT STACK DEPTH ZERO?
        BNE     7$              ;IF NE NO
        MOV     SP,R0           ;COPY CURRENT STACK POINTER
        ADD     (SP),R0         ;ADD NUMBER OF BYTES TO BE TRANSFERED
        MOV     16(R0),R0       ;GET FAULT PC ADDRESS
        CMP     R0,#$DRLM1      ;FAULT OCCUR IN DIRECTIVE DISPATCHER?
        BLO     3$              ;IF LO NO
        CMP     R0,#$DRLM2      ;FAULT OCCUR IN DIRECTIVE DISPATCHER?
        BLOS    90$             ;IF LOS YES
3$:     CMP     R0,#$DQLM1      ;FAULT OCCUR IN QIO DIRECTIVE?
        BLO     4$              ;IF LO NO
        CMP     R0,#$DQLM2      ;FAULT OCCUR IN QIO DIRECTIVE?
        BLOS    90$             ;IF LOS YES
4$:                             ;REFERENCE LABEL


        .IF DF  P$$LAS

        CMP     R0,#$DPLM1      ;FAULT OCCUR RETRIEVING DEF BLOCK ADDR?
        BLO     7$              ;IF LO NO
        CMP     R0,#$DPLM2      ;FAULT OCCUR RETRIEVING DEF BLOCK ADDR?
        BLOS    90$             ;IF LOS YES

        .ENDC


        .IFTF

7$:     TST     $STKDP          ;STACK DEPTH ZERO?
        BNE     60$             ;IF NE NO - FATAL SYSTEM ERROR
        MOV     R5,R4           ;COPY ADDRESS OF HEADER
        ADD     #H.ODVA,R4      ;POINT TO ODT SST VECTOR DESCRIPTOR
        CALL    10$             ;SST ADDRESS IN ODT VECTOR?
        MOV     #80$,-(SP)      ;SST ADDRESS IN TASK VECTOR?
10$:    MOV     (R4)+,R3        ;GET ADDRESS OF SST VECTOR
        BEQ     20$             ;IF EQ NO VECTOR THIS DESCRIPTOR
        CMP     4(SP),(R4)      ;VECTOR LONG ENOUGH TO COVER SST?
        BHIS    20$             ;IF HIS NO
        ADD     4(SP),R3        ;POINT TO APPROPRIATE VECTOR ENTRY
                                                                        ;JRC001
        .IF DF  A$$CHK!M$$MGE                                           ;JRC001
                                                                        ;JRC001
        MOV     R3,R0           ;SUPPLY VECTOR ELEMENT ADDRESS AND      ;JRC001
        MOV     #2,R1           ;TWO BYTE SIZE FOR CALL                 ;JRC001
        CALL    $ACHCK          ;ADDRESS CHECK VECTOR ELEMENT           ;JRC001
        BCS     20$             ;IF CS THEN VECTOR ELEMENT NOT VALID    ;JRC001
                                                                        ;JRC001
        .ENDC   ;DF A$$CHK!M$$MGE                                       ;JRC001

        .IFT

        MFPI    (R3)            ;GET ADDRESS OF SST ROUTINE
        MOV     (SP)+,R3        ;

        .IFF

        MOV     (R3),R3         ;GET ADDRESS OF SST ROUTINE

        .IFTF

        BNE     30$             ;IF NE SST ROUTINE FOUND
20$:    TST     (R4)+           ;POINT TO NEXT VECTOR DESCRIPTOR
        RETURN                  ;
30$:    TST     (SP)+           ;REMOVE RETURN ADDRESS
        MOV     (SP),R1         ;GET NUMBER OF BYTES TO BE TRANSFERED

        .IFT

        MFPI    SP              ;GET CURRENT TASK STACK POINTER
        SUB     R1,(SP)         ;CALCULATE NEW TOP OF STACK
        MOV     (SP),R0         ;COPY NEW TOP OF STACK ADDRESS
        MTPI    SP              ;RESTORE NEW TASK STACK POINTER

        .IFF

        MOV     (R5),R0         ;GET CURRENT TASK STACK POINTER
        SUB     R1,R0           ;CALCULATE NEW TOP OF STACK
        MOV     (R5),R4         ;SAVE CURRENT TASK STACK POINTER
        MOV     R0,(R5)         ;RESTORE NEW TASK STACK POINTER

        .IFTF


        .IF DF  A$$CHK!M$$MGE

        CALL    $ACHCK          ;ADDRESS CHECK PUSH ONTO TASK STACK
        BCS     70$             ;IF CS ADDRESS CHECK FAILURE

        .ENDC


        .IFT

        CALL    $RELOM          ;RELOCATE AND MAP STACK ADDRESS

        .IFF

        MOV     (R4)+,(R0)+     ;MOVE SAVED R4
        MOV     (R4),(R0)+      ;MOVE SAVED R5
        MOV     R3,(R0)+        ;SET SST PC WORD
        CLR     (R0)+           ;SET SST PS WORD

        .IFTF

        MOV     (SP)+,R1        ;GET NUMBER OF BYTES TO TRANSFER
        CMP     -(R1),-(R1)     ;ADJUST BY 4 BYTES (PS AND PC WORDS)
        ASR     R1              ;CONVERT TO WORD COUNT
        TST     (SP)+           ;REMOVE SST CODE FROM STACK
40$:    DEC     R1              ;ANY MORE PARAMETERS TO TRANSFER?
        BLT     50$             ;IF LT NO
        MOV     (SP)+,(R0)+     ;TRANSFER PARAMETER TO TASK STACK
        BR      40$             ;
50$:                            ;REF LABEL

        .IFT

        MOV     #$STACK-4,R4    ;POINT TO SAVED PC WORD
        MOV     (R4),(R0)+      ;SAVE PC AT TRAP ON USER STACK
        MOV     R3,(R4)+        ;SET SST PC WORD
        MOV     (R4),(R0)       ;SAVE PS AT TRAP ON USER STACK
        MOV     #CMODE!PMODE,(R4) ;SET SST PS WORD

        .IFTF

        RETURN                  ;EXIT FROM TRAP

;
; SST FAULT AT NON ZERO STACK DEPTH-FATAL SYSTEM ERROR
;

60$:    CRASH                   ;CRASH SYSTEM

;
; SST CANNOT BE EFFECTED BECAUSE OF BAD TASK STACK
;


        .IF DF  A$$CHK!M$$MGE

70$:    MOV     #S.CSST,2(SP)   ;SET BAD STACK SST ABORT CODE

        .ENDC


;
; SST CANNOT BE EFFECTED BECAUSE OF NO SST VECTOR ENTRY
;

80$:    MOV     2(SP),R0        ;SET SST ABORT CODE

        .IFT

        MOV     #$STACK-22,SP   ;RELOAD EXEC STACK POINTER

        .IFF

        MOV     #$STACK-12,SP   ;RELOAD EXEC STACK POINTER

        .IFTF

        CALLR   $ABCTK          ;ABORT CURRENT TASK

;
; FAULT FROM PROTECTED LIMITS IN DRDSP OR DRQIO
;

        .IFT

90$:    INC     $STKDP          ;CORRECT STACK DEPTH INDICATOR
        DRSTS   D.RS98          ;SET DIRECTIVE STATUS

        .ENDC


        .END
        .TITLE  SYSCM
        .IDENT  /15/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 15
;
; D. N. CUTLER 11-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
; 
;       T. J. MILLER 19-JUL-77
;
;               TM095 -- DATA STRUCTURES REQUIRED FOR DYNAMIC UMR
;                       ALLOCATION.
;       B. SCHREIBER 28-JUL-77
;
;               BS004 -- CHANGE SYSTEM IDENTIFICATION.
;
;       T. J. MILLER 13-SEP-77
;
;               TM101 -- REMOVE NULL TASK HEADER, PCB, AND MOST OF TCB
;                       FOR ELIMINATION OF NULL TASK.
;
;               TM103 -- ENHANCED CLOCK SUPPORT.
;
;       CHUCK SPITZ 3-MAY-78
;
;               CS012 -- CORRECT ERROR LOGGING CONDITIONALS
;
;       CHUCK SPITZ 25-JUN-78
;
;               CS013 -- ADD SUPPORT FOR NEW TERMINAL DRIVER
;
;       B. SCHREIBER    14-JUL-78
;
;               BS063 -- CHANGE SYSTEM IDENTIFICATION.
;
;       CHUCK SPITZ     5-SEP-78
;
;               CS017 -- ADD STOP BIT DIRECTIVES AND CHANGE SYS ID
;
;       J. E. PROVINO   18-SEP-78
;
;               JP048 -- CHANGE $CMEND TO $CMFIN
;
;
;       CHUCK SPITZ     30-OCT-78
;               CS018 -- ADD PARENT OFFSPRING TASKING
;
;       CHUCK SPITZ 8-DEC-78
;               CS020 -- ADD GROUP GLOBAL EF'S
;
;       CHUCK SPITZ     8-DEC-78
;               CS021 -- ADD DISABLE CONTEXT SWITCHING
;
;       CHUCK SPITZ 4-MAY-79
;               CS033 -- ADD MULTIPLE CLI SUPPORT FOR DECNET
; SYSTEM COMMON DATA AREA
;
; MACRO LIBRARY CALLS
;

        .MCALL  HDRDF$,HWDDF$,TCBDF$
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS

;
; MAKE CLOCK PARAMETERS GLOBAL
;

S$$RTZ==H$$RTZ                  ;LINE FREQUENCY
S$$IEN==K$$IEN                  ;ENABLE BITS PATTERN
S$$LDC==K$$LDC                  ;LOAD VALUE FOR COUNT REGISTER
S$$TPS==K$$TPS                  ;TICKS PER SECOND ON P CLOCK

;
; LOCAL SYMBOL DEFINITIONS
;
; FUNCTION MASK LITERAL
;

FMASK=  0                       ;INITIALIZE FUNCTION MASK


        .IF DF  M$$EXT&M$$MGE

FMASK=  FMASK!FE.EXT            ;INCLUDE EXTENDED MEMORY MASK

        .ENDC


        .IF DF  M$$MUP

FMASK=  FMASK!FE.MUP            ;INCLUDE MULTI-USER PROTECTION MASK

        .ENDC


        .IF DF  R$$EXV

FMASK=  FMASK!FE.EXV            ;INCLUDE EXTENDED VIRT ADDR MASK

        .ENDC


        .IF DF  L$$DRV

FMASK=  FMASK!FE.DRV

        .ENDC


        .IF DF  P$$LAS

FMASK=  FMASK!FE.PLA            ;PLAS SUPPORT

        .ENDC


        .IF DF  Q$$OPT

FMASK=  FMASK!FE.PKT            ;QIO PACKET PREALLOCATION

        .ENDC


        .IF DF  C$$CKP&D$$YNC

FMASK=  FMASK!FE.CAL            ;DYNAMIC CHECKPOINT SPACE ALLOCATION

        .ENDC


        .IF DF  E$$XPR&M$$MGE&D$$YNM

FMASK=  FMASK!FE.EXP            ;EXTEND TASK DIRECTIVE

        .ENDC


        .IF DF  L$$SI1

FMASK=  FMASK!FE.LSI            ;PROCESSOR IS AN LSI-11

        .ENDC
                                                                        ; CS018
        .IF DF P$$OFF                                                   ; CS018
                                                                        ; CS018
FMASK=  FMASK!FE.OFF            ;PARENT OFFSPRING TASKING               ; CS018
                                                                        ; CS018
        .ENDC                                                           ; CS018
                                                                        ; CS013
        .IF DF T$$CPW                                                   ; CS013
                                                                        ; CS013
FMASK=  FMASK!FE.FDT            ;FULL DUPLEX TERMINAL DRIVER            ; CS013
                                                                        ; CS013
        .ENDC                                                           ; CS013
                                                                        ; CS013
        .IF DF M$$MGE&D$$YNM                                            ; CS013
                                                                        ; CS013
FMASK=  FMASK!FE.DYM            ;DYNAMIC MEMORY ALLOCATION              ; CS013
                                                                        ; CS013
        .ENDC                                                           ; CS013
                                                                        ; CS013


;
; NULL TASK CONTROL BLOCK
;
; THIS TCB TERMINATES THE SYSTEM AND ACTIVE TASK LISTS.  IT MUST HAVE
; A PRIORITY OF ZERO AND ALWAYS BE BLOCKED.  REQUIRED POSITIONS ARE
; ENFORCED BY THE "ASSUME" MACRO.
;

$CMBEG::                        ;BEGINNING OF SYSCM AREA FOR CDA
$HEADR::.WORD   0               ;T.LNK-POINTER TO CURRENT TASK HEADER
        ASSUME  .-$HEADR,T.PRI  ;T.PRI MUST BE ZERO
        .BYTE   0               ;T.PRI-NULL TASK PRIORITY IS ZERO
$CURPR::.BYTE   0               ;T.IOC-CURRENT TASK PRIORITY
$COMEF::.WORD   0               ;T.TCB-COMMON EVENT FLAGS 1-16
        .WORD   0               ;T.NAM-COMMON EVENT FLAGS 17-32
$SYSID::.ASCII  /26  /          ;T.NAM+2,T.RCVL-SYSTEM IDENTIFICATION   ; CS017
$TKNPT::.WORD   0               ;T.RCVL+2-POINTER TO TKTN TCB           ;**-1
$SHFPT::.WORD   0               ;T.ASTL-POINTER TO SHUFFLER TCB
$CKCNT::.WORD   K$$CNT          ;T.ASTL+2-ADDRESS OF CLOCK COUNT REG
$CKCSR::.WORD   K$$CSR          ;T.EFLG-ADDR OF CLOCK CNTRL STATUS REG


        .IF EQ  K$$CSR-177546

$CKLDC::.WORD   0               ;T.EFLG+2-CLOCK LOAD COUNT

        .IFF

$CKLDC::.WORD   K$$LDC          ;T.EFLG+2-CLOCK LOAD COUNT

        .ENDC


$SYUIC::                        ;


        .IF DF  M$$MGE

        .BYTE   54,1            ;T.UCB-DEFAULT MAPPED SYSTEM UIC

        .IFF

        .BYTE   50,1            ;T.UCB-DEFAULT UNMAPPED SYSTEM UIC

        .ENDC


        ASSUME  .-$HEADR,T.TCBL ;T.TCBL MUST BE ZERO


        .IF NDF E$$DVC&E$$NSI&E$$PER                                    ; CS012
                                                                        ;**-1
$ERRSQ::                        ;ERROR SEQ # ALWAYS ZERO IF NO LOGGING

        .ENDC


        .WORD   0               ;T.TCBL-LINK TO NEXT TCB
        ASSUME  .-$HEADR,T.STAT ;T.STAT MUST BE NONZERO
$EXSIZ::.WORD   $SYTOP          ;T.STAT-ADDR OF LAST BYTE IN EXEC
$PWRFL::.WORD   1               ;T.ST2-POWERFAIL RECOVERY REQUEST FLAG
$SIGFL::.WORD   0               ;T.ST3-TASK WAITING FOR SIG EVENT
$LOGHD::.WORD   0               ;T.NRPC-LOGICAL DEVICE ASSIGNMENT LIST
$MCRCB::.WORD   0               ;T.LBN+1-MCR COMMAND BLOCK ADDRESS
$LSTLK::.WORD   0               ;T.LDV-LOCK WORD (TCB ADDRESS OF OWNER)
        .WORD   3               ;T.PCB-CONSTANT FOR ALLOCATION ROUTINES
$CRAVL::.WORD   $SYBEG          ;T.MXSZ-ACTIVE TASK LIST LISTHEAD
        ASSUME  .-$HEADR,T.ACTL ;T.ACTL MUST BE ZERO
        .WORD   0               ;T.ACTL-NEXT ACTIVE TASK-DUMMY BLK SIZE

;
; END OF SUPERIMPOSED AREA-REMAINING SYSTEM COMMON AREA
;

$ACTHD::.WORD   $HEADR          ;ACTIVE TASK LIST LISTHEAD
$ABTIM::.WORD   0               ;ABSOLUTE TIME COUNTER
$TKTCB::.WORD   $HEADR          ;POINTER TO CURRENT TASK TCB
$RQSCH::.WORD   $HEADR          ;SCHEDULE REQUEST TCB ADDRESS
$STKDP::.WORD   0               ;STACK DEPTH INDICATOR
$DEVHD::.WORD   $DEVTB          ;POINTER TO FIRST DEVICE CONTROL BLOCK
$MCRPT::.WORD   0               ;POINTER TO MCR TCB
                                                                        ; CS033
        .IF DF M$$CLI                                                   ; CS033
                                                                        ; CS033
        .ASCIZ  <15><12>/MCR>/  ;MCR PROMPT STRING                      ; CS033
        .EVEN                                                           ; CS033
                                                                        ; CS033
        .ENDC   ;M$$CLI                                                 ; CS033
                                                                        ; CS033
$ERRPT::.WORD   0               ;POINTER TO ERROR LOGGER TCB
$CFLPT::.WORD   0               ;POINTER TO FIRST CHECKPOINT FILE PCB
        .BLKW   1               ;CLOCK INTERRUPT FORK BLOCK LINK
        .BLKW   1               ;CLOCK INTERRUPT FORK BLOCK PC
$INTCT::.WORD   -1              ;CLOCK INTERRUPT TICKS COUNT
$FRKHD::.WORD   0               ;FORK QUEUE LISTHEAD
        .WORD   $FRKHD          ;(LAST POINTS TO FIRST INITIALLY)
$FMASK::.WORD   FMASK           ;SYSTEM FEATURE MASK


        .IF DF  P$$RTY

$PARPT::.WORD   $PARTB          ;PARITY ADDRESS VECTOR TABLE POINTER

        .IFF

$PARPT::.WORD   0               ;PARITY ADDRESS VECTOR TABLE POINTER

        .ENDC


$CLKHD::.WORD   0               ;CLOCK QUEUE
$COPT:: .WORD   .CO0            ;POINTER TO COMMAND OUTPUT UCB


        .IF NDF L$$LDR&R$$11S

$PARHD::.WORD   $PCBS           ;POINTER TO PARTITION LIST
$LDRPT::.WORD   .LDR            ;POINTER TO LOADER TCB
$TSKHD::.WORD   $STD            ;POINTER TO SYSTEM TASK DIRECTORY

        .IFF

$PARHD::.WORD   0               ;POINTER TO PARTITION LIST
$LDRPT::.WORD   0               ;POINTER TO LOADER TCB
$TSKHD::.WORD   $HEADR          ;POINTER TO SYSTEM TASK DIRECTORY

        .ENDC

$GGEF:: .WORD   0               ;GROUP GLOBAL EVENT FLAGS POINTER       ; CS020

$IDLCT::.BYTE   0               ;IDLE PATTERN COUNT BYTE
$IDLFL::.BYTE   0               ;IDLE PATTERN FLAG BYTE
$IDLPT::.WORD   7760            ;IDLE PATTERN WORD

;
; DAYS PER MONTH TABLE (ENTRY CONTAINS DAYS PER MONTH + 1)
;

$DYPMN::.BYTE   29.,32.         ;FEBRUARY, MARCH
        .BYTE   31.,32.         ;APRIL, MAY
        .BYTE   31.,32.         ;JUNE, JULY
        .BYTE   32.,31.         ;AUGUST, SEPTEMBER
        .BYTE   32.,31.         ;OCTOBER, NOVEMBER
        .BYTE   32.,32.         ;DECEMBER, JANUARY

;
; BIT MASK TABLE
;

$BTMSK::.WORD   1               ;BIT 0.
        .WORD   2               ;BIT 1.
        .WORD   4               ;BIT 2.
        .WORD   10              ;BIT 3.
        .WORD   20              ;BIT 4.
        .WORD   40              ;BIT 5.
        .WORD   100             ;BIT 6.
        .WORD   200             ;BIT 7.
        .WORD   400             ;BIT 8.
        .WORD   1000            ;BIT 9.
        .WORD   2000            ;BIT 10.
        .WORD   4000            ;BIT 11.
        .WORD   10000           ;BIT 12.
        .WORD   20000           ;BIT 13.
        .WORD   40000           ;BIT 14.
        .WORD   100000          ;BIT 15.

;
; ONLINE ERROR LOGGING DATA BASE
;


        .IF DF  E$$DVC!E$$NSI!E$$PER                                    ; CS012
                                                                        ;**-1
$ERRHD::.WORD   0               ;ERROR LOGGING MESSAGE QUEUE LISTHEAD
        .WORD   .-2             ;
$ERRLM::.WORD   512.            ;LIMIT ON RESIDENT ERROR LOGGING DATA
$ERRSQ::.WORD   0               ;UNIVERSAL ERROR SEQUENCE NUMBER
$ERRSV::.WORD   0               ;POINTER TO ERROR FILE IDENTIFICATION
$ERRSZ::.WORD   0               ;RESIDENT BYTES OF ERROR LOGGING DATA
$IOABM::.WORD   0               ;DEVICE I/O ACTIVE BITMAP

        .ENDC


;
; SYSTEM BOOTSTRAP AND SAVE CONFIGURATION VECTOR
;

$SYSIZ::.WORD   S$$YSZ          ;SIZE OF MEMORY IN 32W BLOCKS
        .BLKB   1               ;PHYSICAL UNIT NUMBER OF LOAD DEVICE
        .BLKB   3               ;LBN OF LOAD/SAVE IMAGE ON DISK
        .BLKW   1               ;NAME OF LOAD DEVICE IN ASCII
        .BLKW   1               ;SIZE OF LOAD IMAGE IN 256W BLOCKS

;
; TIME LIMIT PARAMETERS
;

        .WORD   -1              ;YEARS PER UNIVERSE
        .WORD   13.             ;MONTHS PER YEAR
        .WORD   32.             ;DAYS PER MONTH (CALCULATED)
        .WORD   24.             ;HOURS PER DAY
        .WORD   60.             ;MINUTES PER HOUR
        .WORD   60.             ;SECONDS PER MINUTE


        .IF EQ  K$$CSR-177546

$TKPS:: .WORD   H$$RTZ          ;TICKS PER SECOND

        .IFF

$TKPS:: .WORD   K$$TPS          ;TICKS PER SECOND

        .ENDC


;
; CURRENT TIME VECTOR
;

        .WORD   74.             ;YEAR OF UNIVERSE
        .WORD   4               ;MONTH OF YEAR
        .WORD   29.             ;DAY OF MONTH
        .WORD   0               ;HOUR OF DAY
        .WORD   0               ;MINUTE OF HOUR
        .WORD   0               ;SECOND OF MINUTE
$TTNS:: .WORD   0               ;TICK OF SECOND

;
; LIFO SEND AND I/O PREALLOCATION LIST POINTER AND PARAMETERS
;


        .IF DF  Q$$OPT

$PKAVL::.WORD   0               ;POINTER TO FIRST PACKET IN LIST
$PKNUM::.BYTE   0               ;NUMBER OF PACKETS CURRENTLY IN LIST
$PKMAX::.BYTE   Q$$OPT          ;MAXIMUM NUMBER ALLOWED IN LIST

        .IFF

$PKNUM::                        ;REF LABEL FOR MCR
$PKMAX::                        ;REF LABEL FOR MCR

        .ENDC


;
; GLOBAL TASK SIZE LIMIT FOR EXTEND TASK DIRECTIVE
;


        .IF DF  E$$XPR&M$$MGE&D$$YNM

$MXEXT::.WORD   177777          ;INITIALIZE TO NO LIMIT

        .IFF

$MXEXT::                        ;REF LABEL

        .ENDC


;
; UMR ALLOCATION LISTHEAD AND WAIT QUEUE LISTHEAD.  THE ALLOCATION
; LISTHEAD DOUBLES AS A DESCRIPTOR OF THE UMR'S STATICLY ALLOCATED TO
; THE EXEC AND ANYONE ELSE.
;


        .IF DF  M$$EXT

$UMRHD::.WORD   0               ;MAPPING ASSIGNMENT BLOCK LISTHEAD
        .WORD   UBMPR           ;ADDRESS OF FIRST ASSIGNED UMR
        .WORD   N$$UMR          ;NUMBER OF UMR'S STATICLY ASSIGNED * 4
$UMRWT::.WORD   0,.-2           ;UMR WAIT QUEUE LISTHEAD

        .ENDC
                                                                        ; CS013
                                                                        ; CS013
;                                                                       ; CS013
; TEMPORARY STROAGE AREA FOR $GSPKT                                     ; CS013
;                                                                       ; CS013
                                                                        ; CS013
        .IF DF T$$CPW                                                   ; CS013
                                                                        ; CS013
$TEMP2::.BLKW   1               ;TEMP STORAGE FOR $GSPKT                ; CS013
                                                                        ; CS013
        .ENDC                                                           ; CS013
                                                                        ; CS013
;                                                                       ; CS013
; TEMPORARY STORAGE FOR SPAWN                                           ; CS013
;                                                                       ; CS013
                                                                        ; CS013
        .IF DF P$$OFF                                                   ; CS013
                                                                        ; CS013
$TEMP0::.WORD   0                                                       ; CS013
$TEMP1::.WORD   0                                                       ; CS013
                                                                        ; CS013
        .ENDC   ;P$$OFF                                                 ; CS013
                                                                        ; CS013

$DICSV::.WORD   0               ;TEMP STORAGE OF DIC                    ; CS017
$MOULS::.WORD   0               ;MOUNTED DEVICE LISTHEAD                ; CS017
                                                                        ; CS017
$CXDBL::.BYTE   0               ;CONTEXT SWITCHING DISABLED FLAG (0=NO) ; CS021
        .EVEN                                                           ; CS021
                                                                        ; CS021

$CMFIN::                        ;END OF SYSCM AREA FOR CDA              ; JP048
        .END                                                            ;**-1
        .TITLE  SYSDF
        .IDENT  /08/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 08
;
; D. N. CUTLER 23-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       P. WANNHEDEN 8-JUN-77
;
;               PW001 -- ADD DEFINITIONS OF:
;                       D.RS17 - VECTOR ALREADY IN USE (CINT$)
;                       D.RS19 - ILLEGAL VECTOR (CINT$)
;                       D.RS81 - MAPPING ERROR (CINT$)
;
;       P. WANNHEDEN 13-JUN-77
;
;               PW002 -- DEFINE ITB OFFSETS AND LENGTH GLOBALLY.
;
;       J. PROVINO 5-SEP-78
;
;               JP048 -- NEW SYMBOLS FOR CDA
;
;       CHUCK SPITZ 15-DEC-78
;               CS022 -- GLOBALLY DEFINE TCB OFFSETS
;
;       CHUCK SPITZ 24-JAN-79
;               CS020 -- GROUP GLOBAL EVENT FLAGS
;
; SYSTEM GLOBAL AND CONTROL BLOCK OFFSET DEFINITIONS
;
; GLOBALLY DEFINE THE HIGHEST VECTOR ADDRESS
;

        .GLOBL  V$$CTR

;
; DEFINE SYSTEM DEPENDENT CONTROL BLOCK OFFSETS AND LENGTHS GLOBALLY
;

        .MCALL  ITBDF$,PCBDF$,PKTDF$,SCBDF$,TCBDF$,HWDDF$               ; CS020
        ITBDF$  <:>,<=>,SYSDEF          ;DEFINE ITB OFFSETS AND LENGTH  ;**-1
        PCBDF$  <:>,<=>,SYSDEF          ;DEFINE PCB OFFSETS AND LENGTH
        SCBDF$  <:>,,SYSDEF             ;DEFINE SCB OFFSETS
        TCBDF$  <:>,<=>,SYSDEF          ;DEFINE TCB OFFSETS             ; CS022
                                                                        ;**-1
        HWDDF$  ,<=>                    ;DEFINE HARDWARE OFFSETS        ; CS020
;
; CAUSE OFFSET DEFINITIONS FROM PREFIX FILES TO BE LISTED
;

S$$YDF=0

;
; SYSTEM GLOBAL SYMBOL DEFINITIONS
;
; DIRECTIVE STATUS CODES
;
; INSUFFICIENT DYNAMIC CORE AVAILABLE TO SATISFY REQUEST
;

D.RS1==-1.                      ;

;
; SPECIFIED TASK NOT INSTALLED IN THE SYSTEM
;

D.RS2==-2.                      ;

;
; UNASSIGNED LUN
;

D.RS5==-5.                      ;

;
; DRIVER NOT LOADED
;

D.RS6==-6.                      ;
;
; TASK NOT ACTIVE
;

D.RS7==-7.                      ;

;
; TASK NOT SUSPENDED/NO DATA QUEUED/TASK CHECKPOINTING ALREADY ENABLED
; OR DISABLED/AST RECOGNITION ALREADY ENABLED OR DISABLED/AST ENTRY ALREADY
; UNSPECIFIED
;

D.RS8==-8.                      ;

;
; ISSUING TASK NOT CHECKPOINTABLE
;

D.RS10==-10.                    ;

;
; PRIVILEGE VIOLATION
;

D.RS16==-16.                    ;

;
; VECTOR ALREADY IN USE (CINT$)
;

D.RS17==-17.

;
; ILLEGAL VECTOR (CINT$)
;

D.RS19==-19.

;
; DIRECTIVE ISSUED/NOT ISSUED FROM AST ROUTINE
;

D.RS80==-80.                    ;

;
; CANNOT MAP ISR OR DISABLE-INTERRUPT ROUTINE (CINT$)
;

D.RS81==-81.

;
; ALIGNMENT ERROR
;

D.RS84==-84.                    ;

;
; ADDRESS WINDOW OVERFLOW
;

D.RS85==-85.                    ;

;
; INVALID REGION ID
;

D.RS86==-86.                    ;

;
; INVALID WINDOW ID
;

D.RS87==-87.                    ;

;
; SPECIFIED LUN IS LOCKED IN USE.
;

D.RS90==-90.                    ;

;                                                                       ; CS020
; INVALID UIC                                                           ; CS020
;                                                                       ; CS020
                                                                        ; CS020
D.RS91==-91.                    ;                                       ; CS020
                                                                        ; CS020
;
; INVALID DEVICE AND/OR UNIT SPECIFIED.
;

D.RS92==-92.                    ;

;
; INVALID TIME PARAMETER
;

D.RS93==-93.                    ;

;
; PARTITION/REGION NOT IN SYSTEM
;

D.RS94==-94.                    ;

;
; INVALID PRIORITY
;

D.RS95==-95.                    ;

;
; INVALID LUN
;

D.RS96==-96.                    ;

;
; INVALID EFN OR REQUIRED EFN NOT SPECIFIED
;

D.RS97==-97.                    ;

;
; PART OF DPB IS OUTSIDE OF ISSUING TASK'S ADDRESS SPACE
;

D.RS98==-98.                    ;

;
; INVALID DIC OR DPB SIZE
;

D.RS99==-99.                    ;

;
; EFN WAS SET
;

D.RS22==2.                      ;

;
; EFN WAS CLEAR
;

D.RS00==0.                      ;

;
; IF DYNAMIC ALLOCATION IS PRESENT DEFINE D$$YNM GLOBALLY
;

        .IIF DF D$$YNM , D$$YNM==0 ;

;
; IF 11/70 EXTENDED MEMORY IS PRESENT DEFINE M$$EXT GLOBALLY
;

        .IIF DF M$$EXT , M$$EXT==0 ;

;
; IF MEMORY MANAGEMENT IS PRESENT DEFINE M$$MGE GLOBALLY
;

        .IIF DF M$$MGE , M$$MGE==0 ;

                                                                        ; JP048
;                                                                       ; JP048
; IF SEND / RECEIVE BY REFERENCE SUPPORTED, DEFINE P$$SRF GLOBALLY      ; JP048
;                                                                       ; JP048
                                                                        ; JP048
        .IIF DF P$$SRF , P$$SRF==P$$SRF                                 ; JP048
                                                                        ; JP048
        .END
        .TITLE  SYSXT
        .IDENT  /11.03/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 11.03
;
; D. N. CUTLER 10-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 11-MAR-77
;
;               TM075 -- CLEAR I.PRM+16 ON COMPLETION OF TERMINAL I/O.
;
;       P. WANNHEDEN 8-JUN-77
;
;               PW001 -- ADDITION OF SPECIAL INTERRUPT SAVE ROUTINE
;                       AND FORK ROUTINE FOR USE IN CONJUNCTION
;                       WITH THE CINT$ DIRECTIVE.
;                       CALL ROUTINE WHOSE ADDRESS IS STORED IN AST BLOCK
;                       WHEN DEQUEUING AST BLOCK WITH A.CBL=0.
;
;       T. J. MILLER 12-SEP-77
;
;               TM101 -- REPLACE NULL TASK WITH IDLE CODE IN EXEC.
; 
;       CHUCK SPITZ 25-JUN-78
;               CS013 -- ADD SUPPORT TO $FINBF FOR FD TTDRV
;
;       CHUCK SPITZ 30-AUG-78
;               CS017 -- ADD STOP BIT DIRECTIVES AND USE TCB FOR ALL
;                       AST LISTHEADS.
;
;       CHUCK SPITZ 25-OCT-78
;               CS018 -- ADD PARENT OFFSPRING TASKINGAND FIX $FINBF TO
;                       HANDLE ZERO LENGTH TRANSFERS.
;
;       B. S. MCCARTHY 29-NOV-78
;               BM003 -- CORRECT ERROR IN PARENT OFFSPRING TASKING
;                        (HANDLING OF EXIT AST'S)
;
;       CHUCK SPITZ 8-DEC-78
;               CS020 -- ADD GROUP GLOBAL EF'S
;
;       CHUCK SPITZ 8-DEC-78
;               CS021 -- ADD DISABLE CONTEXT SWITCHING
;
;       CHUCK SPITZ 19-DEC-78
;               CS024 -- USE $SGFIN IN INITL
;
;
; SYSTEM ENTRANCE, EXIT, AND PROCESSOR DISPATCHING
;
; MACRO LIBRARY CALLS
;

        .MCALL  ABODF$,HDRDF$,HWDDF$,PCBDF$,TCBDF$
        .MCALL  ITBDF$,DCBDF$                                           ; CS013
        ABODF$                  ;DEFINE TASK ABORT CODES                ;**-1
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
        ITBDF$                  ;DEFINE INTERRUPT TRANSFER BLOCK OFFSETS
        DCBDF$                  ;DEFINE DEVICE CONTROL BLOCK OFFSETS    ; CS013

;+
; **-$DIRSV-DIRECTIVE SAVE
;
; THIS ROUTINE IS CALLED FROM DIRECTIVE LEVEL TRAP SERVICE ROUTINES. THE
; STACK DEPTH IS +1, THUS A SWITCH TO THE SYSTEM STACK IS ALWAYS NEC-
; ESSARY. AT THE END OF TRAP PROCESSING A RETURN IS EXECUTED TO EXIT
; FROM THE SYSTEM.
;
; INPUTS:
;
;       4(SP)=PS WORD PUSHED BY TRAP.
;       2(SP)=PC WORD PUSHED BY TRAP.
;       0(SP)=SAVED R5 PUSHED BY 'JSR R5,$DIRSV'.
;
; OUTPUTS:
;
;       REGISTER R4 IS PUSHED ONTO THE CURRENT STACK AND THEN A SWITCH
;       TO THE SYSTEM STACK IS EXECUTED. REGISTERS R3 THRU R0 ARE
;       PUSHED ON THE SYSTEM STACK, THE NEW PROCESSOR PRIORITY IS
;       SET, AND A CALL TO THE CALLER IS EXECUTED.
;-

$DIRSV::MOV     R4,-(SP)        ;;;SAVE REGISTER R4
        DEC     $STKDP          ;;;SET PROPER STACK DEPTH
        BNE     10$             ;;;IF NE DON'T SWITCH STACKS
        MOV     SP,@$HEADR      ;;;SAVE CURRENT STACK POINTER


        .IF NDF M$$MGE

        MOV     #$STACK,SP      ;;;LOAD SYSTEM STACK POINTER

        .ENDC


10$:    MTPS    #0              ;;;ALLOW INTERRUPTS
        MOV     R3,-(SP)        ;SAVE REGISTERS R3 THRU R0
        MOV     R2,-(SP)        ;
        MOV     R1,-(SP)        ;
        MOV     R0,-(SP)        ;
        CALL    (R5)            ;CALL SYNCHRONOUS TRAP ROUTINE
        BR      $DIRXT          ;EXIT FROM TRAP

;+
; **-$FORK-FORK AND CREATE SYSTEM PROCESS
;
; THIS ROUTINE IS CALLED FROM AN I/O DRIVER TO CREATE A SYSTEM PROCESS THAT
; WILL RETURN TO THE DRIVER AT STACK DEPTH ZERO TO FINISH PROCESSING.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB FOR THE UNIT BEING PROCESSED.
;
; OUTPUTS:
;
;       REGISTERS R5 AND R4 ARE SAVED IN THE CONTROLLER FORK BLOCK AND
;       A SYSTEM PROCESS IS CREATED. THE PROCESS IS LINKED TO THE FORK
;       QUEUE AND A JUMP TO $INTXT IS EXECUTED.
;-

$FORK:: MOV     R4,-(SP)        ;SAVE REGISTER R4
        MOV     U.SCB(R5),R4    ;POINT TO CONTROLLER STATUS BLOCK
        CLRB    S.CTM(R4)       ;DISABLE TIMEOUT
        ADD     #S.FRK+6,R4     ;POINT TO END OF FORK BLOCK
        MOV     (SP)+,(R4)      ;PUT SAVED R4 IN FORK BLOCK

;+
; **-$FORK1-FORK AND CREATE SYSTEM PROCESS
;
; THIS ROUTINE IS AN ALTERNATE ENTRY TO CREATE A SYSTEM PROCESS AND
; SAVE REGISTER R5.
;
; INPUTS:
;
;       R4=ADDRESS OF THE LAST WORD OF A 3 WORD FORK BLOCK PLUS 2.
;       R5=REGISTER TO BE SAVED IN THE FORK BLOCK.
;
; OUTPUTS:
;
;       REGISTER R5 IS SAVED IN THE SPECIFIED FORK BLOCK AND A SYSTEM
;       PROCESS IS CREATED. THE PROCESS IS LINKED TO THE FORK QUEUE
;       AND A JUMP TO $INTXT IS EXECUTED.
;-

$FORK1::MOV     R5,-(R4)        ;SAVE REGISTER R5

;+
; **-$FORK0-FORK AND CREATE SYSTEM PROCESS
;
; THIS ROUTINE IS AN ALTERNATE ENTRY TO CREATE A SYSTEM PROCESS.
;
; INPUTS:
;
;       R4=ADDRESS OF THE LAST WORD OF A 2 WORD FORK BLOCK PLUS 2.
;
; OUTPUTS:
;
;       A SYSTEM PROCESS IS CREATED, LINKED TO THE FORK QUEUE AND A
;       JUMP TO $INTXT IS EXECUTED.
;-

$FORK0::MOV     (SP)+,-(R4)     ;SET FORK PC
        CLR     -(R4)           ;CLEAR LINK TO NEXT FORK BLOCK
        MFPS    -(SP)           ;SAVE CURRENT PROCESSOR PRIORITY
        MTPS    #PR7            ;;;LOCK OUT INTERRUPTS
        MOV     R4,@$FRKHD+2    ;;;LINK NEW ENTRY TO OLD LAST
        MOV     R4,$FRKHD+2     ;;;SET ADDRESS OF NEW LAST
        MTPS    (SP)+           ;;;RESTORE PROCESSOR PRIORITY
        ASRB    $IDLFL          ;INTERRUPT OF IDLE LOOP?
        BCC     $INTXT          ;IF CC NO


        .IF DF  M$$MGE

        MOV     #$DIRXT,$STACK-24 ;FORCE DEQUEUE FROM FORK LIST

        .IFF

        MOV     #$DIRXT,$STACK-14 ;FORCE DEQUEUE FROM FORK LIST

        .ENDC


        .IF DF  C$$INT

        RETURN                  ;

;+
; **-$FORK2-FORK ROUTINE FOR USE IN CONJUNCTION WITH
;       THE CINT$ DIRECTIVE.
;
; INPUT:
;       R5      POINTING TO FORK BLOCK IN ITB
;
; OUTPUT:
;       IF THE FORK BLOCK IS ALREADY IN USE (FORK PC NON-ZERO),
;       A SYSTEM PROCESS IS CREATED, LINKED TO THE FORK QUEUE AND A
;       JUMP TO $INTXT IS EXECUTED.
;       ELSE THE INTERRUPT IS DISMISSED (NO RETURN TO CALLER).
;
;       IMMEDIATELY ON RETURN FROM THIS ROUTINE, THE FOLLOWING
;       INSTRUCTION SHOULD BE EXECUTED:
;
;               CLR     @R3
;
;       WHICH DECLARES THE FORK BLOCK FREE.
;-

$FORK2::TST     2(R5)           ;;;FORK BLOCK ALREADY IN USE?
        BNE     10$             ;;;Y - JUMP
        MOV     R4,6(R5)        ;;;SAVE R4 IN FORK BLOCK
        MOV     R5,R4           ;;;
        ADD     #6,R4           ;;;POINT JUST AFTER 3-WORD FORK BLOCK
        BR      $FORK1          ;;;
10$:    TST     (SP)+           ;;;CLEAR STACK
                                ;;;FALL THRU TO $INTXT

        .ENDC


;+
; **-$INTXT-INTERRUPT EXIT
;
; THIS ROUTINE MAY BE CALLED VIA A JMP TO EXIT FROM AN INTERRUPT.
;
; INPUTS:
;
;       0(SP)=INTERRUPT SAVE RETURN ADDRESS.
;
; OUTPUTS:
;
;       A RETURN TO INTERRUPT SAVE IS EXECUTED.
;-

$INTXT::RETURN                  ;

;+
; **-$INTSC-INTERRUPT SAVE (INTERRUPT FROM VECTOR CONNECTED
;       TO VIA CINT$ DIRECTIVE).
;
; CALLS ISR WITH R4 AND R5 SAVED AND:
;
;       R5      POINTER TO FORK BLOCK IN ITB
;       PRI     TAKEN FROM ITB
;       CONDITION CODES TAKEN FROM ITB
;-

        .IF DF  C$$INT

$INTSC::MOV     R4,-(SP)        ;;;SAVE R4
        DEC     $STKDP          ;;;SWITCH STACKS?
        BNE     10$             ;;;N - JUMP
        MOV     SP,@$HEADR      ;;;Y - SAVE STACK POINTER

        .IF NDF M$$MGE

        MOV     #$STACK,SP      ;;;LOAD SYSTEM STACK POINTER

        .IFTF
10$:                            ;;;REF LABEL

        .IFF

        MOV     KISAR5,-(SP)    ;;;SAVE KERNEL APR 5
        MOV     X.REL-X.PSW(R5),KISAR5 ;;;MAP ISR IN KERNEL APR5

        .ENDC

$INTS2: MTPS    (R5)+           ;;;LOAD ISR PRIORITY
        INC     R5              ;;;SKIP OVER UNUSED BYTE
        CALL    @(R5)+          ;;;CALL ISR

        .IF DF  M$$MGE

        MOV     (SP)+,KISAR5    ;;;RESTORE KERNEL APR 5

        .ENDC

        BR      $INTX1          ;;;EXIT FROM INTERRUPT

        .ENDC



;+
; **-$INTSE-INTERRUPT SAVE (ERROR LOGGING DEVICES)
;
; THIS ROUTINE IS CALLED FROM AN INTERRUPT SERVICE ROUTINE WHEN AN
; INTERRUPT IS NOT GOING TO BE IMMEDIATELY DISMISSED. REGISTER R4 IS
; SAVED AND THEN LOADED WITH THE ADDRESS OF THE SCB OF THE CONTROLLER
; THAT CAUSED THE INTERRUPT. A CHECK IS THEN MADE TO SEE IF AN ERROR IS
; ALREADY IN PROGRESS. IF IT IS NOT, THEN THE CURRENT I/O ACTIVE BITMAP
; IS SAVED IN THE SCB. THE APPROPRIATE BIT IS THEN CLEARED IN THE ACTIVE
; BITMAP AND REGISTER R4 IS LOADED WITH THE CONTROLLER INDEX. A NORMAL
; INTERRUPT SAVE IS THEN EXECUTED.
;
; INPUTS:
;
;       4(SP)=PS WORD PUSHED BY INTERRUPT.
;       2(SP)=PC WORD PUSHED BY INTERRUPT.
;       0(SP)=SAVED R5 PUSHED BY 'JSR R5,$INTSE'.
;       0(R5)=ADDRESS OF THE SCB OF INTERRUPTING CONTROLLER.
;       2(R5)=NEW PROCESSOR PRIORITY.
;
; OUTPUTS:
;
;       REGISTER R4 IS PUSHED ONTO THE CURRENT STACK AND THEN LOADED
;       WITH THE ADDRESS OF THE SCB OF THE CONTROLLER THAT CAUSED THE
;       INTERRUPT. IF AN ERROR IS NOT IN PROGRESS, THEN THE I/O ACTIVE
;       BITMAP IS SAVE IN THE SCB. THE APPROPRIATE BIT IS CLEARED IN THE
;       ACTIVE BITMAP AND REGISTER R4 IS LOADED WITH THE CONTROLLER
;       INDEX.
;-

        .ENABL  LSB
$INTSE::MOV     R4,-(SP)        ;;;SAVE REGISTER R4
        MOV     (R5)+,R4        ;;;GET ADDRESS OF SCB


        .IF DF  E$$DVC

        BITB    #SP.EIP,S.PRI(R4) ;;;ERROR IN PROGRESS?
        BNE     1$              ;;;IF NE YES
        MOV     $IOABM,S.BMSV(R4) ;;;SAVE I/O ACTIVE BITMAP
1$:     BIC     S.BMSK(R4),$IOABM ;;;CLEAR APPROPRIATE BIT

        .ENDC


        MOVB    S.CON(R4),R4    ;;;GET CONTROLLER INDEX
        BR      2$              ;;;FINISH IN COMMON CODE

;+
; **-$INTSV-INTERRUPT SAVE
;
; THIS ROUTINE IS CALLED FROM AN INTERRUPT SERVICE ROUTINE WHEN AN
; INTERRUPT IS NOT GOING TO BE IMMEDIATELY DISMISSED. A SWITCH TO
; THE SYSTEM STACK IS EXECUTED IF THE CURRENT STACK DEPTH IS +1. WHEN
; THE INTERRUPT SERVICE ROUTINE FINISHES ITS PROCESSING, IT EITHER FORKS
; , JUMPS TO $INTXT, OR EXECUTES A RETURN.
;
; INPUTS:
;
;       4(SP)=PS WORD PUSHED BY INTERRUPT.
;       2(SP)=PC WORD PUSHED BY INTERRUPT.
;       0(SP)=SAVED R5 PUSHED BY 'JSR R5,$INTSV'.
;       0(R5)=NEW PROCESSOR PRIORITY.
;
; OUTPUTS:
;
;       REGISTER R4 IS PUSHED ONTO THE CURRENT STACK AND THE CURRENT
;       STACK DEPTH IS DECREMENTED. IF THE RESULT IS ZERO, THEN
;       A SWITCH TO THE SYSTEM STACK IS EXECUTED. THE NEW PROCESSOR
;       STATUS IS SET AND A CO-ROUTINE CALL TO THE CALLER IS EXECUTED
;-

$INTSV::MOV     R4,-(SP)        ;;;SAVE REGISTER R4
2$:     DEC     $STKDP          ;;;SWITCH STACKS?
        BNE     3$              ;;;IF NE NO
        MOV     SP,@$HEADR      ;;;SAVE CURRENT STACK POINTER


        .IF NDF M$$MGE

        MOV     #$STACK,SP      ;;;LOAD SYSTEM STACK POINTER

        .ENDC


        .IF DF  L$$SI1

3$:     MTPS    (R5)            ;;;LOAD NEW PRIORITY
        CALL    2(R5)           ;;;CALL THE CALLER BACK

        .IFF

3$:     BIC     (R5)+,PS        ;;;LOAD NEW PRIORITY
        CALL    (R5)            ;;;CALL THE CALLER BACK

        .ENDC


;+
; **-$INTXT-INTERRUPT EXIT
;
; THIS ROUTINE IS ENTERED VIA A RETURN TO EXIT FROM AN INTERRUPT. IF THE
; STACK DEPTH IS NOT EQUAL TO ZERO, THEN REGISTERS R4 AND R5 ARE
; RESTORED AND AN RTI IS EXECUTED. ELSE A CHECK IS MADE TO SEE
; IF THERE ARE ANY ENTRIES IN THE FORK QUEUE. IF NONE, THEN R4 AND
; R5 ARE RESTORED AND AN RTI IS EXECUTED. ELSE REGISTERS R3 THRU
; R0 ARE SAVED ON THE CURRENT STACK AND A DIRECTIVE EXIT IS EXECUTED.
;
; INPUTS: (MAPPED SYSTEM)
;
;       06(SP)=PS WORD PUSHED BY INTERRUPT.
;       04(SP)=PC WORD PUSHED BY INTERRUPT.
;       02(SP)=SAVED R5.
;       00(SP)=SAVED R4.
;
; INPUTS: (REAL MEMORY SYSTEM)
;
;       NONE.
;-

$INTX1::MTPS    #PR7            ;;;LOCK OUT INTERRUPTS
        TST     $STKDP          ;;;STACK DEPTH ZERO?
        BNE     10$             ;;;IF NE NO
        TST     $FRKHD          ;;;ANYTHING IN FORK QUEUE?
        BEQ     5$              ;;;IF EQ NO
        MTPS    #0              ;;;ALLOW INTERRUPTS
        MOV     R3,-(SP)        ;SAVE REGISTERS R3 THRU R0
        MOV     R2,-(SP)        ;
        MOV     R1,-(SP)        ;
        MOV     R0,-(SP)        ;

;+
; **-$DIRXT-DIRECTIVE EXIT
;
; THIS ROUTINE IS CALLED VIA A JUMP TO EXIT FROM A DIRECTIVE OR TRAP
; SERVICE ROUTINE. IF THERE ARE ANY ENTRIES IN THE FORK QUEUE, THEN
; THE FIRST ENTRY IS REMOVED AND THE FORK ROUTINE IS EXECUTED. ELSE
; A CHECK IS MADE TO SEE IF REDISPATCHING OF THE PROCESSOR IS NECES-
; SARY. IF NOT, THEN REGISTERS R0 THRU R5 ARE RESTORED AND AN RTI
; IS EXECUTED. ELSE THE PROCESSOR IS REDISPATCHED AND THE EXIT
; SEQUENCE IS EXECUTED AGAIN.
;
; INPUTS: (MAPPED SYSTEM)
;
;       16(SP)=PS WORD PUSHED BY INTERRUPT OR TRAP.
;       14(SP)=PC WORD PUSHED BY INTERRUPT OR TRAP.
;       12(SP)=SAVED R5.
;       10(SP)=SAVED R4.
;       06(SP)=SAVED R3.
;       04(SP)=SAVED R2.
;       02(SP)=SAVED R1.
;       00(SP)=SAVED R0.
;
; INPUTS: (REAL MEMORY (SYSTEM)
;
;       06(SP)=SAVED R3.
;       04(SP)=SAVED R2.
;       01(SP)=SAVED R1.
;       00(SP)=SAVED R0.
;-

$DIRXT::MTPS    #PR7            ;;;LOCK OUT INTERRUPTS
        MOV     $FRKHD,R3       ;;;ANYTHING IN FORK QUEUE
        BNE     20$             ;;;IF NE YES
        TSTB    $CXDBL          ;;;IS CONTEXT SWITCHING DISABLED?       ; CS021
        BEQ     31$             ;;;IF EQ NO                             ; CS021
        MOV     $TKTCB,R5       ;;;PICK UP CURRECT TASK TCB             ; CS021
        TSTB    T.ST2(R5)       ;;;TASK EXITING DUE TO ABORT?           ; CS021
        BPL     4$              ;;;IF PL NO                             ; CS021
        JMP     TEXIT           ;;;INITIATE TASK EXIT                   ; CS021
31$:                            ;;;REF LABEL                            ; CS021
        MOV     $RQSCH,R5       ;;;SCHEDULING REQUESTED?
        BNE     40$             ;;;IF NE YES
4$:                             ;;;REF LABEL                            ; CS021
        MOV     (SP)+,R0        ;;;RESTORE REGISTERS R0 THRU R3
        MOV     (SP)+,R1        ;;;
        MOV     (SP)+,R2        ;;;
        MOV     (SP)+,R3        ;;;
5$:                             ;;;REF LABEL

        .IF NDF M$$MGE

        MOV     @$HEADR,SP      ;;;RELOAD USER STACK POINTER

        .ENDC


10$:    INC     $STKDP          ;;;INCREMENT STACK DEPTH
        MOV     (SP)+,R4        ;;;RESTORE REGISTERS R4 AND R5
        MOV     (SP)+,R5        ;;;

;+
; NONSENSE INTERRUPT ENTRY/EXIT
;-


        .IF NDF E$$NSI

;
; IF ERROR LOGGING OF UNDEFINED INTERRUPTS IS NOT SUPPORTED,
; ALL UNUSED VECTORS POINT TO THE NONSENSE INTERRUPT ADDRESS.
;

$NS0::                          ;
$NS1::                          ;
$NS2::                          ;
$NS3::                          ;
$NS4::                          ;
$NS5::                          ;
$NS6::                          ;
$NS7::                          ;

        .ENDC


$NONSI::RTI                     ;;;

;
; EXECUTE FORK ROUTINE
;
; FORK ROUTINES ARE ENTERED VIA A CALL WITH THE ARGUMENTS:
;
;       R3=ADDRESS OF THE BEGINNING OF THE FORK BLOCK+2.
;       R4=RESTORED FROM FORK BLOCK.
;       R5=RESTORED FROM FORK BLOCK.
;

20$:    MOV     (R3),$FRKHD     ;;;REMOVE ENTRY FROM FORK QUEUE
        BNE     30$             ;;;IF NE MORE ENTRIES
        MOV     #$FRKHD,$FRKHD+2 ;;;RESET FORK QUEUE LISTHEAD
30$:    MTPS    #0              ;;;ALLOW INTERRUPTS
        ADD     #10,R3          ;POINT PAST SAVED R4


        .IF DF  L$$DRV&M$$MGE

        MOV     KISAR5,-(SP)    ;SAVE APR5
        MOV     (R3),KISAR5     ;MAP THE DRIVER

        .IFTF

        MOV     -(R3),R4        ;RESTORE REGISTERS R4 AND R5
        MOV     -(R3),R5        ;
        CALL    @-(R3)          ;CALL FORK ROUTINE

        .IFT

        MOV     (SP)+,KISAR5    ;RESTORE APR5

        .ENDC


        BR      $DIRXT          ;TRY EXIT AGAIN

;
; RESCHEDULING OR POWERFAIL
;

40$:    MTPS    #0              ;;;ALLOW INTERRUPTS
        TST     $PWRFL          ;POWER FAILURE?
        BEQ     RESCH           ;IF EQ NO
        CALL    $POWER          ;EXECUTE POWER RECOVERY ROUTINES
DIRXT:  BR      $DIRXT          ;TRY EXIT AGAIN                         ; CS020
        .DSABL  LSB                                                     ;**-1

;
; RESCHEDULING REQUESTED
;

        .ENABL LSB                                                      ; CS020
RESCH:  CLR     $RQSCH          ;CLEAR SCHEDULE REQUEST


        .IF NDF M$$MGE

        MOV     $HEADR,R4       ;GET ADDRESS OF CURRENT HEADER
        BEQ     5$              ;IF EQ NO CURRENT TASK
        TST     @H.GARD(R4)     ;STACK OVERFLOW?
        BEQ     5$              ;IF EQ NO
        CLR     @H.GARD(R4)     ;CLEAR HEADER GUARD WORD
        MOV     #S.CSST,R0      ;SET SST ABORT-BAD STACK
        CALL    $ABCTK          ;ABORT CURRENT TASK

        .ENDC


5$:     MOV     #T2.STP!T2.SPN!T2.WFR,R1 ;SET SUSPEND-WAITFOR MASK
        MOV     #T2.WFR,R4      ;SET WAITFOR MASK                       ; CS017
10$:    TST     T.STAT(R5)      ;TASK BLOCKED?                          ;**-1
        BNE     30$             ;IF NE YES
        MOV     T.ST2(R5),R0    ;GET CONTENTS OF SECOND STATUS WORD     ; CS017


        .IF DF  C$$CKP&T$$BUF!A$$TRP!P$$OFF                             ; CS018
                                                                        ;**-1
        MOV     T.ASTL(R5),R2   ;AST QUEUED?
        BEQ     20$             ;IF EQ NO
        BIT     #T2.AST!T2.DST,R0 ;AST IN PROGRESS OR DISABLED?         ; CS017
        BEQ     70$             ;IF EQ NO                               ;**-1
        TSTB    A.CBL(R2)       ;BUFFERED I/O REQUEST?
        BMI     70$             ;IF MI YES

        .IFTF

20$:    BIT     R1,R0           ;STOPPED, SUSPENDED OR IN WAITFOR?      ; CS017
        BEQ     60$             ;IF EQ NO                               ;**-1
        BIT     R4,R0           ;IN WAITFOR?                            ; CS017
        BEQ     30$             ;IF EQ, NO                              ; CS017
        MOV     T.PCB(R5),R3    ;GET PCB ADDRESS OF TASK PARTITION      ;**-2
        MOV     P.HDR(R3),R2    ;POINT TO TASK HEADER
        BIT     #T2.ABO,T.ST2(R5) ;TASK MARKED FOR ABORT?               ; CS020
        BNE     50$             ;IF NE YES, FINISH HIM OFF              ; CS020
        BIT     H.EFLM(R2),@H.EFLM+2(R2) ;WAITFOR SATISFIED?
        BNE     50$             ;IF NE YES
                                                                        ; CS017
        .IF DF S$$TOP                                                   ; CS017
                                                                        ; CS017
        BIT     #T2.SEF,R0      ;STOPPED FOR EVENT FLAGS?               ; CS017
        BEQ     30$             ;NO                                     ; CS017
        BIT     #T2.AST!T2.STP,R0 ;TASK ALREADY STOPPED OR AT AST       ; CS023
        BNE     30$             ;IF NE YES, DON'T STOP HIM.             ; CS023
        MOV     R5,R0           ;COPY TCB ADDRESS                       ; CS017
        CALL    $STPTK          ;STOP THE TASK                          ; CS017
        BR      5$              ;RESET REGISTERS AND GO AGAIN           ; CS017
                                                                        ; CS017
        .ENDC   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
30$:    MOV     T.ACTL(R5),R5   ;GET ADDRESS OF NEXT TCB
        BNE     10$             ;IF NE OKAY

;
; EXECUTIVE IDLE LOOP
;
; THE EXECUTIVE IDLE LOOP IS ENTERED WHEN THERE ARE NO RUNNABLE TASKS.
; THE NULL TCB AT THE END OF THE TASK LIST IS ALWAYS GUARANTEED TO BE
; BLOCKED.  TWO FLAGS ARE SET FOR OTHER EXECUTIVE ROUTINES IN THE IDLE
; LOOP.
;
;    1. THE ADDRESS OF THE NULL TCB (#$HEADR) IS SET INTO THE RESCHEDULE
;       POINTER ($RQSCH) TO PREVENT $DIRXT FROM EVER RETURNING TO SYSTEM
;       STATE WHILE THE EXEC IS IDLE.  THIS FORCES EXECUTION BACK TO THE
;       IDLE LOOP IN LIEU OF A REAL SCHEDULE REQUEST.
;
;   2.  AN IDLE FLAG IS SET ($IDLFL) FOR THE FORK ROUTINES TO CAUSE THEM
;       TO FORCE CONTROL BACK TO $DIRXT WHEN NECESSARY TO DEQUEUE A
;       FORK.  (IT IS IMPOSSIBLE FOR THE IDLE LOOP TO ALWAYS RETURN TO
;       $DIRXT WHEN NECESSARY BECAUSE OF A WINDOW BETWEEN THE CHECK OF
;       THE FORK LIST AND THE WAIT INSTRUCTION.)
;

        MOV     #$HEADR,$RQSCH  ;PREVENT $DIRXT RETURN TO USER STATE
        MOV     #$IDLPT,R1      ;POINT TO IDLE PATTERN WORD
        CLRB    $CURPR          ;CLEAR CURRENT TASK PRIORITY
40$:                            ;REF LABEL


        .IF DF  P$$P45

        DECB    $IDLCT          ;TIME TO MOVE PATTERN?
        BGE     45$             ;IF GE NO
        MOVB    #4,$IDLCT       ;RESET COUNT
        ASLB    (R1)+           ;MOVE PATTERN ($IDLPT)
        RORB    (R1)            ;($IDLPT+1)
        ADCB    -(R1)           ;($IDLPT)
45$:    MOV     (R1),R0         ;PUT IT WHERE IT CAN BE SEEN ($IDLPT)

        .ENDC


        INCB    -(R1)           ;INDICATE IN IDLE STATE ($IDLFL)
        TST     $FRKHD          ;FORK QUEUED SINCE LAST TIME IN $DIRXT?
        BNE     46$             ;IF NE YES
        WAIT                    ;WAIT FOR INTERRUPT
        CLRB    (R1)+           ;RESET IDLE FLAG ($IDLFL)
        BR      40$             ;
46$:    CLRB    (R1)            ;RESET IDLE FLAG ($IDLFL)
        BR      DIRXT           ;BR TO DEQUEUE FORK ($DIRXT)            ; CS020
                                                                        ;**-1
;
; WAITFOR SATISFIED-CLEAR WAIT STATE
;

50$:                            ;REF LABEL                              ; CS020
                                                                        ; CS020
        .IF DF G$$EFN                                                   ; CS020
                                                                        ; CS020
        CALL    $DEAGF          ;DEACCESS GROUP GLOBAL EF'S             ; CS020
                                                                        ; CS020
        .ENDC   ;G$$EFN                                                 ; CS020
                                                                        ; CS020
        DEC     T.ST2(R5)       ;CLEAR WAITFOR STATE                    ; CS020
                                                                        ; CS020
        .IF DF S$$TOP                                                   ; CS017
                                                                        ; CS017
        BMI     60$             ;IF MI, AT AST STATE                    ; CS017
        BIC     #T2.SEF,T.ST2(R5) ;CLEAR STOPPED FOR EFN BIT            ; CS017
                                                                        ; CS017
        .ENDC   ;S$$TOP                                                 ; CS017
                                                                        ; CS017
                                                                        ;**-1
;
; RESTART OR CONTINUE A TASK
;

60$:                            ;REF LABEL

        .IFT

        CLR     R4              ;SET FLAG TO SIGNIFY RESTART OF TASK

        .ENDC


70$:    MOV     #H.DSW,R0       ;POINT TO DIRECTIVE STATUS WORD
        MOVB    T.PRI(R5),$CURPR ;SET CURRENT TASK PRIORITY
        MOV     $HEADR,R3       ;GET ADDRESS OF CURRENT TASK HEADER
        BEQ     80$             ;IF EQ NO CURRENT TASK
        CMP     R5,$TKTCB       ;NEW TASK SAME AS CURRENT?
        BNE     73$             ;IF NE NO
        JMP     130$            ;NO CONTEXT SWITCH NECESSARY

;
; SAVE CONTEXT OF CURRENT TASK
;

73$:    MOV     H.GARD(R3),R2   ;POINT TO HEADER GUARD WORD
        MOV     SP,R1           ;POINT TO SAVED R0
        MOV     (R1)+,-(R2)     ;SAVE R0
        MOV     (R1)+,-(R2)     ;SAVE R1
        MOV     (R1)+,-(R2)     ;SAVE R2
        MOV     (R1)+,-(R2)     ;SAVE R3


        .IF DF  M$$MGE

        MOV     (R1)+,-(R2)     ;SAVE R4
        MOV     (R1)+,-(R2)     ;SAVE R5
        MOV     (R1)+,-(R2)     ;SAVE PC
        MOV     (R1),-(R2)      ;SAVE PS
        MFPI    SP              ;GET USER STACK POINTER
        MOV     (SP)+,(R3)      ;SAVE USER STACK POINTER IN HEADER

        .IFF


        .IF DF  E$$EAE

        MOV     H.FPSA(R3),R2   ;POINT TO EAE SAVE AREA
        BEQ     75$             ;IF EQ TASK DOES NOT USE EAE
        MOV     SC,(R2)+        ;SAVE EAE REGISTERS
        MOV     AC,(R2)+        ;
        MOV     MQ,(R2)         ;

        .ENDC


        .IFTF

75$:    MOV     (R0),H.DSW(R3)  ;SAVE DIRECTIVE STATUS WORD


        .IF DF  F$$LPP

        MOV     H.FPSA(R3),R2   ;POINT TO FLOATING POINT SAVE AREA
        BEQ     80$             ;IF EQ TASK DOES NOT USE FLOATING POINT


        .IF DF  M$$MGE

        MOV     $TKTCB,R3       ;GET TCB ADDRESS OF CURRENT TASK
        MOV     T.PCB(R3),R1    ;GET ADDRESS OF TASK PARTITION PCB
        MOV     P.REL(R1),KISAR6 ;MAP TO TASK PARTITION


        .IF DF  P$$LAS

        ADD     T.OFF(R3),KISAR6 ;ADD IN OFFSET TO TASK IMAGE

        .ENDC


        .ENDC


        STFPS   (R2)+           ;SAVE FLOATING POINT STATUS
        SETD                    ;SET FLOATING DOUBLE MODE
        STD     R0,(R2)+        ;SAVE FLOATING POINT REGISTERS
        LDD     R4,R0           ;
        STD     R0,(R2)+        ;
        LDD     R5,R0           ;
        STD     R0,(R2)+        ;
        STD     R1,(R2)+        ;
        STD     R2,(R2)+        ;
        STD     R3,(R2)+        ;

        .ENDC


;
; LOAD CONTEXT OF NEW TASK
;

80$:    MOV     R5,$TKTCB       ;SET ADDRESS OF NEW TCB
        MOV     T.PCB(R5),R3    ;GET ADDRESS OF TASK PARTITION PCB
        MOV     P.HDR(R3),R2    ;GET ADDRESS OF TASK HEADER
        MOV     R2,$HEADR       ;SET ADDRESS OF TASK HEADER

        .IFT


        .IF DF  C$$CKP&T$$BUF!A$$TRP!P$$OFF                             ; CS018
                                                                        ;**-1
        MOV     R4,-(SP)        ;SAVE EFFECT AST FLAG

        .ENDC


        MOV     H.WND(R2),R4    ;POINT TO NUMBER OF WINDOW BLOCKS
        TST     W.BLVR+2(R4)    ;IS TASK MAPPED TO THE EXEC?
        BEQ     85$             ;IF EQ NO

        .IFTF

        MOV     R2,R1           ;COPY ADDRESS OF TASK HEADER
        ADD     R0,R1           ;POINT TO DIRECTIVE STATUS WORD
        MOV     (R1)+,(R0)+     ;RESTORE DIRECTIVE STATUS WORD
        MOV     (R1)+,(R0)+     ;RESTORE POINTER TO FCS IMPURE AREA
        MOV     (R1)+,(R0)+     ;RESTORE POINTER TO FORTRAN IMPURE AREA
        MOV     (R1)+,(R0)+     ;RESTORE POINTER TO OVERLAY IMPURE AREA
        MOV     (R1)+,(R0)+     ;RESTORE PTR TO VECTOR OF IMPURE PTRS

        .IFT

        MOV     #UISDR0,R0      ;POINT TO USER DESCRIPTOR REGISTER 0
        MOV     #77406,(R0)     ;SETUP PRIVILEGED TASK DESCRIPTOR REGISTERS
        MOV     (R0)+,(R0)      ;
        MOV     (R0)+,(R0)      ;
        MOV     (R0)+,(R0)      ;


        .IF DF  R$$EXV

        MOV     (R0)+,(R0)      ;

        .ENDC


        MOV     (R0),UISDR0+14. ;ALLOW FULL ACCESS TO I/O PAGE
        MOV     #UISAR0,R1      ;POINT TO USER ADDRESS REGISTER 0
        MOV     #KISAR0,R0      ;POINT TO KERNAL ADDRESS REGISTER 0
        MOV     (R0)+,(R1)+     ;SETUP PRIVILEGED TASK ADDRESS REGISTERS
        MOV     (R0)+,(R1)+     ;
        MOV     (R0)+,(R1)+     ;


        .IF DF  R$$EXV

        MOV     (R0)+,(R1)+     ;

        .ENDC


        MOV     (R0),(R1)       ;
        MOV     #177600,UISAR0+14. ;SET ADDRESS REGISTER 7 FOR I/O PAGE
        BR      90$             ;
85$:    MOV     #UISDR0,R0      ;POINT TO USER DESCRIPTOR REGISTER 0
        CLR     (R0)+           ;CLEAR ALL USER DESCRIPTOR REGISTERS
        CLR     (R0)+           ;
        CLR     (R0)+           ;
        CLR     (R0)+           ;
        CLR     (R0)+           ;
        CLR     (R0)+           ;
        CLR     (R0)+           ;
        CLR     (R0)            ;
90$:    MOV     (R4)+,-(SP)     ;PUSH NUMBER OF WINDOW BLOCKS
100$:   ADD     #W.BLGH,R4      ;POINT PAST CURRENT WINDOW BLOCK
        MOV     -W.BLGH(R4),R3  ;PICK UP NEXT PCB ADDRESS
        BEQ     115$            ;IF EQ WINDOW IS NOT MAPPED
        CMP     -(R4),-(R4)     ;POINT TO FIRST PDR ADDRESS
        MOV     P.REL(R3),R0    ;PICK UP PARTITION RELOCATION BIAS


        .IF DF  P$$LAS

        ADD     -2(R4),R0       ;ADD IN WINDOW OFFSET

        .ENDC


        MOVB    (R4)+,R1        ;POINT TO FIRST PDR
        MOVB    (R4)+,R3        ;PICK UP NUMBER OF PDR'S TO LOAD
110$:   MOVB    (R4),(R1)+      ;SET USER DESCRIPTOR ACCESS CODE
        MOVB    #177,(R1)+      ;SET BLOCK LENGTH
        MOV     R0,UISAR0-UISDR0-2(R1) ;LOAD USER ADDRESS REGISTER
        ADD     #200,R0         ;ADVANCE TO NEXT 4K BOUNDARY
        DEC     R3              ;ANY MORE TO LOAD?
        BGT     110$            ;IF GT NO
        MOV     (R4)+,-(R1)     ;LOAD LAST USER DESCRIPTOR REGISTER
115$:   DEC     (SP)            ;ANY MORE WINDOW BLOCKS?
        BGT     100$            ;IF GT YES
        MOV     (R2),(SP)       ;LOAD USER STACK POINTER
        MTPI    SP              ;


        .IF DF  C$$CKP&T$$BUF!A$$TRP!P$$OFF                             ; CS018
                                                                        ;**-1
        MOV     (SP)+,R4        ;RESTORE EFFECT AST INDICATOR

        .ENDC


        .IFF


        .IF DF  E$$EAE

        MOV     H.FPSA(R2),R0   ;POINT TO EAE SAVE AREA
        BEQ     120$            ;IF EQ TASK DOES NOT USE EAE
        CMP     (R0)+,(R0)+     ;POINT TO SAVED MQ REGISTER
        MOV     (R0),MQ         ;RESTORE EAE REGISTERS
        MOV     -(R0),AC        ;
        MOV     -(R0),SC        ;

        .ENDC


        .IFTF


        .IF DF  F$$LPP

        MOV     H.FPSA(R2),R0   ;POINT TO FLOATING POINT SAVE AREA
        BEQ     120$            ;IF EQ TASK DOES NOT USE FLOATING POINT


        .IF DF  M$$MGE

        MOV     T.PCB(R5),R1    ;GET ADDRESS OF TCB OF NEXT TASK
        MOV     P.REL(R1),KISAR6 ;MAP TO TASK PARTITION


        .IF DF  P$$LAS

        ADD     T.OFF(R5),KISAR6 ;ADD IN OFFSET TO TASK IMAGE

        .ENDC


        .ENDC


        TST     (R0)+           ;POINT TO SAVED FLOATING POINT REGISTERS
        SETD                    ;SET FLOATING DOUBLE MODE
        LDD     (R0)+,R0        ;RESTORE FLOATING POINT REGISTERS
        LDD     (R0)+,R1        ;
        STD     R1,R4           ;
        LDD     (R0)+,R1        ;
        STD     R1,R5           ;
        LDD     (R0)+,R1        ;
        LDD     (R0)+,R2        ;
        LDD     (R0)+,R3        ;
        LDFPS   @H.FPSA(R2)     ;RESTORE FLOATING POINT STATUS

        .ENDC


120$:   MOV     H.GARD(R2),R0   ;POINT TO HEADER GUARD WORD
        MOV     SP,R1           ;POINT TO CURRENT CONTEXT
        MOV     -(R0),(R1)+     ;RESTORE R0
        MOV     -(R0),(R1)+     ;RESTORE R1
        MOV     -(R0),(R1)+     ;RESTORE R2
        MOV     -(R0),(R1)+     ;RESTORE R3

        .IFT

        MOV     -(R0),(R1)+     ;RESTORE R4
        MOV     -(R0),(R1)+     ;RESTORE R5
        MOV     -(R0),(R1)+     ;RESTORE PC
        MOV     -(R0),(R1)      ;RESTORE PS

        .ENDC


130$:                           ;REF LABEL


        .IF DF  C$$CKP&T$$BUF!A$$TRP!P$$OFF                             ; CS018
                                                                        ;**-1
        TST     R4              ;EFFECT AST?
        BEQ     190$            ;IF EQ NO
        MOV     R5,R0           ;CALCULATE ADDRESS OF AST LISTHEAD
        ADD     #T.ASTL,R0      ;
        CALL    $QRMVF          ;REMOVE AST ENTRY FROM QUEUE


        .IF DF  C$$CKP&T$$BUF!P$$OFF                                    ; CS018
                                                                        ;**-1
        MOVB    A.CBL(R1),R4    ;BUFFERED I/O OR OFFSPRING EXIT ?       ; BM003
        BMI     210$            ;IF MI YES                              ;**-1

        .ENDC


        .ENDC


        .IF DF  A$$TRP

        MOV     R5,R4           ;CALCULATE ADDRESS OF STATUS WORD
        ADD     #T.ST2,R4       ;
        MOVB    (R4),-(SP)      ;COPY CURRENT EXTENSION BYTE
        BIC     #^C<T2.STP!T2.SPN!T2.WFR>,(SP) ;CLEAR ALL BUT WAIT STATE
        ASL     (SP)            ;SHIFT INTO POSITITON FOR SAVE
        BIC     #<T2.STP!T2.SPN!T2.WFR>*2!T2.STP!T2.SPN!T2.WFR,(R4) ;
        BIS     (SP)+,(R4)      ;SAVE WAIT STATE
        BIS     #T2.AST,(R4)    ;SET AST IN PROGRESS
        MOV     R1,R3           ;COPY AST CONTROL BLOCK ADDRESS
        MOV     R3,-(SP)        ;SAVE AST CONTROL BLOCK ADDRESS
        CMP     (R3)+,(R3)+     ;POINT TO NUMBER OF BYTES TO ALLOCATE
        MOV     $HEADR,R4       ;POINT TO TASK HEADER


        .IF DF  M$$MGE

        MFPI    SP              ;GET CURRENT STACK POINTER
        MOV     (SP)+,R0        ;

        .IFF

        MOV     (R4),R0         ;GET CURRENT STACK POINTER

        .ENDC


        MOV     (R3)+,R1        ;GET NUMBER OF BYTES TO ALLOCATE ON TASK STACK
        SUB     R1,R0           ;CALCULATE NEW TOP OF STACK


        .IF DF  A$$CHK!M$$MGE

        CALL    $ACHCK          ;ADDRESS CHECK STACK SPACE
        BCS     160$            ;IS CS ADDRESS CHECK FAILURE

        .ENDC


        .IF DF  M$$MGE

        MOV     R0,-(SP)        ;SET NEW TASK STACK POINTER
        MTPI    SP              ;
        CALL    $RELOM          ;RELOCATE AND MAP STACK ADDRESS
        MOV     SP,R1           ;CALCULATE ADDRESS OF TRAP PC
        ADD     #7*2,R1         ;

        .IFF

        MOV     (R4),R1         ;RETRIEVE OLD TOP OF STACK
        MOV     R0,(R4)         ;SET NEW TASK STACK POINTER
        MOV     (R1)+,(R0)+     ;MOVE SAVED R4
        MOV     (R1)+,(R0)+     ;MOVE SAVED R5
        MOV     (R3)+,(R0)+     ;SET AST TRAP PC
        CLR     (R0)+           ;SET AST TRAP PS

        .IFTF

        MOV     (R1)+,-(SP)     ;SAVE PC AT TRAP
        MOV     (R1),R2         ;SAVE PS AT TRAP

        .IFT

        MOV     #CMODE!PMODE,(R1) ;SET AST TRAP PS
        MOV     (R3)+,-(R1)     ;SET AST TRAP PC

        .IFTF

        MOV     (R3)+,-(SP)     ;GET NUMBER OF PARAMETERS TO MOVE
140$:   DEC     (SP)            ;ANY MORE PARAMETERS TO MOVE?
        BLT     150$            ;IF LT NO
        MOV     (R3)+,(R0)+     ;MOVE PARAMETER TO USER STACK
        BR      140$            ;
150$:   TST     (SP)+           ;CLEAN STACK

        .IFF

        MOV     @.DSW,(R0)+     ;MOVE DSW TO TASK STACK

        .IFT

        MFPI    @#H.DSW         ;GET USER DSW
        MOV     (SP)+,(R0)+     ;MOVE DSW TO TASK STACK

        .ENDC


        MOV     (SP)+,(R0)+     ;MOVE PC AT TRAP TO TASK STACK
        MOV     R2,(R0)+        ;MOVE PS AT TRAP TO TASK STACK
        MOV     H.EFLM(R4),(R0) ;SAVE WAITFOR MASK WORD
        MOV     H.EFLM+2(R4),H.EFSV(R4) ;SAVE WAITFOR MASK ADDRESS


        .IF DF  A$$CHK!M$$MGE

        BR      170$            ;TAKE COMMON EXIT
160$:   MOV     #S.CAST,R0      ;SET AST ABORT
        CALL    $ABCTK          ;ABORT CURRENT TASK

        .ENDC


170$:   MOV     (SP)+,R0        ;RETRIEVE AST CONTROL BLOCK ADDRESS
        MOV     A.CBL(R0),R1    ;GET LENGTH OF BLOCK TO RELEASE
        BNE     175$            ;JUMP IF NON-ZERO

        .IF DF  M$$MGE

        CMP     -(R0),-(R0)     ;ZERO - POINT TO A.KSR5
        MOV     (R0)+,KISAR5    ;MAP DEQUEUE SUBROUTINE IN APR 5
        CALL    @(R0)+          ;CALL DEQUEUE SUBROUTINE

        .IFF

        CALL    @-2(R0)         ;CALL DEQUEUE SUBROUTINE

        .ENDC

        BR      200$            ;EXIT
175$:   TSTB    R1              ;LENGTH NON-ZERO?
        BNE     180$            ;Y - JUMP
        MOV     T.SAST(R5),(R0) ;LINK SPEC AST CONTROL BLOCK ONTO       ; CS017
        MOV     R0,T.SAST(R5)   ; SPEC AST LISTHEAD                     ; CS017
        BR      200$            ;TRY EXIT AGAIN                         ;**-3
180$:   CALL    $DEACB          ;DEALLOCATE CONTROL BLOCK
        BR      200$            ;TRY EXIT AGAIN

        .ENDC


190$:   TSTB    T.ST2(R5)       ;TASK BEING HALTED?
        BPL     200$            ;IF PL NO
TEXIT:  CALL    $CEXIT          ;FORCE TASK EXIT                        ; CS020
200$:   JMP     $DIRXT          ;                                       ;**-1
                                                                        ; CS018
        .IF DF  C$$CKP&T$$BUF!P$$OFF                                    ; CS018
                                                                        ; CS018
210$:   MOV     #$DIRXT,-(SP)   ;SET RETURN ADDRESS
        MOV     R1,R0           ;SET ADDRESS OF AST CONTROL BLOCK
                                                                        ; CS018
        .IF DF T$$CPW!P$$OFF                                            ; CS018
                                                                        ; CS018
        CALL    $SGFIN          ;SETUP TO IGNORE SEGMENT FAULTS         ; CS018
                                                                        ; CS018
        .ENDC   ;T$$CPW!P$$OFF                                          ; CS018
                                                                        ; CS018
        .ENDC   ;C$$CKP&T$$BUF!P$$OFF                                   ; CS018
                                                                        ; CS018
        .IF DF  P$$OFF                                                  ; CS018
                                                                        ; CS018
        ASLB    R4              ;OFFSPRING EXIT BLOCK?                  ; CS018
                                                                        ; CS018
        .IF DF  C$$CKP&T$$BUF!T$$CPW                                    ; CS018
                                                                        ; CS018
        BPL     $FINBF          ;IF PL NO                               ; CS018
                                                                        ; CS018
        .ENDC   ;C$$CKP&T$$BUF!T$$CPW                                   ; CS018
                                                                        ; CS020
        .IFTF   ;P$$OFF                                                 ; CS020
                                                                        ; CS020
        .DSABL LSB                                                      ; CS020
                                                                        ; CS020
        .IFT    ;P$$OFF                                                 ; CS020
                                                                        ; CS020
                                                                        ; CS018
;+                                                                      ; CS018
; **-$FINXT-FINISH OFFSPRING TASK EXIT PROCESSING                       ; CS018
;                                                                       ; CS018
; QUEUE AST AND RETURN EXIT STATUS TO A PARENT TASK ONCE THAT TASK      ; CS018
; HAS BEEN SCHEDULED.                                                   ; CS018
;                                                                       ; CS018
; INPUTS:                                                               ; CS018
;                                                                       ; CS018
;       R0=ADDRESS OF OFFSPRING CONTROL BLOCK.                          ; CS018
;                                                                       ; CS018
; OUTPUTS:                                                              ; CS018
;                                                                       ; CS018
;       ALL EXIT CONDITIONS ARE EFFECTED AND THE OFFSPRING CONTROL BLOCK; CS018
;       IS DEALLOCATED IF IT IS NOT USED AS AN AST CONTROL BLOCK.       ; CS018
;-                                                                      ; CS018
                                                                        ; CS018
$FINXT::MOV     R0,R3           ;COPY OCB POINTER                       ; CS018
        MOV     R0,R4           ;COPY OCB POINTER                       ; CS018
        TST     (R3)+           ;SKIP OVER LINK WORD (O.LNK)            ; CS018
        MOV     #O.LGTH,(R3)+   ;SET LENGTH TO DEALLOCATE (O.LNK=A.CBL) ; CS018
        MOV     (R3),R5         ;PICK UP PARENT TCB ADDR (O.PTCB=A.BYT) ; CS018
        MOV     #8.*2,(R3)+     ;BYTES ON USER STACK (O.PTCB=A.BYT)     ; CS018
        TST     (R3)+           ;SKIP OVER AST WORD (O.AST=A.AST)       ; CS018
        MOV     (R3),R0         ;PICK UP EFN NUMBER (O.EFN=A.NPR)       ; CS018
        CALL    $SETF           ;SET THE EVENT FLAG                     ; CS018
        MOV     #1,(R3)+        ;SET NUMBER OF AST PARMS (O.EFN=A.NPR)  ; CS018
        MOV     (R3)+,R0        ;PICK UP VIRTUAL ESB ADDR (O.ESB=A.PRM) ; CS018
        BEQ     40$             ;IF EQ THERE IS NONE                    ; CS018
        MOV     (R3),-(SP)      ;PICK UP NEXT WORD OF STATUS            ; CS018
        MTPI    (R0)            ;STORE WORD IN USER BUFFER (CAN TRAP)   ; CS018
40$:    TST     O.AST(R4)       ;EFFECT AST?                            ; CS018
        BEQ     50$             ;IF EQ NO                               ; CS018
        MOV     R5,R0           ;SET PARENT TCB ADDRESS                 ; CS018
        MOV     R4,R1           ;SET AST BLOCK ADDRESS                  ; CS018
        CALLR   $QASTT          ;QUEUE AST FOR PARENT AND RETURN        ; CS018
50$:    MOV     R4,R0           ;POINT TO BLOCK TO RELEASE              ; CS018
        MOV     #O.LGTH,R1      ;PICK UP SIZE TO RELEASE                ; CS018
        CALL    $DEACB          ;DEALLOCATE OCB                         ; CS018
        CALLR   $SETRT          ;INSURE RESCAN OF TASK                  ; CS018
                                                                        ; CS018
        .ENDC   ;P$$OFF                                                 ; CS018
                                                                        ; CS018
                                                                        ; CS018

;+
; **-$FINBF-FINISH TERMINAL INPUT BUFFERED I/O
;
; THIS ROUTINE IS CALLED TO COMPLETE A BUFFERED TERMINAL INPUT
; REQUEST THAT HAS BEEN PLACED IN THE AST QUEUE.
;
; INPUTS:
;
;       R0=ADDRESS OF I/O PACKET.
;
; OUTPUTS:
;
;       THE BUFFERED I/O IS TRANSFERED TO THE USER TASK AND $IOFIN
;       IS CALLED TO FINISH THE I/O REQUEST.
;-


                                                                        ; CS013
        .IF DF T$$CPW                                                   ; CS013
                                                                        ; CS013
$FINBF::SAVNR                   ;SAVE NONVOLITILE REGISTERS             ; CS013
        MOV     R0,R3           ;COPY I/O PACKET ADDRESS                ; CS013
        MOV     I.TCB(R3),R5    ;RETRIEVE TASK TCB ADDRESS              ; CS013
        INCB    T.IOC(R5)       ;INCREMENT OUTSTANDING I/O COUNT        ; CS013
        MOV     I.IOSB(R3),R0   ;GET ADDRESS OF TASK'S I/O STATUS BUFFER; CS013
        BEQ     10$             ;NONE - JUMP                            ; CS013
        MOV     I.PRM+6(R3),-(SP) ;PUSH FIRST WORD OF I/O STATUS        ; CS013
        MTPI    (R0)+           ;WRITE IN USER IOSB (ANY TRAP IGNORED)  ; CS013
        MOV     I.PRM+10(R3),-(SP) ;PUSH SECOND WORD OF I/O STATUS      ; CS013
        MTPI    (R0)+           ;WRITE IN USER IOSB+2 (ANY TRAP IGNORED); CS013
        CLR     I.IOSB+4(R3)    ;NO I/O STATUS BLOCK FOR $IOFIN         ; CS013
10$:    MOV     R3,-(SP)        ;SAVE I/O PACKET ADDRESS                ; CS013
        ADD     #I.PRM+16,R3    ;POINT TO PCB ADDRESS                   ; CS013
        MOV     (R3),R5         ;SAVE PCB ADDRESS (I.PRM+16)            ; CS013
        CLR     (R3)            ;CLEAR PCB ADDRESS WORD (I.PRM+16)      ; CS013
        TST     -(R3)           ;BACKUP POINTER (I.PRM+14)              ; CS013
        MOV     -(R3),R2        ;PICK UP INPUT BUFFER ADDRESS (I.PRM+12); CS013
        BEQ     20$             ;IF EQ THERE IS NONE                    ; CS013
        MOV     -10(R3),R4      ;GET START ADDR OF USER BUFFER (I.PRM+2); CS013
        MOV     @I.UCB-<I.PRM+12>(R3),R0 ;POINT TO DRIVER DCB           ; CS013
        MOV     D.PCB(R0),R0    ;POINT TO DRIVER PCB                    ; CS013
        MOV     P.REL(R0),-(SP) ;PUSH BASE ADDRESS OF PARTITION         ; CS013
11$:    CMP     R2,#120000      ;BUFFER IN DRIVER SPACE?                ; CS013
        BLO     15$             ;IF LO NO                               ; CS013
        MOV     R2,R1           ;COPY BUFFER ADDRESS                    ; CS013
        BIC     #77,R1          ;REMOVE DISPLACEMENT IN BLOCK BITS      ; CS013
        SUB     #120000,R1      ;CALC OFFSET IN DRIVER PAR IN BYTES     ; CS013
        SUB     R1,R2           ;REDUCE ADDRESS TO FIT IN KERNEL 5      ; CS013
        ASL     R1              ;CONVERT BYTE OFFSET TO 32W BLOCKS      ; CS013
        ASL     R1              ;                                       ; CS013
        SWAB    R1              ;                                       ; CS013
        ADD     (SP),R1         ;CALCULATE PHYSICAL MEMORY OFFSET       ; CS013
        MOV     R1,KISAR5       ;MAP BUFFER                             ; CS013
15$:    MOV     (R2)+,-(SP)     ;SAVE POINTER TO NEXT BUFFER            ; CS013
        MOV     (R2)+,R0        ;PICK UP SIZE OF BLOCK                  ; CS013
        SUB     #4,R0           ;REDUCE COUNT BY HEADER BYTES           ; CS013
        SUB     R0,-(R3)        ;IS THERE THAT MUCH LEFT?               ; CS013
        BCC     16$             ;IF CC YES                              ; CS013
        ADD     (R3),R0         ;ELSE SET CORRECT COUNT                 ; CS013
        CLR     (R3)            ;CLEAR REMAINING BYTE COUNT             ; CS013
16$:    TST     R0              ;ANYTHING TO MOVE?                      ; CS013
        BEQ     17$             ;NO, DON'T CALL BLXIO WITH 0 LENGTH     ; CS013
        MOV     -10(R3),R3      ;PICK UP KISAR6 BIAS (I.PRM)            ; CS013
        ADD     P.REL(R5),R3    ;ADD IN PARTITION BASE                  ; CS013
        CALL    $BLXIO          ;TRANSFER TO USER BUFFER                ; CS013
17$:    MOV     (SP)+,R2        ;RETRIEVE POINTER TO NEXT BUFFER        ; CS013
        MOV     2(SP),R3        ;RETRIEVE I/O PACKET POINTER            ; CS013
        ADD     #I.PRM+10,R3    ;POINT TO BYTE COUNT                    ; CS013
        TST     (R3)+           ;MORE TO GO? (I.PRM+10)                 ; CS013
        BNE     11$             ;IF NE YES                              ; CS013
        MOV     (SP)+,KISAR5    ;MAP DRIVER IN I SPACE                  ; CS013
        MOV     (R3),R0         ;POINT TO FIRST BUFFER (I.PRM+12)       ; CS013
        MOV     @I.UCB-<I.PRM+12>(R3),R2 ;POINT TO DRIVER DCB           ; CS013
        MOV     D.DSP(R2),R2    ;POINT TO DRIVER DISPATCH TABLE         ; CS013
        CALL    @D.VDEB(R2)     ;CALL DRIVER DEALLOCATION ROUTINE       ; CS013
20$:    MOV     (SP)+,R3        ;RESTORE PACKET ADDRESS                 ; CS013
        CALLR   $IOFIN          ;COMPLETE I/O  REQUEST                  ; CS013
                                                                        ; CS013
        .IFF    ;T$$CPW                                                 ; CS013
                                                                        ; CS013
        .IF DF  C$$CKP&T$$BUF

$FINBF::SAVNR                   ;SAVE NONVOLITILE REGISTERS
        MOV     R0,R3           ;COPY I/O PACKET ADDRESS
        MOV     I.TCB(R3),R5    ;RETRIEVE TASK TCB ADDRESS
        INCB    T.IOC(R5)       ;INCREMENT OUTSTANDING I/O COUNT


        .IF DF  M$$MGE

        MOV     I.IOSB(R3),R0   ;GET VIRTUAL ADDRESS OF I/O STATUS BLK
        BEQ     10$             ;IF EQ NONE SPECIFIED
        CALL    $RELOC          ;RELOCATE I/O STATUS BLOCK
        MOV     R1,I.IOSB+2(R3) ;SET RELOCATION BIAS
        MOV     R2,I.IOSB+4(R3) ;SET BUFFER ADDRESS

        .IFTF

10$:    MOV     I.UCB(R3),R5    ;GET TERMINAL UCB ADDRESS
        MOV     R3,R4           ;COPY ADDRESS OF I/O PACKET
        ADD     #I.PRM+12,R4    ;POINT TO INPUT BUFFER ADDRESS
        MOV     (R4),-(SP)      ;SAVE INPUT BUFFER ADDRESS
        MOV     (R4),R2         ;SET ADDRESS OF INPUT BUFFER FOR COPY
        MOV     -(R4),-(SP)     ;GET NUMBER OF BYTES TRANSFERED
        MOV     (SP),-(SP)      ;COPY NUMBER OF BYTES TRANSFERED
        MOV     -(R4),R0        ;GET FINAL I/O STATUS
        TST     -(R4)           ;BYPASS SIZE OF USER BUFFER
        MOV     -(R4),R1        ;SET ADDRESS OF USER BUFFER FOR COPY

        .IFT


        .IF DF  D$$YNM

        MOV     14(R4),R1       ;GET ADDRESS OF DESCRIPTOR PCB


        .IF DF  R$$LKL

        CLR     14(R4)          ;CLEAR LAST PARAMETER WORD

        .ENDC


        ADD     P.REL(R1),-(R4) ;CONVERT TO ACTUAL RELOCATION BIAS
        MOV     (R4)+,KISAR6    ;MAP TO USER BUFFER
        MOV     (R4),R1         ;RELOAD USER BUFFER ADDRESS

        .IFF

        MOV     -(R4),KISAR6    ;MAP TO USER BUFFER

        .ENDC


        .ENDC


20$:    DEC     (SP)            ;ANY MORE BYTES TO COPY?
        BLT     30$             ;IF LT NO
        MOVB    (R2)+,(R1)+     ;TRANSFER BYTE TO USER BUFFER
        BR      20$             ;
30$:    TST     (SP)+           ;CLEAN STACK
        MOV     (SP)+,R1        ;SET SECOND I/O STATUS WORD
        CALL    $IOFIN          ;FINISH I/O OPERATION
        MOV     (SP)+,R0        ;RETRIEVE ADDRESS OF INPUT BUFFER


        .IF NDF T$$VBF

        CMP     -(R0),-(R0)     ;ADJUST TO START OF BUFFER
        MOV     #84.,R1         ;SET SIZE OF BLOCK TO RELEASE

        .IFF

        MOV     -(R0),R1        ;PICK UP BUFFER SIZE
        TST     -(R0)           ;POINT TO START OF BUFFER

        .ENDC


        CALL    $DEACB          ;DEALLOCATE INPUT BUFFER
        RETURN                  ;

        .ENDC

                                                                        ; CS013
        .ENDC   ;T$$CPW                                                 ; CS013
                                                                        ; CS013
                                                                        ; CS018
; (REMOVE CONDITIONAL)                                          ; CS024 ; CS018
                                                                        ; CS018
;+                                                                      ; CS018
; **-$SGFIN-SEGMENT FAULT AND TRAP 4 INTERCEPT ROUTINE                  ; CS018
;                                                                       ; CS018
; THIS ROUTINE IS A CO-ROUTINE WHICH SETS UP TO IGNORE SEGMENT FAULTS   ; CS018
; AND TRAPS THROUGH 4.                                                  ; CS018
;                                                                       ; CS018
; INPUTS:                                                               ; CS018
;                                                                       ; CS018
;       NONE.                                                           ; CS018
;                                                                       ; CS018
; OUTPUTS:                                                              ; CS018
;                                                                       ; CS018
;       NONE.                                                           ; CS018
;-                                                                      ; CS018
                                                                        ; CS018
$SGFIN::MOV     @#4,-(SP)       ;SAVE CONTENTS OF TRAP 4 VECTOR         ; CS018
                                                                        ; CS018
                                                                        ; CS018
        .IF DF  P$$D70                                                  ; CS018
                                                                        ; CS018
        MOV     @#114,-(SP)     ;SAVE MAIN MEMORY TIMEOUT AND PARITY    ; CS018
        MOV     4(SP),-(SP)     ;COPY RETURN ADDRESS                    ; CS018
        MOV     @#250,6(SP)     ;SAVE SEGMENT TRAP ADDRESS              ; CS018
        MOV     #10$,@#114      ;TRAP THESE FAULTS                      ; CS018
                                                                        ; CS018
        .IFF    ;P$$D70                                                 ; CS018
                                                                        ; CS018
        MOV     2(SP),-(SP)     ;COPY RETURN ADDRESS                    ; CS018
        MOV     @#250,4(SP)     ;SAVE CONTENTS OF SEGMENT FAULT VECTOR  ; CS018
                                                                        ; CS018
        .IFTF   ;P$$D70                                                 ; CS018
                                                                        ; CS018
        MOV     #10$,@#4        ;POINT TO ROUTINE TO SET CARRY          ; CS018
        MOV     #10$,@#250      ;                                       ; CS018
                                                                        ; CS018
;                                                                       ; CS018
; CONTENTS OF STACK AT THIS POINT:                                      ; CS018
;                                                                       ; CS018
;       0(SP)=COROUTINE RETURN ADDRESS TO CALLER.                       ; CS018
;       2(SP)=CONTENTS OF @#114 (IF DF P$$D70)                          ; CS018
;       4(SP)=CONTENTS OF @#4                                           ; CS018
;       6(SP)=CONTENTS OF @#250                                         ; CS018
;                                                                       ; CS018
                                                                        ; CS018
        CALL    @(SP)+          ;RETURN TO CALLER                       ; CS018
                                                                        ; CS018
        .IFT    ;P$$D70                                                 ; CS018
                                                                        ; CS018
        MOV     (SP)+,@#114     ;RESTORE MAIN MEMORY TIMEOUT TRAP       ; CS018
                                                                        ; CS018
        .ENDC   ;P$$D70                                                 ; CS018
                                                                        ; CS018
        MOV     (SP)+,@#4       ;RESTORE TRAP 4 VECTOR                  ; CS018
        MOV     (SP)+,@#250     ;RESTORE SEGMENT FAULT VECTOR           ; CS018
        RETURN                  ;RETURN TO CALLER'S CALLER              ; CS018
                                                                        ; CS018
10$:    BIS     #1,2(SP)        ;SET CARRY BIT                          ; CS018
        RTI                                                             ; CS018
                                                                        ; CS018
; (REMOVE CONDITIONAL)                                          ; CS024 ; CS018
;+                                                                      ;**-1
; **-$SAVNR-SAVE NONVOLATILE REGISTERS
;
; THIS ROUTINE IS A CO-ROUTINE THAT SAVES REGISTERS R4 AND R5.
;-

$SAVNR::MOV     R4,-(SP)        ;SAVE R4
        MOV     R5,-(SP)        ;SET RETURN ADDRESS
        MOV     4(SP),R5        ;RESTORE R5
        CALL    @(SP)+          ;CALL THE CALLER
        MOV     (SP)+,R4        ;RESTORE R4
        MOV     (SP)+,R5        ;RESTORE R5
        RETURN                  ;RETURN TO ORIGINAL CALLER

;+
; **$SWSTK-SWITCH STACKS
;
; THIS ROUTINE IS CALLED FROM TASK LEVEL TO SWITCH TO THE SYSTEM
; STACK THUS INHIBITING TASK SWITCHING. THE CALLING TASK MUST BE
; PRIVILEGED IF RUNNING IN A MAPPED SYSTEM AND MAPPED TO THE EXEC.
; CONTROL IS PASSED HERE FROM DRDSP AFTER THE TRAP HAS OCCURED AND
; $DIRSV HAS BEEN CALLED.
;
; CALLING SEQUENCE:
;
;       EMT     376             ;TRAP TO $EMSST IN DRDSP
;       .WORD   ADDR            ;ADDRESS FOR RETURN TO USER STATE
;
; INPUTS AT THIS POINT:
;
;       R3=ADDRESS OF PC WORD OF TRAP ON STACK + 2
;
;   MAPPED SYSTEM:
;
;       22(SP)=PS PUSHED BY TRAP
;       20(SP)=PC PUSHED BY TRAP
;       16(SP)=SAVED R5
;       14(SP)=SAVED R4
;       12(SP)=SAVED R3
;       10(SP)=SAVED R2
;       06(SP)=SAVED R1
;       04(SP)=SAVED R0
;       02(SP)=RETURN ADDRESS FOR SYSTEM EXIT
;       00(SP)=104376
;
;   UNMAPPED SYSTEM:
;
;       10(SP)=SAVED R3
;       06(SP)=SAVED R2
;       04(SP)=SAVED R1
;       02(SP)=SAVED R0
;       00(SP)=RETURN ADDRESS FOR SYSTEM EXIT
;
; OUTPUTS:
;
;       THE USER IS CALLED BACK ON THE SYSTEM STACK WITH ALL REGISTERS
;       PRESERVED.  TO RETURN TO TASK LEVEL THE CALLER MERELY EXECUTES
;       A RETURN.
;
;-

$SWSTK::CLRB    (R3)            ;SET INITIAL PS WORD


        .IF DF  M$$MGE

        MOV     #KISAR6,R5      ;POINT TO KERNAL APR 6
        MOV     UISAR6,(R5)     ;SET UP KERNAL APR 6
        MOV     UISAR5,-(R5)    ;SET UP KERNAL APR 5


        .IF NDF R$$EXV

        MOV     UISAR4,-(R5)    ;SET UP KERNAL APR 4

        .ENDC


        .IFTF

        MOV     -(R3),R5        ;PICK UP TRAP PC WORD
        MOV     (R5)+,(R3)      ;SET ADDRESS FOR RETURN TO USER STATE

        .IFT

        MOV     R5,(SP)         ;SET CALLER'S ADDRESS

        .IFF

        MOV     R5,-(SP)        ;SET CALLER'S ADDRESS

        .ENDC


        MOV     -(R3),R5        ;RESTORE R5
        MOV     12(SP),R3       ;RESTORE R3
        CALLR   @(SP)+          ;CALL THE CALLER

        .END
        .TITLE  SYTAB
        .IDENT  /09/
 
;
; COPYRIGHT (C) 1974, 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 09
;
; H. LEV 23-AUG-75
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;
;
; MODIFIED BY:
;       T. J. MILLER    31-JUL-77
;
;               TM115 -- MODIFY LOADER TCB FOR LB:
;
;       CHUCK SPITZ 9-SEP-78
;               CS017 -- MODIFY LOADR TCB FOR T.SAST
;
;       CHUCK SPITZ 2-NOV-78
;               CS018 -- MODIFY LOADR TCB FOR PARENT OFFSPRING TASKING
;
;       CHUCK SPITZ 30-MAR-79
;               CS046 -- DO NOT ALLOW SENDS TO LOADR
;
; SYSTEM TABLES NEEDED TO BOOTSTRAP SYSTEM AND FOR RESIDENT TASKS
;
; MACRO LIBRARY CALLS
;


        .IF NDF L$$LDR&R$$11S

        .MCALL  HWDDF$,PCBDF$,TCBDF$
        HWDDF$                  ; DEFINE HARDWARE REGISTERS
        PCBDF$
        TCBDF$                  ; DEFINE TASK CONTROL BLOCK OFFSETS

;
; LOCAL DATA
;
; LOADER TASK HEADER
;

.LDRHD::.BLKW   1               ;H.CSP-CURRENT STACK POINTER
        .WORD   $PCBS-.LDRHD    ;H.HDLN-HEADER LENGTH IN BYTES
        .BLKW   2               ;H.EFLM-EVENT FLAG MASK WORD AND ADDRESS
        .BYTE   1,1             ;H.CUIC-CURRENT TASK UIC
        .BYTE   1,1             ;H.DUIC-DEFAULT TASK UIC


        .IF DF  M$$MGE

        .WORD   170000          ;H.IPS-INITIAL PROCESSOR STATUS WORD

        .IFF

        .WORD   0               ;H.IPS-INITIAL PROCESSOR STATUS WORD

        .IFTF

        .WORD   $LOADR          ;H.IPC-INITIAL PROGRAM COUNTER
        .WORD   20$             ;H.ISP-INITIAL STACK POINTER
10$:    .WORD   1               ;H.ODVA-NUMBER OF WINDOW BLOCKS
        .WORD   $PCBS           ;H.ODVL-W.BPCB-PARTITION CNTRL BLK ADDR
        .WORD   2               ;H.TKVA-W.BLVR-LOW VIRTUAL ADDRESS
        .WORD   117777          ;H.TKVL-W.BHVR-HIGH VIRTUAL ADDRESS
        .BLKW   1               ;H.PFVA-W.BATT-ATTACHMENT DESCR ADDRESS
        .BLKW   1               ;H.FPVA-W.BSIZ-WINDOW SIZE
        .BLKW   1               ;H.RCVA-W.BOFF-OFFSET IN PARTITION
        .BYTE   UISDR5          ;H.EFSV-W.BFPD-FIRST USER PDR
        .BYTE   1               ;H.EFSV+1-W.BNPD-NUMBER OF PDR'S
        .WORD   0               ;H.FPSA-W.BLPD-CONTENTS OF LAST PDR
        .WORD   10$             ;H.WND-POINTER TO NUMBER OF WINDOW BLKS
        .BLKW   1               ;H.DSW-DIRECTIVE STATUS WORD
        .BLKW   9.              ;H.FCS THRU H.GARD-2-LOADER'S STACK
20$:    .WORD   30$             ;H.GARD-POINTER TO HEADER GUARD WORD
        .WORD   1               ;H.NLUN-NUMBER OF LUNS
        .WORD   .SY0            ;UCB POINTER FOR FIRST LUN
        .WORD   0               ;WINDOW POINTER FOR FIRST LUN

        .IFT

        .BLKW   4               ;SAVE AREA FOR R4,R5,PC,PS

        .IFTF

        .BLKW   4               ;SAVE AREA FOR R0,R1,R2,R3
30$:    .WORD   0               ;HEADER GUARD WORD

;
; LOADER PARTITION CONTROL BLOCK
;

$PCBS:: .WORD   0               ;P.LNK-LINK TO NEXT PARTITION PCB
        .BYTE   248.            ;P.PRI-PRIORITY
        .BYTE   0               ;P.IOC-I/O COUNT
        .RAD50  /LDR/           ;P.NAM-FIRST WORD OF PARTITION NAME
        .WORD   0               ;P.NAM+2-SECOND WORD OF PARTITION NAME
        .WORD   0               ;P.SUB-SUBPARTITION LINK
        .WORD   $PCBS           ;P.MAIN-LINK TO MAIN PARTITION

        .IFT

        .WORD   0               ;P.REL-RELOCATION BIAS OF PARTITION

        .IFF

        .WORD   .LDRHD          ;P.HDR-POINTER TO LOADER HEADER

        .IFTF

        .BLKW   4               ;P.SIZE THRU P.BUSY-UNUSED
        .WORD   $STD            ;P.TCB-LOADER TCB ADDRESS
        .WORD   0               ;P.STAT-PARTITION STATUS

        .IFT

        .WORD   .LDRHD          ;P.HDR-POINT TO LOADER TASK HEADER

        .ENDC


;
; LOADER TASK CONTROL BLOCK
;

$STD::                          ;START OF TASK LIST
.LDR::  .WORD   0               ;T.LNK-UTILITY LINK WORD
        .BYTE   248.            ;T.PRI-TASK PRIORITY
        .BYTE   0               ;T.IOC-TASK I/O COUNT
        .WORD   $STD            ;T.TCB-POINTER TO THIS TCB
        .RAD50  /. LDR./        ;T.NAM-TASK NAME
        .WORD   0,.-2           ;T.RCVL-RECEIVE LISTHEAD
        .WORD   0,.-2           ;T.ASTL-AST QUEUE LISTHEAD
        .WORD   0,0             ;T.EFLG-TASK LOCAL EVENT FLAGS
        .WORD   0               ;T.UCB-TI UCB ADDRESS
        .WORD   $HEADR          ;T.TCBL-TASK LIST THREAD WORD
        .WORD   TS.EXE          ;T.STAT-BLOCKING BITS
        .WORD   T2.CHK!T2.FXD   ;T.ST2-STATE BITS
        .WORD   T3.PRV!T3.NSD   ;T.ST3-ATTRIBUTE BITS                   ; CS046
        .BYTE   248.            ;T.DPRI-NONRESIDENT PARTITION COUNTER   ;**-1
        .BLKB   3               ;T.LBN-LBN OF TASK IMAGE
        .WORD   .LB0            ;T.LDV-LOAD DEVICE UCB
        .WORD   $PCBS           ;T.PCB-TASK PCB ADDRESS
        .WORD   0               ;T.MXSZ-MAXIMUM SIZE OF TASK IMAGE
        .WORD   0               ;T.ACTL-ACTIVE TASK LIST THREAD


        .IF DF  P$$LAS

        .WORD   0,.-2           ;T.ATT-ATTACHMENT DESCRIPTOR LISTHEAD
        .WORD   0               ;T.OFF-OFFSET IN TASK PARTITION
        .BYTE   0               ;(UNUSED)
        .BYTE   0               ;T.SRCT-SEND BY REF WITH EFN COUNT
        .WORD   0,.-2           ;T.RRFL-RECEIVE BY REFERENCE LISTHEAD   ;**-4
                                                                        ;**-3
        .ENDC


                                                                        ; CS018
        .IF DF P$$OFF                                                   ; CS018
                                                                        ; CS018
        .WORD   0,.-2           ;T.OCBH-OFFSPRING CONTROL BLOCK LIST    ; CS018
        .WORD   0               ;T.RDCT-OFFSPRING RUNDOWN COUNT         ; CS018
                                                                        ; CS018
        .ENDC   ;P$$OFF                                                 ; CS018
                                                                        ; CS018
        .WORD   0               ;T.SAST-SPECIFIED AST LISTHEAD          ; CS017
                                                                        ; CS017
        .ENDC


        .END
        .TITLE  TDSCH
        .IDENT  /08/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 08
;
; D. N. CUTLER 11-AUG-73
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       C. A. D'ELIA
;       T. J. MILLER
;
; MODIFIED BY:
;
;       T. J. MILLER 26-MAY-77
;
;               TM086 -- MODIFY TO USE NEW EVENT FLAG SETTING ROUTINE.
;
; TIME DEPENDENT SCHEDULING AND DEVICE TIME OUT
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  CLKDF$,HDRDF$,HWDDF$,TCBDF$,PCBDF$
        CLKDF$                  ;DEFINE CLOCK QUEUE CONTROL BLOCK OFFSET
        HDRDF$                  ;DEFINE TASK HEADER OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
 
;
; LOCAL DATA
;
        
        
        .IF DF  R$$NDC
        
RNDCT:  .WORD   R$$NDC          ;CLOCK TICKS TO NEXT SCHEDULE INTERVAL
        
        .ENDC
        
        
        .IF DF  S$$WPC&D$$ISK
 
SWPCT:  .WORD   S$$WPC          ;CLOCK TICKS TO NEXT SWAPPING INTERVAL
 
        .ENDC
 
 
;+
; **-$CKINT-CLOCK INTERRUPT
;
; THIS ROUTINE IS ENTERED AS THE RESULT OF A CLOCK INTERRUPT. $INTSV
; IS CALLED TO SAVE REGISTERS R4 AND R5 AND $INTCT IS INCREMENT. IF
; THE RESULT IS NONZERO, THEN A JUMP TO $INTXT IS EXECUTED. ELSE
; A FORK IS EXECUTED SO THAT PENDING CLOCK INTERRUPTS CAN BE PRO-
; CESSED.
;-
 
$CKINT::CALL    $INTSV,PR6      ;;;SAVE REGISTERS AND SET PRIORITY
        
        
        .IF DF  K$$W11
        
        MOV     #3,K$$W11       ;;;ENABLE AND START TIMER
        
        .ENDC
        
        
        MOV     #$INTCT,R4      ;;;POINT TO INTERRUPT COUNT
        INC     (R4)            ;;;INCREMENT INTERRUPT COUNT
        BEQ     10$             ;;;IF EQ FORK
        RETURN                  ;;;EXIT FROM INTERRUPT
10$:    CALL    $FORK0          ;;;EXECUTE FORK
 
;
; UPDATE ABSOLUTE AND REAL TIME OF DAY AND DATE
;
 
UPTIM:  MOV     #$TKPS+2,R4     ;POINT PAST CONVERSION VECTOR
        MOV     #$TTNS+2,R5     ;POINT PAST CURRENT TIME VECTOR
10$:    MOV     #$TTNS-10,R2    ;POINT TO DAY
        INC     -(R5)           ;UPDATE A COUNTER
        CMP     -(R4),(R5)      ;EXCEEDED LIMIT?
        BHI     20$             ;IF HI NO
        CLR     (R5)            ;RESET COUNTER
        CMP     R5,R2           ;CHECK FOR LAST DAY OR MONTH
        BHI     10$             ;IF HI NO
        INC     (R5)            ;DAY AND MONTH ARE 1 ORIGIN
        BCS     10$             ;IF CS NOT DAY
        MOV     -(R2),R1        ;GET CURRENT MONTH
        MOVB    $DYPMN-1(R1),R0 ;GET DAYS FOR NEXT MONTH PLUS 1
        MOV     R0,(R4)         ;MOVE TO DAYS PER MONTH LIMIT
        DEC     R1              ;IS CURRENT MONTH ENDING JANUARY?
        BNE     10$             ;IF NE NO
        BIT     #3,-(R2)        ;IS THIS A LEAP YEAR?
        BNE     10$             ;IF NE NO
        INC     (R4)            ;INCREMENT DAYS FOR FEBRUARY
        BR      10$             ;
20$:    INC     $ABTIM          ;UPDATE ABSOLUTE TIME COUNTER
        BNE     TDS             ;IF NE NO OVERFLOW
        MOV     #$CLKHD,R0      ;POINT TO CLOCK QUEUE LISTHEAD
40$:    MOV     (R0),R0         ;GET ADDRESS OF NEXT ENTRY
        BEQ     TDS             ;IF EQ NO MORE IN LIST
        DEC     C.TIM+2(R0)     ;ADJUST HIGH ORDER TIME
        BR      40$             ;
 
;
; TIME DEPENDENT SCHEDULING
;
 
TDS:    MOV     $CLKHD,R4       ;GET ADDRESS OF NEXT IN QUEUE
        BEQ     DVOUT           ;IF EQ NONE IN LIST
        TST     C.TIM+2(R4)     ;HIGH ORDER PART NONZERO?
        BNE     DVOUT           ;IF NE YES
        CMP     $ABTIM,C.TIM(R4) ;TIME TO GO?
        BLO     DVOUT           ;IF LO NO
        MOV     (R4),$CLKHD     ;REMOVE ENTRY FROM CLOCK QUEUE
        MOVB    C.RQT(R4),R5    ;GET ENTRY REQUEST TYPE
        ADD     R5,PC           ;DISPATCH TO PROCESSING ROUTINE
10$:    BR      20$             ;MARK TIME REQUEST
        BR      30$             ;TASK REQUEST WITH PERIODIC RESCHEDULE
        BR      30$             ;SINGLE SHOT TASK REQUEST
        BR      15$             ;SINGLE SHOT INTERNAL SUBROUTINE
 
 
        .IF DF  D$$SHF&D$$YNM
 
        BR      15$             ;SINGLE SHOT INTERNAL SUBROUTINE
 
;
; CLEAR STOP BIT AND REALLOCATE PARTITION
;
 
        MOV     C.TCB(R4),R0    ;PICK UP TCB ADDRESS
        CALL    $EXRQN          ;CLEAR STOP BIT AND REALLOCATE PARTITION
        BR      TDS             ;
 
        .ENDC
 
 
;
; SINGLE SHOT INTERNAL SYSTEM SUBROUTINE (TYPE 6 OR 8)
;
 
15$:                            ;
 
 
        .IF DF  L$$DRV & M$$MGE
 
        MOV     KISAR5,-(SP)    ;SAVE APR5
        MOV     C.AR5(R4),KISAR5  ;MAP TO SYSTEM ROUTINE (DRIVER)
 
        .IFTF
 
        CALL    @C.SUB(R4)      ;CALL SYSTEM SUBROUTINE
 
        .IFT
 
        MOV     (SP)+,KISAR5    ;RESTORE APR5
 
        .ENDC
 
 
        BR      TDS             ;
 
;
; MARK TIME REQUEST
;
 
20$:    MOV     C.SRC(R4),R0    ;PICK UP EVENT FLAG MASK WORD
        MOV     C.DST(R4),R1    ;PICK UP EVENT FLAG MASK ADDRESS
        MOV     C.TCB(R4),R5    ;PICK UP TCB ADDRESS
        CALL    $SETM           ;SET THE EVENT FLAG
        CLR     R5              ;RESET CLOCK BLOCK TYPE
 
 
        .IF DF  A$$TRP
 
        MOV     C.AST(R4),R3    ;GET AST TRAP ADDRESS
        BEQ     40$             ;IF EQ NO AST SPECIFIED
        MOVB    C.EFN(R4),R2    ;GET EFN NUMBER
        MOV     R4,R1           ;COPY ADDRESS OF CLOCK QUEUE ENTRY
        TST     (R4)+           ;POINT TO CONTROL BLOCK LENGTH
        MOV     #C.LGTH,(R4)+   ;SET LENGTH OF AST CONTROL BLOCK
        MOV     #8.*2,(R4)+     ;SET BYTES TO ALLOCATE ON TASK STACK
        MOV     R3,(R4)+        ;INSERT AST TRAP ADDRESS
        MOV     #1,(R4)+        ;SET NUMBER OF AST PARAMETERS
        MOV     R2,(R4)         ;INSERT EFN AS AST PARAMETER
        CALL    $QASTT          ;QUEUE AST TO TASK
        BR      TDS             ;
 
        .IFF
 
        BR      40$             ;RELEASE CLOCK CONTROL BLOCK
 
        .ENDC
 
 
;
; SCHEDULE REQUEST
;
 
30$:    MOV     C.TCB(R4),R0    ;GET TASK TCB ADDRESS
        MOV     C.UIC(R4),R1    ;GET REQUEST UIC
        CALL    $TSKRT          ;REQUEST TASK EXECUTION
40$:    MOV     R4,R0           ;SET ADDRESS OF BLOCK TO RELEASE
        CMPB    #C.SCHD,R5      ;PERIODIC REQUEST?
        BEQ     50$             ;IF EQ YES
        CALL    $DECLK          ;DEALLOCATE CONTROL BLOCK
        BR      TDS             ;
50$:    MOV     C.RSI+2(R0),R1  ;SET HIGH ORDER PART OF TIME
        MOV     C.RSI(R0),R2    ;SET LOW ORDER PART OF TIME
        MOV     R5,R4           ;SET REQUEST TYPE
        MOV     C.TCB(R0),R5    ;SET ADDRESS OF REQUEST TASK TCB
        CALL    $CLINS          ;REINSERT ENTRY IN CLOCK QUEUE
        BR      TDS             ;
 
;
; DEVICE TIME OUT
;
 
DVOUT:  TST     $TTNS           ;ONE SECOND ELAPSED?
        BNE     ROBIN           ;IF NE NO
        MOV     #$SCDVT,-(SP)   ;SET ADDRESS OF DEVICE TABLE SCANNING CO-ROUTINE
10$:    CALL    @(SP)+          ;GET NEXT UCB ADDRESS
        BCS     ROBIN           ;IF CS END OF TABLE
        MTPS    S.PRI(R4)       ;;;RAISE PRIORITY TO DEVICE LEVEL
        TSTB    U.STS(R5)       ;;;UNIT BUSY?
        BPL     20$             ;;;IF PL NO
        TSTB    S.CTM(R4)       ;;;TIMEOUT ACTIVE?
        BEQ     20$             ;;;IF EQ NO
        DECB    S.CTM(R4)       ;;;DECREMENT TIMEOUT COUNT
        BNE     20$             ;;;IF NE MORE TIME TO GO
        MOV     #IE.DNR&377,R0  ;;;SET DEVICE TIMEOUT STATUS
        MOV     D.DSP(R3),R1    ;;;GET ADDRESS OF DRIVER DISPATCH TABLE
        MOV     S.CSR(R4),R2    ;;;GET ADDRESS OF DEVICE CSR
 
 
        .IF DF  L$$DRV&M$$MGE
 
        MOV     KISAR5,-(SP)    ;;;SAVE APR5
        MOV     D.PCB(R3),R3    ;;;GET DRIVER PCB ADDRESS
        BEQ     15$             ;;;IF EQ DRIVER IS PART OF EXEC
        MOV     P.REL(R3),KISAR5  ;;;MAP THE DRIVER
15$:                            ;;;
 
        .IFTF
 
        MOVB    S.CON(R4),R3    ;;;GET CONTROLLER INDEX
 
;
; CALL DRIVER AT TIMEOUT ENTRY POINT WITH THE ARGUMENTS:
;
;       R0=DEVICE TIMEOUT STATUS 'IE.DNR'.
;       R2=ADDRESS OF DEVICE CSR.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
 
        CALL    @D.VOUT(R1)     ;;;ENTER DRIVER
 
        .IFT
 
        MOV     (SP)+,KISAR5    ;;;RESTORE APR5
 
        .ENDC
 
 
20$:    MTPS    #0              ;;;ALLOW INTERRUPTS
        BR      10$             ;GO AGAIN
 
;
; EXECUTIVE LEVEL ROUND ROBIN SCHEDULING
;
        
ROBIN:                          ;REF LABEL
        
        
        .IF DF  R$$NDC
        
        DEC     RNDCT           ;TIME TO SCHEDULE?
        BNE     SWAP            ;IF NE NO
        MOV     #R$$NDC,RNDCT   ;RESET CLOCK TICKS TO NEXT INTERVAL
        CALL    $DRDSE          ;CAUSE A REDISPATCH OF PROCESSOR
        MOV     #$ACTHD-T.ACTL,R1 ;SET ADDRESS OF PREVIOUS ENTRY
10$:    MOV     R1,R0           ;SAVE ADDRESS OF PREVIOUS ENTRY
        MOV     T.ACTL(R0),R1   ;GET ADDRESS OF NEXT ENTRY
        BEQ     SWAP            ;IF EQ END OF LIST
        CMPB    #R$$NDH,T.PRI(R1) ;PRIORITY IN RANGE?
        BLO     10$             ;IF LO NO
20$:    CMPB    #R$$NDL,T.PRI(R1) ;PRIORITY IN RANGE?
        BHI     SWAP            ;IF HI NO
        TST     T.STAT(R1)      ;TASK BLOCKED?
        BNE     30$             ;IF NE YES
        BIT     #T2.SPN!T2.WFR,T.ST2(R1) ;TASK IN WAITFOR OR SUSPEND?
        BEQ     40$             ;IF EQ NO
30$:    MOV     R1,R0           ;SAVE ADDRESS OF LAST ENTRY
        MOV     T.ACTL(R0),R1   ;GET ADDRESS OF NEXT ENTRY
        BR      20$             ;
40$:    TST     T.ACTL(R1)      ;NULL TASK?
        BEQ     SWAP            ;IF EQ YES
        MOV     T.ACTL(R1),T.ACTL(R0) ;REMOVE TCB FROM TASK LIST
        MOV     R1,R2           ;SAVE ADDRESS OF TCB
        MOV     R0,R1           ;SET ADDRESS OF LAST ENTRY
50$:    MOV     R1,R0           ;SAVE ADDRESS OF LAST ENTRY
        MOV     T.ACTL(R0),R1   ;GET ADDRESS OF NEXT ENTRY
        CMPB    T.PRI(R1),T.PRI(R2) ;IN SAME PRIORITY CLASS?
        BEQ     50$             ;IF EQ YES
        MOV     R2,T.ACTL(R0)   ;SET ADDRESS OF NEXT IN LAST
        MOV     R1,T.ACTL(R2)   ;SET ADDRESS OF NEXT IN REMOVED ENTRY
        MOV     R2,R0           ;SET ADDRESS OF LAST ENTRY
        BR      20$             ;
        
        .ENDC
        
        
;
; DISK SWAPPING ALGORITHM - REDUCE SWAPPING PRIORITY OF RESIDENT TASKS
;
 
SWAP:                           ;REF LABEL
 
 
        .IF DF  C$$CKP&S$$WPC&D$$ISK
 
        DEC     SWPCT           ;TIME TO MODIFY PRIORITY DIFFERENCES?
        BNE     70$             ;IF NE NO
        MOV     #S$$WPC,SWPCT   ;RESET SWAP COUNT
        MOV     $PARHD,R5       ;POINT TO FIRST PCB IN LIST
10$:                            ;REF LABEL
 
 
        .IF DF  D$$YNM&M$$MGE
 
        BIT     #PS.SYS,P.STAT(R5) ;SYSTEM CONTROLLED PARTITION?
        BNE     30$             ;IF NE YES
 
        .IFTF
 
        BITB    P.BUSY(R5),P.BUSY+1(R5) ;PARTITION OCCUPIED?
        BEQ     20$             ;IF EQ NO
15$:    BIT     #PS.COM!PS.DRV,P.STAT(R5) ;COMMON OR DRIVER PARTITION?
        BNE     40$             ;IF NE YES
        MOV     P.TCB(R5),R4    ;PICK UP OWNER TCB ADDRESS
        BIT     #TS.CKP!TS.CKR!TS.OUT,T.STAT(R4) ;TASK IN MEMORY?
        BNE     40$             ;IF NE NO
        MOV     P.HDR(R5),R4    ;POINT TO TASK HEADER
        CMPB    H.SPRI(R4),#-S$$WPR ;SWAPPING PRIORITY AT MINIMUM?
        BLE     40$             ;IF LE YES
        DECB    H.SPRI(R4)      ;REDUCE SWAPPING PRIORITY
20$:    CMP     R5,P.MAIN(R5)   ;IS THIS THE MAIN PARTITION?
        BNE     40$             ;IF NE NO
30$:    MOV     R5,R0           ;COPY PCB ADDRESS
        CALL    $NXTSK          ;REALLOCATE PARTITION
40$:                            ;REF LABEL
 
        .IFT
 
        BIT     #PS.SYS,P.STAT(R5) ;SYSTEM CONTROLLED PARTITION?
        BEQ     60$             ;IF EQ NO
        TST     P.SUB(R5)       ;IS THERE ANOTHER SUBPARTITION?
        BEQ     50$             ;IF EQ NO
        MOV     P.SUB(R5),R5    ;POINT TO NEXT SUBPARTITION PCB
        BR      15$             ;
50$:    MOV     P.MAIN(R5),R5   ;POINT TO MAIN SYS PARTITION PCB
 
        .ENDC
 
 
60$:    MOV     (R5),R5         ;POINT TO NEXT PCB IN LIST
        BNE     10$             ;IF NE THERE IS ONE
70$:                            ;REF LABEL
 
        .ENDC
 
 
;
; EXIT TIME DEPENDENT SCHEDULE IF THERE ARE NOT REMAINING UNPROCESSED CLOCK TICK
;
 
TIMXT:  DEC     $INTCT          ;ANY MORE TICKS TO PROCESS?
        BGE     10$             ;IF GE YES
        RETURN                  ;
10$:    JMP     UPTIM           ;
 
        .END
        .TITLE  TTATT
        .IDENT  /V02.23/
;
; 09-FEB-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW010   14-APR-78       PETER WANNHEDEN
;               SUPPORT DEVICE-INDEPENDENT CURSOR CONTROL.
;               ADD IMPLICIT PAGE WIDTH AND LENGTH PER TERMINAL TYPE.
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED.
;       PW029   12-MAY-78       PETER WANNHEDEN
;               RETURN F2.SFF ON IO.GTS.
;       CS013   15-JUN-78       CHUCK SPITZ
;               ADD SUPPORT FOR RSX-11M
;       DD004   04-OCT-78       DALE R. DONCHIN
;               CHECK THAT A LINE CAN BE REMOTE BEFORE CHANGING ITS
;               REMOTE STATUS
;       DD006   01-NOV-78       DALE R. DONCHIN
;               FIX MULTIPROCESSOR FORK BUG.
;               FLUSH TYPE-AHEAD BUFFER WHEN UNSLAVING A TERMINAL.
;       DD010   15-NOV-78       DALE R. DONCHIN
;               ADD SUPPORT FOR ONLINE RECONFIGURATION
;       DD011   04-DEC-78       DALE R. DONCHIN
;               ADD TF.TBF, TF.CTS AND F2.CUP SUPPORT
;       DD013   12-JAN-78       DALE R. DONCHIN
;               FIX MISCELLANEOUS CONDITIONALIZATION ERRORS
;       DD015   28-FEB-79       DALE R. DONCHIN
;               ADD SEPARATE ^C AST
;       DD017   23-APR-79       DALE R. DONCHIN
;               MAINTAIN U.CW2 BIT DEFINITIONS
;       DD018   01-MAY-79       DALE R. DONCHIN
;               CORRECT MAPPING WHEN DRIVER > 4K
;
;+
; TTATT - THIS MODULE CONTAINS THE ROUTINES TO PROCESS
; THE FOLLOWING I/O FUNCTION CODES:
;       IO.ATT
;       IO.DET
;       IO.GTS
;       SF.GMC
;       SF.SMC
;-
;
;

        .IF NDF R$$MPL                                                          ; CS013
                                                                                ; CS013
        .MCALL  HWDDF$                                                          ; CS013
                                                                                ; CS013
        HWDDF$                  ;DEFINE KINAR5                                  ; CS013
                                                                                ; CS013
        .ENDC                                                                   ; CS013
                                                                                ; CS013
        .IF DF  T$$GTS

        .MCALL  TTSYM$
        TTSYM$                  ;DEFINE F1.XXX AND F2.XXX SYMBOLS
;
; GENERATE TERMINAL SUPPORT WORDS
;
; ALWAYS SUPPORTED OPTIONS:
;
TSP1    =       F1.ACR!F1.BUF!F1.CCO!F1.HLD!F1.LWC!F1.RNE                       ; DD013
TSP1    =       TSP1!F1.RST!F1.SYN!F1.TRW!F1.UTB!F1.VBF                         ;**-1
;
TSP2    =       F2.SFF                                                          ;PW029
;                                                                               ;**-1
; CONDITIONALLY SUPPORTED OPTIONS:
;
.IIF DF T$$BTW  TSP1    =       TSP1!F1.BTW
.IIF DF T$$CCA&A$$TRP   TSP1    =       TSP1!F1.UIA
.IIF DF T$$ESC  TSP1    =       TSP1!F1.ESQ
.IIF DF T$$RPR  TSP1    =       TSP1!F1.RPR                                     ;**-1
.IIF DF T$$RUB  TSP1    =       TSP1!F1.RUB
;
.IIF DF T$$GMC  TSP2    =       TSP2!F2.GCH
.IIF DF T$$SMC  TSP2    =       TSP2!F2.SCH
.IIF DF T$$CUP  TSP2    =       TSP2!F2.CUP                                     ; DD011

        .ENDC   ;T$$GTS

;
;
PPATT::

        .IF DF  T$$CCA&A$$TRP

        BIT     #TF.AST,I.FCN(R3)  ;ATTACH FOR UNSOLICITED INPUT AST?

        .IF DF  T$$ESC

        BEQ     40$             ;N - JUMP

        .IFF    ;T$$ESC

        BEQ     SUC             ;N - JUMP

        .ENDC   ;T$$ESC

        MOV     I.PRM(R3),-(SP) ;CHECK FOR NON-SPECIFIED AST ADDRESSES          ; DD015
        BIS     I.PRM+4(R3),(SP)+ ;ARE BOTH AST ADDRESSES ZERO?                 ; DD015
        BEQ     15$             ;Y - ERROR                                      ; DD015
        MOV     #24.,R1         ;GET LENGTH OF AST BLOCK IN BYTES               ; DD015
        CALL    $ALOCB          ;ALLOCATE FROM SYSTEM POOL                      ;**-5
        BCS     20$             ;FAILED - JUMP
        MOV     KINAR5,(R0)+    ;INSERT DRIVER APR 5 MAPPING (A.KSR5)
        MOV     #DQAST,(R0)+    ;INSERT POINTER TO ROUTINE TO CALL WHEN
                                ;AST BLOCK IS DEQUEUED (A.DQSR)
        MOV     R0,U.TAST(R4)   ;SAVE POINTER TO AST BLOCK IN UCB
        TST     (R0)+           ;SKIP OVER LINK WORD
        CLR     (R0)+           ;SET BLOCK LENGTH ZERO TO FORCE SYSXT
                                ;TO CALL US WHEN BLOCK IS DEQUEUED (A.CBL)
        MOV     #16.,(R0)+      ;ALLOCATE 16. BYTES ON TASK'S STACK (A.BYT)
        TST     (R0)+           ;SKIP PAST AST ADDRESS (A.AST)                  ; DD015
                                ;THIS WILL BE FILLED IN AT AST TIME             ; DD015
        MOV     #1,(R0)+        ;INSERT NUMBER OF AST PARAMETERS (A.NPR)        ;**-1
        INC     R0              ;SKIP OVER LOW BYTE OF PARAMETER (A.PRM)
        MOVB    I.PRM+2(R3),(R0)+ ;INSERT USER-DEFINED HIGH BYTE OF PARAMETER
                                ;(A.PRM+1)
        MOV     R5,(R0)+        ;INSERT POINTER TO U.TSTA (A.PRM+2)
        CLRB    (R0)+           ;CLEAR FLAGS (A.PRM+4)
        MOVB    I.FCN(R3),(R0)+ ;SAVE SUBFUNCTION CODE (A.PRM+5)                ; DD015
        MOV     I.PRM+4(R3),@R0 ;INSERT ^C ADDRESS INTO AST BLOCK               ; DD015
        BEQ     5$              ;NONE SPECIFIED - JUMP                          ; DD015
        BIT     #TF.XCC,I.FCN(R3) ;CONFLICTING SUBFUNCTION CODE?                ; DD015
        BNE     10$             ;Y - ERROR                                      ; DD015
        BIT     #1,@R0          ;ODD ADDRESS GIVEN?                             ; DD015
        BNE     10$             ;Y - ERROR                                      ; DD015
5$:     MOV     I.PRM(R3),2(R0) ;INSERT ALL CHARACTER AST ADDRESS               ; DD015
                                                                                ; DD015
        .IF DF  T$$ESC                                                          ; DD015
                                                                                ; DD015
        BEQ     40$             ;NONE SPECIFIED - JUMP                          ; DD015
                                                                                ; DD015
        .IFF    ;T$$ESC                                                         ; DD015
                                                                                ; DD015
        BEQ     SUC             ;NONE SPECIFIED - JUMP                          ; DD015
                                                                                ; DD015
        .ENDC   ;T$$ESC                                                         ; DD015
                                                                                ; DD015
        BIT     #1,2(R0)        ;ODD ADDRESS GIVEN?                             ; DD015
        BNE     10$             ;Y - ERROR                                      ; DD015
        BR      SUC             ;SUCCESS                                        ;**-1
10$:    SUB     #20.,R0         ;POINT TO TOP OF AST BLOCK                      ; DD015
        MOV     R3,-(SP)        ;SAVE A REG                                     ; DD015
        CALL    $DEACB          ;DEALLOCATE NEEDLESS AST BLOCK                  ; DD015
        MOV     (SP)+,R3        ;RESTORE A REG                                  ; DD015
        CLR     U.TAST(R4)      ;CLEAR POINTER TO AST BLOCK                     ; DD015
15$:    MOV     #IE.SPC,R0      ;SET ILLEGAL AST ADDRESS ERROR CODE             ; DD015
        BR      FIN             ;CALL $IOFIN TO FINISH UP                       ; DD015
20$:    MOV     #IE.NOD,R0      ;ERROR - NO DYNAMIC MEMORY                      ;**-2
        BR      FIN                                                             ;**-1

        .ENDC   ;T$$CCA&A$$TRP

40$:

        .IF DF  T$$ESC

        BIT     #TF.ESQ,I.FCN(R3) ;TASK WANTS ESCAPE SEQUENCES?
        BEQ     SUC             ;N - JUMP
        BIS     #S3.WES,4(R5)   ;Y - REMEMBER
        BR      SUC             ;SUCCESS

        .ENDC   ;T$$ESC

;
PPDET:: MOV     R3,-(SP)        ;SAVE R3
        CALL    I1CTXL          ;FLUSH TYPE-AHEAD BUFFER WITH INTERRUPTS
                                ;LOCKED OUT
        BIC     #S1.CTO,@R5     ;CLEAR CTRL-O BIT
        BIS     #S2.IRQ!S2.ORQ!S2.SRQ,2(R5)
                                ;LOOK FOR ALL SORTS OF PACKET IN THE QUEUE
                                ;NEXT TIME

        .IF DF  T$$CCA!A$$TRP

        MOV     U.TUX-U.TSTA(R5),R4 ;GET UCBX
        BEQ     10$             ;NONE - JUMP
        MOV     U.TAST(R4),R0   ;GET AST BLOCK
        BEQ     10$             ;NONE - JUMP
        CLR     U.TAST(R4)      ;ZERO AST BLOCK POINTER
        RORB    A.PRM+4(R0)     ;IS IT QUEUED?
        BCS     10$             ;Y - DON'T DEALLOCATE
        CALL    DEACB           ;DEALLOCATE AST BLOCK TO SYSTEM POOL

        .ENDC   ;T$$CCA!A$$TRP

10$:    MOV     (SP)+,R3        ;RESTORE R3

        .IF DF  T$$ESC

        BIC     #S3.WES,4(R5)   ;DON'T LOOK FOR ESCAPE SEQUENCES ANY MORE

        .ENDC

;
;
SUC:    CLR     R1              ;CLEAR SECOND WORD OF IO STATUS BLOCK
        MOV     #IS.SUC,R0      ;SUCCESS
FIN:    JMP     $IOFIN          ;FINISH IO
;
.PAGE
;

        .IF DF  T$$SMC

PPSPC:: MOV     #CKTAB,-(SP)    ;THIS REQUEST MAY WANT TO CREATE OR
                                ;REMOVE A TYPE-AHEAD BUFFER -
                                ;CHECK ON THE WAY OUT
        SAVNR                   ;SAVE R5
        SUB     #U.TSTA,R5      ;POINT TO START OF UCB

        .ENDC   ;T$$SMC

        .IF DF  T$$GTS!T$$GMC!T$$SMC

        .ENABL  LSB

PPSPC1::MOV     I.PRM(R3),KISAR6 ;MAP USER BUFFER IN APR 6
        MOV     I.PRM+2(R3),R1  ;GET START OF BUFFER (WE KNOW IT IS ON A
                                ;WORD BOUNDARY)

        .ENDC   ;T$$GTS!T$$GMC!T$$SMC

        .IF DF  T$$GTS

        CMP     I.FCN(R3),#IO.GTS ;IS IT IO.GTS?
        BNE     20$             ;N - JUMP
        MOV     #IS.SUC,R0      ;SET SUCCESS
        MOV     #TSP1,(R1)+     ;STORE FIRST WORD OF SUPPORT PARAMETERS
        CMP     I.PRM+4(R3),#2  ;WANTS MORE THAN 1 WORD?
        BEQ     19$             ;N - JUMP                                       ; DD004
        MOV     #TSP2,(R1)+     ;STORE SECOND WORD                              ;**-1
19$:    JMP     150$            ;RETURN                                         ; DD004
20$:                                                                            ;**-1

        .ENDC   ;T$$GTS

        .IF DF  T$$GMC

        CMP     I.FCN(R3),#SF.GMC ;IS IT SF.GMC?
        BEQ     70$             ;Y - JUMP

        .ENDC   ;T$$GMC

        .IF DF  T$$SMC

; SF.SMC
;
30$:    CALL    100$            ;GET NEXT CHARACTERISTIC FROM USER BUFFER
        MOV     R2,-(SP)        ;SAVE BITMASK
        CMPB    -(R1),#TC.ISL   ;WANTS TO CHANGE U.UNIT?
        BEQ     110$            ;Y - ILLEGAL
        CMPB    (R1)+,#TC.PRI   ;WANTS TO CHANGE TERMINAL PRIVILEGE?
        BEQ     115$            ;Y - ILLEGAL
                                                                                ; DD004
        .IF DF  T$$MOD                                                          ; DD004
                                                                                ; DD004
        CMPB    -1(R1),#TC.DLU  ;WANTS TO CHANGE REMOTE STATUS OF A LINE?       ; DD004
        BNE     35$             ;N - JUMP                                       ; DD004
                                                                                ; DD004
        .IF DF  R$$MPL                                                          ; DD004
                                                                                ; DD004
        MOV     U.SCB(R5),R0    ;GET SCB                                        ; DD004
        MOV     S.KRB(R0),R0    ;GET KRB                                        ; DD004
        MOVB    K.PRM(R0),R0    ;GET CONTROLLER TYPE                            ; DD004
                                                                                ; DD004
        .IFF    ;R$$MPL                                                         ; DD004
                                                                                ; DD004
        MOV     U.CTYP(R5),R0   ;GET CONTROLLER TYPE                            ; DD004
                                                                                ; DD004
        .ENDC   ;R$$MPL                                                         ; DD004
                                                                                ; DD004
        JMP     @RMDSP(R0)      ;DISPATCH BY CONTROLLER TYPE                    ; DD004
                                                                                ; DD004
        .IF DF  D$$M11                                                          ; DD004
                                                                                ; DD004
        .IF DF  R$$MPL                                                          ; DD004
                                                                                ; DD004
RMTDH:: MOV     U.SCB(R5),R0    ;GET SCB                                        ; DD004
        MOV     S.KRB(R0),R0    ;GET KRB                                        ; DD004
        MOVB    K.CON(R0),R0    ;GET CONTROLLER INDEX                           ; DD004
        ASRB    R0              ;CONVERT TO A COUNT (0 TO N)                    ; DD004
        MOVB    R0,-(SP)        ;SAVE IT                                        ; DD004
        MOV     YMCP1,R0        ;GET POINTER TO DM11-BB KRB LIST                ; DD004
        CMPB    L.NUM-L.KRB(R0),(SP)+ ;IS THIS KRB IN THE LIST?                 ; DD004
        BLOS    127$            ;N - JUMP                                       ; DD004
                                                                                ; DD004
        .IFF    ;R$$MPL                                                         ; DD004
                                                                                ; DD004
RMTDH:: TST     U.DMCS(R5)      ;GET DM11-BB CSR                                ; DD004
        BEQ     127$            ;NONE- JUMP                                     ; DD004
                                                                                ; DD004
        .ENDC   ;R$$MPL                                                         ; DD004
                                                                                ; DD004
        .ENDC   ;D$$M11                                                         ; DD004
                                                                                ; DD004
        .IF DF  D$$LMD                                                          ; DD004
                                                                                ; DD004
RMTDL::                                                                         ; DD004
                                                                                ; DD004
        .ENDC   ;D$$LMD                                                         ; DD004
                                                                                ; DD004
        .IF DF  D$$ZMD                                                          ; DD004
                                                                                ; DD004
RMTDZ::                                                                         ; DD004
                                                                                ; DD004
        .ENDC   ;D$$ZMD                                                         ; DD004
                                                                                ; DD004
                                                                                ; DD004
35$:                                                                            ; DD004
                                                                                ; DD004
        .ENDC   ;T$$MOD                                                         ; DD004
                                                                                ; DD004
        MOVB    @R1,R0          ;GET NEW VALUE FROM USER BUFFER
40$:    ASRB    R2              ;SHIFT BITMASK RIGHT
        BCS     50$             ;CARRY - JUMP
        ROLB    R0              ;SHIFT NEW VALUE LEFT
        BR      40$             ;LOOP
50$:    ROLB    R2              ;PICK UP LOST BIT
        COMB    R2              ;INVERT RIGHT-ADJUSTED MASK
        BITB    R2,(R1)+        ;NEW VALUE IN RANGE?
        BNE     120$            ;N - ERROR
        BICB    (SP)+,@R4       ;CLEAR OLD VALUE
        BISB    R0,@R4          ;SET NEW VALUE
        CMPB    -2(R1),#TC.SLV  ;IS IT TC.SLV (SLAVE CHARACTERISTIC)?           ; DD006
        BNE     55$             ;N - JUMP                                       ; DD006
        TSTB    R0              ;TERMINAL NOW UNSLAVED?                         ; DD006
        BNE     30$             ;N - JUMP                                       ; DD006
        CALL    500$            ;FLUSH TYPE-AHEAD BUFFER                        ; DD006
55$:    CMPB    -2(R1),#TC.HFF  ;FORMFEED CHARACTERISTIC?                       ; DD017
        BNE     57$             ;N - JUMP                                       ; DD017
        BIC     #U2.HFF,U.CW2(R5) ;Y - CLEAR OLD VALUE IN U.CW2                 ; DD017
        ASSUME  S2.HFF,U2.HFF*2                                                 ; DD017
        ASRB    R0              ;GET NEW VALUE                                  ; DD017
        BISB    R0,U.CW2+1(R5)  ;SET NEW VALUE                                  ; DD017
        BR      30$             ;GET NEXT CHARACTERISTIC                        ; DD017
57$:                                                                            ; DD017

        .IF DF  T$$MOD

        CMPB    -2(R1),#TC.DLU  ;IS IT TC.DLU (DIAL-UP LINE)?
        BNE     30$             ;N - JUMP
        INCB    U.TMTI(R5)      ;Y - SET MODEM TIMER
        BISB    #US.CRW,U.STS(R5) ;SET WAITING FOR CARRIER
        TSTB    R0              ;LINE NOW REMOTE?
        BNE     30$             ;Y - JUMP
        BICB    #US.DSB,U.STS(R5) ;LOCAL - ENABLE LINE

        .ENDC   ;T$$MOD

        BR      30$             ;GET NEXT CHARACTERISTIC

        .ENDC   ;T$$SMC

        .IF DF  T$$GMC

;
; SF.GMC
;
60$:    INC     R1              ;POINT TO NEXT CHARACTERISTIC
70$:    CALL    100$            ;GET NEXT CHARACTERISTIC FROM USER BUFFER
        MOVB    @R4,@R1         ;STORE CURRENT VALUE IN USER BUFFER
        MOVB    R2,R0           ;COPY BITMASK
        COMB    R0              ;INVERT IT
        BICB    R0,@R1          ;CLEAR IRRELEVANT BITS
80$:    ASRB    R2              ;SHIFT BITMASK RIGHT
        BCS     60$             ;CARRY - JUMP
        RORB    @R1             ;SHIFT VALUE IN USER BUFFER RIGHT TOO
        BR      80$             ;LOOP

        .ENDC   ;T$$GMC

        .IF DF  T$$GMC!T$$SMC

90$:

        .IF DF  T$$GMC&T$$SMC

        CMP     I.FCN(R3),#SF.GMC

        .ENDC   ;T$$GMC&T$$SMC

        JMP     @-(R0)          ;ENTER ROUTINE TO HANDLE SPECIAL
                                ;CASE OF SF.GMC OR SF.SMC
100$:   MOV     #IS.SUC,R0      ;ASSUME ALL DONE
        SUB     #2,I.PRM+4(R3)  ;ANY MORE TO DO?
        BMI     140$            ;N - JUMP
        MOVB    (R1)+,R0        ;GET NEXT CHARACTERISTIC
        BEQ     130$            ;BAD CODE - JUMP
        CMP     R0,#MCHI        ;TOO HIGH?
        BHI     130$            ;Y - JUMP
        ASL     R0              ;MULTIPLY CODE BY 2
        ADD     #MCTAB-2,R0     ;MAKE POINTER IN MCTAB
        CLR     R2              ;
        BISB    (R0)+,R2        ;GET BITMASK FOR THIS CODE
        MOVB    (R0)+,R4        ;GET OFFSET IN UCB
        BEQ     130$            ;CHARACTERISTIC NOT RECOGNIZED - JUMP
        BMI     90$             ;NEEDS SPECIAL HANDLING - JUMP
        ADD     R5,R4           ;MAKE POINTER TO BYTE IN UCB
        RETURN                  ;RETURN
;
; ERRORS IN SF.GMC OR SF.SMC REQUESTS
;

        .IF DF  T$$SMC

110$:   MOV     #<IE.ABO&377>!<SE.FIX*400>,R0
                                ;WANTS TO CHANGE FIXED CHARACTERISTIC
        BR      140$            ;
115$:   MOV     #IE.PRI&377,R0  ;WANTS TO CHANGE TERMINAL PRIVILEGE
        BR      135$            ;
120$:   MOV     #<IE.ABO&377>!<SE.VAL*400>,R0
                                ;ILLEGAL CHARACTERISTIC VALUE
        BR      135$            ;

        .IF DF  D$$H11!D$$Z11

125$:   MOV     #<IE.ABO&377>!<SE.SPD*400>,R0
                                ;ILLEGAL SPEED (NOT SUPPORTED BY CONTROLLER)
        BR      135$            ;

        .ENDC   ;D$$H11!D$$Z11

        .IF DF  T$$MOD                                                          ; DD004
                                                                                ; DD004
        .IF NDF D$$M11                                                          ; DD004
                                                                                ; DD004
RMTDH::                                                                         ; DD004
                                                                                ; DD004
        .ENDC   ;NDF D$$M11                                                     ; DD004
                                                                                ; DD004
        .IF NDF D$$LMD                                                          ; DD004
                                                                                ; DD004
RMTDL::                                                                         ; DD004
                                                                                ; DD004
        .ENDC   ;NDF D$$LMD                                                     ; DD004
                                                                                ; DD004
        .IF NDF D$$ZMD                                                          ; DD004
                                                                                ; DD004
RMTDZ::                                                                         ; DD004
                                                                                ; DD004
        .ENDC   ;NDF D$$ZMD                                                     ; DD004
                                                                                ; DD004
RMTDJ::                                                                         ; DD004
127$:   MOV     #<IE.ABO&377>!<SE.NSC*400>,R0                                   ; DD004
                                ;WANTS TO MAKE A LOCAL ONLY LINE REMOTE         ; DD004
        BR      135$            ;                                               ; DD004
                                                                                ; DD004
        .ENDC   ;T$$MOD                                                         ; DD004
                                                                                ; DD004
        .ENDC   ;T$$SMC

130$:   MOV     #<IE.ABO&377>!<SE.NIH*400>,R0
                                ;ILLEGAL CHARACTERISTIC CODE
135$:   DEC     R1              ;BACK UP POINTER IN USER BUFFER
140$:   TST     (SP)+           ;CLEAN STACK
                                                                                ; DD013
        .ENDC   ;T$$GMC!T$$SMC                                                  ; DD013
                                                                                ; DD013
        .IF DF  T$$GTS!T$$GMC!T$$SMC                                            ; DD013
                                                                                ; DD013
150$:   SUB     I.PRM+2(R3),R1  ;GET OFFSET IN USER BUFFER
        CALL    RESM            ;RESTORE DATA MAPPING                           ;PW026
        JMP     FIN             ;FINISH REQUEST                                 ; DD004
                                                                                ;**-2
        .ENDC   ;T$$GTS!T$$GMC!T$$SMC                                           ; DD013
                                                                                ; DD013
        .IF DF  T$$GMC!T$$SMC                                                   ; DD013
                                                                                ; DD013
.PAGE
;
; GET/SET RECEIVE/TRANSMIT SPEED
;

        .IF DF  D$$H11!D$$Z11   ;ONLY DH11 AND DZ11 HAVE SETTABLE SPEED

MCRSP::
MCXSP::

        .IF DF  T$$GMC&T$$SMC

        BEQ     230$            ;GET SPEED - JUMP

        .ENDC   ;T$$GMC&T$$SMC

        .IF DF  T$$SMC

;
; SET SPEED
;
        MOVB    (R1)+,R0        ;SET SPEED - GET USER VALUE
        BEQ     120$            ;ZERO - ERROR
        CMP     R0,#SPHI        ;IN RANGE?
        BHI     120$            ;N - ERROR
        BIS     #400,R0         ;FLAG SET SPEED
        CALL    300$            ;CALL CONTROLLER DEPENDENT ROUTINE
        BCS     125$            ;ERROR - JUMP
        BR      100$            ;OK - GET NEXT CHARACTERISTIC

        .ENDC   ;T$$SMC

        .IF DF  T$$GMC

;
; GET SPEED
;
230$:   CLR     R0              ;INDICATE GET SPEED
        INC     R1              ;BUMP POINTER IN USER BUFFER
        CALL    300$            ;CALL CONTROLLER DEPENDENT ROUTINE
        MOV     U.CW3(R5),R0    ;GET U.CW3
        COM     R2              ;INVERT BITMASK
        BIC     R2,R0           ;CLEAR IRRELEVANT BITS
;
;       THE CODE BELOW ASSUMES
;       THAT NO CONTROLLER USES BIT 15 OF THE LINE PARAMETER
;       REGISTER FOR SPEED PARAMETER (R0 BIT 15 MUST = 0)
;
240$:   ROR     R2              ;SHIFT BITMASK RIGHT
        BCC     250$            ;VALUE NOW RIGHT-JUSTIFIED - JUMP
        ASR     R0              ;SHIFT SPEED VALUE RIGHT
        BR      240$            ;LOOP
250$:   MOV     R4,-(SP)        ;SAVE START OF SPEED TABLE
        MOV     #SPHI,R2        ;GET NUMBER OF ENTRIES IN TABLE
260$:   CMPB    R0,(R4)+        ;MATCH?
        BEQ     270$            ;Y - JUMP
        SOB     R2,260$         ;N - LOOP
        MOV     @SP,R4          ;UNRECOGNIZED SPEED - RETURN A ZERO
270$:   SUB     (SP)+,R4        ;GET OFFSET IN TABLE
        MOVB    R4,-1(R1)       ;STORE IN USER BUFFER
        BR      100$            ;GET NEXT CHARACTERISTIC

        .ENDC   ;T$$GMC

;
; LOCAL SUBROUTINE TO CALL CONTROLLER-DEPENDENT ROUTINE
;
300$:   CMPB    -2(R1),#TC.RSP  ;RECEIVE SPEED?
        BEQ     310$            ;Y - JUMP
        BIS     #100000,R0      ;N - FLAG TRANSMIT SPEED
310$:   MOV     R3,-(SP)        ;SAVE R3
        MOV     R5,-(SP)        ;SAVE R5
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
        MOV     #26,R2          ;SET INDEX FOR LINE PARAMETER ROUTINE           ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
        MOV     #14,R2          ;SET INDEX FOR LINE PARAMETER ROUTINE           ; DD010
                                                                                ; DD010
        .ENDC                                                                   ; DD010
                                                                                ; DD010
        ADD     #U.TSTA,R5      ;POINT TO U.TSTA                                ;**-1
        CALL    CTRD            ;CALL CONTROLLER-DEPENDENT ROUTINE
        MOV     (SP)+,R5        ;RESTORE REG'S
        MOV     (SP)+,R3
        RETURN                  ;RETURN WITH CC-C PRESERVED
;
; ERRORS IN GET/SET SPEED
;
                                                                                ;PW026
        .IFTF   ;D$$H11!D$$Z11                                                  ;PW026
                                                                                ;PW026
YJLPAR::                        ;DJ11, DL11 DON'T HAVE SETTABLE                 ;PW026
YLLPAR::                        ;LINE PARAMETERS                                ;PW026
                                                                                ;PW026
        .IFT    ;D$$H11!D$$Z11                                                  ;PW026
                                                                                ;PW026
        CMPB    -(R1),(SP)+     ;BACKUP USER BUFFER POINTER AND                 ;PW026
                                ;POP RETURN ADDRESS                             ;**-1
        MOV     (SP)+,R5        ;RESTORE R5
        MOV     (SP)+,R3        ;RESTORE R3
        TST     (SP)+           ;REMOVE 1 MORE RETURN ADDRESS

        .IFTF   ;D$$H11!D$$Z11

        MOV     #<IE.ABO&377>!<SE.NSC*400>,R0
                                ;CONTROLLER DOES NOT HAVE SETTABLE SPEED

        .IFF    ;D$$H11!D$$Z11

        BR      140$            ;FINISH REQUEST

        .IFT    ;D$$H11!D$$Z11

        BR      135$            ;BACK UP POINTER AND FINISH REQUEST

        .ENDC   ;D$$H11!D$$Z11

.PAGE
;
; GET/SET TERMINAL TYPE
;
MCTTP::

        .IF DF  T$$GMC&T$$SMC

        BEQ     430$            ;GET TERMINAL TYPE - JUMP

        .ENDC   ;T$$GMC&T$$SMC

        .IF DF  T$$SMC

;
; SET TERMINAL TYPE.
; IF THE TYPE IS RECOGNIZED (CONTAINED IN THE TABLES TTYP1, TTYP2, TTYP3),      ;PW010
; SET THE CORRESPONDING IMPLICIT CHARACTERISTICS. IMPLICIT CHARACTERISTICS      ;PW010
; ARE:                                                                          ;PW010
;       TC.HHT                                                                  ;**-2
;       TC.HFF
;       TC.HFL
;       TC.LPP                                                                  ;PW010
;       TC.SCP
;       TC.VFL
;       TC.WID                                                                  ;PW010
;                                                                               ;PW010
; IN ADDITION, THE CURSOR POSITIONING TYPE IS STORED.                           ;PW010
;                                                                               ;PW010
; IN ANY CASE, STORE NEW TYPE VALUE IN U.TTYP.
;
        MOVB    @R1,R2          ;GET NEW TYPE VALUE
        BEQ     420$            ;ZERO - UNKNOWN, JUMP
        CMPB    R2,#TTPHI       ;IN TERMINAL TYPE TABLE?
        BHI     420$            ;N - UNKNOWN, JUMP
                                                                                ; DD018
        .IF NDF T$$COM                                                          ; DD018
                                                                                ; DD018
        MOV     KISAR6,-(SP)    ;SAVE TASK MAPPING                              ; DD018
        MOV     PAR6S,KISAR6    ;MAP DRIVER TABLES                              ; DD018
                                                                                ; DD018
        .IFTF   ;NDF T$$COM                                                     ; DD018
                                                                                ; DD018
        BIC     #U2.CRT,U.CW2(R5) ;ASSUME 0 FOR ALL CHARACTERISTICS
        BIC     #S2.HFF!S2.HHT!S2.HFL!S2.VFL,U.TSTA+2(R5)
        MOVB    TTYP1-1(R2),R0  ;GET IMPLICIT CHARACTERISTICS                   ;PW010
        BICB    #300,R0         ;CLEAR OUT CURSOR POS. TYPE                     ;PW010
;                                                                               ;**-4
;       ALL IMPLICIT CHARACTERISTICS EXCEPT TC.SCP MUST ALL BE
;       IN THE HIGH BYTE OF STATUS WORD 2
;
        .IIF LT S2.HFF-400 .ERROR
        .IIF LT S2.HFL-400 .ERROR
        .IIF LT S2.HHT-400 .ERROR
        .IIF LT S2.VFL-400 .ERROR
410$:   BISB    R0,U.TSTA+3(R5) ;STORE IMPLICIT CHARACTERISTICS IN HIGH         ;PW010
                                ;BYTE OF STATUS WORD 2                          ;PW010
        BIC     #U2.HFF,U.CW2(R5) ;ASSUME NEW TYPE DOESN'T SUPPORT FF           ; DD017
        BITB    #S2.HFF/400,R0  ;WAS FORMFEED CHARACTERISTIC SET?               ; DD017
        BEQ     415$            ;N - JUMP                                       ; DD017
        BIS     #U2.HFF,U.CW2(R5) ;Y - SET CORRESPONDING BIT IN U.CW2           ; DD017
415$:                                                                           ; DD017
        MOVB    TTYP2-1(R2),U.CW4(R5) ;STORE IMPLICIT PAGE WIDTH                ;PW010
        MOVB    TTYP3-1(R2),U.TLPP(R5) ;STORE IMPLICIT PAGE LENGTH              ;PW010
        BPL     420$            ;NOT A SCOPE - JUMP                             ;PW010
        BICB    #200,U.TLPP(R5) ;CLEAR SCOPE FLAG IN U.TLPP                     ;PW010
        BIS     #U2.CRT,U.CW2(R5) ;SET SCOPE FLAG IN U.CW2                      ;PW010
420$:   MOVB    @R1,U.TTYP(R5)  ;SET TERMINAL TYPE                              ; DD017
        BIC     #U2.L3S!U2.VT5,U.CW2(R5) ;CLEAR TYPE BITS IN U.CW2              ; DD017
        CMPB    (R1)+,#T.L30S   ;LA30S?                                         ; DD017
        BNE     422$            ;N - JUMP                                       ; DD017
        BIS     #U2.L3S,U.CW2(R5) ;Y - SET TYPE BIT IN U.CW2                    ; DD017
        BR      424$                                                            ; DD017
422$:   CMPB    -1(R1),#T.VT05  ;VT05B?                                         ; DD017
        BNE     424$            ;N - JUMP                                       ; DD017
        BIS     #U2.VT5,U.CW2(R5) ;Y - SET TYPE BIT IN U.CW2                    ; DD017
424$:                           ;REF LABEL                                      ; DD017
                                                                                ; DD018
        .IFT    ;NDF T$$COM                                                     ; DD018
                                                                                ; DD018
        MOV     (SP)+,KISAR6    ;RESTORE TASK MAPPING                           ; DD018
                                                                                ; DD018
        .ENDC   ;NDF T$$COM                                                     ; DD018
                                                                                ; DD018
        BR      440$                                                            ;**-3

        .ENDC   ;T$$SMC

        .IF DF  T$$GMC

;
; GET TERMINAL TYPE
;
430$:   MOVB    U.TTYP(R5),(R1)+

        .ENDC   ;T$$GMC

440$:   JMP     100$            ;GET NEXT CHARACTERISTIC
        .PAGE                                                                   ; DD011
;                                                                               ; DD011
; GET/SET TYPE-AHEAD BUFFER ACTIVE CHARACTER COUNT                              ; DD011
;                                                                               ; DD011
MCTBF::                                                                         ; DD011
                                                                                ; DD011
        .IF DF  T$$GMC&T$$SMC                                                   ; DD011
                                                                                ; DD011
        BEQ     530$            ;GET COUNT - JUMP                               ; DD011
                                                                                ; DD011
        .ENDC   ;T$$GMC&T$$SMC                                                  ; DD011
                                                                                ; DD011
        .IF DF  T$$SMC                                                          ; DD011
                                                                                ; DD011
;                                                                               ; DD011
; FLUSH THE TYPE-AHEAD BUFFER                                                   ; DD011
;                                                                               ; DD011
        CALL    500$            ;FAKE A ^X                                      ; DD011
        TSTB    (R1)+           ;BYPASS DUMMY SET VALUE                         ; DD011
        JMP     100$            ;GET NEXT CHARACTERISTIC                        ; DD011
500$:   CALL    620$            ;MAP DRIVER DATABASE                            ; DD011
        CALLR   I1CTXL          ;FLUSH BUFFER.  RETURN WILL REMAP USER          ; DD011
                                                                                ; DD011
        .ENDC   ;T$$SMC                                                         ; DD011
                                                                                ; DD011
        .IF DF  T$$GMC                                                          ; DD011
                                                                                ; DD011
;                                                                               ; DD011
; GET THE NUMBER OF CHARACTERS IN THE TYPE-AHEAD BUFFER                         ; DD011
;                                                                               ; DD011
530$:   CALL    MAPD            ;MAP DATA AREA                                  ; DD011
        MOV     U.TTAB(R5),R2   ;GET TABUF                                      ; DD011
        MOVB    2(R2),R2        ;GET ACTIVE CHARACTER COUNT                     ; DD011
        MOV     I.PRM(R3),KISAR6 ;MAP USER BUFFER                               ; DD011
        MOVB    R2,(R1)+        ;STORE COUNT IN BUFFER                          ; DD011
        JMP     100$            ;GET NEXT CHARACTERISTIC                        ; DD011
                                                                                ; DD011
        .ENDC   ;T$$GMC                                                         ; DD011
        .PAGE                                                                   ; DD011
;                                                                               ; DD011
; GET/SET CONTROL-S STATUS                                                      ; DD011
;                                                                               ; DD011
MCCTS::                                                                         ; DD011
                                                                                ; DD011
        .IF DF  T$$GMC&T$$SMC                                                   ; DD011
                                                                                ; DD011
        BEQ     630$            ;GET ^S STATUS - JUMP                           ; DD011
                                                                                ; DD011
        .ENDC   ;T$$GMC&T$$SMC                                                  ; DD011
                                                                                ; DD011
        .IF DF  T$$SMC                                                          ; DD011
                                                                                ; DD011
;                                                                               ; DD011
; SET OR CLEAR ^S CONDITION                                                     ; DD011
;                                                                               ; DD011
        CALL    600$            ;CALL ROUTINE TO DUMMY UP THE ^S OR ^Q          ; DD011
        JMP     100$            ;GET NEXT CHARACTERISTIC                        ; DD011
600$:   MOVB    (R1)+,R2        ;GET NEW VALUE FROM USER BUFFER                 ; DD011
        CALL    620$            ;MAP OUR DATA AREA                              ; DD011
        TSTB    R2              ;ARE WE SETTING ^S?                             ; DD011
        BNE     610$            ;Y - JUMP                                       ; DD011
        CALLR   I1CTQL          ;N - FAKE A ^Q.  TASK MAPPED ON RETURN          ; DD011
610$:   CALLR   I1CTSL          ;FAKE A ^S, RETURN WILL REMAP TASK              ; DD011
620$:   MOV     @SP,-(SP)       ;PUSH RETURN ADDRESS AGAIN                      ; DD011
        MOV     R3,2(SP)        ;SAVE R3                                        ; DD011
        ADD     #U.TSTA,R5      ;POINT TO U.TSTA                                ; DD011
        CALL    MAPD            ;MAP DRIVER DATA AREA                           ; DD011
        CALL    @(SP)+          ;CALL CALLER BACK AS A CO-ROUTINE               ; DD011
        SUB     #U.TSTA,R5      ;UPON RETURN TO US, POINT TO UCB AGAIN          ; DD011
        MOV     (SP)+,R3        ;RESTORE R3                                     ; DD011
        MOV     I.PRM(R3),KISAR6 ;REMAP USER BUFFER                             ; DD011
        RETURN                                                                  ; DD011
                                                                                ; DD011
        .ENDC   ;T$$SMC                                                         ; DD011
                                                                                ; DD011
        .IF DF  T$$GMC                                                          ; DD011
                                                                                ; DD011
;                                                                               ; DD011
; GET TERMINAL ^S AND ^O STATUS                                                 ; DD011
;                                                                               ; DD011
630$:   CLRB    @R1             ;ASSUME NEITHER ^S OR ^O IS SET                 ; DD011
        BIT     #S1.CTS,U.TSTA(R5) ;VERIFY ASSUMPTION FOR ^S BIT                ; DD011
        BEQ     640$            ;ASSUMED CORRECTLY - JUMP                       ; DD011
        INCB    @R1             ;ASSUMPTION WAS WRONG - SET THE BIT             ; DD011
640$:   BIT     #S1.CTO,U.TSTA(R5) ;VERIFY ASSUMPTION FOR ^O BIT                ; DD011
        BEQ     650$            ;^O IS NOT SET - JUMP                           ; DD011
        BISB    #2,@R1          ;^O IS SET, SET CORRESPONDING USER BIT          ; DD011
650$:   TSTB    (R1)+           ;UPDATE BUFFER POINTER                          ; DD011
        JMP     100$            ;GET NEXT CHARACTERISTIC                        ; DD011
                                                                                ; DD011
        .ENDC   ;T$$GMC                                                         ; DD011
                                                                                ; DD011
        .ENDC   ;T$$GMC!T$$SMC                                                  ; DD011
.PAGE                                                                           ;**-3
;
; SUBROUTINE CALLED FROM SYSXT WHEN AN AST BLOCK IS DEQUEUED.
;
; IF THE TASK HAPPENED TO DETACH WHILE THIS BLOCK WAS IN THE
; AST QUEUE, DEALLOCATE THE BLOCK.
;
; ELSE, SHOW AST BLOCK NOT IN QUEUE ANY MORE. TRY TO GET ANOTHER
; CHARACTER FROM THE TYPE-AHEAD BUFFER TO REQUEUE THE AST BLOCK.
;
; INPUT:
;       R0      POINTER TO LINK WORD IN AST BLOCK
;
;

        .IF DF  T$$CCA!A$$TRP                                                   ; DD013
                                                                                ;**-1
        .ENABL  LSB
;
DQAST:: CALL    MAPD            ;MAP DATA AREA                                  ;PW026
        MOV     A.PRM+2(R0),R5  ;GET POINTER TO U.TSTA                          ;**-1
        MOV     U.TUX-U.TSTA(R5),R4 ;GET UCBX
        BEQ     DEACB           ;NONE - TERMINAL MUST BE DETACHED, JUMP
        TST     U.TAST(R4)      ;AST BLOCK POINTER ZEROED?
        BEQ     DEACB           ;Y - SAME THING, JUMP
        DECB    A.PRM+4(R0)     ;SHOW AST BLOCK NOT IN QUEUE ANY MORE
        BNE     10$             ;AST BLOCK LOCKED - JUMP

        .IF DF  M$$PRO

        CLR     R3              ;IF A SWITCH TO ANOTHER CPU TAKES PLACE,
                                ;NO SPECIAL FORK PROCESSING ROUTINE IS
                                ;REQUIRED - JUST GET ANOTHER CHARACTER
                                ;FROM THE TYPE-AHEAD BUFFER
        CALL    SWCPU           ;SWITCH TO CORRECT CPU
;
; IF WE FALL THRU HERE, WE ARE ALREADY ON THE CORRECT CPU
;

        .ENDC   ;M$$PRO

        CALL    SETDSI          ;DISABLE INPUT PROCESSING
        RETURN                  ;SIMULATE RETURN FROM A FORK PROCESSING
                                ;ROUTINE IN ORDER TO GET ANOTHER CHARACTER
                                ;FROM THE TYPE-AHEAD BUFFER
;
;
DEACB:  CMP     -(R0),-(R0)     ;POINT TO START OF AST BLOCK
        MOV     #24.,R1         ;GET LENGTH                                     ; DD015
        CALLR   $DEACB          ;DEALLOCATE IT TO SYSTEM POOL                   ;**-1
;
10$:    RETURN                  ;RETURN
;
        .DSABL  LSB
;

        .ENDC   ;T$$CCA!A$$TRP                                                  ; DD013
                                                                                ;**-1
;
        .END
        .TITLE  TTCAN
        .IDENT  /V01.34/
;
; 06-FEB-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW004   11-APR-78       PETER WANNHEDEN
;               USE ALL MEMORY UP TO TOP OF PARTITION AS POOL.
;       PW013   19-APR-78       PETER WANNHEDEN
;               ADD SUPPORT FOR SERIAL CONSOLE.
;       PW014   20-APR-78       PETER WANNHEDEN
;               IMPROVE TIME-OUT ROUTINE.
;       PW020   26-APR-78       PETER WANNHEDEN
;               REMOVE TIME-OUT ENTRY POINT (SUPERSEDED BY $NLTMO).
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED:
;               USE SUBROUTINE MAPD TO MAP TT DRIVER DATA AREA.
;               MOVE DRIVER INITIALIZATION ROUTINE OUT OF THIS MODULE
;               AND INTO MODULE "TTDAT".
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD010   15-NOV-78       DALE R. DONCHIN
;               ADD SUPPORT FOR ONLINE RECONFIGURATION
;       DD014   19-JAN-79       DALE R. DONCHIN
;               CHANGE POWERUP BREAKPOINT CONDITIONALIZATION
;       DD015   28-FEB-79       DALE R. DONCHIN
;               DON'T MISTAKE CO: AND VT: FOR TERMINALS
;       DD018   01-MAY-79       DALE R. DONCHIN
;               CORRECT MAPPING WHEN DRIVER > 4K
;
;
;+
; THIS MODULE CONTAINS ENTRY POINTS FOR THE FOLLOWING ROUTINES
; CALLED BY THE EXECUTIVE:
;
;       TTCAN   - CANCEL IO
;       TTPWUP  - POWER-UP                                                      ;**-1
;-
;
;
        .MCALL  DCBDF$,HWDDF$
;
        DCBDF$                  ;DEFINE DCB SYMBOLS
        HWDDF$                  ;DEFINE HARDWARE SYMBOLS
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        .MCALL  KRBDF$                                                          ; CS013
                                                                                ; CS013
        KRBDF$                  ;DEFINE KRB SYMBOLS                             ; CS013
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        .MCALL  SCBDF$                                                          ; CS013
                                                                                ; CS013
        SCBDF$                  ;DEFINE SCB SYMBOLS                             ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
;
;
;
.SBTTL  TTCAN - CANCEL I/O
;
;+
; TTCAN - CANCEL CURRENT IO REQUESTS.
;       THIS ROUTINE IS CALLED FROM THE EXECUTIVE TO CANCEL (KILL)
;       CURRENT IO REQUESTS FOR A TASK ON A LINE.
;       THE UC.KIL BIT IN U.CTL IN THE UCB IS SET FOR ALL TERMINAL
;       UNITS TO FORCE THE EXECUTIVE TO CALL THIS ROUTINE
;       EVEN THOUGH THE UNIT IS NOT MARKED BUSY.
;-
;
;
        .ENABL  LSB
;
TTCAN:: MTPS    #0              ;;;ALLOW INTERRUPTS
        CALL    MAPD            ;MAP DATA AREA                                  ;PW026
        ADD     #U.TUX,R5       ;POINT TO U.TUX                                 ;**-1
        ASSUME  U.TSTA,U.TUX+2
        MOV     (R5)+,R4        ;GET UCBX AND POINT TO U.TSTA
        BEQ     30$             ;NONE - LINE IDLE, JUMP
        ASSUME  U.TCI,0
        MOV     @R4,R3          ;GET CURRENT INPUT PACKET
        BEQ     10$             ;NONE - JUMP
        BIT     #S1.USI,@R5     ;UNSOLICITED INPUT?
        BNE     10$             ;Y - IGNORE
        CMP     I.TCB(R3),R1    ;FROM THE RIGHT TASK?
        BNE     10$             ;N - JUMP
        MOV     #IE.ABO&377,@R3 ;SET ABORT STATUS
        CALL    KILLI           ;KILL INPUT
10$:    MOV     U.TCO(R4),R3    ;GET CURRENT OUTPUT PACKET
        BEQ     30$             ;NONE - JUMP
        CMP     I.TCB(R3),R1    ;FROM THE RIGHT TASK?
        BNE     30$             ;N - JUMP
        MOV     #IE.ABO&377,@R3 ;SET ABORT STATUS
        BR      KILLO           ;KILL OUTPUT
;
;
.SBTTL  KILLO1 - KILL OUTPUT WITH STATUS IE.DNR
;+
; KILLO1 - KILL OUTPUT WITH STATUS IE.DNR
;       USED FOR TIME-OUT OR MODEM HUNG UP.
;
; INPUT:
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;
; REGISTERS ALTERED: R0,R1,R2,R3
;-
;
;
KILLO1::MOV     U.TCO(R4),R3    ;GET CURRENT OUTPUT PACKET
        BEQ     30$             ;NONE - JUMP
        MOV     #IE.DNR&377,@R3 ;OK - LOAD STATUS
                                ;FALL THRU TO "KILLO"
;
;
.SBTTL  KILLO - KILL OUTPUT WITH STATUS IE.ABO
;
;+
; KILLO - KILL OUTPUT WITH STATUS IE.ABO.
;
; INPUT:
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;       I.LNK IN CURRENT OUTPUT REQUEST PACKET CONTAINS STATUS
;               TO RETURN TO TASK
;
; NOTE - MUST EXECUTE ON CORRECT CPU!
;
; REGISTERS ALTERED: R0,R1,R2,R3
;-
;
;
KILLO:: SAVNR                   ;SAVE R4,R5
        CALL    SETDSI          ;DISABLE INPUT PROCESSING
        BISB    #US.OIU,U.STS-U.TSTA(R5) ;DISABLE RECOGNITION OF OUTPUT
                                         ;INTERRUPTS
        BICB    #FR.ORD,U.TFRQ-U.TSTA(R5)
                                ;PREVENT MULTIPLE COMPLETIONS
        BIC     #S2.WRA,2(R5)   ;CLEAR WRAP-AROUND CONTEXT
        CALL    ABOXL           ;ABORT OUTPUT WITH INTERRUPTS LOCKED OUT
        CALLR   FPORD           ;SAY OUTPUT DONE
;
;
.SBTTL  KILLI1 - KILL INPUT WITH STATUS IN R0
;+
; KILLI1 - KILL SOLICITED OR UNSOLICITED INPUT WITH STATUS IN R0.
;       USED TO KILL INPUT BECAUSE OF TIME-OUT OR MODEM HUNG UP.
;
; INPUT:
;       R0      STATUS (IS.TMO OR IE.DNR)
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;
; REGISTERS ALTERED: R0,R1,R2,R3
;-
;
;
        ASSUME  U.TCI,0
KILLI1::MOV     @R4,R3          ;GET CURRENT PACKET
        BEQ     30$             ;NONE - RETURN
        MOV     R0,@R3          ;OK - STORE STATUS
                                ;FALL THRU TO "KILLI"
;
;
.SBTTL  KILLI - KILL INPUT WITH STATUS IE.ABO
;
;+
; KILLI - KILL INPUT WITH STATUS IE.ABO.
;
; INPUT:
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;       I.LNK IN CURRENT INPUT REQUEST PACKET CONTAINS STATUS
;               TO RETURN TO TASK
;
; NOTE - MUST EXECUTE ON CORRECT CPU!
;
; REGISTERS ALTERED: R0,R1,R2,R3
;-
;
;
KILLI:: SAVNR                   ;SAVE R4,R5
        CALL    SETDSI          ;DISABLE INPUT PROCESSING
        TST     U.TCO(R4)       ;DOING TASK OUTPUT?
        BNE     20$             ;Y - JUMP
;
; IF WE ARE KILLING A READ WITH ECHO, IT IS POSSIBLE THAT THE ECHO
; HAS NOT YET COMPLETED. IF SO, WE MUST LOGICALLY KILL THE ECHO.
;
        BISB    #US.OIU,U.STS-U.TSTA(R5) ;SET OUTPUT INTERRUPT UNEXPECTED
        BIC     #S1.OBY,@R5     ;SET OUTPUT FREE
20$:    BICB    #FR.IRD,U.TFRQ-U.TSTA(R5)
                                ;PREVENT MULTIPLE COMPLETIONS
        BIC     #S1.ESC!S1.DEC!S1.DPR,@R5
                                ;GET OUT OF ESCAPE SEQUENCE MODE
                                ;CLEAR DEFERRED ECHO FLAG
                                ;CLEAR DEFERRED PROCESSING FLAG
        CLRB    U.TISV(R4)      ;CLEAR INPUT STATE VARIABLE
        CALLR   FPIRD           ;SAY INPUT DONE
30$:    RETURN                  ;RETURN                                         ;**-11
;
;

        .IF DF  M$$PRO

.SBTTL  FPTIM - FORK LEVEL TIME-OUT ROUTINE
;
; THIS ROUTINE IS ENTERED FROM THE FORK DISPATCHER AFTER A SWITCH
; TO THE CORRECT CPU TO HANDLE A TIME-OUT.
;
        ASSUME  U.TUX,U.TSTA-2
FPTIM:: TST     -(R5)           ;POINT TO U.TUX
        CALL    60$             ;HANDLE TIME-OUT ON THIS UNIT
        TST     (SP)+           ;ROUTINE RETURNS AS A COROUTINE - POP
                                ;RETURN ADDRESS
        RETURN                  ;RETURN TO FORK DISPATCHER

        .ENDC   ;M$$PRO

;
;
.SBTTL  TIME - TIME-OUT (DRIVER TIMER).
;
;
TTICK:: CALL    MAPD            ;MAP DATA AREA                                  ;PW026
        DECB    TENSEC          ;ADJUST TEN SECOND TIMER                        ;**-1
        BNE     40$             ;NOT TEN SECONDS YET - JUMP
        MOVB    #10.,TENSEC     ;RESET TO 10 SECONDS
40$:    MOV     #DCB0,R3        ;POINT TO POINTER TO TT0: DCB
        MOV     #$SCDV1,-(SP)   ;GET ADDRESS OF DEVICE TABLE SCAN ROUTINE
50$:

        .IF NDF T$$MOD

80$:

        .ENDC   ;NOT T$$MOD

        CALL    @(SP)+          ;GET NEXT TERMINAL
        BCS     CLINS           ;ALL DONE - JUMP
        CMP     D.NAM(R3),#"TT  ;IS DEVICE NAME "TT"?                           ; DD015
        BNE     90$             ;N - ABORT SCAN                                 ; DD015
        BIT     #DV.TTY,U.CW1(R5) ;IS IT A TERMINAL?
        BEQ     90$             ;N - ABORT SCAN
;
; FOUND A TERMINAL. CHECK TIMERS.
;
        ADD     #U.TUX,R5       ;POINT TO U.TUX
        ASSUME  U.TSTA,U.TUX+2
60$:    MOV     (R5)+,R4        ;GET UCBX AND POINT TO U.TSTA
        BEQ     80$             ;NONE - JUMP
        CMPB    TENSEC,#10.     ;DID TEN SECOND TIMER JUST EXPIRE?
        BNE     70$             ;N - IGNORE INPUT TIMER
        MOV     R4,R1           ;
        ADD     #U.TITI,R1      ;POINT TO INPUT TIMER
        MOV     #IS.TMO,R0      ;GET STATUS FOR INPUT TIME-OUT
        MOV     #KILLI1,R2      ;POINT TO KILL INPUT ROUTINE
        CALL    110$            ;CHECK INPUT TIMER
70$:    BIT     #S1.CTS,@R5     ;OUTPUT STOPPED BY CTRL-S?
        BNE     80$             ;Y - IGNORE OUTPUT TIMER
        MOV     R4,R1           ;
        ADD     #U.TOTI,R1      ;POINT TO OUTPUT TIMER
        MOV     #KILLO1,R2      ;POINT TO KILL OUTPUT ROUTINE
        CALL    110$            ;CHECK OUTPUT TIMER

        .IF DF  T$$MOD

80$:    MOV     R5,R1           ;
        ADD     #U.TMTI-U.TSTA,R1 ;POINT TO MODEM TIMER
        MOV     #MTIM,R2        ;POINT TO MODEM TIME-OUT ROUTINE
        CALL    110$            ;CHECK MODEM TIMER

        .ENDC   ;T$$MOD

        BR      50$             ;LOOP
;
; FOUND A DEVICE OTHER THAN A TERMINAL - ABORT SCAN
;
90$:    ADD     #S$$SPA,SP      ;FLUSH STACK
;
; ALL DONE - REQUEUE CLOCK BLOCK
;
CLINS:: MOV     #$TTCB,R0       ;GET CLOCK BLOCK                                ;PW026
        CLR     R1              ;CLEAR HIGH ORDER DELTA TIME                    ;**-1
        MOV     $TKPS,R2        ;LOW ORDER = 1 SECOND
        MOV     #C.SYST,R4      ;TYPE = SYSTEM SUBROUTINE
        CALLR   $CLINS          ;INSERT IN CLOCK QUEUE AND RETURN
;
;
110$:   TSTB    @R1             ;TIMER ACTIVE?                                  ;PW014
        BEQ     120$            ;N - RETURN                                     ;PW014
        DECB    @R1             ;Y - UPDATE TIMER                               ;PW014
        BEQ     130$            ;TIMER EXPIRED - JUMP                           ;PW014
120$:   RETURN                  ;RETURN                                         ;**-5
130$:

        .IF DF  M$$PRO

; WE JUST DECREMENTED THE TIMER TO 0, BUT WE MAY BE ON THE WRONG CPU.
; SET TIMER BACK TO +1 AND SWITCH TO THE CORRECT CPU.
;
        INCB    @R1             ;SET TIMER TO +1
        MOV     #FR.TIM,R3      ;GET FORK REQUEST BIT
        CALL    SWCPU           ;SWITCH TO CORRECT CPU
;
; IF WE FALL THRU HERE, WE ARE ALREADY ON THE CORRECT CPU.
;
        CLRB    @R1             ;FINALLY SET THE TIMER TO 0
        MOV     U.TUX-U.TSTA(R5),R4 ;RESTORE UCBX POINTER

        .ENDC   ;M$$PRO

        .IF DF  T$$CON                                                          ;PW013
                                                                                ;PW013
        MOV     U.SCB-U.TSTA(R5),R3 ;GET SCB                                    ;PW013
                                                                                ;PW013
        .IF DF R$$MPL                                                           ;PW013
                                                                                ;PW013
        MOV     S.KRB(R3),R3    ;GET KRB                                        ;PW013
        TSTB    K.PRM(R3)       ;DL11?                                          ;PW013
        BNE     140$            ;N - JUMP                                       ;PW013
        ASSUME  K.CSR,0                                                         ;PW013
        MOV     @R3,R3          ;GET CSR ADDRESS                                ;PW013
                                                                                ;PW013
        .IFF    ;R$$MPL                                                         ;PW013
                                                                                ;PW013
        TST     U.CTYP-U.TSTA(R5) ;DL11?                                        ;PW013
        BNE     140$            ;N - JUMP                                       ;PW013
        MOV     S.CSR(R3),R3    ;GET CSR ADDRESS                                ;PW013
                                                                                ;PW013
        .ENDC   ;R$$MPL                                                         ;PW013
                                                                                ;PW013
        BIT     #20,4(R3)       ;TERMINAL IN CONSOLE MODE?                      ;PW013
        BNE     120$            ;Y - IGNORE TIME-OUT                            ;PW013
                                                                                ;PW013
        .ENDC   ;T$$CON                                                         ;PW013
                                                                                ;PW013
140$:   JMP     @R2             ;HANDLE TIME-OUT                                ;PW013
;                                                                               ;**-1
        .DSABL  LSB
;

        .ENABL  LSB

        .IF DF  T$$MOD

;
; HANDLE MODEM TIME-OUT
;
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
MTIM:   MOV     #10,R2          ;SET INDEX FOR MODEM TIME-OUT ROUTINE           ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
MTIM:   MOV     #12,R2          ;SET INDEX FOR MODEM TIME-OUT ROUTINE           ; DD010
                                                                                ; DD010
        .IFTF                                                                   ; DD010
                                                                                ; DD010
        CALLR   CTRD            ;DO CONTROLLER-DEPENDENT STUFF                  ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ;**-2
        .ENDC   ;T$$MOD
;
;
.SBTTL  TTPWUP - POWER-UP.
;
;+
; TTPWUP - POWER-UP.
;-
;
;
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
TTINIT::                                                                        ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
TTPWUP::
                                                                                ; DD010
        .ENDC                                                                   ; DD010

        .IF DF  DDBUG                                                           ; DD014
                                                                                ;**-1
1$:     BPT                     ;GET TO XDT
        MOV     #NOP,1$         ;NOP THE BPT

        .ENDC   ;DDBUG                                                          ; DD014
                                                                                ;**-1
                                                                                ; CS013
        .IF DF  T$$COM                                                          ; CS013
                                                                                ; CS013
        MOV     $TTCOM,R0       ;GET TTCOM PCB ADDRESS                          ; CS013
                                                                                ; DD010
        .IF NDF R$$CON                                                          ; DD010
                                                                                ; DD010
        BEQ     10$             ;NOT A VIRGIN SYSTEM - JUMP                     ; DD010
                                                                                ; DD010
        .ENDC   ;NDF R$$CON                                                     ; DD010
                                                                                ; DD010
        MOV     P.REL(R0),KINAR6 ;MAP INITIALIZATION CODE IN APR 6              ; CS013
        CALL    INIT+20000      ;DO VIRGIN INITIALIZATION                       ; CS013
                                ;THE INIT ROUTINE IS BUILT FOR MAPPING          ; CS013
                                ;IN APR5, BUT IS NOW MAPPED IN APR 6            ; CS013
10$:    CALL    MAPD            ;MAP DRIVER DATA AREA                           ; CS013
                                                                                ; CS013
        .IFF    ;T$$COM                                                         ; CS013
                                                                                ; CS013
        CALL    MAPD            ;MAP DATA AREA                                  ; CS013
                                                                                ; DD010
        .IF NDF R$$CON                                                          ; DD010
                                                                                ; DD010
        BNE     20$             ;NOT A VIRGIN SYSTEM - JUMP                     ; DD010
                                                                                ; DD010
        .ENDC   ;NDF R$$CON                                                     ; DD010
                                                                                ; DD010
                                                                                ; CS013
        .IF NDF R$$MPL                                                          ; CS013
                                                                                ; CS013
        MOV     R3,-(SP)        ;SAVE R3                                        ; CS013
        MOV     R4,-(SP)        ;SAVE R4                                        ; CS013
                                                                                ; CS013
        .IFTF                                                                   ; CS013
                                                                                ; CS013
        MOV     @#KISAR5,R0     ;COPY REAL START OF DRIVER DATA                 ; DD018
        ADD     #200,R0         ;ADD THE EQUIVALENT OF 4 K WORDS                ; DD018
        MOV     R0,@#KISAR6     ;MAP REST OF DRIVER                             ; DD018
        MOV     R0,@#PAR6S      ;SAVE DRIVER KISAR6                             ; DD018
        CALL    INIT            ;DO VIRGIN INITIALIZATION                       ; CS013
                                                                                ; CS013
        .IFT                                                                    ; CS013
                                                                                ; CS013
        MOV     (SP)+,R4        ;RESTORE R4                                     ; CS013
        MOV     (SP)+,R3        ;RESTORE R3                                     ; CS013
                                                                                ; CS013
        .ENDC   ;NDF R$$MPL                                                     ; CS013
                                                                                ; CS013
        .ENDC   ;T$$COM                                                         ; CS013
                                                                                ; CS013
20$:                            ;REF LABEL                                      ; CS013
                                                                                ; CS013
        .IF NDF R$$MPL                                                          ; CS013
                                                                                ; CS013
;                                                                               ; CS013
; SET UP DATABASES OF UCB'S AND CSR'S                                           ; CS013
;                                                                               ; CS013
                                                                                ; CS013
        MOV     U.CTYP(R5),R2   ;GET CONTROLLER TYPE                            ; CS013
        TSTB    U.UNIT(R5)      ;UNIT ZERO?                                     ; CS013
        BNE     27$             ;NO - DON'T DO CSR                              ; CS013
                                                                                ; CS013
        .IF DF D$$M11                                                           ; CS013
                                                                                ; CS013
        CMP     #TTTDH,R2       ;IS IT A DH-11                                  ; CS013
        BNE     25$             ;NO                                             ; CS013
        BIT     #U2.RMT,U.CW2(R5) ;REMOTE?                                      ; CS013
        BEQ     25$             ;NO                                             ; CS013
        MOV     U.DMCS(R5),DMCSR(R3) ;FILL IN DM11-BB CSR                       ; CS013
25$:                            ;REF LABEL                                      ; CS013
                                                                                ; CS013
        .ENDC   ;D$$M11                                                         ; CS013
                                                                                ; CS013
        MOV     TTCSR(R2),R2    ;POINT TO D'X'CSR                               ; CS013
        ADD     R3,R2           ;GET D'X'CSR(CON #)                             ; CS013
        MOV     S.CSR(R4),(R2)  ;PLUG IN CSR                                    ; CS013
        MOV     U.CTYP(R5),R2   ;GET CONTROLLER TYPE                            ; CS013
27$:    MOV     TTUCB(R2),R2    ;POINT TO D'X'UCB                               ; CS013
        ADD     R3,R2           ;GET D'X'UCB(CON #)                             ; CS013
        MOVB    U.UNIT(R5),R1   ;GET UNIT NUMBER                                ; CS013
        ASL     R1              ;       * 2                                     ; CS013
        ADD     (R2),R1         ;ADD POINTER AND UNIT #                         ; CS013
        MOV     R5,(R1)         ;PLUG IN UCB                                    ; CS013
                                                                                ; CS013
        .ENDC   ;NDF R$$MPL                                                     ; CS013
                                                                                ; CS013
                                                                                ;**-4
        .IF DF  M$$EXT

; LOAD UMR'S 5 AND 6 TO MAP DRIVER WITH 18-BIT ADDRESSES IDENTICAL
; TO 16-BIT ADDRESSES
;
        MOV     #UMR5S,R1       ;POINT TO SAVED UMR 5
        MOV     #UBMPR+<5*4>,R2 ;POINT TO UMR 5
        MOV     (R1)+,(R2)+     ;INITIALIZE UMR'S 5 AND 6
        MOV     (R1)+,(R2)+
        MOV     (R1)+,(R2)+
        MOV     (R1)+,(R2)+

        .ENDC   ;M$$EXT

        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
        RETURN                                                                  ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
        ADD     #U.TSTA,R5      ;POINT TO U.TSTA
        CALL    CKTAB           ;CHECK WHETHER TYPE-AHEAD BUFFER SHOULD
                                ;BE ALLOCATED OR DEALLOCATED

        .IF DF  T$$MOD

        BICB    #US.CRW!US.DSB,U.STS-U.TSTA(R5)
                                ;ASSUME LOCAL LINE

        .ENDC

        MOV     #10,R2          ;SET ROUTINE INDEX FOR POWER-UP
30$:    CALLR   CTRD            ;CALL CONTROLLER-DEPENDENT ROUTINE
                                ;AND RETURN
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010

        .DSABL  LSB
;
;
        .END                                                                    ;**-113
        .TITLE  TTCIS
        .IDENT  /V02.14/
;
; 23-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW021   27-APR-78       PETER WANNHEDEN
;               AFTER A CALL TO "SETDSI", RETURN TO THE EXECUTIVE AT
;               PRIORITY ZERO. ALSO, AVOID SCANNING THE UCB QUEUE.
;       PW023   03-MAY-78       PETER WANNHEDEN
;               IGNORE POST-FORK-PROCESSING REQUESTS FOR A REMOTE LINE
;               THAT HAS GONE INTO DISABLED OR WAITING-FOR-CARRIER STATE.
;       PW026   05-MAY-78       PETER WANNHEDEN
;               USE SUBROUTINE MAPD TO MAP TT DRIVER DATA AREA.
;       PW027   11-MAY-78       PETER WANNHEDEN
;               MAKE LOADABLE CTB UNCONDITIONAL.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD006   01-NOV-78       DALE R. DONCHIN
;               FIX MULTIPROCESSOR FORK BUG.
;               FLUSH TYPE-AHEAD BUFFER WHEN UNSLAVING A TERMINAL.
;       DD012   06-DEC-78       DALE R. DONCHIN
;               FIX BUG WHEN HAVE ONLY 1 DL-11.
;               RESCAN FOR FORK REQUESTS AFTER PROCESSING TYPE-AHEAD
;       DD013   12-JAN-79       DALE R. DONCHIN
;               FIX MISCELLANEOUS CONDITIONALIZATION ERRORS
;       DD018   01-MAY-79       DALE R. DONCHIN
;               CORRECT MAPPING WHEN DRIVER > 4K
;
;
;+
; CONTROLLER INDEPENDENT ROUTINES TO SET UP FOR INTERRUPT PROCESSING
; AND TO QUEUE A FORK REQUEST.
;-
;
;
        .MCALL  UCBDF$,SCBDF$                                                   ; CS013
        UCBDF$  ,,TTDEF                                                         ;**-1
        SCBDF$
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        .MCALL  KRBDF$                                                          ; CS013
                                                                                ; CS013
        KRBDF$
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
;
;
;+
; TTSET - COMMON INTERRUPT SET UP ROUTINE.
;
; INPUT:
;       R2      SAVED BY CALL (JSR R2).
;               POINTS TO POINTER TO CTB POINTER. (RSX-11M+)                    ;PW027
;               POINTS TO CONTROLLER TYPE. (RSX-11M)                            ;PW027
;       R4      SAVED BY $INTSV.                                                ;**-2
;               CONTAINS CONTROLLER NUMBER * 2.
;       R5      SAVED BY $INTSV.
;
; OUTPUT:
;       R2      FREE TO USE
;       R3      CSR ADDRESS
;       R4      KRB ADDRESS
;       R5      FREE TO USE
;
; CALLS CALLER BACK AS COROUTINE WITH ALL OF DRIVER MAPPED.
; CALLER EXECUTES "RETURN" BACK TO THIS ROUTINE TO RESTORE
; REGISTERS, QUEUE A FORK REQUEST IF NECESSARY AND DISMISS
; THE INTERRUPT.
;-
;
;
        .ENABL  LSB
;
TTSET:: MOV     R3,-(SP)        ;;;SAVE R3
        MOV     KISAR6,-(SP)    ;;;SAVE KERNEL APR 6
                                                                                ; DD018
        .IF DF  T$$COM                                                          ; DD018
                                                                                ; DD018
        MOV     KINAR6,-(SP)    ;;;SAVE KERNEL INSTRUCTION APR 6                ; DD018
                                                                                ; DD018
        .ENDC   ;T$$COM                                                         ; DD018
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        ADD     @(R2)+,R4       ;;;GET POINTER TO KRB POINTER                   ;**-4
        MOV     @R4,R4          ;;;GET KRB ADDRESS                              ;**-7
        MOV     @R4,R3          ;;;GET CSR ADDRESS
        CALL    MAPD            ;;;MAP DATA AREA                                ; CS013
                                                                                ; CS013
        .IFF                                                                    ; CS013
                                                                                ; CS013
        CALL    MAPD            ;;;MAP DATA AREA                                ; CS013
        MOV     (R2)+,R5        ;;;PICK UP CONTROLLER TYPE                      ; CS013
        MOV     TTCSR(R5),R3    ;;;GET POINTER TO CONTROLLER CSR TABLE          ; CS013
        MOV     TTUCB(R5),R5    ;;;GET POINTER TO CONTROLLER UCB TABLE          ; CS013
        ADD     R4,R3           ;;;ADD IN CONTROLLER UNIT FOR CSR               ; CS013
        ADD     R5,R4           ;;;ADD IN CONTROLLER UNIT FOR UCB               ; CS013
        MOV     (R4),R4         ;;;GET ADDRESS OF UCB LIST                      ; CS013
        MOV     (R3),R3         ;;;GET CSR                                      ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        CALL    @R2             ;;;CALL CALLER
                                                                                ; DD018
        .IF DF  T$$COM                                                          ; DD018
                                                                                ; DD018
        MOV     (SP)+,KINAR6    ;;;RESTORE KERNEL INSTRUCTION APR 6             ; DD018
                                                                                ; DD018
        .ENDC   ;T$$COM                                                         ; DD018
                                                                                ; DD018
        MOV     (SP)+,KISAR6    ;;;RESTORE KERNEL APR 6
        MOV     (SP)+,R3        ;;;RESTORE R2, R3
        MOV     (SP)+,R2        ;;;

        .IF DF  M$$PRO

        MOV     $TTUQP,R4       ;;;GET POINTER TO UCB QUEUE HEAD
        TST     (R4)+           ;;;ANYTHING IN UCB QUEUE?
        BNE     50$             ;;;Y - QUEUE FORK BLOCK AND RETURN              ; DD013
        RETURN                  ;;;N - RETURN                                   ;**-1
50$:    CALLR   190$                                                            ; DD013

        .IFF

        TST     $TTUQ           ;;;ANYTHING IN UCB QUEUE?
        BEQ     110$            ;;;N - RETURN
        MOV     #$TTFB+2,R4     ;;;POINT TO PC IN FORK BLOCK
        TST     (R4)+           ;;;FORK BLOCK ALREADY IN QUEUE?
        BNE     110$            ;;;Y - RETURN
        CALL    $FORK0          ;;;QUEUE FORK BLOCK

        .IFTF

;
; COME HERE AT SYSTEM STATE, PRIORITY 0
;
FP000:: CALL    MAPD            ;MAP DATA AREA                                  ;PW026
        CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ;PW021
        CALL    120$            ;;;PROCESS ALL UCB'S IN UCB QUEUE               ;**-2
;
; COME BACK HERE WITH INTERRUPTS LOCKED OUT, UCB QUEUE EMPTY AND LOCKED.
; CLEAR FORK PC TO SHOW FORK BLOCK NOT IN QUEUE, UNLOCK UCB QUEUE AND RETURN.
;

        .IFT

        CLR     6(R4)           ;;;CLEAR FORK PC
        JMP     220$            ;;;GO AND UNLOCK UCB QUEUE

        .IFF

        CLR     4(R4)           ;;;CLEAR FORK PC

        .IFTF

110$:   RETURN                  ;;;RETURN
120$:

        .IFT

        MOV     $TTUQP,R4       ;;;GET POINTER TO UCB QUEUE HEAD
        LOCK$   -LK.SPN(R4),SPIN ;;;LOCK UCB QUEUE

        .IFF

        MOV     #$TTUQ,R4       ;;;POINT TO UCB QUEUE HEAD

        .IFTF

        MOV     (R4)+,R5        ;;;GET FIRST UCB IN QUEUE
        BEQ     110$            ;;;NONE - RETURN
        MOV     @R5,-(R4)       ;;;DEQUEUE UCB
        BNE     130$            ;;;NOT LAST - JUMP
        MOV     R4,2(R4)        ;;;LAST UCB DEQUEUED - UPDATE PTR TO LAST
130$:   INC     @R5             ;;;SHOW UCB NOT IN QUEUE ANY MORE

        .IFT

        ULOCK$  -LK.SPN(R4),SPIN ;;;UNLOCK UCB QUEUE
        BIS     #S1.DSI,U.TSTA-U.TFLK(R5) ;;;DISABLE INPUT PROC. DURING FORK    ;DD006

        .ENDC

        CALL    140$            ;;;PROCESS ALL FORK REQUEST BITS                ;PW021
                                ;;;FOR THIS UCB                                 ;PW021
        BR      120$            ;;;TRY TO DEQUEUE ANOTHER UCB                   ;PW021
;                                                                               ;PW021
;                                                                               ;PW021
;+                                                                              ;PW021
; SETDSI - DISABLE INPUT PROCESSING.                                            ;PW021
;                                                                               ;PW021
; SOME SYSTEM STATE ROUTINES WHICH ARE NOT CALLED FROM THE DRIVER               ;PW021
; FORK DISPATCHER MAY DISABLE INPUT CHARACTER PROCESSING BY CALLING             ;PW021
; THIS ROUTINE. THE CALLER IS CALLED BACK AS A COROUTINE.                       ;PW021
; ON RETURN HERE, ALL FORK REQUESTS FOR THE UCB ARE PROCESSED.                  ;PW021
; AFTER THAT, INPUT PROCESSING IS ENABLED AND AN ATTEMPT IS MADE TO             ;PW021
; RETRIEVE CHARACTERS FROM THE TYPE-AHEAD BUFFER.                               ;PW021
;-                                                                              ;PW021
;                                                                               ;PW021
;                                                                               ;PW021
SETDSI::BIS     #S1.DSI,@R5     ;DISABLE INPUT PROCESSING                       ;PW021
        CALL    @(SP)+          ;CALL CALLER                                    ;PW021
        CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ;PW021
;                                                                               ;PW021
;
; FIND ALL BITS THAT ARE SET IN THE FORK LEVEL REQUEST BYTE.
; FOR EACH BIT FOUND, CLEAR IT AND CALL THE CORRESPONDING
; FORK LEVEL ROUTINE.
;
135$:   ADD     #U.TFLK-U.TSTA,R5 ;;;POINT TO U.TFLK                            ;PW021
        ASSUME  U.TFRQ,<U.TFLK-1>
140$:   TSTB    -(R5)           ;;;ANY BITS SET IN REQUEST BYTE?
        BEQ     160$            ;;;N - JUMP
        MTPS    #0              ;;;Y - ALLOW INTERRUPTS
        MOV     #FRKTB-2,R2     ;GET START OF TABLE WITH POINTERS
                                ;TO FORK LEVEL ROUTINES
        CLR     R3              ;INITIALIZE BITMASK
        SEC                     ;MAKE SURE WE SHIFT IN A ONE
150$:   ROL     R3              ;SHIFT MASK LEFT
        TST     (R2)+           ;UPDATE TABLE POINTER
        BITB    R3,@R5          ;THIS BIT SET?
        BEQ     150$            ;N - LOOP (WITH CC-C = 0)
        BICB    R3,@R5          ;Y - CLEAR IT
        ADD     #U.TUX-U.TFRQ,R5 ;POINT TO U.TUX
        MOV     (R5)+,R4        ;GET UCBX IN R4

        .IF DF  DEBUG

        BIT     #S1.DSI,@R5
        BNE     151$
        BPT
151$:

        .ENDC

        ASSUME  U.TSTA,<U.TUX+2>
        CALL    @(R2)+          ;CALL ROUTINE WITH:
                                ;  R4 = POINTER TO UCBX
                                ;  R5 = POINTER TO U.TSTA
        MTPS    #TTPRI          ;LOCK OUT INTERRUPTS                            ;PW021
        BR      135$            ;;;GET NEXT FORK REQUEST BIT                    ;PW021
;                                                                               ;**-27
; NO MORE PROCESSING AT ZERO PRIORITY. ENABLE PROCESSING OF INPUT
; CHARACTERS AND SEE WHAT IS WAITING FOR US IN THE TYPE-AHEAD BUFFER.
;
160$:   ADD     #U.TSTA-U.TFRQ,R5 ;;;POINT TO U.TSTA
        BIC     #S1.DSI,@R5     ;;;ENABLE PROCESSING OF INPUT CHARACTERS
        CALL    NXTIC           ;;;PROCESS CHARACTERS FROM TYPE-AHEAD BUFFER    ; DD012
        TSTB    U.TFRQ-U.TSTA(R5) ;;;ANY FORK REQUESTS NOW PENDING?             ; DD012
        BNE     135$            ;;;Y - JUMP                                     ; DD012
        RETURN                                                                  ; DD012
;                                                                               ;**-3
;
; POST-FORK PROCESSING. PICK UP CHARACTER FROM U.TECB AND PROCESS IT.
;
FPPFP:: MOV     #NXTIC,@SP      ;MODIFY RETURN ADDRESS                          ;PW021
                                                                                ;**-1
        .IF DF  DEBUG

        TST     R4
        BNE     171$
        BPT
171$:

        .ENDC

        MTPS    #TTPRI          ;LOCK OUT INTERRUPTS
        MOVB    U.TECB(R4),R2   ;;;GET CHARACTER TO PROCESS
        BIC     #S1.DSI,@R5     ;;;ENABLE INPUT PROCESSING
                                                                                ;PW023
        .IF DF  T$$MOD                                                          ;PW023
                                                                                ;PW023
        BITB    #US.DSB!US.CRW,U.STS-U.TSTA(R5)                                 ;PW023
                                ;;;LINE DISABLED OR WAITING FOR CARRIER?        ;PW023
        BNE     110$            ;;;Y - JUMP                                     ;PW023
                                                                                ;PW023
        .ENDC   ;T$$MOD                                                         ;PW023
                                                                                ;PW023
        CALLR   ICH2A           ;;;PROCESS CHARACTER
;
;

        .IF DF  M$$PRO

;+
; SWCPU - SWITCH TO CORRECT CPU.
;
; INPUT:
;       R3      BITMASK TO SET IN FORK REQUEST BYTE
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF ALREADY EXECUTING ON THE CORRECT CPU (THE ONE THAT OWNS
;       THE UNIBUS WHERE THE CONTROLLER SITS), IMMEDIATE RETURN
;       TO CALLER.
;
;       ELSE, FORK REQUEST BIT SET IN UCB. UCB ADDED TO END OF
;       TARGET CPU'S UCB QUEUE, UNLESS IT IS ALREADY QUEUED.
;       TARGET CPU'S FORK BLOCK QUEUED TO FORK QUEUE, UNLESS IT
;       IS ALREADY QUEUED. RETURN TO CALLER'S CALLER.
;
; REGISTERS ALTERED: R4
;-
;
;
SWCPU:: MOV     U.SCB-U.TSTA(R5),R4 ;GET SCB
        MOV     S.KRB(R4),R4    ;GET KRB
        BIT     K.URM(R4),@$CPURM ;ALREADY ON THE RIGHT CPU?
        BNE     230$            ;Y - RETURN
        MOV     K.URM(R4),@SP   ;N - SAVE URM AND POP RETURN ADDRESS - WANT
                                ;TO RETURN TO CALLER'S CALLER
        MOV     #$URMTB,R4      ;GET START OF URM TABLE
180$:   BIT     @SP,(R4)+       ;IS THIS THE CORRECT CPU?
        BEQ     180$            ;N - LOOP
        TST     (SP)+           ;CLEAN STACK
        MOV     $TTUQT-$URMTB-2(R4),R4 ;GET POINTER TO POINTER TO LAST
                                ;UCB IN TARGET CPU'S UCB QUEUE
        CALL    200$            ;PLACE FORK REQUEST (NO NEED TO RAISE PRIORITY,
                                ;WE ARE ON THE WRONG CPU ANYWAY...)
190$:   LOCK$   -LK.SPN-2(R4),SPIN ;LOCK UCB QUEUE
        TST     6(R4)           ;FORK BLOCK ALREADY QUEUED?
        BNE     220$            ;Y - JUMP
        ADD     #6,R4           ;N - POINT TO FORK PC
        MOV     #FP000,@R4      ;SET FORK PC
        CLR     -(R4)           ;CLEAR LINK WORD
        CALL    $QFORK          ;QUEUE FORK BLOCK
        CMP     -(R4),-(R4)     ;BACK UP R4
195$:   BR      220$            ;UNLOCK FORK BLOCK AND RETURN

        .IFTF

;
;
;+
; FORK - SET FORK LEVEL REQUEST AND ADD UCB TO UCB QUEUE.
;
; INPUT:
;       R3      BITMASK TO SET IN FORK REQUEST BYTE
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       REQUEST BIT SET IN UCB. UCB ADDED TO END OF UCB QUEUE,
;       UNLESS IT WAS ALREADY QUEUED.
;
; REGISTERS ALTERED: R4
;-
;
;
FORK::

        .IFT

        MOV     $TTUQP,R4       ;;;POINT TO UCB QUEUE HEAD
        TST     (R4)+           ;;;POINT TO POINTER TO LAST IN QUEUE
200$:   LOCK$   -LK.SPN-2(R4),SPIN ;;;LOCK UCB QUEUE

        .IFF

        MOV     #$TTUQ+2,R4     ;;;POINT TO POINTER TO LAST IN QUEUE

        .IFTF

        BIS     #S1.DSI,@R5     ;;;FORCE INPUT TO TABUF
                                ;;;PREVENT RETRIEVAL FROM TABUF
        ADD     #U.TFRQ-U.TSTA,R5 ;;;POINT TO U.TFRQ
        BISB    R3,(R5)+        ;;;SET REQUEST BIT (U.TFRQ)
        ASSUME  U.TFLK,<U.TFRQ+1>
        BIT     #1,@R5          ;;;UCB ALREADY QUEUED?
        BEQ     210$            ;;;Y - JUMP
        MOV     R5,@(R4)+       ;;;N - QUEUE IT
        MOV     R5,-(R4)        ;;;SET NEW LAST
        CLR     @R5             ;;;CLEAR LINK WORD
210$:   ADD     #U.TSTA-U.TFLK,R5 ;;;RESTORE R5

        .IFT

220$:   ULOCK$  -LK.SPN-2(R4),SPIN ;;;UNLOCK UCB QUEUE

        .ENDC

230$:   RETURN                  ;;;

        .DSABL  LSB


        .END
        .TITLE  TTDAT
        .IDENT  /V02.16/
;
; 27-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW004   11-APR-78       PETER WANNHEDEN
;               ADD POINTER TO END OF POOL MINUS T$$BFL (FOR DEBUG CODE ONLY).
;       PW010   14-APR-78       PETER WANNHEDEN
;               SUPPORT DEVICE-INDEPENDENT CURSOR CONTROL.
;               ADD IMPLICIT PAGE WIDTH AND LENGTH PER TERMINAL TYPE.
;       PW012   18-APR-78       PETER WANNHEDEN
;               FIX INCORRECT CONDITIONALIZATION.
;       PW020   26-APR-78       PETER WANNHEDEN
;               USE $NLTMO FOR TIME-OUT.
;       PW022   02-MAY-78       PETER WANNHEDEN
;               WHEN VERTICAL FILL REQUIRED, OUTPUT 4 NULLS AFTER LF.
;       PW025   05-MAY-78       PETER WANNHEDEN
;               DELETE JUMP TABLE ASSOCIATED WITH CHARACTER RECOGNITION
;               TABLE FOR ICHAR1.
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED:
;               MOVE DRIVER INITIALIZATION ROUTINE TO THIS MODULE.
;               DELETE DRIVER DISPATCH TABLE FROM THIS MODULE.
;       PW027   11-MAY-78       PETER WANNHEDEN
;               SUPPORT NEW CHARACTERISTIC: TC.BIN.
;               SUPPORT NEW TERMINAL TYPES: LA120, VT100.
;       PW031   31-MAY-78       PETER WANNHEDEN
;               SUPPORT TF.XOF.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD002   30-AUG-78       DALE R. DONCHIN
;               FIX BUG IN ESCAPE SEQUENCE PROCESSING.
;               SUPPORT ANSI STANDARD ESCAPE SEQUENCES
;       DD003   05-SEP-78       DALE R. DONCHIN
;               ECHO THE CLI PROMPT FOR ^R DURING UNSOLICITED READ
;       DD004   04-OCT-78       DALE R. DONCHIN
;               CHECK THAT A LINE CAN BE MADE REMOTE BEFORE CHANGING
;               ITS REMOTE STATUS
;       DD005   06-OCT-78       DALE R. DONCHIN
;               ADD READ WITH TERMINATOR TABLE FUNCTION
;       DD007   06-NOV-78       DALE R. DONCHIN
;               REPLACE ASHC WITH NON-EIS INSTRUCTIONS FOR RSX11M
;       DD009   08-NOV-78       DALE R. DONCHIN
;               ALLOW ^C TO CAUSE AN AST ON SOLICITED IO.RLB READS.
;               FIX AND IMPROVE NOECHO HANDLING
;       DD010   15-NOV-78       DALE R. DONCHIN
;               ADD SUPPORT FOR ONLINE RECONFIGURATION
;       DD011   04-DEC-78       DALE R. DONCHIN
;               ADD SUPPORT FOR TF.TBF
;       CJR001  22-FEB-79       CRAIG J. RICHARDSON
;               ADD SCS-11 CONTROL/C SUPPORT
;       DD015   28-FEB-79       DALE R. DONCHIN
;               ADD CLEAR SCREEN TO CURSOR POSITIONING.
;               DON'T MISTAKE CO: AND VT: FOR TERMINALS
;       DD017   23-APR-79       DALE R. DONCHIN
;               ADD HARDWARE TAB GET/SET CHARACTERISTIC
;       DD018   01-MAY-79       DALE R. DONCHIN
;               MAINTAIN CORRECT VERTICAL POSITION FOR CRT'S
;               CORRECT MAPPING WHEN DRIVER > 4K
;
;+
; THIS MODULE CONTAINS ALL DRIVER DATA, EXCEPT THE DRIVER DISPATCH TABLE.
; IT ALSO CONTAINS THE DRIVER INITIALIZATION ROUTINE.
;
; IN A SYSTEM THAT SUPPORTS SEPARATE KERNEL DATA SPACE MAPPING,
; THIS MODULE MUST BE BUILT INTO THE TASK IMAGE "TTCOM".
;-
;
;
        .MCALL  FILIO$, SPCIO$, TTSYM$
;
        FILIO$                  ;DEFINE I/O FUNCTION CODES
        SPCIO$
        TTSYM$
                                                                                ; CS013
        .IF NDF R$$MPL                                                          ; CS013
                                                                                ; CS013
        .MCALL  HWDDF$                                                          ; CS013
                                                                                ; CS013
        HWDDF$                  ;DEFINE KINAR5                                  ; CS013
                                                                                ; CS013
        .ENDC   ;NDF R$$MPL                                                     ; CS013
                                                                                ; CS013
;
;
; MACRO TO GENERATE CHARACTER RECOGNITION TABLE AND CORRESPONDING
; DISPATCH TABLE.
;
        .MACRO  CREC    PREFIX,CHAR
        .IRP    X,<CHAR>
        .PSECT  CHRT
        .IIF NDF CHRT CHRT==.
        .IIF NDF 'PREFIX'CRT 'PREFIX'CRT==.
        .BYTE   CH.'X'
        .PSECT  CHRD
        .IIF NDF CHRD CHRD==.
        .WORD   'PREFIX''X'
        .ENDR
        .PSECT
        .ENDM   CREC
;
CH.DEF  =       0               ;DEFINE "DEFAULT" CHARACTER
                                ;FOR CHARACTER DISPATCHING
;
; CHARACTER RECOGNITION TABLES.
; EACH TABLE SHOULD BE ORDERED IN DESCENDING FREQUENCY OF
; OCCURRENCE FOR MAXIMUM PERFORMANCE.
;
;       CHARACTERS THAT HAVE SPECIAL SIGNIFICANCE BEFORE
;       STORING IN TYPE-AHEAD BUFFER - USED BY ICHAR1.
;       NOTE - ICHAR1 RECOGNIZES CTRL-X SEPARATELY.
;       ALL ENTRIES IN THE TABLE MUST BE NUMERICALLY SMALLER
;       OR EQUAL TO CTRL-X (30).                                                ;PW025
;                                                                               ;PW025
        .PSECT                                                                  ;PW025
;                                                                               ;PW025
I1CRT:: .BYTE   CH.CTS, CH.CTQ, CH.CTX, CH.CTO, CH.CTC                          ;PW025
ASXOFF==I1CRT                   ;THIS LABEL MUST POINT TO AN XOFF               ;PW031
                                ;CHARACTER (CTRL-S)                             ;PW031
;                                                                               ;**-3
;
;       CHARACTERS THAT HAVE SPECIAL SIGNIFICANCE AFTER
;       RETRIEVAL FROM TYPE-AHEAD BUFFER (OR WHEN BUFFER BYPASSED)
;       USED BY ICHAR2. NOTE - ESCAPE AND RUBOUT ARE RECOGNIZED SEPARATELY
;       BY ICHAR2. ALL ENTRIES IN THE TABLE MUST BE NUMERICALLY
;       SMALLER THAN ESCAPE (33).
;
        CREC    I2,<CR,CTZ,CTU>

        .IF DF  T$$CTR

        CREC    I2,<CTR>

        .ENDC

        CREC    I2,<CTC,CTS,CTQ,CTO,DEF>
;
;
;       CHARACTERS THAT HAVE TO BE EXPANDED ON OUTPUT - USED BY EXPCHR.
;       CARRIAGE-RETURN IS RECOGNIZED SEPARATELY BY EXPCHR.
;       ALL ENTRIES IN THE TABLE MUST BE SMALLER THAN CARRIAGE-RETURN (15).
;
        CREC    EX,<HT,LF,FF,VT,BSP,DEF>
;
;
;       RECOGNITION TABLE FOR VERTICAL FORMAT CONTROL BYTES.
;       NOTE - THIS TABLE USES -1 AS TABLE TERMINATOR.
;
;       THE WORD IN TABLE CHRD IS ENCODED AS FOLLOWS:
;
;       LOW BYTE DESCRIBES LEADING LF'S OR FF:
;       0       = NO LEADING CHARACTERS
;       CH.FF   = LEADING FF
;       -N      = N LEADING LF'S
;
;       HIGH BYTE DESCRIBES TRAILING CR:
;       0       = NO TRAILING CR
;       S2.CR   = TRAILING CR
;
;       DEFINE SYMBOLS FOR ENCODED VALUES
;
        .IIF GT S2.CR-200 .ERROR ;S2.CR MUST BE IN LOW BYTE
VFNUL   =       0               ;NULL - NOTHING
VFZER   =       376!<S2.CR*400> ;0 - 2 LF'S, 1 CR
VFONE   =       CH.FF!<S2.CR*400> ;1 - 1 FF, 1 CR
VFPLU   =       S2.CR*400       ;+ - NO LF OR FF, 1 CR
VFDOL   =       377             ;$ - 1 LF, NO CR
VFDF    =       377!<S2.CR*400> ;DEFAULT - 1 LF, 1 CR
;
;       DEFINE THE TABLE TERMINATOR
;
CH.DF   =       -1
;
        CREC    VF,<DOL,PLU,ZER,ONE,NUL,DF>
;
;
; SPECIAL ECHO STRINGS
;
ASHT::  .BYTE   CH.SP,CH.SP,CH.SP,CH.SP,CH.SP,CH.SP,CH.SP,CH.SP
                                ;8 SPACES - USED TO SIMULATE HOR. TAB

        .IF DF  T$$CTR

ASCTR:: .ASCII  /^R/            ;CTRL-R

        .ENDC

ASCTU:: .ASCII  /^U/            ;CTRL-U
ASCLP:: .BYTE   12,'>           ;ABBREVIATED CLI PROMPT                         ; DD003
ASCLI:: .ASCII  <12>/MCR>/      ;FULL CLI PROMPT                                ; DD003
;
; DON'T SEPARATE THE LINES BELOW!
;
ASCTZ::.ASCII   /^Z/            ;CTRL-Z
ASCR::  .BYTE   CH.CR,0,0,0,0,0,0,0,0,0,0
                                ;CARRIAGE RETURN PLUS UP TO 10 FILLERS
                                ;(WORST CASE FOR LA30S)
;
; DON'T SEPARATE THE LINES ABOVE!
;
ASBELL::.BYTE   7               ;BELL
ASBSL:: .ASCII  "\"             ;BACKSLASH

        .IF DF  T$$RUB

ASRBS:: .BYTE   CH.BSP,CH.SP,CH.BSP ;BACKSPACE-SPACE-BACKSPACE
                                ;(FOR SCOPE RUBOUT)
ASBSP:: .BYTE   CH.BSP,CH.BSP,CH.BSP,CH.BSP ;8 BACKSPACES
        .BYTE   CH.BSP,CH.BSP,CH.BSP,CH.BSP ;TO RUBOUT HTAB ON SCOPE

        .ENDC

;
        NLFF==4                 ;NUMBER OF VERTICAL FILL CHARACTERS             ;PW022
        .REPT   4               ;OUTPUT 4 LF'S IN PLACE OF FF AND VT            ; DD018
        .BYTE   CH.LF           ;FOR SCOPES                                     ; DD018
        .ENDR                                                                   ; DD018
ASLF::  .BYTE   CH.LF           ;LINE FEED                                      ;**-2
        .REPT   NLFF
        .BYTE   0               ;FILLERS
        .ENDR
;
;
        .IF DF  T$$ESC

; SYNTAX RULE TABLE FOR ESCAPE SEQUENCES
;
        .ENABL  LSB                                                             ; DD002
                                                                                ; DD002
        .BYTE   'P,'P,40$-ESCST ;P - NEXT = 40$ (VT61 EXCEPTION)                ; DD002
        .BYTE   'Y,'Y,30$-ESCST ;Y - NEXT = 30$ (VT61 EXCEPTION)                ; DD002
ESCST:: .BYTE   '?,'?,40$-ESCST ;? - NEXT = 40$ (OLDER TERM. EXCEPTION)         ; DD002
        .BYTE   'O,'O,40$-ESCST ;O - NEXT = 40$ (ANSI SS3 INTRODUCER)           ; DD002
        .BYTE   '[,'[,20$-ESCST ;[ - NEXT = 20$ (ANSI CSI)                      ; DD002
10$:    .BYTE   40,57,10$-ESCST ;INTERMEDIATE CHAR. - NEXT = SAME (10$)         ; DD002
        .BYTE   60,176,0        ;FINAL CHARACTER - DONE                         ; DD002
20$:    .BYTE   40,77,20$-ESCST ;INTERMEDIATE CHAR. - NEXT = SAME (20$)         ; DD002
        .BYTE   100,176,0       ;FINAL CHARACTER - DONE                         ; DD002
30$:    .BYTE   40,176,40$-ESCST ;FIRST COORD. (BIAS 40) - NEXT = 40$           ;**-9
40$:    .BYTE   40,176,0        ;SECOND COORD (BIAS 40) - DONE
                                                                                ; DD002
        .DSABL  LSB                                                             ; DD002

        .ENDC

;
; TABLE OF HORIZONTAL FILL REQUIREMENT FOR LA30S.
; INDEX = CURRENT HORIZONTAL POSITION DIVIDED BY 8.
;
;       NUMBER OF FILL CHAR.S   HOR.POS.
HORFT:: .BYTE   4.              ;0-7.
        .BYTE   8.              ;8.-15.
        .BYTE   6.              ;16.-23.
        .BYTE   3.              ;24.-31.
        .BYTE   0.              ;32.-39.
        .BYTE   2.              ;40.-47.
        .BYTE   4.              ;48.-55.
        .BYTE   6.              ;56.-63.
        .BYTE   8.              ;64.-71.
        .BYTE   10.             ;72. AND UP
;
;

        .IF DF  T$$GMC!T$$SMC

SPHI    ==      S.EXTB          ;HIGHEST RECOGNIZED SPEED CODE

        .IF DF  D$$H11

; TABLE OF RECEIVE AND TRANSMIT SPEED PARAMETERS FOR DH11.
; THE TABLE IS INDEXED BY S.XXX-1, WHERE S.XXX IS THE SYMBOLIC
; NAME FOR THE DESIRED SPEED (DEFINED BY TTSYM$).
; EACH ENTRY IS A BYTE CONTAINING THE PARAMETER TO LOAD INTO
; THE LINE PARAMETER REGISTER FOR SPEED S.XXX.
; IF S.XXX IS UNSUPPORTED, THE BYTE CONTAINS A NEGATIVE VALUE.
;
SPDH::  .BYTE   0               ;S.0
        .BYTE   1               ;S.50
        .BYTE   2               ;S.75
        .BYTE   -1              ;S.100 - UNSUPPORTED
        .BYTE   3               ;S.110
        .BYTE   4               ;S.134
        .BYTE   5               ;S.150
        .BYTE   6               ;S.200
        .BYTE   7               ;S.300
        .BYTE   10              ;S.600
        .BYTE   11              ;S.1200
        .BYTE   12              ;S.1800
        .BYTE   -1              ;S.2000 - UNSUPPORTED
        .BYTE   13              ;S.2400
        .BYTE   -1              ;S.3600 - UNSUPPORTED
        .BYTE   14              ;S.4800
        .BYTE   -1              ;S.7200 - UNSUPPORTED
        .BYTE   15              ;S.9600
        .BYTE   16              ;S.EXTA
        .BYTE   17              ;S.EXTB

        .ENDC   ;D$$H11

        .IF DF  D$$Z11

; TABLE OF RECEIVE AND TRANSMIT SPEED PARAMETERS FOR DZ11.
; THE TABLE FORMAT IS IDENTICAL TO THAT OF THE DH11 TABLE
; DESCRIBED ABOVE.
;
SPDZ::  .BYTE   -1              ;S.0 - UNSUPPORTED
        .BYTE   0               ;S.50
        .BYTE   1               ;S.75
        .BYTE   -1              ;S.100 - UNSUPPORTED
        .BYTE   2               ;S.110
        .BYTE   3               ;S.134
        .BYTE   4               ;S.150
        .BYTE   -1              ;S.200 - UNSUPPORTED
        .BYTE   5               ;S.300
        .BYTE   6               ;S.600
        .BYTE   7               ;S.1200
        .BYTE   10              ;S.1800
        .BYTE   11              ;S.2000
        .BYTE   12              ;S.2400
        .BYTE   13              ;S.3600
        .BYTE   14              ;S.4800
        .BYTE   15              ;S.7200
        .BYTE   16              ;S.9600
        .BYTE   -1              ;S.EXTA - UNSUPPORTED
        .BYTE   -1              ;S.EXTB - UNSUPPORTED

        .ENDC   ;D$$Z11

        .ENDC   ;T$$GMC!T$$SMC                                                  ;PW010
                                                                                ;PW010
        .IF DF  T$$GMC!T$$SMC!T$$CUP                                            ;PW010
                                                                                ;PW010
;                                                                               ;PW010
;                                                                               ;PW010
; TABLES OF IMPLICIT CHARACTERISTICS PER TERMINAL TYPE.                         ;PW010
; EACH TABLE IS INDEXED WITH TERMINAL TYPE (TC.XXX) MINUS 1.                    ;PW010
; HIGHEST INDEX = TTPHI. EACH ENTRY IS A BYTE, WITH MEANING                     ;PW010
; DESCRIBED BELOW.                                                              ;PW010
;                                                                               ;PW010
;       TABLE   BIT(-S) MEANING                                                 ;PW010
; ------------------------------------------------------                        ;PW010
;       TTYP1   0-5     TO BE COPIED DIRECTLY INTO THE HIGH BYTE                ;PW010
;                       OF STATUS WORD 2 (U.TSTA+2).                            ;PW010
;               6-7     CURSOR POSITIONING COMMAND TYPE (RANGE 0-3).            ;PW010
;                       THIS VALUE IS USED AS INDEX INTO TABLE "CPOST"          ;PW010
;                       (SEE BELOW).                                            ;PW010
;       TTYP2   0-7     PAGE WIDTH.                                             ;PW010
;       TTYP3   0-6     PAGE LENGTH.                                            ;PW010
;               7       1 = SCOPE.                                              ;PW010
;                                                                               ;PW010
;                                                                               ;PW010
;       MACRO TO GENERATE AN ENTRY IN THE TABLES TTYP1, TTYP2 AMD TTYP3.        ;PW010
;                                                                               ;PW010
        .MACRO  TERM    TYPE,WID,LEN,HHT=0,HFF=0,HFL=0,VFL=0,SCP=0,CUP=0        ;PW010
        .PSECT  TTYP1                                                           ;PW010
        .IIF NDF TTYP1 TTYP1==.                                                 ;PW010
        .=TTYP1+TYPE-1                                                          ;PW010
        X=<HHT*S2.HHT>!<HFF*S2.HFF>!<VFL*S2.VFL>                                ;PW010
        .BYTE   X/400!HFL!<CUP*100>                                             ;PW010
        .IF DF  T$$GMC!T$$SMC                                                   ;PW010
        .PSECT  TTYP2                                                           ;PW010
        .IIF NDF TTYP2 TTYP2==.                                                 ;PW010
        .=TTYP2+TYPE-1                                                          ;PW010
        .BYTE   WID                                                             ;PW010
        .PSECT  TTYP3                                                           ;PW010
        .IIF NDF TTYP3 TTYP3==.                                                 ;PW010
        .=TTYP3+TYPE-1                                                          ;PW010
        .BYTE   <SCP*200>!LEN                                                   ;PW010
        .ENDC                                                                   ;PW010
        .PSECT                                                                  ;PW010
        .ENDM   TERM                                                            ;PW010
;                                                                               ;PW010
TTPHI   ==      T.L120          ;HIGHEST TERMINAL TYPE WITH IMPLICIT            ;PW010
                                ;CHARACTERISTICS                                ;PW010
;                                                                               ;PW010
        TERM    T.AS33  WID=72.,LEN=66.,HFL=1                                   ;PW010
        TERM    T.KS33  WID=72.,LEN=66.,HFL=1                                   ;PW010
        TERM    T.AS35  WID=72.,LEN=66.,HFL=1                                   ;PW010
        TERM    T.L30S  WID=80.,LEN=66.,HFL=7                                   ;PW010
        TERM    T.L30P  WID=80.,LEN=66.                                         ;PW010
        TERM    T.LA36  WID=132.,LEN=66.                                        ;PW010
        TERM    T.VT05  WID=72.,LEN=20.,HHT=1,VFL=1,SCP=1,CUP=1                 ;PW010
        TERM    T.VT50  WID=80.,LEN=12.,HHT=1,SCP=1                             ;PW010
        TERM    T.VT52  WID=80.,LEN=24.,HHT=1,SCP=1,CUP=2                       ;PW010
        TERM    T.VT55  WID=80.,LEN=24.,HHT=1,SCP=1,CUP=2                       ;PW010
        TERM    T.VT61  WID=80.,LEN=24.,HHT=1,SCP=1,CUP=2                       ;PW010
        TERM    T.L180  WID=132.,LEN=66.,HFF=1                                  ;PW010
        TERM    T.V100  WID=80.,LEN=24.,HHT=1,SCP=1,CUP=3                       ;PW010
        TERM    T.L120  WID=132.,LEN=66.,HFF=1                                  ;PW010
                                                                                ;PW010
        .ENDC   ;T$$GMC!T$$SMC!T$$CUP                                           ;PW010
                                                                                ;PW010
;                                                                               ;**-33
;
; MISCELLANEOUS BYTES
;
TENSEC::.BYTE   10.             ;10 SECOND TIMER
;
        .EVEN
;
;
; TABLE OF POINTERS TO DISPATCH TABLES IN CONTROLLER-DEPENDENT                  ;**-50
; MODULES. INDEX = CONTROLLER TYPE CODED AS FOLLOWS:
;       0 = DL-11
;       2 = DZ-11
;       4 = DH-11
;       6 = DJ-11
;      10 = DM-11BB                                                             ; DD010
;
                                                                                ; DD010
        .IIF DF R$$CON  CTBL::  .IRP    X,<L,Z,H,J,M>                           ; DD010
                                                                                ; DD010
        .IIF NDF R$$CON CTBL::  .IRP    X,<L,Z,H,J>                             ; DD010
                                                                                ; DD010
        .IF DF  D$$'X'11                                                        ;**-1
        .WORD   $Y'X'TBL
        .PSECT  CTBL                                                            ;PW026
$Y'X'TBL:.WORD  Y'X'STAX        ;START OUTPUT                                   ;PW026
        .WORD   Y'X'ABOX        ;ABORT OUTPUT                                   ;PW026
        .WORD   Y'X'RESX        ;RESUME OUTPUT                                  ;PW026
        .WORD   Y'X'STOX        ;STOP OUTPUT                                    ;PW026
                                                                                ; DD010
        .IF NDF R$$CON                                                          ; DD010
                                                                                ; DD010
        .WORD   Y'X'PWUP        ;POWER-UP                                       ;PW026
                                                                                ; DD010
        .IFTF   ;NDF R$$CON                                                     ; DD010
                                                                                ; DD010
        .WORD   Y'X'MTIM        ;MODEM TIMER                                    ;PW026
                                                                                ; DD010
        .IFF    ;NDF R$$CON                                                     ; DD010
                                                                                ; DD010
        .WORD   Y'X'CPUP        ;CONTROLLER POWER-UP                            ; DD010
        .WORD   Y'X'UPUP        ;UNIT POWER-UP                                  ; DD010
        .WORD   Y'X'CONL        ;CONTROLLER ONLINE                              ; DD010
        .WORD   Y'X'COFF        ;CONTROLLER OFFLINE                             ; DD010
        .WORD   Y'X'UONL        ;UNIT ONLINE                                    ; DD010
        .WORD   Y'X'UOFF        ;UNIT OFFLINE                                   ; DD010
                                                                                ; DD010
        .ENDC   ;NDF R$$CON                                                     ; DD010
                                                                                ; DD010
        .IF DF  T$$GMC!T$$SMC                                                   ;PW026
                                                                                ;PW026
        .WORD   Y'X'LPAR        ;GET/SET LINE PARAMETERS                        ;PW026
                                                                                ;PW026
        .ENDC   ;T$$GMC!T$$SMC                                                  ;PW026
                                                                                ;PW026
        .PSECT                                                                  ;PW026
        .IFF
        .WORD   0
        .ENDC
        .ENDR
;
;
; TABLE OF POINTERS TO FORK LEVEL ROUTINES. THE ORDER OF ENTRIES
; IN THIS TABLE MUST MATCH THE BIT POSITIONS OF THE CORRESPONDING
; BITS IN THE FORK REQUEST BYTE U.TFRQ IN THE UCB.
;
FRKTB:: .WORD   FPIRD           ;FR.IRD - INPUT DONE
        .WORD   FPORD           ;FR.ORD - OUTPUT DONE
        .WORD   FPSUI           ;FR.SUI - START OF UNSOLICITED INPUT

        .IF DF  T$$CCA

        .WORD   FPAST           ;FR.AST - CHARACTER THAT CAUSES AST

        .ENDC   ;T$$CCA

        .IF DF  M$$PRO

        .WORD   FPTIM           ;FR.TIM - TIME-OUT

        .ENDC   ;M$$PRO

        .WORD   FPGRQ           ;FR.GRQ - GET REQUEST PACKET FROM QUEUE
                                                                                ;CJR001
        .IF DF  R$$SCS                                                          ;CJR001
                                                                                ;CJR001
        .WORD   FPFLU           ;FR.FLU - FLUSH TASKS RUNNING ON TERMINAL       ;CJR001
                                                                                ;CJR001
        .ENDC   ;R$$SCS                                                         ;CJR001
                                                                                ;CJR001
        .WORD   FPPFP           ;FR.PFP - POST-FORK PROCESSING OF
                                ;CHARACTER IN U.TECB
;
;
; I/O FUNCTION CODE DISPATCH TABLES.
; VERIFY THAT THE TABLE MATCHES THE NUMERIC VALUES OF I/O FUNCTION CODES
;
        ASSUME  IO.WLB/400,1
        ASSUME  IO.RLB/400,2
        ASSUME  IO.ATT/400,3
        ASSUME  IO.DET/400,4
        ASSUME  IO.GTS/400,5
        ASSUME  SF.SMC/400,5
        ASSUME  SF.GMC/400,5
                                                                                ; DD005
        .IF DF  T$$RPR                                                          ; DD005
                                                                                ; DD005
        ASSUME  IO.RPR/400,11                                                   ; DD005
                                                                                ; DD005
        .ENDC                                                                   ; DD005
                                                                                ; DD005
        ASSUME  IO.RTT/400,12                                                   ; DD005
;
; DISPATCH TABLE FOR PROCESSING DIFFERENT FUNCTION CODES BEFORE
; ENTERING A PACKET IN THE I/O QUEUE.
;                                                                               ;**-1
QPDSP:: .WORD   QPWLB           ;IO.WLB
        .WORD   QPRLB           ;IO.RLB
        .WORD   QPATT           ;IO.ATT
        .WORD   QPDET           ;IO.DET

        .IF DF  T$$GTS!T$$GMC!T$$SMC

        .WORD   QPSPC           ;SPECIAL FUNCTIONS:
                                ; IO.GTS
                                ; SF.SMC
                                ; SF.GMC
                                                                                ; DD005
        .IFF                                                                    ; DD005
                                                                                ; DD005
        .WORD   0                                                               ; DD005
                                                                                ; DD005

        .ENDC

        .WORD   0               ;IO.HNG (RESERVED FOR IAS COMPATIBILITY)        ; DD005
        .WORD   0               ;RESERVED EXEC CLOSE-OUT-LUN FUNCTION           ; DD005
        .WORD   0               ;RESERVED FOR USER MODE DIAGNOSTICS             ; DD005
                                                                                ; DD005
        .IF DF  T$$RPR                                                          ; DD005
                                                                                ; DD005
        .WORD   QPRPR           ;IO.RPR                                         ; DD005
                                                                                ; DD005
        .IFF                                                                    ; DD005
                                                                                ; DD005
        .WORD   0                                                               ; DD005
                                                                                ; DD005
        .ENDC                                                                   ; DD005
                                                                                ; DD005
        .WORD   QPRLB           ;IO.RTT (TREAT AS IO.RLB AT THIS POINT)         ; DD005
;
;
; DISPATCH TABLE FOR PROCESSING DIFFERENT FUNCTION CODES AFTER
; A PACKET HAS BEEN DEQUEUED FROM THE I/O QUEUE
;
PPDSP:: .WORD   PPWLB           ;IO.WLB                                         ;**-8
        .WORD   PPRLB           ;IO.RLB
        .WORD   PPATT           ;IO.ATT
        .WORD   PPDET           ;IO.DET

        .IF DF  T$$SMC                                                          ;PW012
                                                                                ;PW012
        .WORD   PPSPC           ;SF.SMC                                         ;PW012
                                                                                ; DD005
        .IFF                                                                    ; DD005
                                                                                ; DD005
        .WORD   0                                                               ; DD005
                                                                                ; DD005
                                                                                ;**-6
        .ENDC
        .WORD   0               ;IO.HNG (CURRENTLY NOT IMPLEMENTED)             ; DD005
        .WORD   0               ;RESERVED EXEC FUNCTION                         ; DD005
        .WORD   0               ;USER MODE DIAGNOSTICS                          ; DD005
                                                                                ; DD005
        .IF DF  T$$RPR                                                          ; DD005
                                                                                ; DD005
        .WORD   PPRPR           ;IO.RPR                                         ; DD005
                                                                                ; DD005
        .IFF                                                                    ; DD005
                                                                                ; DD005
        .WORD   0                                                               ; DD005
                                                                                ; DD005
        .ENDC                                                                   ; DD005
                                                                                ; DD005
        .WORD   PPRLB           ;IO.RTT                                         ; DD005

;
;
; DISPATCH TABLE FOR INPUT CHARACTER PROCESSING.
; THIS TABLE IS CONSULTED EACH TIME ECHO DONE OCCURS.
; THE TABLE CONTAINS POINTERS TO ROUTINES IN THE MODULE "ICHAR".
; INDEX = INPUT LOGIC STATE VARIABLE (U.TISV IN UCBX) MULTIPLIED BY 2.
;
ISDSP:: .WORD   CFGRQ           ;NOTHING MORE TO ECHO

        .IF DF  T$$CTR

SV.CR1==<.-ISDSP>/2
        .WORD   I2CTR1          ;USED FOR CTRL-R ECHOING
        .WORD   I2CTR2          ;USED FOR CTRL-R ECHOING                        ;**-3
        .WORD   I2CTR3          ;USED FOR CTRL-R ECHOING                        ;**-4
        .WORD   I2CTR4          ;USED FOR CTRL-R ECHOING                        ; DD009

        .ENDC

SV.CU1==<.-ISDSP>/2
        .WORD   I2CTU1          ;USED FOR CTRL-U ECHOING
        .WORD   I2CTU2          ;USED FOR CTRL-U ECHOING                        ;**-3
        .WORD   I2CTU3          ;USED FOR CTRL-U ECHOING                        ;**-4
;
;
; DISPATCH TABLE FOR OUTPUT CHARACTER PROCESSING.
; THIS TABLE IS CONSULTED EACH TIME AN OUTPUT CHARACTER IS EXPANDED.
; THE TABLE CONTAINS POINTERS TO ROUTINES IN THE MODULE "EXPCHR".
; INDEX = BITS 8 AND 9 IN U.TSTA+2 IN UCBX MULTIPLIED BY 2.
; (BIT COMBINATION 11 UNUSED).
;
OSDSP:: .WORD   EXPC0           ;DEFAULT CASE
        .WORD   EXPC1           ;USED FOR WRAP-AROUND
        .WORD   EXPC2           ;USED FOR WRAP-AROUND
                                                                                ; DD004
        .IF DF  T$$MOD&T$$SMC                                                   ; DD004
                                                                                ; DD004
;                                                                               ; DD004
;                                                                               ; DD004
; DISPATCH TABLE FOR CHECKING WHETHER A PARTICULAR LINE CAN BE SET REMOTE       ; DD004
;                                                                               ; DD004
RMDSP:: .WORD   RMTDL           ;DL                                             ; DD004
        .WORD   RMTDZ           ;DZ                                             ; DD004
        .WORD   RMTDH           ;DH                                             ; DD004
        .WORD   RMTDJ           ;DJ                                             ; DD004
                                                                                ; DD004
        .ENDC                                                                   ; DD004
                                                                                ; DD004
;
;

        .IF DF  T$$GMC!T$$SMC

;
; TABLE OF CHARACTERISTIC CODES FOR GET MULTIPLE CHARACTERISTICS
; FUNCTION (SF.GMC) AND SET MULTIPLE CHARACTERISTICS FUNCTION (SF.SMC).
;
; EACH RECOGNIZED CODE HAS A 1-WORD ENTRY IN THE TABLE.
; THIS WORD CONTAINS ONE OF THE FOLLOWING:
;
;       1. IF THE WORD NOT = 0 AND BIT 15 = 0:
;       LOW BYTE = A BITMASK THAT MAPS THE DESIRED CHARACTERISTIC
;       VALUE IN THE PROPER BYTE IN THE UCB. BITS ARE SET FOR
;       RELEVANT BITS IN THE UCB BYTE.
;       HIGH BYTE = OFFSET FROM START OF THE UCB TO THE BYTE
;       THAT CONTAINS THE DESIRED CHARACTERISTIC.
;
;       2. IF BIT 15 = 1:
;       THE WORD IS THE ADDRESS OF A SUBROUTINE THAT HANDLES
;       THIS PARTICULAR CHARACTERISTIC.
;       (ALL VIRTUAL ADDRESSES IN THE DRIVER ARE 120000 OR HIGHER).
;
;       3. IF THE WHOLE WORD = 0:
;       THIS CHARACTERISTIC IS NOT RECOGNIZED BY SF.GMC OR SF.SMC.
;
;
; DEFINE MACRO TO GENERATE TABLE ENTRIES
;
        .MACRO  MCGEN   NAME,OFS,BM
        .IF LE  NAME-MCHI
        .=MCTAB+<2*<NAME-1>>
        .IF NB  BM
        .IF LE  BM-377
        .BYTE   BM,OFS
        .IFF
        .BYTE   BM/400,OFS+1
        .ENDC
        .IFF
        .WORD   OFS
        .ENDC
        .IFF
        .ERROR  ;ILLEGAL CHARACTERISTIC
        .ENDC
        .ENDM   MCGEN
;
MCHI    ==      TC.MAX-1                ;HIGHEST RECOGNIZED CHARACTERISTIC      ;PW027
;                                                                               ;**-1
MCTAB:: .REPT   MCHI
        .WORD   0                       ;INITIALIZE WHOLE TABLE TO ZEROS
        .ENDR
        MCGEN   TC.WID,U.CW4,377        ;NUMBER OF COLUMNS
        MCGEN   TC.LPP,U.TLPP,377       ;NUMBER OF LINES PER PAGE

        .IF DF  D$$H11!D$$Z11

        MCGEN   TC.RSP,MCRSP            ;RECEIVE SPEED
        MCGEN   TC.XSP,MCXSP            ;TRANSMIT SPEED

        .ENDC   ;D$$H11!D$$Z11

        MCGEN   TC.ISL,U.UNIT,377       ;SUB-LINE ON CONTROLLER
        MCGEN   TC.RAT,U.TSTA+4,S3.TAB  ;READ-AHEAD TYPE
        MCGEN   TC.TTP,MCTTP            ;TERMINAL TYPE
        MCGEN   TC.SCP,U.CW2,U2.CRT     ;SCOPE
        MCGEN   TC.HFL,U.TSTA+2,S2.HFL  ;HORIZONTAL FILL REQUIREMENT
        MCGEN   TC.VFL,U.TSTA+2,S2.VFL  ;VERTICAL FILL REQUIREMENT
        MCGEN   TC.HFF,U.TSTA+2,S2.HFF  ;HARDWARE FORM-FEED
        MCGEN   TC.HHT,U.TSTA+2,S2.HHT  ;HARDWARE TAB                           ; DD017
        MCGEN   TC.ACR,U.TSTA+2,S2.ACR  ;AUTOMATIC CR-LF ON LONG LINES
        MCGEN   TC.SMR,U.CW2,U2.LWC     ;LOWERCASE INPUT ENABLED
        MCGEN   TC.ESQ,U.CW2,U2.ESC     ;ESCAPE SEQUENCES RECOGNIZED

        .IF DF  T$$MOD

        MCGEN   TC.DLU,U.CW2,U2.RMT     ;DIAL-UP LINE

        .ENDC

        MCGEN   TC.HLD,U.CW2,U2.HLD     ;HOLD-SCREEN MODE
        MCGEN   TC.NEC,U.CW2,U2.NEC     ;NO ECHO ON SOLICITED INPUT
        MCGEN   TC.SLV,U.CW2,U2.SLV     ;SLAVED TERMINAL
        MCGEN   TC.PRI,U.CW2,U2.PRV     ;PRIVILEGED TERMINAL
        MCGEN   TC.FDX,U.TSTA+2,S2.FDX  ;FULL DUPLEX
        MCGEN   TC.BIN,U.TSTA+4,S3.RAL  ;READ-PASS-ALL                          ;PW027
        MCGEN   TC.8BC,U.TSTA+4,S3.8BC  ;8 BIT CHARACTERS PASSED ON READ
        MCGEN   TC.TBF,MCTBF            ;TYPE-AHEAD BUFFER ACTIVE COUNT         ; DD011
        MCGEN   TC.CTS,MCCTS            ;CONTROL-S STATUS                       ; DD011
;
        .=MCTAB+<2*MCHI>                ;END OF TABLE
;
;

        .ENDC   ;T$$GMC!T$$SMC

;
;

        .IF DF  D$$M11!D$$LMD

;
; DISPATCH TABLE FOR MODEM INTERRUPT SERVICE ROUTINE.
; INDEX = BITS 1 AND 2 IN U.STS (US.DSB AND US.CRW).
;
MDSP::  .WORD   MODI4           ;ENABLED, NOT WAITING FOR CARRIER
        .WORD   MODI2           ;DISABLED, NOT WAITING FOR CARRIER
        .WORD   MODI5           ;ENABLED, WAITING FOR CARRIER
        .WORD   MODI3           ;DISABLED, WAITING FOR CARRIER

        .ENDC   ;D$$M11!D$$LMD
;
;
; MISCELLANEOUS WORDS
;
PAR6S:: .BLKW   1               ;SAVED DRIVER MAPPING FOR KISAR6
FREEB:: .WORD   0               ;FREE BUFFER LISTHEAD
DCB0::  .BLKW   1               ;POINTER TO DCB FOR FIRST TERMINAL
                                ;SET UP BY INITIALIZATION ROUTINE
;
;

        .IF DF  M$$EXT

; SAVED SETTINGS FOR UMR 5 AND 6 TO MAP DRIVER WITH 18-BIT ADDRESSES
; IDENTICAL TO 16 BIT ADDRESSES
;
UMR5S:: .BLKW   2               ;UMR 5
        .BLKW   2               ;UMR 6

        .IFF    ;M$$EXT

        .IF DF  D$$H11

; RELOCATION CONSTANT TO TRANSFORM A VIRTUAL ADDRESS WITHIN THE DRIVER
; TO A PHYSICAL ADDRESS. THIS RELOCATION IS REQUIRED ONLY FOR DMA
; CONTROLLERS (SUCH AS THE DH-11), AND ONLY IF EXTENDED MEMORY IS NOT
; PRESENT. THE FORMAT OF THE DOUBLE-WORD RELOCATION CONSTANT IS SUCH
; THAT WHEN IT IS ADDED TO A VIRTUAL ADDRESS IN THE RANGE 120000-157777
; (CARRY IS ADDED TO BIT 4 OF THE HIGH ORDER WORD), THE RESULT IS
; THE 18-BIT PHYSICAL ADDRESS (2 HIGH BITS IN BITS 4-5 OF RELC+0,
; 16 LOW BITS IN RELC+2).
;
; THE RELOCATION CONSTANT IS CALCULATED AND STORED HERE BY THE POWER-UP
; CODE.
;
; IF EXTENDED MEMORY IS PRESENT, THE POWER-UP CODE HAS MAPPED THE DRIVER
; IN UMR'S 5 AND 6, WHICH MEANS THAT DRIVER VIRTUAL ADDRESSES ARE
; IDENTICAL WITH THE 18-BIT ADDRESSES.
;
RELC::  .BLKW   2

        .ENDC   ;D$$H11

        .ENDC   ;M$$EXT

                                                                                ;PW010
        .IF DF  T$$CUP                                                          ;PW010
                                                                                ;PW010
; TABLE OF POINTERS TO ROUTINES TO EXPAND A CURSOR POSITIONING COMMAND          ;PW010
; INTO A CHARACTER STRING APPROPRIATE FOR THE TERMINAL TYPE.                    ;PW010
; INDEX INTO THIS TABLE = 2*X-2, WHERE X = THE VALUE IN BITS 6-7 OF THE         ;PW010
; TABLE "TTYP1" (SEE ABOVE) FOR THE TERMINAL TYPE.                              ;PW010
;                                                                               ;PW010
CPOST:: .WORD   CPOS1           ;1 - VT05 STYLE                                 ;PW010
        .WORD   CPOS2           ;2 - VT52 STYLE                                 ;PW010
        .WORD   CPOS3           ;3 - VT100 STYLE                                ;PW010
;                                                                               ;PW010
;                                                                               ;PW010
; NOTE - THE LOCATIONS EXPCP, CP0, CP1, CP2 AND CP3 BELOW ARE READ/WRITE        ;PW010
; LOCATIONS!                                                                    ;PW010
; THIS IS SAFE SINCE THEY ARE ONLY USED BY THE SYSTEM STATE CODE                ;PW010
; IN MODULE "TTRW" - NEVER BY INTERRUPT LEVEL CODE.                             ;PW010
;                                                                               ;PW010
; POINTER TO ROUTINE TO EXPAND 1 CHARACTER ON OUTPUT, OR TO ROUTINE             ;PW010
; THAT EXPANDS CURSOR POSITIONING COMMAND.                                      ;PW010
;                                                                               ;PW010
EXPCP:: .WORD   EXPC3                                                           ;PW010
;                                                                               ;PW010
; TERMINAL-DEPENDENT CURSOR POSITIONING COMMAND STRINGS                         ;PW010
;                                                                               ;PW010
; TYPE 2 - VT52. MUST BE LOCATED ON WORD BOUNDARY!                              ;PW010
;                                                                               ;PW010
CP2::   .BYTE   CH.ESC,'H,CH.ESC,'J                                             ; DD015
        .BYTE   CH.ESC,'Y,0,0                                                   ;PW010
;                                                                               ;PW010
; TYPE 1 - VT05                                                                 ;PW010
;                                                                               ;PW010
CP1::   .BYTE   35,0,0,0,0      ;4 FILLERS AFTER HOME CURSOR                    ; DD015
        .BYTE   37,0,0,0,0      ;4 FILLERS AFTER ERASE-TO-EOS                   ; DD015
        .BYTE   16,0,0,0,0,0,0  ;4 FILLERS AFTER Y-COORDINATE                   ;PW010
;                                                                               ;PW010
; TYPE 3 - VT100                                                                ;PW010
;                                                                               ;PW010
CP3::   .BYTE   CH.ESC,'[,'2,'J                                                 ; DD015
        .BYTE   CH.ESC,'[,0,0,0,';,0,0,0                                        ;PW010
CP3A::  .BYTE   'H                                                              ;PW010
        .EVEN                                                                   ;PW010
                                                                                ;PW010
        .ENDC   ;T$$CUP                                                         ;PW010
                                                                                ;PW010
        .IF DF D$$M11&R$$MPL                                                    ; CS013
                                                                                ; CS013
        .IF DF  T$$COM                                                          ; CS013
                                                                                ; CS013
YMCP1:: .BLKW   1               ;POINTER TO $YMCTB                              ; CS013
                                                                                ; CS013
        .IFF    ;T$$COM                                                         ; CS013
                                                                                ; CS013
YMCP1== YMCTBP                  ;POINTER TO $YMCTB                              ; CS013
                                                                                ; CS013
        .ENDC   ;T$$COM                                                         ; CS013
                                                                                ; CS013
        .ENDC   ;D$$M11&R$$MPL                                                  ; CS013
                                                                                ; CS013
        .IF DF  DEBUG                                                           ;PW004
                                                                                ;PW004
POOLE:: .BLKW   1               ;POINTER TO END OF POOL MINUS T$$BFL BYTES      ;PW004
                                                                                ;PW004
        .ENDC                                                                   ;PW004
                                                                                ;PW004
                                                                                ; CS013
                                                                                ; CS013
        .IF NDF R$$MPL                                                          ; CS013
                                                                                ; CS013
;                                                                               ; CS013
;TABLE OF POINTERS TO CSR TABLES                                                ; CS013
;                                                                               ; CS013
TTCSR:: .IRP    X,<L,Z,H,J,M>                                                   ; CS013
        .IF DF D$$'X'11                                                         ; CS013
        .WORD   D'X'CSR                                                         ; CS013
        .IFF                                                                    ; CS013
        .WORD   0                                                               ; CS013
        .ENDC                                                                   ; CS013
        .ENDR                                                                   ; CS013
                                                                                ; CS013
;                                                                               ; CS013
;TABLE OF POINTERS TO UCB TABLES                                                ; CS013
;                                                                               ; CS013
TTUCB:: .IRP    X,<L,Z,H,J,M>                                                   ; CS013
        .IF DF D$$'X'11                                                         ; CS013
        .WORD   D'X'UCB                                                         ; CS013
        .IFF                                                                    ; CS013
        .WORD   0                                                               ; CS013
        .ENDC                                                                   ; CS013
        .ENDR                                                                   ; CS013
                                                                                ; CS013
;                                                                               ; CS013
; DL-11 DATABASES                                                               ; CS013
;                                                                               ; CS013
                                                                                ; CS013
        .IF DF  D$$L11                                                          ; CS013
                                                                                ; CS013
DLUCB::                         ;DL UCB POINTER TABLE POINTER TABLE             ; CS013
N=0                                                                             ; CS013
        .REPT   D$$L11                                                          ; CS013
        .WORD   DLUC0+N                                                         ; CS013
N=N+2                                                                           ; CS013
        .ENDR                                                                   ; CS013
DLUC0:  .BLKW   D$$L11          ;DL UCB POINTERS                                ; CS013
                                                                                ; CS013
DLCSR:: .BLKW   D$$L11          ;DL CSR TABLE                                   ; CS013
                                                                                ; CS013
        .ENDC   ; DF D$$L11                                                     ; CS013
                                                                                ; CS013
;                                                                               ; CS013
; DH-11 DATABASES                                                               ; CS013
;                                                                               ; CS013
        .IF DF  D$$H11                                                          ; CS013
                                                                                ; CS013
DMUCB::                         ;POINT DM11-BB UCB'S TO DH UCB'S                ; CS013
DHUCB::                         ;DH UCB POINTER TABLE POINTER TABLE             ; CS013
N=0                                                                             ; CS013
        .REPT   D$$H11                                                          ; CS013
        .WORD   DHUC0+N         ;POINTER TO DH11 UCB TABLE                      ; CS013
N=N+34.                                                                         ; CS013
        .ENDR                                                                   ; CS013
                                                                                ; CS013
DHUC0:                          ;DH UCB TABLES                                  ; CS013
        .REPT   D$$H11                                                          ; CS013
        .REPT   16.                                                             ; CS013
        .WORD   0               ;ADDR OF UCB FOR LINE (PLUGGED AT TTPWF)        ; CS013
        .ENDR                                                                   ; CS013
        .WORD   -1              ;END OF UCB LIST                                ; CS013
        .ENDR                                                                   ; CS013
                                                                                ; CS013
DHCSR:: .BLKW   D$$H11          ;DH11 CSR ADDRESS                               ; CS013
;                                                                               ; CS013
; DM11-BB DATABASES                                                             ; CS013
;                                                                               ; CS013
                                                                                ; CS013
        .IF DF  D$$M11                                                          ; CS013
                                                                                ; CS013
DMCSR:: .BLKW   D$$M11          ;DM11-BB CSR ADDRESSES                          ; CS013
                                                                                ; CS013
        .ENDC   ; DF D$$M11                                                     ; CS013
                                                                                ; CS013
        .ENDC   ; DF D$$H11                                                     ; CS013
                                                                                ; CS013
;                                                                               ; CS013
; DZ-11 DATABASES                                                               ; CS013
;                                                                               ; CS013
                                                                                ; CS013
        .IF DF  D$$Z11                                                          ; CS013
                                                                                ; CS013
DZUCB:                          ;DZ UCB POINTER TABLE POINTER TABLE             ; CS013
N=0                                                                             ; CS013
        .REPT   D$$Z11                                                          ; CS013
                                                                                ; CS013
        .WORD   DZUC0+N         ;POINTER TO DZ11 UCB TABLE (INDEXED BY          ; CS013
                                ; CONTROLLER NUMBER)                            ; CS013
N=N+18.                                                                         ; CS013
        .ENDR                                                                   ; CS013
                                                                                ; CS013
DZUC0:                          ;REF LABEL                                      ; CS013
                                                                                ; CS013
        .REPT   D$$Z11                                                          ; CS013
        .REPT   8.                                                              ; CS013
        .WORD   0               ;UCB ADDRESS FOR EACH LINE                      ; CS013
        .ENDR                                                                   ; CS013
        .WORD   -1              ;END OF UCB LIST                                ; CS013
        .ENDR                                                                   ; CS013
                                                                                ; CS013
DZCSR:  .BLKW   D$$Z11          ;DZ11 CSR ADDRESS                               ; CS013
        .ENDC   ; DF D$$Z11                                                     ; CS013
                                                                                ; CS013
;                                                                               ; CS013
; DJ-11 DATABASES                                                               ; CS013
;                                                                               ; CS013
                                                                                ; CS013
        .IF DF  D$$J11                                                          ; CS013
                                                                                ; CS013
DJUCB:                          ;REF LABEL                                      ; CS013
N=0                                                                             ; CS013
                                                                                ; CS013
        .REPT   D$$J11                                                          ; CS013
        .WORD   DJUC0+N         ;POINTER TO DJ11 UCB TABLE                      ; CS013
N=N+34.                                                                         ; CS013
        .ENDR                                                                   ; CS013
                                                                                ; CS013
DJUC0:                          ;REF LABEL                                      ; CS013
                                                                                ; CS013
        .REPT   D$$J11                                                          ; CS013
        .REPT   16.                                                             ; CS013
        .WORD   0               ;ADDRESS OF LINE'S UCB                          ; CS013
        .ENDR                                                                   ; CS013
        .WORD   -1              ;END OF UCB LIST                                ; CS013
        .ENDR                                                                   ; CS013
                                                                                ; CS013
DJCSR:  .BLKW   D$$J11          ;DJ11 CSR ADDRESS                               ; CS013
                                                                                ; CS013
        .ENDC   ; DF D$$J11                                                     ; CS013
                                                                                ; CS013
        .ENDC   ;NDF R$$MPL                                                     ; CS013
.PAGE                                                                           ;PW026
;+                                                                              ;PW026
; DRIVER INITIALIZATION ROUTINE.                                                ;PW026
;                                                                               ;PW026
; THIS CODE IS EXECUTED ONCE ONLY AT THE FIRST CALL                             ;PW026
; TO THE DRIVER AFTER IT HAS BEEN LOADED.                                       ;PW026
; IT SERVES THE FOLLOWING PURPOSES:                                             ;PW026
;       1. ESTABLISH THE MAPPING OF THE DRIVER DATA AREA                        ;PW026
;          AND SAVE THE APR VALUES IN SAVE LOCATIONS SO THEY CAN                ;PW026
;          BE QUICKLY LOADED WHENEVER THE DRIVER IS CALLED.                     ;PW026
;       2. SAVE KINAR5 IN THE TT-DRIVER FORK BLOCK (FORK BLOCKS                 ;PW026
;          IF  MULTI-PROCESSOR SYSTEM).                                         ;PW026
;       3. CALCULATE AND SAVE UMR'S 5 AND 6 VALUES (IF DH-11                    ;PW026
;          AND EXTENDED MEMORY SUPPORTED).                                      ;PW026
;       4. CALCULATE AND SAVE A CONSTANT USED TO TRANSFORM A DRIVER             ;PW026
;          VIRTUAL ADDRESS INTO A PHYSICAL ADDRESS (IF DH-11 BUT                ;PW026
;          NOT EXTENDED MEMORY SUPPORTED).                                      ;PW026
;       5. INITIALIZE AND QUEUE THE TT-DRIVER CLOCK BLOCK.                      ;PW026
;       6. SAVE A POINTER TO THE FIRST TT DCB IN THE SYSTEM.                    ;PW026
;       7. CONSTRUCT THE LIST OF FREE BUFFERS IN THE TT-DRIVER BUFFER POOL.     ;PW026
;                                                                               ;PW026
; IN A SYSTEM THAT SUPPORTS SEPARATE KERNEL DATA SPACE MAPPING,                 ;PW026
; THIS MODULE RESIDES IN THE COMMON BLOCK "TTCOM".                              ;PW026
; WHEN "INIT" IS CALLED IN SUCH A SYSTEM, THE MAPPING IS:                       ;PW026
;       INSTR. SPACE APR 5:     DRIVER CODE                                     ;PW026
;       INSTR. SPACE APR 6:     DRIVER DATA AND INITIALIZATION ROUTINE          ;PW026
;                               (FIRST 4 KW OF TTCOM)                           ;PW026
;       DATA SPACE APR 5:       DRIVER CODE                                     ;PW026
;       DATA SPACE APR 6:       UNDEFINED                                       ;PW026
; ON RETURN FROM "INIT", THE MAPPING IS THE "NORMAL" DRIVER MAPPING,            ;PW026
; WHICH IS:                                                                     ;PW026
;       INSTR. SPACE APR 5:     DRIVER CODE (TTDRV)                             ;PW026
;       DATA SPACE APR 5-6:     DRIVER DATA (TTCOM)                             ;PW026
;                                                                               ;PW026
; IN A SYSTEM THAT DOES NOT SUPPORT SEPARATE KERNEL DATA SPACE MAPPING,         ;PW026
; THIS MODULE RESIDES TOGETHER WITH ALL OTHER CODE AND DATA IN "TTDRV".         ;PW026
; THE COMMON BLOCK "TTCOM" DOES NOT EXIST. IN SUCH A SYSTEM, WHEN               ;PW026
; "INIT" IS CALLED, THE MAPPING IS:                                             ;PW026
;       INSTR. AND DATA SPACE APR 5: DRIVER CODE                                ;PW026
; ON RETURN, THE MAPPING IS THE "NORMAL" DRIVER MAPPING, WHICH IS:              ;PW026
;       INSTR. SPACE APR 5-6:   DRIVER CODE AND DATA (TTDRV)                    ;PW026
;                                                                               ;PW026
; FROM THE DESCRIPTION ABOVE, IT FOLLOWS THAT THE INITIALIZATION ROUTINE        ;PW026
; MAY BE MAPPED EITHER IN APR 5 (NON-D-SPACE SYSTEM) OR APR 6 (D-SPACE          ;PW026
; SYSTEM) WHEN CALLED. IT MUST THEREFORE BE WRITTEN IN POSITION-INDEPENDENT     ;PW026
; CODE (PIC).                                                                   ;PW026
;-                                                                              ;PW026
;                                                                               ;PW026
;                                                                               ;PW026
        .PSECT  $$$$$$,OVR                                                      ;PW026
;                                                                               ;PW026
TTPOOL::.BLKW   1               ;START OF DRIVER'S PRIVATE POOL                 ;PW026
;                                                                               ;PW026
; NOTE - THE ROUTINE BELOW MUST FIT INTO ONE FIXED LENGTH BUFFER                ;PW026
; (LENGTH = T$$BFL BYTES), OR IT WILL OVERWRITE ITSELF.                         ;PW026
; NOTE ALSO THAT THE ROUTINE MUST MAP ITSELF IN BOTH I- AND D-SPACE.            ;PW026
;                                                                               ;PW026
; INPUT:                                                                        ;PW026
;       R0      START OF DRIVER POOL                                            ;PW026
;       R1      POINTER T$$BFL BYTES BELOW END OF DRIVER POOL                   ;PW026
;                                                                               ;PW026
CPOOL:  MOV     R0,R2           ;COPY POINTER TO CURRENT BUFFER                 ;PW026
        ADD     #T$$BFL,R0      ;POINT TO NEXT BUFFER                           ;PW026
        MOV     R0,@R2          ;LINK NEW TO OLD                                ;PW026
        CMP     R0,R1           ;END OF POOL?                                   ;PW026
        BLO     CPOOL           ;N - LOOP                                       ;PW026
        CLR     @R2             ;Y - CLEAR POINTER IN LAST BUFFER               ;PW026
        RETURN                  ;ALL DONE                                       ;PW026
        .IIF GT .-<TTPOOL+T$$BFL>, .ERROR                                       ;PW026
;                                                                               ;PW026
;                                                                               ;PW026
INIT::  MOV     @#KINAR5,R0     ;GET START OF DRIVER CODE                       ;PW026
                                                                                ;PW026
        .IF DF  M$$PRO                                                          ;PW026
                                                                                ;PW026
        MOV     #M$$PRO,R2      ;GET NUMBER OF CPU'S                            ;PW026
        MOV     #$TTFB+10,R1    ;GET POINTER TO KINAR6 WORD IN                  ;PW026
                                ;FORK BLOCK FOR CPU 0                           ;PW026
5$:     MOV     R0,@R1          ;SAVE KINAR5 IN FORK BLOCK                      ;PW026
        ADD     #TT$UQL,R1      ;POINT TO NEXT UCB QUEUE                        ;PW026
        SOB     R2,5$           ;LOOP                                           ;PW026
                                                                                ;PW026
        .IFF    ;M$$PRO                                                         ;PW026
                                                                                ;PW026
        MOV     R0,@#$TTFB+10   ;SAVE KINAR5 IN FORK BLOCK                      ;PW026
                                                                                ;PW026
        .ENDC   ;M$$PRO                                                         ;PW026
                                                                                ;PW026
        .IF DF  T$$COM                                                          ;PW026
                                                                                ;PW026
        MOV     @#$TTCOM,-(SP)  ;SAVE TTCOM PCB ADDRESS                         ;PW026
        CLR     @#$TTCOM        ;INDICATE DRIVER INITIALIZATION DONE            ;PW026
                                                                                ;PW026
        .IF DF  D$$M11                                                          ;PW026
                                                                                ;PW026
        MOV     @#YMCTBP,R1     ;GET POINTER TO $YMCTB                          ;PW026
                                                                                ;PW026
        .IFTF   ;D$$M11                                                         ;PW026
                                                                                ;PW026
        MOV     @#KINAR6,R0     ;GET START OF DRIVER DATA                       ;PW026
        MOV     R0,@#PAR5S      ;SAVE A COPY                                    ;PW026
        MOV     @#KINAR5,@#PAR6I ;GET START OF DRIVER CODE                      ; DD018
        ADD     #200,@#PAR6I    ;COMPUTE AND SAVE HIGH 4K MAPPING               ; DD018
        MOV     R0,@#KDSAR5     ;MAP DRIVER DATA                                ;PW026
                                                                                ;PW026
        .IFT    ;D$$M11                                                         ;PW026
                                                                                ;PW026
        MOV     R1,@#YMCP1      ;SAVE POINTER TO $YMCTB                         ;PW026
                                                                                ;PW026
        .ENDC   ;D$$M11                                                         ;PW026
                                                                                ;PW026
        .ENDC   ;T$$COM                                                         ;PW026
                                                                                ;PW026
        MOV     R0,R1           ;COPY REAL START OF DRIVER DATA                 ;PW026
        ADD     #200,R0         ;ADD THE EQUIVALENT OF 4 K WORDS                ;PW026
        MOV     R0,@#KISAR6     ;MAP REST OF DRIVER                             ;PW026
        MOV     R0,@#PAR6S      ;SAVE DRIVER KISAR6                             ;PW026
                                                                                ;PW026
        .IF DF  D$$H11                                                          ;PW026
                                                                                ;PW026
        .IF DF  M$$EXT                                                          ;PW026
                                                                                ;PW026
;                                                                               ;PW026
; SET UP UMR'S 5 AND 6 TO MAP ALL OF THE DRIVER DATA AREA.                      ;PW026
; SAVE THE UMR VALUES.                                                          ;PW026
;                                                                               ;PW026
        CLR     R0              ;                                               ;PW026
                                                                                ; DD007
        .IF DF  R$$EIS                                                          ; DD007
                                                                                ; DD007
        ASHC    #6,R0           ;GET PHYS. START ADDRESS                        ; DD007
                                                                                ; DD007
        .IFF    ;R$$EIS                                                         ; DD007
                                                                                ; DD007
        MOV     R1,R0           ;GET PHYS. START ADDRESS                        ; DD007
        SWAB    R0              ;USE NON-EIS EMULATION OF ASHC #6,R0            ; DD007
        BIC     #177400,R0      ;                                               ; DD007
        SWAB    R1              ;                                               ; DD007
        BIC     #377,R1         ;                                               ; DD007
        ROR     R0              ;                                               ; DD007
        ROR     R1              ;                                               ; DD007
        ROR     R0              ;                                               ; DD007
        ROR     R1              ;                                               ; DD007
                                                                                ; DD007
        .ENDC   ;R$$EIS                                                         ; DD007
                                                                                ; DD007
        MOV     #UMR5S,R2       ;POINT AT SAVED UMR 5                           ;PW026
        MOV     #UBMPR+<5*4>,R3 ;POINT AT UMR 5                                 ;PW026
        MOV     R1,(R3)+        ;SET UP UMR 5                                   ;PW026
        MOV     R0,(R3)+        ;                                               ;PW026
        MOV     R1,(R2)+        ;SAVE UMR 5 SETTING                             ;PW026
        MOV     R0,(R2)+        ;                                               ;PW026
        ADD     #20000,R1       ;ADVANCE 8 K BYTES                              ;PW026
        ADC     R0              ;                                               ;PW026
        MOV     R1,(R3)+        ;SET UP UMR 6                                   ;PW026
        MOV     R0,(R3)+        ;                                               ;PW026
        MOV     R1,(R2)+        ;SAVE UMR 6 SETTING                             ;PW026
        MOV     R0,(R2)+        ;                                               ;PW026
                                                                                ;PW026
        .IFF    ;M$$EXT                                                         ;PW026
                                                                                ;PW026
;                                                                               ;PW026
; COMPUTE AND SAVE THE DOUBLE-WORD RELOCATION CONSTANT TO TRANSFORM A DRIVER    ;PW026
; VIRTUAL ADDRESS INTO AN 18-BIT ADDRESS.                                       ;PW026
; (SEE DETAILED DESCRIPTION AT LABEL "RELC:").                                  ;PW026
;                                                                               ;PW026
        SWAB    R1              ;SHIFT KISAR5 6 BITS LEFT                       ;PW026
        MOVB    R1,R0           ;GET ORIGINAL BITS 10-11 IN BITS 2-3            ;PW026
        RORB    R1              ;ORIGINAL BIT 8 INTO CARRY                      ;PW026
        ROR     R1              ;BIT 8 INTO BIT 15, BIT 9 INTO CARRY            ;PW026
        ROR     R1              ;BIT 9 INTO BIT 15 - SHIFT IS COMPLETED         ;PW026
        BIC     #77,R1          ;CLEAR 6 LOW BITS                               ;PW026
        ASL     R0              ;SHIFT 2 HIGH BITS INTO BITS 4-5                ;PW026
        ASL     R0              ;                                               ;PW026
        SUB     #120000,R1      ;SUBTRACT DRIVER BASE VIRTUAL ADDRESS           ;PW026
        BCC     10$             ;NO CARRY - JUMP                                ;PW026
        SUB     #20,R0          ;SUBTRACT CARRY FROM R0 BIT 4                   ;PW026
10$:    BIC     #^C<60>,R0      ;CLEAR ALL BUT BITS 4-5                         ;PW026
        MOV     R0,@#RELC       ;SAVE RELOCATION CONSTANT                       ;PW026
        MOV     R1,@#RELC+2                                                     ;PW026
                                                                                ;PW026
        .ENDC   ;M$$EXT                                                         ;PW026
                                                                                ;PW026
        .ENDC   ;D$$H11                                                         ;PW026
                                                                                ;PW026
        MOV     #TTICK,@#$TTCB+C.SUB ;INITIALIZE CLOCK BLOCK                    ;PW026
        CALL    @#CLINS         ;QUEUE IT                                       ;PW026
        MOV     #$DEVHD,R0      ;GET START OF DCB LIST                          ;PW026
20$:    MOV     @R0,R0          ;GET NEXT DCB                                   ;PW026
        CMP     D.NAM(R0),#"TT  ;DOES IT HAVE GENERIC NAME "TT"?                ; DD015
        BNE     20$             ;N - LOOP                                       ; DD015
        MOV     D.UCB(R0),R1    ;GET FIRST UCB                                  ;PW026
        BIT     #DV.TTY,U.CW1(R1) ;IS IT A TERMINAL?                            ;PW026
        BEQ     20$             ;N - LOOP                                       ;PW026
        MOV     R0,@#DCB0       ;SAVE POINTER TO FIRST TERMINAL DCB             ;PW026
                                                                                ;PW026
        .IF DF  T$$COM                                                          ;PW026
                                                                                ;PW026
        MOV     (SP)+,R1        ;GET TTCOM PCB                                  ;PW026
                                                                                ;PW026
        .IFF    ;T$$COM                                                         ;PW026
                                                                                ;PW026
        MOV     D.PCB(R0),R1    ;GET TTDRV PCB                                  ;PW026
                                                                                ;PW026
        .ENDC   ;T$$COM                                                         ;PW026
                                                                                ;PW026
        MOV     P.SIZE(R1),R1   ;GET PARTITION SIZE IN 32. WORD BLOCKS          ;PW026
        SWAB    R1              ;CONVERT TO BYTES                               ;PW026
        RORB    R1                                                              ;PW026
        ROR     R1                                                              ;PW026
        ROR     R1                                                              ;PW026
        ADD     #120000-T$$BFL,R1 ;GET POINTER T$$BFL BYTES BELOW END OF        ;PW026
                                ;DRIVER POOL                                    ;PW026
                                                                                ;PW026
        .IF DF  DEBUG                                                           ;PW026
                                                                                ;PW026
        MOV     R1,@#POOLE                                                      ;PW026
                                                                                ;PW026
        .ENDC   ;DEBUG                                                          ;PW026
                                                                                ;PW026
;                                                                               ;PW026
        MOV     #TTPOOL,R0      ;GET START OF POOL                              ;PW026
        MOV     R0,@#FREEB      ;POINT TO FIRST FREE BUFFER                     ;PW026
        BR      CPOOL           ;INITIALIZE POOL                                ;PW026
;                                                                               ;PW026
;                                                                               ;PW026
        .END                                                                    ;PW026
;
;
        .END
        .TITLE  TTDRV
        .IDENT  /19.16/
        
;
; COPYRIGHT (C) 1973, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS. 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 19.15
;
; D. N. CUTLER 24-OCT-73
;
; PRE-VERSION 18 MODIFICATIONS BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;       R. LARY
;       E. L. BAATZ
;
; MODIFIED BY:
;
;       ERIC BAATZ 27-JAN-78
;       EB105 -- REMOVE A WORD FROM THE MINIMUM DRIVER
;
;       ERIC BAATZ 27-JAN-78
;       EB114 -- DO NOT ECHO CONTROL/U AND /Z IF IN NO ECHO MODE
;
;       ERIC BAATZ 27-JAN-78
;       EB116 -- 174 IS NOT A SPECIAL TERMINATOR
;
;       ERIC BAATZ 28-JAN-78
;       EB119 -- ADD TC.RSP AND TC.XSP TO SF.SMC AND UNKNOT
;                CONFUSION OVER HARDWARE FORM FEED SUPPORT
;
;       ERIC BAATZ 7-JUL-78
;       EB151 -- FORGET ABOUT HELD UP CHARACTER ON CANCEL
;
;       CHUCK SPITZ 10-JUL-78
;       CS016 -- REARRANGE UCB TO BE COMPATIBLE WITH NEW TERMINAL DRIVER
;
;       ERIC BAATZ 22-JUL-78
;       EB154 -- CORRECTLY QUEUE CLOCK BLOCK IF MODEM SUPPORT AND FIRST
;                CONTROLLER IS NONEXISTENT
;
;       ERIC BAATZ 3-SEP-78
;       EB161 -- STOP DOUBLE USE OF FORK BLOCK IF A BREAKTHROUGH WRITE
;                IS QUEUED AND AN UNSOLICITED CHARACTER HAS FORKED
;
;       ERIC BAATZ 4-MAR-79
;       EB198 -- CANNOT IO.WBT WHILE DOING A MULTIECHO
;
;       CHUCK SPITZ 4-MAY-79
;       CS033 -- ADD MULTIPLE CLI SUPPORT FOR DECNET
;
;       ERIC BAATZ 19-APR-79
;       EB204 -- NO FILL CHARACTER ON IO.WBT
;
;       ERIC BAATZ 19-APR-79
;       EB205 -- MAKE ESC P AN ESCAPE SEQUENCE
;
;       ERIC BAATZ 26-APR-79
;       EB206 -- CLOSE ESCAPE SEQUENCE DOUBLE FORK TIMING WINDOW
;
;       ERIC BAATZ 28-APR-79
;       EB208 -- NULLS CANNOT START UNSOLICITED INPUT (THEY DEFEAT
;                FORK INTERLOCK NEAR TTINI)
;
;       ERIC BAATZ 29-APR-79
;       EB209 -- ALLOW DETACHES (TO CLEAN UP UCB BITS FROM ATTACHES)
;                FROM DISABLED (HUNGUP) LINES
;
;       ERIC BAATZ 29-APR-79
;       EB210 -- DO NOT HANG IF A CANCELED QIO'S TRAILING CARRIAGE
;                CONTROL (EOLS SET) IS HELD UP BY AN XOFF
;
;       ERIC BAATZ 5-MAY-79
;       EB211 -- CLEAR UCB STATUS BITS THAT NEVER SHOULD BE SET WHEN
;                ANSWERING REMOTE LINES
;
;       ERIC BAATZ 5-MAY-79
;       EB212 -- ALLOW OPTION OF ANSWERING REMOTE LINES AT SPEED
;                OF LAST SET /SPEED
;
;       ERIC BAATZ 6-MAY-79
;       EB213 -- HANG UP DZ11 REMOTE LINE (DEASSERT DTR) IF CARRIER
;                NOT SEEN WITHIN TIMEOUT PERIOD
;
; TERMINAL DRIVER FOR DL11-A LINE INTERFACE AND DH11/DJ11/DZ11
;       LINE MULTIPLEXERS
;
;-
; MACROS TO CONSOLIDATE LOADABLE DRIVER CONDITIONAL ASSEMBLY
;
; IF NECESSARY, SAVE THE PS WORD FROM THE INTERRUPT (IT
; CONTAINS THE UNIT NUMBER OF THE INTERRUPTER), SAVE R4 AND R5,
; AND LOWER OUR PRIORITY.  IF THE DRIVER IS LOADABLE AND MAPPED, ALL
; OF THAT IS DONE BY ANOTHER PART OF THE EXEC (THE INTERRUPT CONTROL
; BLOCK) SO IT DOES NOT HAVE TO BE DONE HERE
;       TYPE = DL, DH, DJ, OR DZ
;       PRI = PRIORITY TO CALL $INTSV WITH
;       NCTRLR = NUMBER OF CONTROLLERS
;
        .MACRO  TTSAV$  TYPE,PRI,NCTRLR

        .IF NDF L$$DRV!M$$MGE!LD$TT

        .IF GT  NCTRLR-1

        MFPS    TYPE'TMP

        .ENDC

        CALL    $INTSV,PRI

        .ENDC

        JSR     R3,TYPE'SAV

        .ENDM
;
; GENERATE COMMON CODE FOR THE SAVE ROUTINES OF THE VARIOUS
; DEVICES THIS DRIVER SUPPORTS.  IF THIS DRIVER IS LOADABLE,
; SOME OF THE CODE IS DONE BY ANOTHER PART OF THE EXEC (THE
; INTERRUPT CONTROL BLOCK) SO IT DOES NOT HAVE TO BE DONE HERE.
;       TYPE = DL, DH, DJ, DZ                                                   ; EB119
;       NCTRLR = NUMBER OF CONTROLLERS                                          ;**-1
;       MUX = NONNULL IF TO GENERATE FOR A MULTIPLEXER
;
        .MACRO  TTSET$  TYPE,NCTRLR,MUX
        MOV     R3,-(SP)

        .IF GT  NCTRLR-1

        .IF NDF L$$DRV!M$$MGE!LD$TT

        MOV     TYPE'TMP,R4
        BIC     #177760,R4
        ASL     R4

        .ENDC

        .IF NB  MUX

        MOV     TYPE'TBL(R4),R3
        MOV     TYPE'CSR(R4),R4

        .IFF

        MOV     CNTBL(R4),R5

        .ENDC

        .IFF

        .IF NB  MUX

        MOV     TYPE'TBL,R3
        MOV     TYPE'CSR,R4

        .IFF

        MOV     CNTBL,R5

        .ENDC

        .ENDC

        .ENDM
                                                                                ; EB119
;                                                                               ; EB119
; DEFINE THE MACRO USED TO GENERATE THE SET SPEED TABLE FOR SF.SMC              ; EB119
;                                                                               ; EB119
;       SYMBOL = A BAUD RATE SYMBOL FROM TTSYM$ (OF THE FORM S.X)               ; EB119
;       DH = THE FOUR BIT PATTERN THAT MUST BE ASSERTED IN THE                  ; EB119
;            DH11 LINE PARAMETER CSR TO GET THE BAUD RATE REPRESENTED           ; EB119
;            BY SYMBOL.  A VALUE OF ZERO INDICATES THAT A SPEED IS              ; EB119
;            NOT SUPPORTED BY THE DH11.                                         ; EB119
;       DZ = THE FOUR BIT PATTERN THAT MUST BE ASSERTED IN THE                  ; EB119
;            DZ11 LINE PARAMETER CSR TO GET THE BAUD RATE REPRESENTED           ; EB119
;            BY SYMBOL.  A VALUE OF ZERO INDICATES THAT A SPEED IS              ; EB119
;            NOT SUPPORTED BY THE DZ11.                                         ; EB119
;                                                                               ; EB119
                                                                                ; EB119
        .MACRO  SPDTAB  SYMBOL,DH,DZ                                            ; EB119
        .BYTE   DH*20+DZ                                                        ; EB119
        .BYTE   SYMBOL                                                          ; EB119
        .ENDM                                                                   ; EB119
                                                                                ; EB119
;
; MACRO LIBRARY CALLS
;

        .MCALL  PCBDF$,TTSYM$
        PCBDF$                  ;DEFINE PARTITION CONTROL BLOCK OFFSETS
        TTSYM$                  ;DEFINE "TF.", "F1.", "F2.", "T.",
                                ; AND "TC." SYMBOLS

        .IF DF  D$$M11

        .GLOBL  U.DMCS          ;REFERENCE SO SYMBOL WILL BE IN
                                ; TTDRV.STB FOR LOA.TSK

        .ENDC

;
; THE SUBFUNCTION BIT IO.UMD (VALUE OF 4) SHOULD NEVER BE USED
; TO INDICATE A TERMINAL SUBFUNCTION, BECAUSE IT FLAGS THE FUNCTION
; AS A USER MODE DIAGNOSTIC.  FUNCTION CODE 10 (10*400 IF YOU PREFER)
; IS RESERVED FOR DIAGNOSTICS.
;

M$$CRI=80.              ;NUMBER OF BYTES OF INFORMATION IN A MCR BUFFER

;
; EQUATED SYMBOLS
;
; FOR CONVENIENCE DEFINE AN INTERNAL CONDITIONAL ASSEMBLY SYMBOL
;

        .IF DF  T$$UTB
        .IF NDF C$$CKP!T$$BUF
NOEXBF=0                ;DEFINED IF TASK'S BUFFER TO BE USED FOR
                        ; CHARACTER BUFFERING AND SYSTEM CANNOT
                        ; CHECKPOINT
        .ENDC
        .ENDC

        .IF DF  T$$RNE!T$$RPR!T$$RST!T$$TRW

SS.RAL=200              ;SET IN S.STS IF READ ALL MODE
SS.WAL=100              ;SET IN S.STS IF WRITE ALL MODE
SS.RNE=40               ;SET IN S.STS IF READ WITH NO ECHO
SS.RST=20               ;SET IN S.STS IF READ WITH SPECIAL TERMINATORS

        .ENDC
                                                                                ; EB205
;                                                                               ; EB205
; IN PRE-V3.2 VERSIONS OF THIS TERMINAL DRIVER, "ESC P IC FC"                   ; EB205
; WAS AN ESCAPE SEQUENCE (SEE COMMENTS IN FRONT OF THE LABEL                    ; EB205
; 200$ THAT PRECEDES THE LABEL TTCAN), BECAUSE THE VT61 COULD                   ; EB205
; EMIT A SUBSTANTIAL NUMBER OF SUCH ESCAPE SEQUENCES.  BECAUSE                  ; EB205
; OF THE INCREASING NUMBER OF TERMINALS THAT THINK "ESC P" IS                   ; EB205
; A COMPLETE ESCAPE SEQUENCE (VT52, VT100 (THE PF1 KEY), ETC.),                 ; EB205
; THE TERMINAL DRIVER HAS BEEN MODIFIED TO RECOGNIZE "ESC P"                    ; EB205
; AS AN ESCAPE SEQUENCE.  THE DRIVER CAN BE MODIFIED TO                         ; EB205
; RECOGNIZE "ESC P IC FC" RATHER THAN "ESC P" AS AN ESCAPE                      ; EB205
; SEQUENCE BY REMOVING THE SEMICOLON THAT PRECEDES THE                          ; EB205
; FOLLOWING DEFINITION.                                                         ; EB205
;                                                                               ; EB205
                                                                                ; EB205
;ESCPIC=0                                                                       ; EB205
                                                                                ; EB212
;                                                                               ; EB212
; THE NORMAL BEHAVIOR OF THE TERMINAL DRIVER IS TO ANSWER ALL                   ; EB212
; REMOTE LINES OF A CONTROLLER TYPE (DH11 OR DZ11) AT THE                       ; EB212
; BAUD RATE SPECIFIED DURING SYSGEN.  A SET /SPEED TO A                         ; EB212
; DIFFERENT BAUD RATE WILL AFFECT THE LINE ONLY UNTIL IT IS                     ; EB212
; HUNG UP.  THUS ALL CALLERS ARE ASSURED OF KNOWING THE BAUD                    ; EB212
; RATE OF A REMOTE LINE.  THIS IS ESPECIALLY IMPORTANT WHEN                     ; EB212
; THERE IS NOT A ONE-TO-ONE RELATIONSHIP AMOUNG PHONE NUMBERS                   ; EB212
; AND LINES (THAT IS, WHEN CALLING ONE NUMBER CAUSES THE PHONE                  ; EB212
; SYSTEM TO HUNT FOR ANY FREE LINE IN A GROUP OF LINES).                        ; EB212
;                                                                               ; EB212
; REMOVING THE SEMICOLON IN FRONT OF THE NEXT SYMBOL DEFINITION                 ; EB212
; CAUSES THE TERMINAL DRIVER TO ANSWER ALL DH11 REMOTE LINES AT                 ; EB212
; THE BAUD RATE SPECIFIED BY THE LAST SET /SPEED COMMAND FOR                    ; EB212
; EACH LINE.                                                                    ; EB212
;                                                                               ; EB212
                                                                                ; EB212
;USESDH=0                                                                       ; EB212
                                                                                ; EB212
;                                                                               ; EB212
; REMOVING THE SEMICOLON IN FRONT OF THE NEXT SYMBOL DEFINITION                 ; EB212
; CAUSES THE TERMINAL DRIVER TO ANSWER ALL DZ11 REMOTE LINES AT                 ; EB212
; THE BAUD RATE SPECIFIED BY THE LAST SET /SPEED COMMAND FOR                    ; EB212
; EACH LINE.                                                                    ; EB212
;                                                                               ; EB212
                                                                                ; EB212
;USESDZ=0                                                                       ; EB212

;
; TERMINAL CONTROL BLOCK OFFSET DEFINITIONS
;

STATS=0                         ;TERMINAL STATUS WORD
STRBF=2                         ;CURRENT BUFFER ADDRESS (INPUT)
RMBYT=4                         ;REMAINING BYTES IN BUFFER (INPUT)
FNBYT=5                         ;FINAL (TERMINATING) BYTE OF A READ
CURBF=6                         ;STARTING BUFFER ADDRESS (INPUT)
DZTIM=7                         ;TIME OUT COUNT FOR DZ11 REMOTE LINES           ; EB213
HORPS=10                        ;HORIZONTAL POSITION OF CARRIAGE
FLBYT=11                        ;FILL BYTE
DFUIC=12                        ;DEFAULT UIC OF TERMINAL                        ; CS016
MEBUF=14                        ;MULTI-ECHO BUFFER ADDRESS                      ; CS016
MBUFR=16                        ;DYNAMIC MULTI-ECHO BUFFER                      ; CS016
INPRQ=20                        ;IF NONZERO, UNSOLICITED INPUT REQUEST          ; CS016
MBUF0=21                        ;ZERO BYTE TERMINATING M-E BUFFER               ; CS016
DHBUF=22                        ;DH11 OUTPUT BUFFER                             ;**-5
IHORP=23                        ;INITIAL HORIZONTAL POSITION (T$$RUB)
NEXTB=IHORP+1

        .IIF DF T$$ACR!T$$BTW!T$$CCA!T$$CCO!T$$ESC!T$$HLD,      T1=0
        .IF DF  T1!T$$RPR!T$$SYN!T$$TRW!T$$UTB!T$$30P                           ; EB119
ATERS=NEXTB                     ;ADDITIONAL TERMINAL STATUS                     ;**-1
NEXTB=NEXTB+2
        .ENDC
        .IF DF  T$$CCA&A$$TRP
CCAST=NEXTB                     ;STARTING ADDRESS OF CONTROL C AST
NEXTB=NEXTB+2
        .ENDC
        .IF DF  T$$ESC
SYNTX=NEXTB                     ;ADDRESS OF CURRENT SYNTAX RULE FOR
NEXTB=NEXTB+2                   ; ESCAPE SEQUENCES
        .ENDC
        .IF DF  D$$M11
DMTIM=NEXTB                     ;TIME OUT COUNT ON REMOTE LINES
NEXTB=NEXTB+1
UDMVC=NEXTB                     ;VECTOR ADDR OF DM11 (USED BY LOA.TSK)
NEXTB=NEXTB+1
DMCSR=NEXTB                     ;CSR OF DM11 FOR THIS UNIT
; U.DMCS=DMCSR                  ;DEFINED BY SGN.  USED BY LOA.TSK
NEXTB=NEXTB+2
        .ENDC

;
; TERMINAL STATUS WORD BIT DEFINITIONS
;

MODE=100000                     ;MODE OF BUSY TERMINAL (0=INPUT 1=OUTPUT)
LFCT=74000                      ;UNPROCESSED LINE FEED COUNT FIELD
LFBT=4000                       ;UNPROCESSED LINE FEED ADD/SUB BIT
CRTY=2000                       ;CARRIAGE CONTROL AT END OF LINE (1=YES)
CRJT=1000                       ;CARRIAGE RETURN JUST TYPED (1=YES)
EOLS=400                        ;END OF LINE SEEN (1=YES)
UIFP=200                        ;UNSOLICITED INPUT FORK PENDING (1=YES)
SOLI=100                        ;SOLICITED INPUT (1=YES)
CTLO=40                         ;OUTPUT DISABLED (1=YES)
RUBP=20                         ;RUBOUT SEQUENCE IN PROGRESS (1=YES)
FLCT=17                         ;UNPROCESSED FILL COUNT FIELD
FLBT=1                          ;UNPROCESSED FILL COUNT BIT

;
; ADDITIONAL TERMINAL STATUS WORD BIT DEFINITIONS
;

RPRM=100000             ;SET IF CURRENT WRITE IS THE PROMPT FROM IO.RPR
BTWP=20000              ;SET IF A WRITE IS BREAKING THROUGH A READ              ;**-1
CCPN=10000              ;SET IF A CONTROL C IS PENDING UNDER SPECIAL
                        ; CIRCUMSTANCES (T$$SYN, T$$HLD)
BAKS=4000               ;SET IF SENDING EXIT HOLD-SCREEN MODE ESCAPE
                        ; SEQUENCE (T$$HLD)
FKCR=2000               ;SET IF LAST CR WAS JUST TO DISPLAY A LONG
                        ; LINE ON MULTIPLE CRT LINES (T$$ACR)
ECHO=1000               ;SET IF ECHOING IN PROGRESS (T$$30P)
XOFF=400                ;SET IF XOFF TO BE SENT AT END OF PRESENT READ
                        ; (T$$RPR)
UPND=200                ;SET IF DHBUF HOLDS BYTE SUPPRESSED BY XOFF
                        ; (T$$HLD, T$$SYN)                                      ; EB119
CHAR=100                ;SET IF MBUFR HOLDS AN INPUT CHARACTER THAT             ;**-1
                        ; HAS BEEN RECEIVED BUT NOT ECHOED (T$$30P)
WESC=40                 ;SET IF ATTACHED TASK WANTS ESCAPE SEQUENCES
                        ; (T$$ESC)
ESCS=20                 ;SET IF IN MIDDLE OF AN ESCAPE SEQUENCE (T$$ESC)
CCON=10                 ;SET IF CONTROL C AST CODE IS ACTIVE (T$$CCA)
MCTR=4                  ;SET IF DOING CONTROL R FROM TASK'S BUFFER
                        ; (T$$CTR, T$$UTB)
NCKP=2                  ;SET IF SOLICITED INPUT REQUEST IS FROM
                        ; A NONCHECKPOINTABLE TASK (T$$UTB)
UOFF=1                  ;SET IF OUTPUT TURNED OFF BY AN XOFF
                        ; (T$$HLD, T$$SYN)                                      ; EB119
                                                                                ;**-1
;
; MOST LOCAL DATA (SEE ALSO CNTBL)
;
; ESCAPE SEQUENCE SYNTAX TABLE
;

        .IF DF  T$$ESC

SYNTAB: .BYTE   73,73           ;;;A ;
        .WORD   265$            ;;;
        .BYTE   77,77           ;;;A ?
        .WORD   265$            ;;;
        .BYTE   117,117         ;;;AN O
        .WORD   270$            ;;;
                                                                                ; EB205
        .IF DF  ESCPIC                                                          ; EB205
                                                                                ; EB205
        .BYTE   120,120         ;;;A P
        .WORD   265$            ;;;
                                                                                ; EB205
        .ENDC                                                                   ; EB205
                                                                                ; EB205
        .BYTE   131,131         ;;;A Y
        .WORD   280$            ;;;
265$:   .BYTE   40,57           ;;;AN INTERMEDIATE CHARACTER
        .WORD   265$            ;;;
        .BYTE   60,176          ;;;ANYTHING ELSE
        .WORD   0               ;;;
270$:   .BYTE   40,57           ;;;AN INTERMEDIATE CHARACTER
        .WORD   270$            ;;;
        .BYTE   100,176         ;;;SPECIAL O RANGE TERMINATOR
        .WORD   0               ;;;
280$:   .BYTE   40,176          ;;;FIRST COORDINATE (BIAS 40)
        .WORD   290$            ;;;
290$:   .BYTE   40,176          ;;;SECOND COORDINATE (BIAS 40)
        .WORD   0               ;;;

        .ENDC

        .IF DF  T$$GTS

;
; FORM THE WORDS RETURNED BY IO.GTS THAT INDICATE WHICH SYSGEN
; OPTIONS ARE IN THIS DRIVER
;

T2=0

        .IF DF  T$$ACR
T2=T2!F1.ACR
        .ENDC
        .IF DF  T$$BTW
T2=T2!F1.BTW
        .ENDC
        .IF DF  T$$BUF&C$$CKP
T2=T2!F1.BUF
        .ENDC
        .IF DF  T$$CCA&A$$TRP
T2=T2!F1.UIA
        .ENDC
        .IF DF  T$$CCO
T2=T2!F1.CCO
        .ENDC
        .IF DF  T$$ESC
T2=T2!F1.ESQ
        .ENDC
        .IF DF  T$$HLD
T2=T2!F1.HLD
        .ENDC
        .IF DF  T$$LWC
T2=T2!F1.LWC
        .ENDC
        .IF DF  T$$RNE
T2=T2!F1.RNE
        .ENDC
        .IF DF  T$$RPR
T2=T2!F1.RPR
        .ENDC
        .IF DF  T$$RST
T2=T2!F1.RST
        .ENDC
        .IF DF  T$$RUB
T2=T2!F1.RUB
        .ENDC
        .IF DF  T$$SYN
T2=T2!F1.SYN
        .ENDC
        .IF DF  T$$TRW
T2=T2!F1.TRW
        .ENDC
        .IF DF  T$$UTB
T2=T2!F1.UTB
        .ENDC
        .IF DF  T$$VBF
T2=T2!F1.VBF
        .ENDC

;
; ALL WORDS OF "T2" MUST BE CONTIGUOUS
;

TCHR1:  .WORD   T2

T2=0                    ;RSX-11M DOES NOT SUPPORT F2.DCH (DUMP/RESTORE
                        ; CHARACTERISTICS), RSX-11D STYLE IO.KIL
                        ; (F2.DKL), ALTS ECHOING AS "$" (F2.ALT),
                        ; OR SIMULATED FORM FEEDS (F2.SFF)

        .IF DF  T$$SMC
T2=T2!F2.SCH
        .ENDC
        .IF DF  T$$GMC
T2=T2!F2.GCH
        .ENDC

        .WORD   T2

TCHR1E=.

        .ENDC           ; DF T$$GTS

        .IF DF  T$$GMC!T$$SMC

;
; DATA STRUCTURES FOR GET AND SET MULTIPLE CHARACTERISTICS
;                                                                               ; EB119
; FROM U2.VT5 TO U2.L3S CONTAINS MASKS FOR U.CW2 TO TEST FOR TERMINAL           ; EB119
;       TYPE.  THIS INFORMATION MUST PRECEDE ANY INFORMATION                    ; EB119
;       ASSOCIATED WITH THE MATERIAL FROM TC.SCP TO TC.XSP.                     ; EB119
; FROM 0*400+360 TO 1*400+360 CONTAINS CONSTANTS USED FOR SETTING               ; EB119
;       RECEIVER AND TRANSMITTER BAUD RATES (SPEEDS)                            ; EB119
; FROM U2.CRT TO U2.PRV CONTAINS MASKS FOR U.CW2 TO TEST FOR TERMINAL           ; EB119
;       CHARACTERISTICS                                                         ; EB119
; FROM TC.SCP TO TC.XSP CONTAINS WHAT CHARACTERISTICS ARE RECOGNIZED            ; EB119
;       BY SF.SMC AND SF.GMC (NOTE THAT TC.RSP AND TC.XSP ARE NOT               ; EB119
;       RECOGNIZED BY SF.GMC)                                                   ; EB119
; FROM T.VT05 TO T.L30S CONTAINS WHAT TERMINAL TYPES ARE RECOGNIZED             ; EB119
;       BY SF.SMC AND SF.GMC                                                    ; EB119
;                                                                               ;**-8

        .WORD   0               ;
                                                                                ;**-4
        .WORD   U2.L3S          ;LA30
        .WORD   U2.VT5          ;VT05
        .WORD   0               ;
                                                                                ; EB119
        .IF DF  T$$SMC                                                          ; EB119
        .WORD   1*400+360       ;TRANSMITTER SPEED                              ; EB119
        .WORD   0*400+360       ;RECEIVER SPEED                                 ; EB119
        .ENDC                                                                   ; EB119
                                                                                ; EB119
        .WORD   U2.PRV          ;PRIVILEGED                                     ; EB119
                                                                                ; EB119
        .IF DF  T$$HFF                                                          ; EB119
        .WORD   U2.HFF          ;HANDLES HARDWARE FORM FEED                     ; EB119
        .ENDC                                                                   ; EB119
                                                                                ; EB119
        .WORD   U2.SLV          ;SLAVE                                          ;**-1
        .WORD   U2.HLD          ;HOLD-SCREEN MODE

        .IF DF  T$$RNE
        .WORD   U2.NEC          ;NO ECHO MODE
        .ENDC

        .WORD   U2.LWC          ;LOWER TO UPPER CASE CONVERSION
        .WORD   U2.ESC          ;CAN GENERATE ESCAPE SEQUENCES
        .WORD   U2.CRT          ;CRT (SCOPE)
GMCTAB:                         ;
        .BYTE   TC.SCP          ;SCOPE (CRT)
        .BYTE   TC.ESQ          ;ESCAPE SEQUENCES
        .BYTE   TC.SMR          ;LOWER TO UPPER CASE CONVERSION

        .IF DF  T$$RNE
        .BYTE   TC.NEC          ;NO ECHO MODE
        .ENDC

        .BYTE   TC.HLD          ;HOLD-SCREEN MODE
        .BYTE   TC.SLV          ;SLAVED
                                                                                ; EB119
        .IF DF  T$$HFF                                                          ; EB119
        .BYTE   TC.HFF                                                          ; EB119
        .ENDC                                                                   ; EB119
                                                                                ; EB119
        .BYTE   TC.PRI          ;PRIVILEGED
                                                                                ; EB119
        .IF DF  T$$SMC                                                          ; EB119
ENDCW2: .BYTE   TC.RSP          ;RECEIVER SPEED (END OF U.CW2                   ; EB119
                                ; CHARACTERISTICS)                              ; EB119
        .BYTE   TC.XSP          ;TRANSMITTER SPEED                              ; EB119
        .ENDC                                                                   ; EB119
                                                                                ; EB119
        .BYTE   T.VT05          ;VT05
        .BYTE   T.L30S          ;LA30
                                                                                ;**-4
        .BYTE   0               ;

        .ENDC                   ; DF T$$GMC!T$$SMC
                                                                                ; EB119
;                                                                               ; EB119
; LEGAL MULTIPLEXER SPEEDS TABLE FOR SF.SMC                                     ; EB119
;                                                                               ; EB119
; EACH ENTRY IS TWO CONSECUTIVE BYTES CONSISTING OF:                            ; EB119
;                                                                               ; EB119
;               HIGH BYTE               LOW BYTE                                ; EB119
;                                                                               ; EB119
;       ------------------------------------------------                        ; EB119
;       !       BAUD RATE      ! DH11 BITS ! DZ11 BITS !                        ; EB119
;       ------------------------------------------------                        ; EB119
;                                                                               ; EB119
; WHERE BAUD RATE = A TTSYM$ SYMBOL INDICATING WHICH BAUD RATE THIS             ; EB119
;       (8 BITS)    ENTRY IS FOR                                                ; EB119
;                                                                               ; EB119
;       DH11 BITS = IF ZERO, THE BAUD RATE IS NOT SUPPORTED FOR THE DH11        ; EB119
;       (4 BITS)    IF NONZERO, THE BIT PATTERN THAT MUST BE ASSERTED           ; EB119
;                       IN THE DH11 LINE PARAMETER REGISTER TO GET THE          ; EB119
;                       BAUD RATE FOR RECEPTION OR TRANSMISSION                 ; EB119
;                                                                               ; EB119
;       DZ11 BITS = IF ZERO, THE BAUD RATE IS NOT SUPPORTED FOR THE DZ11        ; EB119
;       (4 BITS)    IF NONZERO, THE BIT PATTERN THAT MUST BE ASSERTED           ; EB119
;                       IN THE DZ11 LINE PARAMETER REGISTER TO GET THE          ; EB119
;                       BAUD RATE FOR RECEPTION AND TRANSMISSION                ; EB119
;                                                                               ; EB119
; A BYTE OF ZEROS (DZ11 AND DH11 BITS ARE ZERO) TERMINATES THE TABLE.           ; EB119
; DH11 BITS = 1 IS A SPECIAL CASE.                                              ; EB119
;                                                                               ; EB119
; THE SUPPORTED SPEEDS ARE THOSE SUPPORTED BY THE MCR COMMAND SET /SPEED.       ; EB119
;                                                                               ; EB119
                                                                                ; EB119
        .IF DF  T$$SMC                                                          ; EB119
                                                                                ; EB119
SPDTB:  SPDTAB  S.0,1,0         ;SPECIAL CASE FOR DH11                          ; EB119
        SPDTAB  S.110,3,2                                                       ; EB119
S150:   SPDTAB  S.150,5,4                                                       ; EB119
        SPDTAB  S.200,6,0                                                       ; EB119
        SPDTAB  S.300,7,5                                                       ; EB119
        SPDTAB  S.600,10,6                                                      ; EB119
        SPDTAB  S.1200,11,7                                                     ; EB119
        SPDTAB  S.1800,12,10                                                    ; EB119
        SPDTAB  S.2000,0,11                                                     ; EB119
        SPDTAB  S.2400,13,12                                                    ; EB119
        SPDTAB  S.3600,0,13                                                     ; EB119
        SPDTAB  S.4800,14,14                                                    ; EB119
        SPDTAB  S.7200,0,15                                                     ; EB119
        SPDTAB  S.9600,15,16                                                    ; EB119
        SPDTAB  S.EXTA,16,0                                                     ; EB119
        SPDTAB  S.EXTB,17,0                                                     ; EB119
        .BYTE   0                                                               ; EB119
                                                                                ; EB119
        .ENDC                                                                   ; EB119

;
; CONTROL OUTPUT MESSAGES
;

                                                                                ; CS033
        .IF NDF M$$CLI                                                          ; CS033
                                                                                ; CS033
CTRLC:  .ASCIZ  <15><12>/MCR>/  ;
                                                                                ; CS033
        .ENDC   ;M$$CLI                                                         ; CS033
                                                                                ; CS033
CTRLZ:  .ASCIZ  /^Z/<15><12>                                                    ; CS033
CTRLU:  .ASCIZ  /^U/<15><12>    ;MUST BE AFTER A ZERO BYTE
                                                                                ;**-1
        .IF DF  T$$HLD

LEVHSM: .ASCIZ  <33>/\/         ;LEAVE HOLD-SCREEN MODE

        .ENDC

        .IF DF  T$$RUB

        .ASCIZ  <10><10><10><10><10><10><10><10> ;BACKSPACES
CRTBS=.-1                       ;MUST BE AT END OF BACKSPACES
CRTRUB: .ASCIZ  <10>/ /<10>     ;BACKSPACE, SPACE, BACKSPACE

        .ENDC

;
; LA30S CARRIAGE RETURN FILL TABLE
;

FILTB:  .BYTE   4.              ;0-8.
        .BYTE   8.              ;9.-16.
        .BYTE   6.              ;17.-24.
        .BYTE   3.              ;25.-32.
        .BYTE   0.              ;33.-40.
        .BYTE   2.              ;41.-48.
        .BYTE   4.              ;49.-56.
        .BYTE   6.              ;57.-64.
        .BYTE   8.              ;65.-72.
        .BYTE   10.             ;73.-80.

        .EVEN

        .SBTTL  TERMINAL INITIATOR

        .IF DF  T$$RPR!T$$BTW

TTCHK:  MOV     R1,R3           ;SAVE START OF PACKET FOR $IOFIN

        .IF NDF T$$RPR

        BR      30$             ;SKIP AROUND CODE

        .ENDC

        .ENDC                   ; DF T$$RPR!T$$BTW

        .IF DF  T$$RPR

;+
; **-TTCHK-TERMINAL DRIVER SPECIAL PARAMETER CHECKING
;
; ENTRY HERE FROM DRQIO WHEN A QIO FOR THE TERMINAL DRIVER HAS BEEN
; CHECKED.  A READ-WITH-PROMPT QIO HAS A SECOND BUFFER
; SPECIFICATION THAT NEEDS TO BE CHECKED IN THE CONTEXT OF THE
; ISSUING TASK.  IF NECESSARY, DO THE CHECKS.  ALWAYS QUEUE THE REQUEST.
;
; INPUTS:
;
;       R1 -> I/O REQUEST PACKET
;       R4 -> SCB
;       R5 -> UCB
;
; OUTPUTS:
;
;       THE PROMPT (WRITE) BUFFER IS ADDRESS CHECKED TO MAKE SURE IT
;       LIES WITHIN THE ISSUING TASK.  IF IT DOES, THE BUFFER ADDRESS
;       IS RELOCATED AND STORED IN THE I/O PACKET, THE PACKET IS
;       INSERTED IN THE CONTROLLER QUEUE, AND THE DEVICE INITIATOR
;       IS ENTERED TO START THE CONTROLLER.
;-

        CMPB    #IO.RPR/400,I.FCN+1(R1) ;QIO NEED SPECIAL CHECKING?

        .IF DF  T$$BTW

        BNE     30$             ;IF NE NO

        .IFF

        BNE     20$             ;IF NE NO -- JUST QUEUE IT

        .ENDC

        MOV     I.PRM+10(R3),R0 ;GET VIRTUAL ADDRESS OF BUFFER

        .IF DF  A$$CHK!M$$MGE

        MOV     I.PRM+12(R3),R1 ;GET LENGTH OF BUFFER
        BEQ     8$              ;MUST PROMPT WITH AT LEAST 1 CHAR

        .IF DF  T$$VBF

        CMP     #255.,R1        ;PROMPT BIGGER THAN LARGEST BUFFER?

        .IFF

        CMP     #80.,R1         ;PROMPT BIGGER THAN LARGEST BUFFER?

        .IFTF

        BHIS    7$              ;IF HIS NO
        MOV     #IE.BAD&377,R0  ;RETURN BAD PARAMETER STATUS
        BR      9$              ;

        .ENDC

7$:     CALL    $ACHKB          ;ADDRESS CHECK BUFFER
        BCC     10$             ;IF CC OKAY
8$:     MOV     #IE.SPC&377,R0  ;RETURN ILLEGAL BUFFER STATUS
9$:     CLR     R1              ;SET IOSB+2 TO ZERO
        CALLR   $IOFIN          ;FINISH I/O OPERATION
10$:                            ;REF LABEL

        .ENDC

        CALL    $RELOC          ;RELOCATE BUFFER ADDRESS
        MOV     R1,I.PRM+10(R3) ;SET RELOCATION BIAS OF BUFFER
        MOV     R3,R1           ;COPY I/O PACKET ADDRESS
        ADD     #I.PRM+14,R3    ;POINT INTO I/O PACKET
        MOV     (R3)+,(R3)      ;SAVE VERTICAL FORMAT CONTROL
        CMP     -(R3),-(R3)     ;POINT AT PROMPT BUFFER SIZE
        MOV     (R3)+,(R3)      ;MOVE BUFFER SIZE TO SAFETY
        MOV     R2,-(R3)        ;SET ADDRESS OF BUFFER

        .ENDC                   ; DF T$$RPR

        .IF DF  T$$RPR!T$$BTW

20$:    MOV     R4,R0           ;SET ADDRESS OF I/O QUEUE LISTHEAD
        CALL    $QINSP          ;INSERT I/O PACKET IN REQUEST QUEUE
23$:    JMP     TTINI           ;GO TO WORK

        .ENDC

        .IF DF  T$$BTW

30$:    CMPB    #IO.WLB/400,I.FCN+1(R1) ;A WRITE?
        BNE     20$             ;IF NE NO -- JUST QUEUE IT
        BITB    #TF.WBT,I.FCN(R1) ;A BREAKTHROUGH WRITE?
        BEQ     20$             ;IF EQ NO -- JUST QUEUE IT

        .IF DF  M$$MUP

        MOV     I.TCB(R1),R2    ;GET TCB OF REQUESTING TASK
        BIT     #T3.PRV,T.ST3(R2) ;IS IT PRIVILEGED
        BEQ     35$             ;IF EQ NO

        .ENDC

        .IF DF  D$$M11&D$$H11!D$$ZMD

        MOV     #IE.DNR&377,R0  ;ASSUME WRITING TO DISABLED LINE
        BITB    #US.DSB,U.STS(R5) ;IS LINE DISABLED?
        BNE     9$              ;IF NE YES -- REJECT PACKET

        .ENDC

        BISB    #TF.CCO,I.FCN(R1) ;IO.WBT IMPLIES CANCEL CONTROL O

        .IF DF  T$$HLD!T$$SYN                                                   ; EB119
                                                                                ;**-1
        BIC     #UOFF,U.CNT+2+ATERS(R5) ;IGNORE ANY XOFF'S

        .ENDC

        MTPS    S.PRI(R4)       ;DISALLOW INTERRUPTS
        BISB    #US.ECH,U.STS(R5) ;;;DISALLOW INPUT (BUSYING OF UNIT)
        TSTB    U.STS(R5)       ;DRIVER DOING ANYTHING?
        BMI     40$             ;IF MI YES (RATS!)
32$:                            ;REF LABEL
        MOV     (R4),(R1)       ;QUEUE THIS AS FIRST IN QUEUE                   ;**-1
        BNE     3400$           ;IF NE ANOTHER PACKET IN QUEUE
        MOV     R1,2(R4)        ;MAKE "LAST" POINT AT THIS PACKET
3400$:  MOV     R1,(R4)         ;
        MTPS    #0              ;;;REDUCE PRIORITY
        BR      23$             ;HANDLE IT NORMALLY

        .IF DF  M$$MUP

35$:    MOV     #IE.PRI&377,R0  ;IO.WBT ILLEGAL FROM UNPRIVILEGED TASK
        BR      9$              ; IN A MULTIUSER PROTECTION SYSTEM

        .ENDC

40$:    TSTB    @U.CNT+2+MEBUF(R5) ;;;DOING A MULTIECHO (GENERALLY              ; EB198
                                   ;;; A CONTROL/R)?                            ; EB198
        BNE     42$                ;;;IF NE YES                                 ; EB198
        BITB    #US.OUT,U.STS(R5) ;;;OUTPUT INTERRUPT EXPECTED?                 ; EB198
        BNE     42$               ;;;IF NE YES -- MIGHT OVERWRITE               ; EB198
                                  ;;; CHARACTER IN TRANSMITTER BUFFER           ; EB198
        BIT     #SOLI!MODE,U.CNT+2+STATS(R5) ;;;SOLICITED INPUT OR              ; EB198
                                             ;;; OUTPUT IN PROGRESS?            ; EB198
        BNE     41$             ;IF NE YES                                      ;**-2
        MOV     U.CNT+2+STRBF(R5),R0 ;POINT AT UNSOLICITED INPUT BUFFER
        BR      46$             ;PRESS ON
41$:    MOV     S.PKT(R4),R0    ;GET START OF PACKET THAT IS BEING
                                ; PROCESSED
        BIT     #RPRM!BTWP,U.CNT+2+ATERS(R5) ;;;BREAKING THROUGH OR
                                ;;; PROMPTING?
        BEQ     43$             ;;;IF EQ NO
42$:    MOV     #IE.RSU&377,R0  ;;;UNSHARABLE RESOURCE IN USE (CANNOT           ; EB198
                                ;;; IO.WBT WHILE DOING AN IO.WBT,               ; EB198
                                ;;; PROMPT, OR MULTIECHO)                       ; EB198
        CALL    INPT0           ;;;CLEAR US.ECH                                 ;**-2
        MTPS    #0              ;;;REDUCE PRIORITY

        .IF DF  A$$CHK!M$$MGE&T$$RPR

        BR      9$              ;

        .IFF

9$:     CLR     R1              ;WANT IOSB+2 TO BE ZERO
        CALLR   $IOFIN          ;FINISH OFF I/O PACKET

        .ENDC

43$:    CMPB    #IO.RLB/400,I.FCN+1(R0) ;;;DOING A READ?
        BEQ     46$             ;;;IF EQ YES -- BREAKTHROUGH

        .IIF NE UPND-200,       .ERROR  UPND

        TSTB    U.CNT+2+ATERS(R5) ;;;HAVE A HELD UP CHARACTER?
        BPL     32$             ;;;IF PL NO
        BIC     #UPND,U.CNT+2+ATERS(R5) ;;;CLEAR PENDING FLAG
        MOV     #45$,-(SP)      ;;;WANT TO RETURN TO 45$
        MOVB    U.CNT+2+DHBUF(R5),-(SP) ;;;RETRIEVE HELD UP CHARACTER
        CALLR   FCHAR           ;;;FORCE IT OUT
45$:    MOV     U.SCB(R5),R4    ;;;RESTORE THE MESSED UP REGISTER
        BR      32$             ;;;DO THIS IO.WBT AS NEXT FUNCTION
46$:    MOV     R5,R3           ;POINT AT TERMINAL STATUS
        ADD     #U.CNT+2+STATS,R3 ;
        BIT     #EOLS,(R3)      ;;;HAS THE READ "FINISHED"?
        BNE     32$             ;;;IF NE YES -- JUST QUEUE BREAKTHROUGH
        BIT     #SOLI,(R3)      ;SOLICITED INPUT GOING ON?
        BNE     48$             ;IF NE YES
        MOV     (R3),-(R0)      ;SAVE TERMINAL STATUS FOR UNSOL READ
        BIC     #LFCT!CRTY!CRJT!CTLO!FLCT,(R0) ;;;MAKE SAVED STATUS
                                ;;; SHOW INACTIVE ON OUTPUT
        CLR     I.PRM+16(R1)    ;SIGNAL UNSOLICITED READ BREAKTHROUGH
        SUB     #U.CNT+2+STATS-U.BUF,R3 ;POINT AT U.BUF
        BR      50$             ;
48$:    MOVB    S.STS(R4),(R0)  ;SAVE STATUS OF DISPLACED READ
        MOV     R0,I.PRM+16(R1) ;SAVE POINTER TO DISPLACED PACKET
        ADD     #I.PRM+14,R0    ;POINT NEAR END OF DISPLACED PACKET
        MOV     (R3),(R0)       ;SAVE STATS
        BIC     #LFCT!CRTY!CRJT!CTLO!FLCT,(R0) ;;;MAKE SAVED STATS
                                ;;; SHOW INACTIVE ON OUTPUT

; NEXT INSTUCTION DEPENDS ON STATS=U.CNT+2

        MOV     -(R3),-(R0)     ;SAVE U.CNT
        MOV     -(R3),-(R0)     ;SAVE U.BUF+2
        MOV     -(R3),-(R0)     ;SAVE U.BUF
50$:    MOV     I.PRM(R1),(R3)+ ;RESET U.BUF FOR IO.WBT
        MOV     I.PRM+2(R1),(R3)+ ;RESET U.BUF+2
        MOV     I.PRM+4(R1),(R3)+ ;RESET U.CNT
        MOV     R1,S.PKT(R4)    ;MAKE IO.WBT THE CURRENT I/O PACKET
        BIC     #CTLO!LFCT!CRTY!EOLS!RUBP!SOLI,(R3) ;;;RESET
        BIS     #MODE,(R3)      ;;; STATUS WORD FOR IO.WBT                      ; EB204
        BIS     #BTWP,ATERS(R3) ;FLAG IO.WBT ACTION                             ;**-3
        JMP     FWRITE          ;DO THE WRITE

        .ENDC

        .ENABL  LSB
                                                                                ; EB119
        .IF DF  T$$SMC                                                          ; EB119
                                                                                ; EB119
;                                                                               ; EB119
; R0 = IS.SUC&377 (PRESERVE IF AN ERROR IS NOT DETECTED)                        ; EB119
; R1 = POINTER TO WORD PRECEDING GMCTAB THAT CORRESPONDS TO BUFFER'S            ; EB119
;      CHARACTERISTIC SYMBOL (SCRATCH)                                          ; EB119
; -(R2) = BUFFER'S CHARACTERISTIC SYMBOL (SCRATCH)                              ; EB119
; R3 = (SCRATCH)                                                                ; EB119
; R4 = ADDRESS OF I/O PACKET (PRESERVE)                                         ; EB119
; R5 = UCB ADDRESS (PRESERVE)                                                   ; EB119
; NOTHING ON THE STACK                                                          ; EB119
;                                                                               ; EB119
                                                                                ; EB119
1820$:  MOV     U.CW2(R5),-(SP) ;GET CHARACTERISTICS WORD                       ; EB119
                                                                                ; EB119
; NEXT INSTRUCTION DEPENDS ON U2.DH1=100000                                     ; EB119
                                                                                ; EB119
        BPL     1852$           ;IF PL TERMINAL IS NOT ON A MULTIPLEXER         ; EB119
        ASL     (SP)            ;IS MULTIPLEXER A DJ11?                         ; EB119
                                                                                ; EB119
; NEXT INSTRUCTION DEPENDS ON U2.DJ1=U2.DH1/2                                   ; EB119
                                                                                ; EB119
        BMI     1852$           ;IF MI YES -- BAUD RATE NOT PROGRAMMABLE        ; EB119
        MOVB    (R1)+,R2        ;GET DZ11 BAUD RATE MASK                        ; EB119
        TSTB    (SP)+           ;IS MULTIPLEXER A DZ11?                         ; EB119
                                                                                ; EB119
; NEXT INSTRUCTION DEPENDS ON U2.DZ1=100                                        ; EB119
                                                                                ; EB119
        BMI     1822$           ;IF MI YES                                      ; EB119
        COMB    R2              ;CONVERT TO DH11 MASK                           ; EB119
1822$:  CALL    $GTBYT          ;GET BUFFER'S BAUD RATE SYMBOL                  ; EB119
        MOV     #SPDTB,R0       ;POINT AT LEGAL SPEED TABLE                     ; EB119
1824$:  MOVB    (R0)+,R3        ;GET BAUD RATE BITS                             ; EB119
        BNE     1826$           ;IF NE HAVE NOT FOUND END OF TABLE              ; EB119
1825$:  JMP     18772$          ;                                               ; EB119
1826$:  CMPB    (R0)+,(SP)      ;ARE THE BAUD RATE BITS FOR THE                 ; EB119
                                ; BUFFER'S BAUD RATE SYMBOL?                    ; EB119
        BNE     1824$           ;IF NE NO                                       ; EB119
        BIC     R2,R3           ;THROW AWAY BITS FOR OTHER MULTIPLEXER          ; EB119
        BEQ     1825$           ;IF EQ THIS MULTIPLEXER DOES NOT                ; EB119
                                ; SUPPORT THIS BAUD RATE                        ; EB119
        MOV     #SETSPD,(SP)    ;GET ADDRESS OF U.CW3 SETTING ROUTINE           ; EB119
        TSTB    R2              ;IS MULTIPLEXER A DZ11?                         ; EB119
        BMI     1836$           ;IF MI YES                                      ; EB119
        CMP     #<1*20>,R3      ;WANT BAUD RATE OF ZERO?                        ; EB119
        BNE     1828$           ;IF NE NO                                       ; EB119
        CLR     R3              ;ADJUST BAUD RATE BITS                          ; EB119
1828$:  TSTB    (R1)            ;WORKING ON TC.RSP?                             ; EB119
        BEQ     1834$           ;IF EQ YES                                      ; EB119
        SWAB    R3              ;PUT BAUD RATE BITS IN THE CORRECT              ; EB119
        ROR     R3              ; POSITION (SWAB SETS C=0)                      ; EB119
        ROR     R3              ;                                               ; EB119
        MOV     #36004,R2       ;GET BAUD RATE BITS MASK WORD                   ; EB119
1830$:  CALL    @(SP)+          ;SET NEW BAUD RATE INTO U.CW3                   ; EB119
        BIC     #17,(R1)        ;CLEAR LINE NUMBER                              ; EB119
        BISB    U.UNIT(R5),(R1)+ ;;;SELECT DH11 LINE                            ; EB119
        INC     R1              ;;;                                             ; EB119
1832$:  MOV     U.CW3(R5),2(R1) ;;;SET NEW BAUD RATE INTO CSR                   ; EB119
        MTPS    #0              ;;;RETURN PRIORITY TO NORMAL                    ; EB119
        MOV     #IS.SUC&377,R0  ;RESTORE SUCCESS STATUS                         ; EB119
        BR      1872$           ;DECODE NEXT BUFFER BYTE                        ; EB119
1834$:  ASL     R3              ;PUT BAUD RATE BITS IN CORRECT POSITION         ; EB119
        ASL     R3              ;                                               ; EB119
        MOV     #1704,R2        ;GET BAUD RATE BITS MASK WORD                   ; EB119
        BR      1830$           ;                                               ; EB119
1836$:  SWAB    R3              ;PUT BAUD RATE BITS IN CORRECT POSITION         ; EB119
        MOV     #7440,R2        ;GET BAUD RATE BITS MASK WORD                   ; EB119
        CALL    @(SP)+          ;SET NEW BAUD RATE INTO U.CW3                   ; EB119
        BR      1832$           ;                                               ; EB119
                                                                                ; EB119
;                                                                               ; EB119
; INPUTS:                                                                       ; EB119
;                                                                               ; EB119
;       R0 = ADDRESS+1 OF MATCHED BAUD RATE SYMBOL                              ; EB119
;       R2 = BIT MASK TO CLEAR BAUD RATE AND STOP CODE BIT POSITIONS            ; EB119
;            IN U.CW3                                                           ; EB119
;       R3 = CORRECTLY ORIENTED BITS TO ASSERT NEW BAUD RATE                    ; EB119
;       R5 = ADDRESS OF UCB                                                     ; EB119
;                                                                               ; EB119
; OUTPUTS:                                                                      ; EB119
;                                                                               ; EB119
;       R1 = ADDRESS OF CONTROLLER CSR                                          ; EB119
;       PRIORITY = 7                                                            ; EB119
;       R2, R3 ARE DESTROYED                                                    ; EB119
;                                                                               ; EB119
                                                                                ; EB119
SETSPD: BIC     R2,U.CW3(R5)    ;CLEAR OUT SPOT FOR NEW BAUD RATE               ; EB119
                                ; AND ASSUME ONE STOP BIT                       ; EB119
        CMP     #S150,R0        ;SETTING 110 BAUD?                              ; EB119
        BNE     1839$           ;IF NE NO                                       ; EB119
        BIC     #177700,R2      ;FORM BIT MASK FOR STOP CODE                    ; EB119
        BIS     R2,R3           ;SET UP FOR TWO STOP BITS                       ; EB119
1839$:  BIS     R3,U.CW3(R5)    ;SET NEW BAUD RATE                              ; EB119
        MOV     U.SCB(R5),R1    ;POINT AT CSR                                   ; EB119
        MOV     S.CSR(R1),R1    ;                                               ; EB119
        MTPS    #7              ;RAISE PRIORITY                                 ; EB119
        RETURN                  ;;;RETURN AND EVEN OFF STACK                    ; EB119
                                                                                ; EB119
        .ENDC                                                                   ; EB119

        .IF DF  T$$GMC!T$$SMC

1840$:  TST     (SP)+           ;DESTROY SAVED R3
        SUB     #2,U.CNT(R5)    ;FINISHED DECIPHERING BUFFER?
        BLT     1846$           ;IF LT YES
        MOV     #GMCTAB,R2      ;POINT AT RECOGNITION TABLE
        MOV     R2,R1           ;COPY THE POINTER
        CALL    $GTBYT          ;GET BYTE TO DECIPHER
1842$:  TST     -(R1)           ;TABLE OF CHARACTERISTICS EXHAUSTED?
        BEQ     1850$           ;IF EQ YES
        CMPB    (R2)+,(SP)      ;RECOGNIZE CHARACTERISTIC?
        BNE     1842$           ;IF NE NO
        SEC                     ;SET C-BIT TO SHOW TC. MATCH
1844$:  RTS     R3              ;RETURN AND CLEAR STACK                         ; EB119
1846$:  JMP     5$              ;RETURN WITH IOSB+2 = 0                         ;**-1
1850$:  CMPB    #TC.TTP,(SP)    ;WORRYING ABOUT TERMINAL TYPE?
        BEQ     1844$           ;IF EQ YES (C-BIT IS CLEAR)
1852$:  MOV     #SE.NIH*400!<IE.ABO&377>,R0 ;DID NOT RECOGNIZE BYTE
1854$:  MOV     S.PKT(R4),R3    ;POINT AT I/O PACKET
        MOV     U.BUF+2(R5),R1  ;PICK UP WHERE WE STOPPED IN BUFFER
                                ; (ASSUME BUFFER < 4096.-32. BYTES)
        SUB     I.PRM+2(R3),R1  ;STOPPING POINT - START OF BUFFER
        DEC     R1              ;ADJUST
        TST     (SP)+           ;CLEAN UP STACK

        .IF DF  T$$GTS

        BR      1868$           ;RETURN AN ERROR TO THE TASK

        .IFF

        JMP     IODON           ;RETURN AN ERROR TO THE TASK

        .ENDC

        .ENDC                   ; DF T$$GMC!T$$SMC

1860$:                          ;REF LABEL

        .IF DF  T$$GMC!T$$SMC&A$$CHK!T$$GTS

        MOV     U.CNT(R5),R3    ;COPY LENGTH OF BUFFER

        .ENDC

        .IF DF  T$$GMC!T$$GTS!T$$SMC&A$$CHK

        BIT     #1,U.BUF+2(R5)  ;BUFFER ON A BYTE BOUNDARY?

        .IF DF  T$$CCA&A$$TRP

        BNE     1908$           ;IF NE YES

        .IFF

        BEQ     1862$           ;IF EQ NO
1908$:  MOV     #IE.SPC&377,R0  ;ILLEGAL BUFFER

        .IF DF  T$$GMC!T$$SMC

        BR      1846$           ;

        .IFF

        JMP     5$              ;

        .ENDC

1862$:                          ;REF LABEL

        .ENDC                   ; DF T$$CCA&A$$TRP

        BIT     #1,R3           ;BUFFER CONTAINS WORDS?
        BNE     1908$           ;IF NE NO
        CMP     #4096.-32.,R3   ;BUFFER TOO LARGE
        BLT     1908$           ;IF LT YES -- MIGHT BLOW ERROR OFFSET
                                ; ON A MAPPED SYSTEM

        .ENDC                   ; DF T$$GMC!T$$GTS!T$$SMC&A$$CHK

        .IF DF  T$$GTS

        CMPB    #IO.GTS,I.FCN(R1) ;GET TERMINAL SUPPORT QIO?
        BNE     1870$           ;IF NE NO
        CMP     #TCHR1E-TCHR1,R3 ;WANTS MORE THAN WE DELIVER?
        BGE     1863$           ;IF GE NO
        MOV     #TCHR1E-TCHR1,R3 ;CHANGE TO OUR MAXIMUM
1863$:  MOV     #TCHR1,R2       ;POINT AT SUPPORT INFO WORDS
        CLR     R1              ;CLEAR COUNTER OF MOVED BYTES
1864$:  MOVB    (R2)+,-(SP)     ;PUT THE 1ST BYTE OF THE 1ST
        CALL    $PTBYT          ; SUPPORT WORD INTO THE TASK'S BUFFER
        INC     R1              ;COUNT A BYTE MOVED
        CMP     R1,R3           ;TASK WANTS MORE?
        BLT     1864$           ;IF LT YES
1868$:  JMP     IODON           ;RETURN STATUS
1870$:                          ;REF LABEL

        .ENDC

        .IF DF  T$$SMC

        CMPB    #SF.SMC,I.FCN(R1) ;SET MULTIPLE CHARACTERISTICS?
        BNE     1880$           ;IF NE NO

        .IF DF  M$$MUP

        MOV     I.TCB(R1),R3    ;POINT AT TCB OF REQUESTING TASK
        CMP     T.UCB(R3),R5    ;IS TASK'S TI: THIS TERMINAL?
        BEQ     1872$           ;IF EQ YES -- ALMOST ANYTHING IS LEGAL
        BIT     #T3.PRV,T.ST3(R3) ;IS THE TASK PRIVILEGED
        BNE     1872$           ;IF NE YES -- ALMOST ANYTHING IS LEGAL
        MOV     #IE.PRI&377,R0  ;PRIVILEGE VIOLATION
        BR      1846$           ;

        .ENDC

1872$:  JSR     R3,1840$        ;DECIPHER MEANING OF THEIR
                                ; CHARACTERISTICS BYTE
        BCC     1876$           ;IF CC WORRY ABOUT TERMINAL TYPE
        CMP     #ENDCW2,R2      ;U.CW2 CHARACTERISTIC OR SPEED?                 ; EB119
        BHIS    18722$          ;IF HIS U.CW2 CHARACTERISTIC                    ; EB119
        JMP     1820$           ;                                               ; EB119
18722$: CALL    $GTBYT          ;GET DESIRED VALUE FOR CHARACTERISTIC           ; EB119
        CMP     #U2.PRV,(R1)    ;TASK TRYING TO CHANGE PRIVILEGE STATUS?        ;**-1
        BEQ     1852$           ;IF EQ YES -- DO NOT ALLOW THAT
        BITB    #376,(SP)       ;VALUE IS 1 OR 0?
        BEQ     1873$           ;IF EQ YES
        MOV     #SE.BIN*400!<IE.ABO&377>,R0 ;IT SHOULD HAVE BEEN
        BR      1854$           ;
1873$:  BIC     (R1),U.CW2(R5)  ;ASSUME THE VALUE IS ZERO
1874$:  TSTB    (SP)+           ;IS THE VALUE ZERO?
        BEQ     1872$           ;IF EQ YES
1875$:  BIS     (R1),U.CW2(R5)  ;SET THE APPROPRIATE BIT
        BR      1872$           ;TRY TO DECIPHER THEIR NEXT BYTE
1876$:  CALL    $GTBYT          ;GET DESIRED TERMINAL TYPE VALUE
1877$:  TST     -(R1)           ;EXHAUSTED LIST OF RECOGNIZIBLE VALUES?
        BNE     1878$           ;IF NE NO
        CMPB    #T.UNK0,(SP)    ;SET TERMINAL TO UNKNOWN TYPE?
        BEQ     1879$           ;IF EQ YES
18772$: MOV     #SE.VAL*400!<IE.ABO&377>,R0 ;SHOW INAPPROPRIATE VALUE           ; EB119
        BR      1854$           ;                                               ;**-1
1878$:  CMPB    (R2)+,(SP)      ;RECOGNIZE THE TERMINAL TYPE VALUE?
        BNE     1877$           ;IF NE NO
1879$:  BIC     #U2.VT5!U2.L3S,U.CW2(R5) ;IGNORE OLD TERMINAL TYPE
        BR      1874$           ;SET THEIR TYPE [(SP) IS GENERALLY NONZERO]     ; EB119
1880$:                          ;REF LABEL                                      ;**-1

        .ENDC

        .IF DF  T$$GMC

        CMPB    #SF.GMC,I.FCN(R1) ;GET MULTIPLE CHARACTERISTICS?
        BNE     1888$           ;IF NE NO
1882$:  JSR     R3,1840$        ;FIND OUT WHAT CHARACTERISTIC THEY
                                ; ARE INQUIRING ABOUT
        BCC     1884$           ;IF CC WANT TO KNOW THE TERMINAL TYPE
        CLR     -(SP)           ;ASSUME CHARACTERISTIC NOT ASSERTED
                                                                                ; EB119
        .IF DF  T$$SMC                                                          ; EB119
                                                                                ; EB119
        CMP     #ENDCW2,R2      ;GETTING U.CW2 CHARACTERISTIC?                  ; EB119
        BLO     1852$           ;IF LO NO -- CANNOT GET SPEEDS                  ; EB119
                                                                                ; EB119
        .ENDC                                                                   ; EB119
                                                                                ; EB119
        BIT     (R1),U.CW2(R5)  ;CHARACTERISTIC ASSERTED?
        BEQ     1883$           ;IF EQ NO
        INC     (SP)            ;REMEMBER ITS BEING ASSERTED
1883$:  CALL    $PTBYT          ;PUT VALUE INTO TASK'S BUFFER
        BR      1882$           ;TRY AGAIN
1884$:  MOVB    #T.UNK0,-(SP)   ;ASSUME UNKNOWN TERMINAL TYPE
1885$:  TSTB    (R2)+           ;TERMINAL TYPE TABLE EXHAUSTED?
        BEQ     1883$           ;IF EQ YES
        BIT     -(R1),U.CW2(R5) ;IS THIS TERMINAL THIS TYPE?
        BEQ     1885$           ;IF EQ NO
        MOVB    -(R2),(SP)      ;PICK UP THE TERMINAL TYPE
        BR      1883$           ;RETURN IT TO THE TASK
1888$:                          ;REF LABEL

        .ENDC

        .IF DF  T$$GMC!T$$GTS!T$$SMC

        MOV     #IE.IFC&377,R0  ;NO OTHER SUBFUNCTIONS ARE SUPPORTED
        BR      304$            ;
1889$:  BR      1860$           ;

        .ENDC

        .IF DF  T$$CCA&A$$TRP

;
; SET UP FOR UNSOLICITED CHARACTER AST
;

1900$:  MOV     I.PRM(R1),CCAST(R3) ;SAVE AST ENTRY POINT ADDRESS
        BEQ     1908$           ;IF EQ BAD ADDRESS
        BIT     #1,CCAST(R3)    ;IS ADDRESS ODD?
        BNE     1908$           ;IF NE YES
        BIS     #CCON,ATERS(R3) ;ARM UNSOLICITED CHAR AST CODE
        BR      1910$           ;
1908$:  MOV     #IE.SPC&377,R0  ;THERE'S NO POINT IF NO
1910$:  BR      304$            ; AST ADDRESS

        .ENDC

        .IF DF  T$$RPR

;
; START ANALYSIS OF READ AFTER PROMPT QIO FOR SUBFUNCTIONS
;

1920$:  MOV     #RPRM,-(SP)     ;COPY BIT PATTERN FOR ATERS
        BITB    #TF.XOF,I.FCN(R1) ;XOFF TERMINATION SUBFUNCTION?
        BEQ     1922$           ;IF EQ NO
        BIS     #XOFF,(SP)      ;REMEMBER NEED FOR XOFF
1922$:  BIS     (SP)+,ATERS(R3) ;SET STATUS FOR LATER REFERENCE
        CMP     I.PRM+14(R1),U.CNT(R5) ;PROMPT BUFFER LONGER THAN READ?
        BLE     1924$           ;IF LE NO
        MOV     I.PRM+14(R1),U.CNT(R5) ;WANT TO ALLOCATE EXECUTIVE
1924$:  BR      305$            ; BUFFER THAT IS BIG ENOUGH FOR EITHER

        .ENDC

;+
; **-TTINI-TERMINAL INTITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUEUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS
; EXECUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPER-
; ATION IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER (UNIT) TO BE INITIATED.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUEST IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;
; SEE THE I/O DRIVERS REFERENCE MANUAL FOR A DETAILED DESCRIPTION
; OF WHAT THIS DRIVER SUPPORTS.  IN BRIEF:
;
; A$$CHK = ADDRESS CHECKING (GOES WITH T$$RPR, T$$GMC, T$$SMC, T$$GTS)
; A$$TRP = AST SUPPORT IN SYSTEM (GOES WITH T$$CCA)
; C$$CKP = CHECKPOINT SUPPORT IN SYSTEM (GOES WITH T$$BUF)
; D$$H11 = DH11 MULTIPLEXERS
; D$$J11 = DJ11 MULTIPLEXERS
; D$$L11 = DL11/A/B/C/D
; D$$M11 = DM11-BB MODEM CONTROLLER FOR DH11
; D$$YNC = DYNAMIC CHECKPOINTING (GOES WITH C$$CKP AND T$$BUF)
; D$$YNM = DYNAMIC MEMORY MANAGEMENT IN SYSTEM (GOES WITH M$$MGE,
;          C$$CKP, AND T$$BUF)
; D$$ZMD = BELL 103A MODEM CONTROL FOR DZ11 LINES
; D$$Z11 = DZ11 MULTIPLEXER
; I$$RAR = REMOVE AFTER RUNNING (GOES WITH I$$RDN AND M$$MGE)
; I$$RDN = I/O RUNDOWN (GOES WITH I$$RAR AND M$$MGE)
; LD$$H, LD$$J, LD$$L, LD$$Z = VARIOUS FLAVORS OF LOADABLE USER DRIVERS
;          (NOT SUPPORTED)
; LD$TT = DEFINED IF TERMINAL DRIVER IS LOADABLE
; L$$DRV = DEFINED IF LOADABLE TERMINAL DRIVER SUPPORT IN SYSTEM
; L$$SI1 = LSI-11 SUPPORT.  EFFECTS MTPS MACRO.
;          (DH11, DJ11, DM11, AND DZ11 ARE NOT COMPATIBLE WITH Q-BUS)
; L$$50H = FIFTY HERTZ VT05 SUPPORT
; M$$MGE = MEMORY MANAGEMENT SUPPORT
; M$$MUP = AUTOMATIC "BYE" ON DM11 AND DZ11 HANGUPS AND PRIVILEGE CHECKS
; P$$LAS = MEMORY MANAGEMENT DIRECTIVES
; R$$LKL = RMS-11 LOCKING
; R$$11S = IGNORE UNSOLICITED INPUT ON RSX-11S SYSTEMS THAT HAVE
;          NO BASIC MCR
; T$$ACR = AUTOMATIC CR/LF FOR LINES THAT ARE BIGGER THAN TERMINAL
;          BUFFER SIZE (U.CW4)
; T$$BTW = BREAKTHROUGH WRITE
; T$$BUF = CHECKPOINTING DURING TERMINAL INPUT (GOES WITH C$$CKP)
; T$$CCA = UNSOLICITED CHARACTER AST'S (GOES WITH A$$TRP)
; T$$CCO = CLEAR CONTROL O INHIBIT BEFORE DOING WRITE
; T$$CTR = CONTROL R DISPLAYS THE INTERPRETED INCOMPLETE INPUT BUFFER
; T$$ESC = RECOGNITION OF ESCAPE SEQUENCES FOR SOLICITED READS
; T$$GMC = GET MULTIPLE TERMINAL CHARACTERISTICS
; T$$GTS = GET TERMINAL DRIVER SUPPORT MASKS
; T$$HFF = FORM FEEDS ARE PASSED THROUGH ON OUTPUT                              ; EB119
; T$$HLD = HOLD-SCREEN MODE SUPPORT (ALMOST T$$SYN SUPPORT) AND
;          CONTROL C KNOCKS TERMINAL OUT OF IT.  INTERACTS WITH MCR.
; T$$LWC = LOWER CASE TO UPPER CASE MAPPING ON INPUT AND RECOGNITION
;          OF 175 AND 176 AS ASCII CHARACTERS
; T$$MIN = DEFINED IN THE MINIMUM TERMINAL DRIVER AND THE MINIMUM
;          MULTIUSER DRIVER (ALONG WITH T$$BTW, T$$RNE, T$$RST)
; T$$RNE = READ WITH NO ECHO
; T$$RPR = READ AFTER PROMPT
; T$$RST = READ WITH SPECIAL TERMINATORS
; T$$RUB = RUBOUTS ERASE PRINTING CHARACTERS AND TABS ON CRT'S
; T$$SMC = SET MULTIPLE TERMINAL CHARACTERISTICS
; T$$SYN = CTRL S AND Q SUPPORT.  CTRL C CLEARS EFFECT OF CTRL S.
; T$$TRW = TRANSPARENT READS AND WRITES
; T$$UTB = WHEN POSSIBLE, RECEIVED CHARACTERS ARE PUT DIRECTLY INTO THE
;          TASK'S BUFFER
; T$$VBF = VARIABLE LENGTH BUFFERS (FROM 1 BYTE TO 255.) ARE USED BY THE
;          DRIVER
; T$$30P = ONE CHARACTER SOFTWARE BUFFERING OF RECEIVED CHARACTERS              ;**-2
;          (NEEDED ONLY BY LA30P'S BECAUSE THEIR INTERFACES ARE NOT
;          HARDWARE DOUBLE BUFFERED).
;-

        .IIF NE UIFP-200,       .ERROR  UIFP

1$:     TSTB    U.CNT+2+STATS(R5) ;UNSOLICITED INPUT FORK PENDING?
        BMI     2$              ;IF MI YES -- WAIT FOR FORK
        MOV     U.SCB(R5),R4    ;POINT TO SCB
        CALLR   TINP1           ;START UNSOLICITED READ

; NEXT INSTRUCTION DEPENDS ON US.BSY=200

TTINI:  TSTB    U.STS(R5)       ;UNIT BUSY?
2$:     BMI     900$            ;IF MI YES
        BISB    #US.ECH,U.STS(R5) ;IGNORE INPUT CHARACTERS
        TSTB    U.CNT+2+INPRQ(R5) ;UNSOLICITED INPUT REQUEST?                   ;**-8
        BNE     1$              ;IF NE YES
        CALL    $GTPKT          ;GET AN I/O PACKET                              ; EB209
                                                                                ;**-1
        .IF DF  T$$MIN

        BCS     28$             ;IF CS CONTROLLER BUSY OR NO REQUEST
                                ;SO CLEAR ECHO-IN-PROGRESS AND EXIT

        .IFF

        BCS     9$              ;IF CS CONTROLLER BUSY OR NO REQUEST
                                ; SO CLEAR ECHO-IN-PROGRESS AND EXIT

        .ENDC

;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE CONTROLLER (UNIT) TO BE INITIATED.
;
; TERMINAL I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTOR TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTOR TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTOR TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RLB OR IO.WLB).
;       WD. 06 -- VIRUTAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF I/O BUFFER.
;       WD. 13 -- BUFFER ADDRESS OF I/O TRANSFER.
;       WD. 14 -- NUMBER OF BYTES TO BE TRANSFERED.
;       WD. 15 -- CARRIAGE CONTROL BYTE.
;       WD. 16 -- RELOCATION BIAS OF PROMPT.                                    ; EB105
;       WD. 17 -- BUFFER ADDRESS OF PROMPT.                                     ; EB105
;       WD. 20 -- NUMBER OF BYTES IN PROMPT.                                    ; EB105
;       WD. 21 -- CARRIAGE CONTROL BYTE FOR PROMPT.                             ; EB105
;                                                                               ;**-3


        MOV     R5,R3             ;CALCULATE ADDRESS OF                         ; EB209
        ADD     #U.CNT+2+STATS,R3 ;STATUS WORD                                  ; EB209
                                                                                ; EB209
        .IF DF  D$$M11&D$$H11!D$$ZMD

        MOV     #IE.DNR&377,R0  ;ASSUME TERMINAL DISABLED
        BITB    #US.DSB,U.STS(R5) ;UNIT DISABLED?
                                                                                ; EB209
        .IF DF  T$$CCA&A$$TRP!T$$ESC                                            ; EB209
                                                                                ; EB209
        BEQ     3$              ;IF EQ NO                                       ; EB209
        CMPB    #IO.DET/400,I.FCN+1(R1) ;DETACH FUNCTION?                       ; EB209
        BNE     5$                      ;IF NE NO                               ; EB209
        MOV     #IS.SUC&377,R0  ;THE DETACH WILL SUCCEED                        ; EB209
        BR      301$            ;                                               ; EB209
                                                                                ; EB209
        .IFF                                                                    ; EB209
                                                                                ; EB209
        BNE     5$              ;IF NE YES
                                                                                ; EB209
        .ENDC                                                                   ; EB209

        .ENDC

3$:     CMPB    #IO.WLB/400,I.FCN+1(R1) ;WRITE LOGICAL BLOCK FUNCTION?          ; EB209
                                                                                ;**-3
        .IF DF  T$$MIN

        BEQ     30$             ;IF EQ YES

        .IFF

        BEQ     8$              ;IF EQ YES

        .ENDC

        BIC     #CTLO,(R3)      ;ENABLE OUTPUT
        MOV     #IS.SUC&377,R0  ;ASSUME A HAPPY ENDING

        .IF DF  T$$CCA&A$$TRP&T$$ESC

        CMPB    #IO.ATT/400,I.FCN+1(R1) ;ATTACH FUNCTION?
        BNE     300$            ;IF NE NO
        BITB    #TF.ESQ,I.FCN(R1) ;WANT ESCAPE SEQUENCE SUBFUNCTION?
        BEQ     3000$           ;IF EQ NO
        BIS     #WESC,ATERS(R3) ;SHOW WANT ESCAPE SEQUENCES
3000$:  BITB    #TF.AST,I.FCN(R1) ;WANT UNSOLICITED CHAR AST'S?
        BNE     1900$           ;IF NE YES

        .IFF

        .IF DF  T$$CCA&A$$TRP

        CMP     #IO.ATT!TF.AST,I.FCN(R1) ;UNSOLICITED INPUT AST ATTACH?
        BEQ     1900$           ;IF EQ YES

        .ENDC

        .IF DF  T$$ESC

        CMP     #IO.ATT!TF.ESQ,I.FCN(R1) ;ATTACH WITH ESCAPE SEQUENCES?
        BNE     300$            ;IF NE NO
        BIS     #WESC,ATERS(R3) ;REMEMBER THAT THEY ARE WANTED

        .ENDC

        .ENDC                   ; DF T$$CCA&A$$TRP&T$$ESC

300$:                           ;REF LABEL

        .IF DF  T$$RPR

        CMPB    #IO.RPR/400,I.FCN+1(R1) ;READ AFTER PROMPT?
        BEQ     1920$           ;IF EQ YES

        .ENDC

        .IF DF  T$$GMC!T$$GTS!T$$SMC

        CMPB    #IO.GTS/400,I.FCN+1(R1) ;SET/GET CHARACTERISTICS?
        BEQ     1889$           ;IF EQ YES

        .ENDC

        .IF DF  T$$CCA&A$$TRP!T$$ESC

        CMPB    #IO.DET/400,I.FCN+1(R1) ;DETACH?
        BNE     302$            ;IF NE NO
301$:   BIC     #CCON!WESC,ATERS(R3) ;SHOW NO CONTROL C AST ACTION              ; EB209
                                ; AND NO DESIRE FOR ESCAPE SEQUENCES            ;**-1
        BR      5$              ;LEAVE SUCCESSFUL
302$:                           ;REF LABEL

        .ENDC

        CMPB    #IO.RLB/400,I.FCN+1(R1) ;READ LOGICAL BLOCK FUNCTION?
304$:   BNE     5$              ;IF NE NO
305$:                           ;REF LABEL

        .IF DF  T$$TRW

        BITB    #TF.RAL,I.FCN(R1) ;READ ALL?
        BEQ     306$            ;IF EQ NO
        BISB    #SS.RAL,S.STS(R4) ;REMEMBER READING ALL
306$:                           ;REF LABEL

        .ENDC

        .IF DF  T$$RST

        BITB    #TF.RST,I.FCN(R1) ;READ WITH SPECIAL TERMINATORS?
        BEQ     4$              ;IF EQ NO
        BISB    #SS.RST,S.STS(R4) ;SET SPECIAL TERMINATOR FLAG
4$:                             ;REF LABEL

        .ENDC

        .IF DF  T$$RNE

        BIT     #U2.NEC,U.CW2(R5) ;TERMINAL IN NO ECHO MODE?
        BNE     400$            ;IF NE YES
        BITB    #TF.RNE,I.FCN(R1) ;THIS READ WITH NO ECHO?
        BEQ     401$            ;IF EQ NO
400$:   BISB    #SS.RNE,S.STS(R4) ;REMEMBER READING WITH NO ECHO
401$:                           ;REF LABEL

        .ENDC

        .IF DF  T$$UTB

        .IF DF  C$$CKP&T$$BUF

        MOV     I.TCB(R1),R2    ;GET ADDRESS OF REQUESTER TCB
        BIT     #T2.CHK!T2.CKD!T2.DST!T2.AST,T.ST2(R2) ;TASK
                                ; CHECKPOINTABLE?
        BEQ     403$            ;IF EQ YES
        BIS     #NCKP,ATERS(R3) ;REMEMBER AS NONCHECKPOINTABLE

        .ENDC

        MOV     U.BUF+2(R5),R0  ;MAKE INPINI SET UCB TO POINT
        CALL    INPINI          ; AT TASK'S BUFFER
        BR      10$             ;

        .ENDC                   ; DF T$$UTB

;
; REQUEST IS A SOLICITED INPUT REQUEST-GET A BUFFER FOR INPUT
;

403$:                           ;REF LABEL

        .IF NDF T$$UTB!NOEXBF

        .IF DF  T$$VBF

        MOV     U.CNT(R5),R1    ;GET HOW MUCH HE WANTS ALLOCATED
        ADD     #M$$CRB-M$$CRI,R1 ;EXEC BUFFER IS A BIT LONGER
        CALL    GETBF2          ;ALLOCATE EXEC BUFFER

        .IFF

        CALL    GETBF           ;GET BUFFER FOR INPUT

        .ENDC

        BCC     10$             ;IF CC BUFFER ALLOCATED
        MOV     #IE.NOD&377,R0  ;SET NO BUFFER AVAILABLE STATUS

        .IF DF  T$$UTB!T$$RPR

        BIC     #NCKP!RPRM!XOFF,ATERS(R3) ;CLEAR POSSIBLY SET BITS

        .ENDC

        .ENDC                   ; NDF T$$UTB!NOEXBF

5$:     CALL    $IOALT          ;FINISH I/O OPERATION
BTTINI: BR      TTINI           ;TRY AGAIN

        .IF NDF T$$MIN

8$:     BR      30$             ;STRETCH THE BRANCH A BIT
9$:     BR      28$             ; AND SAVE A WORD

        .ENDC

900$:   RETURN                  ;

10$:    BIS     #SOLI,(R3)      ;SET SOLICITED INPUT FLAG

        .IF DF  T$$RPR

        .IIF NE RPRM-100000,    .ERROR  RPRM

        TST     ATERS(R3)       ;READ AFTER PROMPT?

        .IF DF  D$$YNM&M$$MGE

        BMI     29$             ;IF MI YES

        .IFF

        BMI     70$             ;IF MI YES

        .ENDC

        .ENDC

        BIT     #CRJT,(R3)      ;CARRIAGE RETURN JUST TYPED?


        .IF DF  C$$CKP&T$$BUF

;
; TRY TO CHECKPOINT THE TASK WHILE IT IS WAITING FOR INPUT
;

        CALL    27$             ;OUTPUT LF OR CLEAR ECHO-IN-PROGRESS
        MOV     U.SCB(R5),R4    ;RETRIEVE ADDRESS OF SCB
SHOVE:  MOV     S.PKT(R4),R5    ;GET ADDRESS OF I/O PACKET
        MOV     I.TCB(R5),R0    ;GET ADDRESS OF REQUESTER TCB
        BIT     #T2.CHK!T2.CKD!T2.DST!T2.AST,T.ST2(R0) ;STOP TASK?
        BNE     900$            ;IF NE NO

        .IF DF  D$$YNM&M$$MGE
        .IFF

        BIS     #T2.TIO,T.ST2(R0) ;SHOW DOING TERMINAL I/O
        DECB    T.IOC(R0)       ;ADJUST OUTSTANDING I/O REQUEST COUNT

        .IFT

        ADD     #I.PRM,R5       ;POINT TO FIRST PARAMETER WORD
        MOV     T.PCB(R0),R1    ;GET ADDRESS OF REQUESTER HEADER
        MOV     P.HDR(R1),R1    ;
        MOV     H.WND(R1),R1    ;POINT TO NUMBER OF WINDOW BLOCKS
        MOV     (R1)+,R2        ;GET COUNT OF WINDOWS
23$:    DEC     R2              ;ANY MORE WINDOWS TO EXAMINE?
        BLT     900$            ;IF LT NO -- DO NOT CHECKPOINT
        MOV     (R1)+,R4        ;GET ADDRESS OF DESCRIPTOR PCB
        MOV     (R1)+,-(SP)     ;GET LOW VIRTUAL ADDRESS
        MOV     (R1)+,R3        ;GET HIGH VIRTUAL ADDRESS
        SUB     (SP),R3         ;CALCULATE NUMBER OF BYTES MINUS 1
        INC     R3              ;INCREMENT TO ACTUAL NUMBER OF BYTES
        SWAB    R3              ;CONVERT TO 32W BLOCKS
        ASL     R3              ;
        ADC     R3              ;
        ASL     R3              ;
        ADC     R3              ;
        MOV     P.REL(R4),(SP)  ;GET RELOCATION BIAS OF PCB

        .IF DF  P$$LAS

        ADD     W.BOFF-W.BATT(R1),(SP) ;ADD IN OFFSET IN PARTITION

        .ENDC

        ADD     (SP),R3         ;CALCULATE HIGHEST 32W BLOCK
        ADD     #W.BLGH-W.BATT,R1 ;POINT TO NEXT DESCRIPTOR
        CMP     (R5),(SP)+      ;TRANSFER IN THIS PARTITION?
        BLO     23$             ;IF LO NO
        CMP     (R5),R3         ;TRANSFER IN THIS PARTITION?
        BHIS    23$             ;IF HIS NO
        BIS     #T2.TIO,T.ST2(R0) ;SHOW DOING TERMINAL I/O
        DECB    T.IOC(R0)       ;ADJUST OUTSTANDING I/O REQUEST COUNT
        SUB     P.REL(R4),(R5)  ;CONVERT TO RELATIVE RELOCATION BIAS
        MOV     R4,I.PRM+16-I.PRM(R5) ;SAVE ADDRESS OF DESCRIPTOR PCB

        .ENDC

        BIT     #TS.CKR,T.STAT(R0) ;CHECKPOINT ALREADY REQUESTED?
        BEQ     24$             ;IF EQ NO
        BIC     #TS.CKR,T.STAT(R0) ;CLEAR CHECKPOINT REQUEST
24$:    CALLR   $STPTK          ;CLEAR TS.STP, CALL $SETCR, $CHKPT
                                ; AND $NXTSK

        .ENDC                   ; DF C$$CKP&T$$BUF

27$:    BNE     55$             ;IF NE OUTPUT LINE FEED AND RETURN
28$:                            ;REF LABEL

        .IF DF  T$$MIN

        .IF DF  T$$BTW

        CALLR   INPT0           ;CLEAR ECHO IN PROGRESS AND RETURN

        .IFF

        BR      INPT0           ;CLEAR ECHO IN PROGRESS AND RETURN

        .ENDC

        .IFF

        CALLR   INPT0           ;CLEAR ECHO IN PROGRESS AND RETURN

        .ENDC                   ; DF T$$MIN

        .IF DF  D$$YNM&M$$MGE&T$$RPR

29$:    BR      70$             ;

        .ENDC

;
; REQUEST IS AN OUTPUT REQUEST-SET UP CARRIAGE CONTROL FLAGS
;

30$:    BIC     #LFCT!CRTY!EOLS!RUBP!SOLI!FLCT,(R3) ;CLEAR STATUS WORD
        BIS     #MODE,(R3)      ;SET OUTPUT MODE

        .IF DF  T$$BTW

        BITB    #TF.WBT,I.FCN(R1) ;IS THIS A BREAKTHROUGH WRITE?                ;**-1
        BNE     FWRITE          ;IF NE YES (LEAVE US.ECH SET TO
                                ; DISALLOW CONTROL O DURING THE WRITE)

        .ENDC

        CALL    INPT0           ;ALLOW INPUT INTERRUPTS
FWRITE:                         ;REF LABEL

        .IF DF  T$$CCO!T$$BTW

        BITB    #TF.CCO,I.FCN(R1) ;TASK WANTS TO CLEAR CONTROL O FLAG?
        BNE     33$             ;IF NE YES

        .ENDC

        TST     U.ATT(R5)       ;TERMINAL ATTACHED?
        BNE     34$             ;IF NE YES
33$:    BIC     #CTLO,(R3)      ;STOP SUPPRESSING OUTPUT
34$:                            ;REF LABEL

        .IF DF  T$$TRW

        BITB    #TF.WAL,I.FCN(R1) ;WRITE ALL?
        BEQ     36$             ;IF EQ NO

        .IFF

        BR      36$             ;PROCESS CARRIAGE CONTROL

        .ENDC

        .IF DF  T$$RPR!T$$TRW

35$:    BISB    #SS.WAL,S.STS(R4) ;REMEMBER WRITING ALL
        BIC     #CRJT,(R3)      ;CLEAR CR JUST TYPED INDICATOR
        CLRB    HORPS(R3)       ;CLEAR HORIZANTAL POSITION INDICATOR
        BR      60$             ;SKIP CARRIAGE CONTROL BYTE PROCESSING

        .ENDC

36$:    MOVB    I.PRM+6(R1),R0  ;GET CARRIAGE CONTROL BYTE
37$:    BEQ     60$             ;IF EQ NO CARRIAGE CONTROL
        CMPB    #'$,R0          ;CARRIAGE RETURN AT END OF LINE?
        BEQ     40$             ;IF EQ NO
        BIS     #CRTY,(R3)      ;SET FOR CARRIAGE RETURN AT END
40$:    CMPB    #'+,R0          ;LINE FEED AT START OF LINE?
        BEQ     60$             ;IF EQ NO
        CMPB    #'1,R0          ;FORM FEED AT BEGINNING OF LINE?
        BNE     50$             ;IF NE NO

        .IF DF  T$$HFF                                                          ; EB119
                                                                                ;**-1
        BIT     #U2.HFF,U.CW2(R5) ;TERMINAL CAN HANDLE FORM FEED?               ; EB119
        BEQ     48$             ;IF EQ NO                                       ;**-1

        .IIF NE FLBT-1,         .ERROR  FLBT

        INC     (R3)            ;WANT ONE FILL CHARACTER
        MOVB    #14,FLBYT(R3)   ;IT IS TO BE A FORM FEED
        BR      60$             ;

        .ENDC

48$:    ADD     #LFBT*7,(R3)    ;ADD IN SEVEN LINE FEEDS
50$:    ADD     #LFBT,(R3)      ;ADD IN ONE LINE FEED
        CMPB    #'0,R0          ;DOUBLE SPACE?
        BNE     60$             ;IF NE NO
55$:    ADD     #LFBT,(R3)      ;ADD IN ONE LINE FEED
60$:    MTPS    S.PRI(R4)       ;;;LOCK OUT DEVICE INTERRUPTS
        CALLR   OUTPT1          ;;;START OUTPUT

        .IF DF  T$$RPR

;
; IF NECESSARY, COPY THE PROMPT TO AN EXECUTIVE BUFFER SO THE
; TASK CAN BE CHECKPOINTED FOR BOTH THE PROMPT WRITE AND THE
; FOLLOWING READ.
;

70$:    BIC     #CTLO,(R3)      ;CLEAR CONTROL O FLAG
        MOV     S.PKT(R4),R1    ;FIND START OF I/O PACKET
        ADD     #I.PRM+4,R1     ;POINT AT READ BUFFER LENGTH
        CMP     (R1),U.CNT(R5)  ;READ LARGER THAN OUR BUFFER?
        BHIS    72$             ;IS HIS UCB PROPERLY SETUP FOR READ
        MOV     (R1),U.CNT(R5)  ;RESTORE COUNT OF CHARS TO BE READ
        MOVB    (R1),RMBYT(R3)  ;CORRECT COUNT OF BYTES LEFT IN READ BUF
72$:    CMP     (R1)+,(R1)+     ;POINT AT 1ST WORD OF ADDR DOUBLE WORD

        .IF DF  C$$CKP&T$$BUF

        MOV     I.PRM+16-I.PRM-10(R1),-(SP) ;SAVE PROMPT VFC

        .IFF

        MOV     I.PRM+16-I.PRM-10(R1),R0 ;PUT PROMPT WHERE IT'S EXPECTED

        .IFTF

        .IF DF  R$$LKL

        CLR     I.PRM+16-I.PRM-10(R1) ;MAKE LOCKING WORD ZERO AGAIN

        .ENDC

        .IFT

        MOV     I.TCB-I.PRM-10(R1),R2   ;GET TCB ADDRESS
        BIT     #T2.CHK!T2.CKD!T2.DST!T2.AST,T.ST2(R2) ;TASK
                                ; CHECKPOINTABLE?
        BNE     78$             ;IF NE NO

        .IF DF  M$$MGE

        MOV     (R1)+,@#KISAR6  ;MAP TO PROMPT (WRITE) BUFFER

        .IFF

        TST     (R1)+           ;POINT AT PROMPT BUFFER ADDRESS

        .ENDC

        MOV     STRBF(R3),R2    ;POINT AT EXEC READ BUFFER
        MOV     (R1),R0         ;POINT AT PROMPT BUFFER
        MOV     R2,(R1)+        ;PUT EXEC BUFFER ADDRESS IN I/O PACKET
        MOV     (R1),-(SP)      ;SAVE LENGTH OF PROMPT
75$:    MOVB    (R0)+,(R2)+     ;COPY PROMPT TO EXEC BUFFER
        DEC     (SP)            ;DONE?
        BGT     75$             ;IF GT NO
        MOV     R3,(SP)         ;SAVE R3
        MOV     R5,-(SP)        ;SAVE R5
        CALL    SHOVE           ;SET UP THE CHECKPOINT
        MOV     (SP)+,R5        ;RESTORE R5
        MOV     U.SCB(R5),R4    ;RESTORE R4
        MOV     (SP)+,R3        ;RESTORE R3
78$:    MOV     (SP)+,R0        ;RETRIEVE PROMPT VFC

        .ENDC                   ; DF C$$CKP&T$$BUF

        MOV     S.PKT(R4),R1    ;POINT AT I/O PACKET
        BITB    #TF.BIN,I.FCN(R1) ;WRITE ALL PROMPT?
        BNE     35$             ;IF NE YES
        MOV     R0,R0           ;SET CONDITION BITS
        BR      37$             ;INTERPRET PROMPT VFC

        .ENDC                   ; DF T$$RPR

        .DSABL  LSB

        .SBTTL  OUTPUT-NEXT-BYTE ROUTINE

        .ENABL  LSB

        .IF DF  T$$RPR

;
; WRITE OUT THE PROMPT OF AN IO.RPR
;

57$:    MOV     S.PKT(R4),R4    ;;;FIND START OF I/O PACKET
        BIT     #CTLO,(R3)      ;;;CONTROL/O IN MIDDLE OF PROMPT?
        BNE     5704$           ;;;IF NE YES
        DEC     I.PRM+14(R4)    ;;;DONE PROMPTING?
        BMI     5702$           ;;;IF MI YES

        .IF DF  M$$MGE

        MOV     @#KISAR6,-(SP)  ;;;SAVE EXECUTIVE MAPPING
        MOV     I.PRM+10(R4),@#KISAR6 ;;;MAP TO PROMPT BUFFER
        MOVB    @I.PRM+12(R4),-(SP) ;;;GET NEXT BYTE OF PROMPT

        .IFF

        MOVB    @I.PRM+12(R4),-(SP) ;;;GET NEXT BYTE OF PROMPT

        .IFTF

        INC     I.PRM+12(R4)    ;;;POINT AT ITS SUCCESSOR

        .IFT

        MOV     2(SP),@#KISAR6  ;;;RESTORE EXECUTIVE MAPPING
        MOV     (SP)+,(SP)      ;;;LEAVE PROMPT BYTE ON STACK

        .ENDC                   ;;; DF M$$MGE

        MOV     U.SCB(R5),R4    ;;;RESTORE R4
        CALL    INPT0           ;;;ALLOW CONTROL Q, S, AND O INPUT
                                ;;; (REDUNDANT AFTER FIRST CLEARING)
        BR      5703$           ;;;TRANSMIT THE PROMPT CHARACTER
5702$:  BIT     #CRTY,(R3)      ;;;CARRIAGE RETURN AFTER PROMPT?
        BEQ     5704$           ;;;IF EQ NO
        MOV     U.SCB(R5),R4    ;;;RESTORE POINTER TO SCB
        MOV     #15,-(SP)       ;;;TRANSMIT A CARRIAGE RETURN
        BIC     #CRTY,(R3)      ;;;CLEAR WANT CARRIAGE RETURN FLAG

        .IF DF  T$$BTW&T$$30P

5703$:  JMP     ECHOB           ;;;

        .IFF

5703$:  BR      BECHOB          ;;;

        .ENDC

5704$:  BIC     #RPRM,ATERS(R3) ;;;CLEAR PROMPTING FLAG
        MOVB    #IO.RLB/400,I.FCN+1(R4) ;;;CONVERT IO.RPR TO IO.RLB
        MOV     U.SCB(R5),R4    ;;;RESTORE POINTER TO SCB
        RETURN                  ;;;

        .IF DF  T$$BTW

5705$:  BR      57$             ;;;

        .ENDC

        .ENDC                   ;;; DF T$$RPR

        .IF DF  T$$30P

;
; TRANSMITTER NOT BUSY ECHOING, SO PROCESS CHARACTER THAT WAS
; RECEIVED (AND BUFFERED IN SOFTWARE), BUT NOT ECHOED.
;

5708$:  BIC     #CHAR,ATERS(R3) ;;;CLEAR FLAG
        CLR     -(SP)           ;;;CLEAR UPPER BYTE OF STACK
        MOVB    MBUFR(R3),(SP)  ;;;RETRIEVE INPUT CHARACTER
        JMP     RESUME          ;;;PROCESS THE CHARACTER

        .ENDC

        .IF DF  T$$BTW

;
; RESTORE THE SCB AND UCB ENVIRONMENT FOR AN UNSOLICITED READ
; DISPLACED BY AN IO.WBT
;

5710$:  MOVB    #1,S.STS(R4)    ;LINE WAS ONLY BUSY
        CLR     (R3)+           ;CLEAR U.BUF (BUFFER IS IN EXEC SPACE)
        MOV     U.CNT+2+CURBF(R5),(R3)+ ;RESTORE U.BUF+2

; NEXT INSTRUCTION DEPENDS ON STRBF=U.CNT+4

        CMP     (R3)+,(R3)+     ;POINT AT STRBF
        MOV     (R3),-(SP)      ;FORM POINTER TO SAVED STATS
        SUB     #1*2,(SP)       ;
        MOV     @(SP)+,-(R3)    ;RESTORE STATS
        BR      5800$           ;FINISH WITH A FLOURISH

;
; RESTORE THE SCB AND UCB ENVIRONMENT OF THE READ DISPLACED
; BY AN IO.WBT
;

58$:    MOV     U.SCB(R5),R4    ;RESTORE R4
        BISB    #US.BSY,U.STS(R5) ;REBUSY LINE
        BIC     #BTWP,U.CNT+2+ATERS(R5) ;CLEAR BREAKTHROUGH FLAG
        MOV     R5,R3           ;POINT AT U.BUF
        ADD     #U.BUF,R3       ;
        MOV     U.CNT+2+STATS(R5),R1 ;RETRIEVE READ'S I/O PACKET POINTER
        BEQ     5710$           ;IF EQ BROKE THROUGH UNSOLICITED READ
        MOVB    (R1),S.STS(R4)  ;RESTORE SCB STATUS
        MOV     R1,S.PKT(R4)    ;MAKE THE READ THE CURRENT OPERATION
        ADD     #I.PRM+6,R1     ;POINT AT THE READ'S SAVED UCB INFO
        MOV     (R1)+,(R3)+     ;RESTORE U.BUF
        MOV     (R1)+,(R3)+     ;RESTORE U.BUF+2
        MOV     (R1)+,(R3)+     ;RESTORE U.CNT

; NEXT INSTRUCTION DEPENDS ON STATS=U.CNT+2

        MOV     (R1)+,(R3)      ;RETRIEVE TERMINAL STATUS
        CMPB    #IE.ABO,FNBYT(R3) ;CANCEL THE DISPLACED READ?
        BNE     5800$           ;IF NE NO
        JMP     INPT2           ;TERMINATE READ
5800$:  MTPS    S.PRI(R4)       ;RAISE PRIORITY FOR FAKE CONTROL R
        CLR     -(SP)           ;;;FAKE A CONTROL R
        JMP     CTRLR           ;;;

        .ENDC

;
; OUTPT - START OR CONTINUE AN OUTPUT STREAM
;
; AT ENTRY:
;       R5 -> UCB
;       R4 -> SCB
;       R3 -> TCB (UCB + #U.CNT+2)
;       INTERRUPT PRIORITY = THAT OF OUTPUT DEVICE
;
; EXITS VIA RETURN AFTER OUTPUTTING ANOTHER CHARACTER OR THROUGH
; $FORK AT 20$ IF THERE ARE NO MORE CHARACTERS TO OUTPUT OR THROUGH             ; EB105
; $FORK AT INPT1 IF THE INPUT LINE IS COMPLETE (THE OUTPUT                      ;**-1
; INTERRUPT IS FROM A CHARACTER ECHO).
;

OUTPT:                          ;;;REF LABEL

        .IF DF  T$$30P

        BIC     #ECHO,ATERS(R3) ;;;CLEAR ECHOING BIT

        .ENDC

        .IF DF  T$$HLD

        BIT     #BAKS,ATERS(R3) ;;;CLEARING HOLD-SCREEN MODE?
        BEQ     2$              ;;;IF EQ NO
XITHSM: MOVB    @MEBUF(R3),-(SP) ;;;GET NEXT BYTE OF "ESC \"
        BNE     5300$           ;;;IF NE HAVE ANOTHER BYTE TO SEND
        BIC     #BAKS,ATERS(R3) ;;;CLEAR FLAG
        TST     (SP)+           ;;;THROW AWAY TERMINATING BYTE
2$:                             ;;;REF LABEL

        .ENDC

        .IF DF  T$$SYN!T$$HLD

        BIT     #CCPN,ATERS(R3) ;;;CONTROL C PENDING?
        BEQ     2002$           ;;;IF EQ NO
        BIC     #CCPN,ATERS(R3) ;;;CLEAR FLAG
        TSTB    S.STS(R4)       ;;;IS CONTROL C GOING TO BE PROCESSED
                                ;;; IMMEDIATELY?
        BEQ     2000$           ;;;IF EQ YES

        .IIF NE MODE-100000,    .ERROR  MODE

        TST     (R3)            ;;;BUSY ON INPUT?
        BPL     2000$           ;;;IF PL YES
        MOV     #2002$,-(SP)    ;;;SETUP SO NEXT RETURN IS TO 2002$,
                                ;;; WHICH PROPAGATES THE RENEWED OUTPUT
2000$:  MOV     #3,-(SP)        ;;;FAKE A RECEIVED CONTROL C
        JMP     DOCTLC          ;;;EVALUATE IT
2002$:                          ;;;REF LABEL

        .ENDC

        .IF DF  T$$30P

        BIT     #CHAR,ATERS(R3) ;;;HAVE AN INPUT CHAR TO PROCESS?
        BNE     5708$           ;;;IF NE YES

        .ENDC

OUTPT1: BIT     #FLCT,(R3)      ;;;SHOULD A FILL BE ECHOED?
        BNE     60$             ;;;IF NE YES
        BIT     #LFCT,(R3)      ;;;ANY UNPROCESSED LINE FEEDS?
        BNE     40$             ;;;IF NE YES
        MOVB    @MEBUF(R3),-(SP);;;MULTI-ECHO SEQUENCE IN PROGRESS?
        BNE     50$             ;;;IF NE YES
3$:     TST     (SP)+           ;;;NO - REMOVE ZERO CHAR FROM STACK

        .IF DF  T$$BTW!T$$CTR

        MOV     #CTRLU-1,MEBUF(R3) ;;;POINT AT ZERO THAT WON'T DISAPPEAR

        .ENDC

        .IF DF  T$$RPR

        .IIF NE RPRM-100000,    .ERROR  RPRM

        TST     ATERS(R3)       ;;;WRITING A PROMPT?

        .IF DF  T$$BTW

        BMI     5705$           ;;;IF MI YES

        .IFF

        BMI     57$             ;;;IF MI YES

        .ENDC

        .ENDC                   ;;; DF T$$RPR

        .IIF NE MODE-100000,    .ERROR  MODE

        TST     (R3)            ;;;INPUT OR OUTPUT IN PROGRESS?
        BPL     INPPT           ;;;IF PL INPUT

;
; OUTPUT REQUEST IN PROGRESS
;

        BIT     #EOLS!CTLO,(R3) ;;;END OF LINE SEEN OR OUTPUT DISABLED?
        BNE     20$             ;;;IF NE YES
        DEC     U.CNT(R5)       ;;;DECREMENT BYTE COUNT
        BMI     10$             ;;;IF MI CHECK CARRIAGE CONTROL
        CALL    $GTBYT          ;;;GET NEXT BYTE FROM USER BUFFER
BECHOB: BR      ECHOB           ;;;ECHO NEXT BYTE

        .IF DF  T$$BTW

9$:     BR      58$             ;

        .ENDC

10$:    MOVB    #15,-(SP)       ;;;ASSUME TRAILING CARRIAGE RETURN REQUIRED
        BIS     #EOLS,(R3)      ;;;SET END OF LINE SEEN
        BIT     #CRTY,(R3)      ;;;OUTPUT TRAILING CARRIAGE RETURN?
        BNE     ECHOB           ;;;IF NE YES
        TST     (SP)+           ;;;CLEAN STACK

;
; FINISHED AN OUTPUT REQUEST.  WANT TO RETURN STATUS.
;

20$:    CALL    $FORK           ;;;CREATE A SYSTEM PROCESS AND RETURN
        MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS
        BR      55$             ;SEE IF ERROR OR SUCCESS

;
; ECHO LINE FEED
;

40$:    SUB     #LFBT,(R3)      ;;;REDUCE LINE FEED COUNT
        MOVB    #12,-(SP)       ;;;SET TO ECHO LINE FEED
        BR      ECHOB           ;;;ECHO BYTE

;
; MULTI-ECHO SEQUENCE
;

50$:                            ;;;REF LABEL

        .IF DF  T$$BTW!T$$CTR&T$$UTB&M$$MGE

        BIT     #MCTR,ATERS(R3) ;;;CONTROL/R INPUT IN TASK'S BUFFER?
        BEQ     53$             ;;;IF EQ NO

;
; DOING CONTROL R FOR A TASK THAT HAS THE INPUT STRING IN ITS
; ADDRESS SPACE.  TRY HARDER.
;

        CALL    $GTBYT          ;;;PUT NEXT BYTE ON STACK
        MOVB    (SP)+,(SP)      ;;;COLLAPSE STACK
        BNE     ECHOB           ;;;IF NE SOMETHING TO TRANSMIT
        DEC     U.BUF+2(R5)     ;;;POINT AT POSITION TO STORE NEXT
                                ;;; INPUT CHARACTER
        BIC     #MCTR,ATERS(R3) ;;;CLEAR FLAG
        BR      3$              ;;;DO NORMAL COMPLETION
53$:                            ;;;REF LABEL

        .ENDC

5300$:  INC     MEBUF(R3)       ;;;INCREMENT BUFFER ADDRESS
        BR      ECHOB           ;;;ECHO BYTE ON STACK

;
; TERMINAL TIMEOUT-FINISH I/O OPERATION
; ENTERED ON FORK LEVEL WITH TERMINAL CONTROLLER ALREADY RESET
;

TTOUT1: CMPB    #IE.ABO,U.CNT+2+FNBYT(R5) ;TIMEOUT OR CANCEL?
        BEQ     54$             ;IF EQ CANCEL
        MOVB    R0,U.CNT+2+FNBYT(R5) ;REMEMBER TIMEOUT STATUS
54$:                            ;REF LABEL

        .IF DF  T$$BTW!T$$CTR

        MOV     #CTRLU-1,U.CNT+2+MEBUF(R5) ;POINT AT A ZERO BYTE

        .IF DF  T$$UTB&M$$MGE

        BIC     #MCTR,U.CNT+2+ATERS(R5) ;CLEAR SPECIAL CONTROL R FLAG

        .ENDC

        .ENDC

        .IIF NE MODE-100000,    .ERROR  MODE

        TST     U.CNT+2+STATS(R5) ;INPUT OR OUTPUT IN PROGRESS?

        .IF DF  T$$MIN

        .IF DF  T$$BTW

        BPL     INPT22          ;IF PL INPUT

        .IFF

        BPL     INPT2           ;IF PL INPUT

        .ENDC

        .IFF

        BPL     INPT22          ;IF PL INPUT

        .ENDC

55$:    MOV     S.PKT(R4),R1    ;POINT AT COMPLETED OUTPUT I/O PACKET
        MOV     I.PRM+4(R1),R1  ;GET BYTES IT WANTED TRANSFERED
        BIT     #CTLO,U.CNT+2+STATS(R5) ;TERMINATION BY CONTROL O
                                ; OR EOLS?
        BNE     56$             ;IF NE CONTROL O
        MOV     U.CNT(R5),R2    ;SAVE BYTES LEFT TO TRANSFER
        BMI     56$             ;IF MI DID THE ENTIRE WRITE
        SUB     R2,R1           ;CALCULATE BYTES NOT TRANSFERED
        MOV     U.CNT+2+FNBYT-1(R5),R0 ;GET REASON FOR PARTIAL TRANSFER
        CLRB    R0              ;CHANGE INTO IOSB
        SWAB    R0              ;
56$:                            ;REF LABEL

        .IF DF  T$$BTW

        BIT     #BTWP,U.CNT+2+ATERS(R5) ;DID A BREAKTHROUGH WRITE?
        BEQ     IODON           ;IF EQ NO
        MOV     S.PKT(R4),R2    ;POINT AT I/O PACKET FOR WRITE
        MOV     I.PRM+16(R2),U.CNT+2+STATS(R5) ;SAVE DISPLACED READ'S
                                ; I/O PACKET ADDRESS IN THE UCB

        .IF DF  R$$LKL

        CLR     I.PRM+16(R2)    ;MAKE LOCKING WORD ZERO AGAIN

        .ENDC

        .IFTF

IODON:  CALL    $IODON          ;FINISH I/O OPERATION

        .IFT

        BIT     #BTWP,U.CNT+2+ATERS(R5) ;DID A BREAKTHROUGH WRITE?
        BNE     9$              ;IF NE YES

        .ENDC

        .IF DF  T$$MIN

        .IF DF  T$$BTW

        JMP     TTINI           ;GO AGAIN

        .IFF

        BR      BTTINI          ;GO AGAIN

        .ENDC

        .IFF

        JMP     TTINI           ;GO AGAIN

        .ENDC

;
; INPUT REQUEST IN PROGRESS
;

INPPT:  BIT     #EOLS,(R3)      ;;;END OF LINE SEEN?

        .IF NDF T$$MIN

        BNE     INPT11          ;;;IF NE YES

        .IFF

        BNE     INPT1           ;;;IF NE YES

        .ENDC

INPT0:  BICB    #US.ECH,U.STS(R5) ;;;ENABLE INPUT CHARACTER HANDLING
        RETURN                  ;;;

;
; ECHO FILL BYTE
;

        .IIF NE FLBT-1,         .ERROR  FLBT

60$:    DEC     (R3)            ;;;DECREMENT FILL COUNT
        MOVB    FLBYT(R3),-(SP) ;;;SET TO ECHO FILL BYTE
                                ;;;FALL INTO CODE TO ECHO BYTE

        .DSABL  LSB

;
; ECHO NEXT BYTE
;

        .ENABL  LSB

ECHOB:                          ;;;REF LABEL

        .IF DF  T$$TRW

        BITB    #SS.WAL,S.STS(R4) ;;;WRITE PASS ALL?
        BNE     ECHOB1          ;;;IF NE YES

        .ENDC

;
; CHECK IF OUTPUT CHARACTER HAS SPECIAL SIGNIFICANCE
;

        CMPB    (SP),#37        ;;;IS THIS A CONTROL CHARACTER?
        BHI     70$             ;;;IF HI NO
        CMPB    #15,(SP)        ;;;CARRIAGE RETURN?
        BEQ     10$             ;;;IF EQ YES
        CMPB    #14,(SP)        ;;;FORM FEED?
        BEQ     30$             ;;;IF EQ YES
        CMPB    #13,(SP)        ;;;VERTICAL TAB?
        BEQ     40$             ;;;IF EQ YES
        CMPB    #12,(SP)        ;;;LINE FEED?
        BEQ     50$             ;;;IF EQ YES
        CMPB    #11,(SP)        ;;;HORIZONTAL TAB?
        BNE     79$             ;;;IF NE NO

;
; HORIZONTAL TAB
;

        MOVB    HORPS(R3),(SP)  ;;;GET CURRENT HORIZONTAL POSITION
        BIS     #177770,(SP)    ;;;CALCULATE BLANK COUNT TO NEXT TAB STOP
        SUB     (SP),(R3)       ;;;MERGE BLANK COUNT
        MOVB    #' ,FLBYT(R3)   ;;;SET FILL TO A BLANK
5$:     TST     (SP)+           ;;;REMOVE BYTE FROM STACK

        .IF DF  T$$MIN

        .IF DF  T$$BTW

        JMP     OUTPT1          ;;;START OUTPUT

        .IFF

        BR      OUTPT1          ;;;START OUTPUT

        .ENDC

        .IFF

        JMP     OUTPT1          ;;;START OUTPUT

        .ENDC

;
; CARRIAGE RETURN
;

10$:    BIS     #CRJT+FLBT,(R3) ;;;SET CR JUST TYPED AND FORCE 1 FILL
        BIT     #U2.L3S,U.CW2(R5) ;;;LA30S?
        BEQ     20$             ;;;IF EQ NO
        CLR     -(SP)           ;;;PICKUP CURRENT HORIZONAL POSITION
        BISB    HORPS(R3),(SP)  ;;;

        .IF DF  T$$ACR

14$:    SUB     U.CW4(R5),(SP)  ;;;REDUCE THE LOGICAL HORIZONTAL
        BGT     14$             ;;; POSITION TO THE PHYSICAL POSITION
        ADD     U.CW4(R5),(SP)  ;;; (BETWEEN 0 AND 80).

        .IFTF

        ASR     (SP)            ;;;DIVIDE POSITION BY 8.
        ASR     (SP)            ;;;
        ASR     (SP)            ;;;
        ADD     #FILTB,(SP)     ;;;CALCULATE ADDRESS OF FILL TABLE ENTRY
        MOVB    @(SP)+,-(SP)    ;;;GET CORRECT FILL COUNT
        BIC     #^C<17>,(SP)    ;;;CLEAR EXTRANEOUS BITS ON WIDE CARRIAGE
        ADD     (SP)+,(R3)      ;;;SET PROPER FILL COUNT
20$:                            ;;;REF LABEL

        .IFT

        BIT     #FKCR,ATERS(R3) ;;;FAKE CARRIAGE RETURN?
        BNE     60$             ;;;IF NE YES -- NOT A NEW LINE

        .ENDC

27$:    CLRB    HORPS(R3)       ;;;CLEAR HORIZONTAL POSITION
        BR      60$             ;;;OUTPUT CARRIAGE RETURN

;
; FORM FEED
;

30$:                            ;;;REF LABEL

        .IF DF  T$$HFF                                                          ; EB119
                                                                                ;**-1
        BIT     #U2.HFF,U.CW2(R5) ;;;TERMINAL CAN HANDLE FORM FEED?             ; EB119
        BNE     27$               ;;;IF NE YES                                  ; EB119
                                                                                ;**-3
        .ENDC

        ADD     #LFBT*4,(R3)    ;;;ADD IN FOUR LINE FEEDS

;
; VERTICAL TAB
;

40$:    ADD     #LFBT*4,(R3)    ;;;ADD IN FOUR LINE FEEDS
        BR      5$              ;;;GO BACK TO THE TOP TO PRINT THEM

        .IF NDF T$$MIN

INPT22: BR      INPT2           ;;;
INPT11: BR      INPT1           ;;;

        .ENDC

;
; LINE FEED
;

50$:    BIC     #CRJT,(R3)      ;;;CLEAR CARRIAGE RETURN JUST TYPED
        BIT     #U2.VT5,U.CW2(R5) ;;;VT05B?
        BEQ     80$             ;;;IF EQ NO

        .IF DF  L$$50H

        ADD     #FLBT*4,(R3)    ;;;SET FILL COUNT TO 4

        .IFF

        ADD     #FLBT*3,(R3)    ;;;SET FILL COUNT TO 3

        .ENDC

60$:    CLRB    FLBYT(R3)       ;;;SET NULL FILL BYTE
        BR      80$             ;;;

        .IF DF  T$$MIN&T$$BTW

INPT22: BR      INPT2           ;;;

        .ENDC

;
; BYTE REQUIRES HORIZONTAL POSITION
;

70$:    BIC     #CRJT,(R3)      ;;;CLEAR CARRIAGE RETURN JUST TYPED
        TSTB    (SP)            ;;;BYPASS HORIZONAL POSITION CHECK?
        BMI     80$             ;;;IF MI YES

        .IF NDF T$$ACR

;
; SEE IF OUTPUT (OR ECHO) IS OFF SCREEN.  THIS IMPLIES THAT NO MORE
; THAN 255. CHARACTERS CAN BE OUTPUT (TABS ARE EXPANDED INTO BLANKS
; SO THEY COUNT AS MORE THAN ONE CHARACTER) WITH ONE NORMAL WRITE.
;

        CMPB    HORPS(R3),U.CW4(R5) ;;;ANY ROOM LEFT?
        BHIS    5$              ;;;IF HIS NO

        .IFF

;
; SEE IF LINE MUST BE WRAPPED AROUND SCREEN
;

        BIT     #FKCR,ATERS(R3) ;;;LAST PRINTING CHAR WRAPPED AROUND?
        BNE     75$             ;;;IF NE YES -- DON'T TEST FOR WRAP
        CLR     -(SP)           ;;;MAKE THE PRESENT HORIZONTAL
        MOVB    HORPS(R3),(SP)  ;;; POSITION A WORD
73$:    SUB     U.CW4(R5),(SP)  ;;;HORIZONTAL POSITION - BUFFER SIZE
        BGT     73$             ;;;IF GT NOT LOGICALLY ON SAME LINE
        TST     (SP)+           ;;;ADJUST STACK
        BEQ     90$             ;;;IF EQ AT RIGHT EDGE OF SCREEN
75$:    BIC     #FKCR,ATERS(R3) ;;;CLEAR DISPLAY TRANSITION FLAG

        .ENDC

        INCB    HORPS(R3)       ;;;INCREMENT HORIZONTAL POSITION
79$:                            ;;;REF LABEL

        .IF DF  T$$RUB

        CMPB    #10,(SP)        ;;;TRYING TO OUTPUT A BACKSPACE?
        BNE     80$             ;;;IF NE NO
        TSTB    HORPS(R3)       ;;;SAFE TO BACKUP ON LINE?
        BLE     80$             ;;;IF LE NO
        DECB    HORPS(R3)       ;;;BACKUP HORIZONTAL POSITION

        .ENDC

        .IIF NE MODE-100000,    .ERROR  MODE

80$:    TST     (R3)            ;;;INPUT MODE?
        BPL     ECHOB1          ;;;IF PL YES
        BIT     #CTLO,(R3)      ;;;OUTPUT DISABLED?
        BNE     5$              ;;;IF NE YES
ECHOB1: CALLR   OCHAR           ;;;GO AND OUTPUT THE CHARACTER

        .IF DF  T$$ACR

;
; WRAP LINE AROUND SCREEN (BLOWS TABS EXPANDING AT RIGHT EDGE)
;

90$:    BIS     #FKCR,ATERS(R3) ;;;SIGNAL LINE WRAPPING AROUND SCREEN
        BIT     #FLCT,(R3)      ;;;FILLING (DOING A TAB)?
        BEQ     93$             ;;;IF EQ NO
        MOV     (R3),-(SP)      ;;;CHANGE REMAINING FILL COUNT TO
        BIC     #^C<FLCT>,(SP)  ;;; A WORD
        CLR     -(SP)           ;;;DO THE SAME FOR HORIZONTAL
        MOVB    HORPS(R3),(SP)  ;;; POSITION
        ADD     (SP)+,(SP)      ;;;FORM LOGICAL SCREEN POSITION AFTER
                                ;;; WRAPAROUND (DISPLAY WILL BE OFF)
        MOVB    (SP)+,HORPS(R3) ;;;SAVE IT.  IF THIS TRUNCATES,
                                ;;; CONSIDER IT A HINT TO THE USER.
93$:    TSTB    @MEBUF(R3)      ;;;DOING MULTI-ECHO?
        BEQ     100$            ;;;IF EQ NO

        .IF DF  T$$UTB&M$$MGE

        BIT     #MCTR,ATERS(R3) ;;;DOING CONTROL/R?
        BEQ     95$             ;;;IF EQ NO
        INC     U.BUF+2(R5)     ;;;SHOW LAST CHAR NOT REMOVED
        BR      96$             ;;;
95$:                            ;;;REF LABEL

        .ENDC

        DEC     MEBUF(R3)       ;;;SHOW LAST CHAR NOT REMOVED
96$:    BIS     #LFBT,(R3)      ;;;WANT A LINE FEED EVENTUALLY
        MOV     #15,(SP)        ;;;WANT A CARRIAGE RETURN NEXT
        BR      10$             ;;;
100$:   BIS     #LFBT+FLBT,(R3) ;;;SET UP ONE FILL CHAR AND 1 LF
        MOVB    #15,FLBYT(R3)   ;;;THE FILL CHAR IS A CR
        CLRB    1(SP)           ;;;MAKE SURE BYTE ON STACK IS ASCIZ
        JMP     MECHO1          ;;;DEFER OVFLO CHAR TO MULTI-ECHO BUFFER

        .ENDC

        .DSABL  LSB

        .SBTTL  END-OF-INPUT-LINE PROCESSOR

;
; INPT1 - FORK IN ORDER TO FINISH AN INPUT REQUEST
;
; ON ENTRY:
;       R5 -> UCB
;       R4 -> SCB
;       INTERRUPT PRIORITY = THAT OF DEVICE INPUT CAME FROM
;

INPT1:                          ;;;REF LABEL

        .IF DF  T$$RPR

        BIT     #XOFF,ATERS(R3) ;;;SEND XOFF AT READ COMPLETE?
        BEQ     10$             ;;;IF EQ NO
        BIC     #XOFF,ATERS(R3) ;;;CLEAR FLAG
        MOV     #23,-(SP)       ;;;PUT XOFF ON STACK
        BR      ECHOB1          ;;;TRANSMIT IT
10$:                            ;;;REF LABEL

        .ENDC

        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS AND RETURN

        .ENABL  LSB

;
;       END-OF-LINE FORK PROCESS
;

INPT2:  MOV     R5,R3           ;CALCULATE ADDRESS OF TERMINAL STATUS WORD
        ADD     #U.CNT+2+STATS,R3 ;
        BIT     #SOLI,(R3)+     ;SOLICITED INPUT?
        BNE     20$             ;IF NE YES

;
; UNSOLICITED INPUT FINISHED
;

        MOVB    FNBYT-2(R3),@CURBF-2(R3) ;SET FINAL BYTE FOR MCR
        MOV     (R3),R1         ;GET STARTING ADDRESS OF BUFFER
        MOV     R5,-(R1)        ;INSERT ADDRESS OF UCB IN BUFFER
        TST     -(R1)           ;POINT TO BEGINNING OF BUFFER
        CALL    $QMCRL          ;INSERT BUFFER IN MCR QUEUE
10$:    BICB    #US.BSY,U.STS(R5) ;CLEAR UNIT BUSY
        CLRB    S.STS(R4)       ;CLEAR CONTROLLER (UNIT) BUSY
JTTINI: JMP     TTINI           ;GO AGAIN

;
; SOLICITED INPUT FINISHED
;

20$:    MOV     (R3)+,R1        ;GET STARTING ADDRESS OF BUFFER
        MOV     U.CNT(R5),-(SP) ;CALCULATE NUMBER OF BYTES IN INPUT
        SUB     (R3),(SP)       ; BUFFER
        MOVB    #IS.SUC&377,(R3) ;ASSUME NORMAL COMPLETION
        CLRB    1(SP)           ;MAKE SURE COUNT IS POSITIVE
        MOV     (R3)+,R0        ;GET FINAL BYTE (STATUS INDICATION)
        BPL     30$             ;IF PL NORMAL TERMINATION
        CLRB    R0              ;PUT ERROR STATUS IN LOW BYTE OF
        SWAB    R0              ; IOSB AND CLEAR UPPER BYTE

        .IF DF  T$$ESC

        INCB    -(R3)           ;FOUND ESCAPE SEQUENCE?
        BNE     30$             ;IF NE NO
        MOV     #IS.ESQ,R0      ;SHOW AN ESCAPE SEQUENCE IN BUFFER

        .ENDC

30$:                            ;REF LABEL

;
; SEE IF NECESSARY TO MOVE THE RECEIVED CHARACTERS FROM THE
; EXECUTIVE BUFFER TO THE TASK BUFFER
;

        .IF DF  T$$UTB

        .IF DF  C$$CKP&T$$BUF

        BIT     #NCKP,U.CNT+2+ATERS(R5) ;CHARS ALREADY IN TASK BUFFER?
        BEQ     35$             ;IF EQ NO
        BIC     #NCKP,U.CNT+2+ATERS(R5) ;CLEAR NOT CHECKPOINTABLE FLAG

        .ENDC

        MOV     (SP)+,R1        ;SET NUMBER OF BYTES PROCESSED
        CALL    $IODON          ;FINISH I/O OPERATION
        BR      JTTINI          ;ANYTHING ELSE TO DO?
35$:                            ;REF LABEL

        .IF DF  M$$MGE

        MOV     R1,U.BUF+2(R5)  ;POINT AGAIN AT TASK'S BUFFER

        .ENDC

        .ENDC                   ; DF T$$UTB

        .IF NDF T$$UTB!NOEXBF

        .IF DF  C$$CKP&T$$BUF

        MOV     S.PKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        MOV     I.TCB(R3),R2    ;GET ADDRESS OF REQUESTER TCB
        BIT     #T2.TIO,T.ST2(R2) ;DOING TERMINAL I/O?
        BNE     80$             ;IF NE YES

        .IFTF

;
; MOVE CHARACTERS TO TASK'S BUFFER FROM AN EXECUTIVE BUFFER
;

        MOV     (SP),R3         ;SET LOOP COUNT

        .IF DF  M$$MGE

        MOV     U.BUF(R5),@#KISAR6 ;MAP INTO TASK'S SPACE

        .ENDC

        MOV     U.BUF+2(R5),R2  ;POINT AT TASK'S BUFFER
50$:    DEC     R3              ;ANY MORE BYTES TO MOVE?
        BLT     60$             ;IF LT NO
        MOVB    (R1)+,(R2)+     ;PUT BYTE IN TASK'S BUFFER
        BR      50$             ;

;
; RETURN STATUS TO TASK AND RESOURCES TO EXEC FROM SOLICITED READ
;

60$:    MOV     (SP)+,R1        ;SET NUMBER OF BYTES PROCESSED
        CALL    $IODON          ;FINISH I/O OPERATION
        MOV     U.CNT+2+STRBF(R5),R0 ;RETRIEVE BUFFER ADDRESS

        .IF DF  T$$VBF

        MOV     -(R0),R1        ;GET LENGTH OF BUFFER
        TST     -(R0)           ;POINT TO BEGINNING OF BUFFER

        .IFF

        CMP     -(R0),-(R0)     ;POINT TO BEGINNING OF BUFFER
        MOV     #M$$CRB,R1      ;SET LENGTH OF BUFFER

        .ENDC

        CALL    $DEACB          ;DEALLOCATE CORE BLOCK
        BR      JTTINI          ;

        .IFT                    ; DF C$$CKP&T$$BUF

;
; HAUL THE TASK INTO MEMORY SO THE RECEIVED CHARACTERS CAN BE COPIED
; INTO THE TASK'S BUFFER.  COPYING AND PACKET TERMINATION IS DONE BY
; $FINBF IN SYSXT.
;

80$:    BIC     #T2.TIO,T.ST2(R2) ;CLEAR DOING TERMINAL I/O BIT

        .IF DF  I$$RAR!I$$RDN!M$$MGE

        BIC     #TS.RDN,T.STAT(R2) ;CLEAR I/O RUNDOWN IN PROGRESS

        .ENDC

; I.PRI HAD BETTER BE THE SAME AS T.PRI

        MOVB    #200,I.PRI(R3)  ;SET BUFFERED I/O FLAG
        MOV     R0,I.PRM+6(R3)  ;SAVE FINAL I/O STATUS
        MOV     (SP)+,I.PRM+10(R3) ;SAVE NUMBER OF BYTES TRANSFERED
        MOV     R1,I.PRM+12(R3) ;SAVE ADDRESS OF INPUT BUFFER
        MOV     R2,R0           ;COPY TASK TCB ADDRESS
        ADD     #T.ASTL,R2      ;POINT AT TASK'S AST QUEUE
        MOV     (R2),(R3)       ;MAKE AST ENTRY FIRST IN QUEUE.
                                ; IS IT THE ONLY ENTRY?
        BNE     86$             ;IF NE NO
        MOV     R3,T.ASTL+2(R0) ;MAKE LISTHEAD POINT AT NEW END
86$:    MOV     R3,(R2)         ;COMPLETE LINKING
        CALL    $EXRQN          ;CLEAR TS.STP, CALL $SETCR, AND
        BR      10$             ; CALL $NXTSK

        .ENDC                   ; DF C$$CKP&T$$BUF

        .ENDC                   ; NDF T$$UTB!NOEXBT

        .DSABL  LSB

        .SBTTL  CHARACTER INPUT INTERRUPT PROCESSOR

        .ENABL  LSB

        .IF DF  T$$CCA&A$$TRP

;
; QUEUE AN AST BLOCK FOR AN UNSOLICITED CHARACTER
;

1$:     CALL    INPT0           ;CLEAR ECHO IN PROGRESS FLAG
        MOV     #6*2,R1         ;LENGTH OF AST BLOCK
        CALL    $ALOCB          ;ALLOCATE AN AST BLOCK
        BCS     20$             ;IF CS DIDN'T GET ONE
        TST     (R0)+           ;SKIP OVER LINK WORD
        MOV     R1,(R0)+        ;SAVE SIZE OF AST BLOCK
        MOV     R0,R1           ;SAVE BEGINNING ADDRESS OF
        CMP     -(R1),-(R1)     ; AST BLOCK
        MOV     #10*2,(R0)+     ;SAVE BYTES TO ALLOCATE ON STACK
        MOV     U.CNT+2+CCAST(R5),(R0)+ ;SAVE AST TRAP ADDRESS
        MOV     #1,(R0)+        ;SAVE NUMBER OF AST PARAMETERS
        MOV     (SP)+,(R0)      ;UNSOLICITED CHAR IS AST PARAMETER
        MOV     U.ATT(R5),R0    ;GET ADDRESS OF TASK'S TCB
        CALL    $QASTT          ;INSERT AST BLOCK IN AST QUEUE
        BR      JTTINI          ; AND CALL $SETCR

        .ENDC

;
; ICHAR - PROCESS AN INPUT CHARACTER
;
; AT ENTRY:
;       R5 -> UCB
;       R4 -> SCB
;       R3 -> TCB  (UCB + #U.CNT+2)
;       INTERRUPT PRIORITY = THAT OF INTERRUPTING DEVICE
;
; INPUT CHAR IS ON TOP OF STACK AND PARITY BIT IS CLEARED (UNLESS
; INPUTTING IN READ-PASS-ALL MODE).
; EXIT VIA POPPING CHAR FROM STACK AND RETURNING OR BY
; QUEUING A FORK PROCESS AT INPT1 IF THE INPUT REQUEST IS
; SATISFIED OR BY QUEUING A FORK PROCESS AT TINP1 IF THE INPUT
; IS UNSOLICITED.
;

ICHAR:                          ;;;REF LABEL

        .IF DF  T$$30P

        BIT     #ECHO,ATERS(R3) ;;;ECHOING A CHARACTER?
        BEQ     3$              ;;;IF EQ NO

;
; THE TRANSMITTER IS BEING USED
; (WHICH IS TO SAY THE TERMINAL IS A LA30P CONNECTED BY A LC11) TO
; ECHO THE LAST CHARACTER.  BUFFER THIS CHAR IN THE SOFTWARE.
;

        MOVB    (SP),MBUFR(R3)  ;;;SAVE CHAR IN MULTIECHO BUFFER
        BIS     #CHAR,ATERS(R3) ;;;FLAG INPUT CHAR IN BUFFER
        BR      20$             ;;;WORRY ABOUT CHAR WHEN TRANSMITTER
3$:                             ;;; BECOMES FREE

        .ENDC

        BITB    #US.ECH,U.STS(R5) ;;;INPUT CHARACTERS LOCKED OUT?
        BNE     20$             ;;;IF NE YES
DOCTLC: BISB    #US.ECH,U.STS(R5) ;;;LOCK OUT INPUT CHARACTERS
RESUME:                         ;;;REF LABEL

        .IF DF  T$$RPR

        .IIF NE RPRM-100000,    .ERROR  RPRM

        TST     ATERS(R3)       ;;;DOING A PROMPT FOR AN IO.RPR?
        BMI     8$              ;;;IF MI YES

        .ENDC

        .IF DF  T$$TRW!T$$RST

        .IIF NE SS.RAL-200,     .ERROR  SS.RAL

        BITB    #SS.RAL!SS.RST,S.STS(R4) ;;;READ PASS ALL OR READ WITH
                                ;;; SPECIAL TERMINATORS?

        .IF DF  T$$TRW&T$$LWC

        BMI     156$            ;;;IF MI READ PASS ALL

        .IF DF  T$$RST

        BNE     155$            ;;;IF NE YES

        .ENDC

        .IFF                    ;;; DF T$$TRW&T$$LWC

        BNE     155$            ;;;IF NE YES

        .ENDC                   ;;; DF T$$TRW&T$$LWC

        .ENDC                   ;;; DF T$$TRW!T$$RST

8$:     CMPB    #17,(SP)        ;;;CONTROL/O?
        BNE     26$             ;;;IF NE NO
        MOV     #CTLO,-(SP)     ;;;GET OUTPUT DISABLE BIT
        BIC     (R3),(SP)       ;;;.NOT.TERMINAL STATUS.AND.DISABLE BIT
        BIC     #CTLO,(R3)      ;;;.NOT.DISABLE BIT.AND.TERMINAL STATUS
        BIS     (SP)+,(R3)      ;;;DISABLE BIT.OR.TERMINAL STATUS
10$:    CALL    INPT0           ;;;CLEAR ECHO IN PROGRESS

;
; CONTROLLER IS BUSY ON OUTPUT.  IGNORE INPUT REQUEST
;

20$:    TST     (SP)+           ;;;REMOVE BYTE FROM STACK
        RETURN                  ;;;EXIT INTERRUPT
26$:                            ;;;REF LABEL

        .IF DF  T$$RPR

        .IIF NE RPRM-100000,    .ERROR  RPRM

        TST     ATERS(R3)       ;;;DOING A PROMPT FOR AN IO.RPR?
        BMI     10$             ;;;IF MI YES -- IGNORE CHAR IF NOT
                                ;;; A CONTROL Q, S, OR O

        .ENDC

        TSTB    S.STS(R4)       ;;;CONTROLLER (UNIT) BUSY?
        BNE     30$             ;;;IF NE YES
27$:                            ;;;REF LABEL

        .IF DF  T$$CCA&A$$TRP

        BIT     #CCON,ATERS(R3) ;;;CONTROL C AST CODE ACTIVE?
        BNE     140$            ;;;IF NE YES -- CHAR CAUSES AST

        .ENDC

; NEXT INSTRUCTION DEPENDS ON U2.SLV=200

        TSTB    U.CW2(R5)       ;;;SLAVE TERMINAL?
        BMI     10$             ;;;IF MI YES
        CMPB    #3,(SP)         ;;;CONTROL C?
        BEQ     140$            ;;;IF EQ YES
        TST     U.ATT(R5)       ;;;UNIT ATTACHED?
        BNE     10$             ;;;IF NE YES

;
; UNSOLICITED INPUT REQUEST
;

140$:                           ;;;REF LABEL

        .IF DF  T$$CCA&A$$TRP

        TSTB    INPRQ(R3)       ;;;ALREADY WAITING TO FORK?
        BNE     10$             ;;;IF NE YES -- IGNORE THIS CHAR
                                ;;; RATHER THAN THE PRECEDING ONE

        .ENDC

        TSTB    (SP)            ;;;IS THE CHARACTER A NULL?                     ; EB208
        BEQ     10$             ;;;IF EQ YES -- IGNORE IT                       ; EB208
        MOVB    (SP),INPRQ(R3)  ;;;SAVE BYTE (ALSO UNSOL INP PNDG FLG)
        TSTB    S.STS(R4)       ;;;UNIT BUSY ON INPUT OR OUTPUT
        BNE     10$             ;;;IF NE YES -- FORK LATER (TTINI)
        BIS     #UIFP,(R3)      ;;;SET UNSOLICITED INPUT FORK PENDING
        TST     (SP)+           ;;;REMOVE BYTE FROM STACK
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS AND RETURN

;
; UNSOLICITED INPUT FORK PROCESS
;

TINP1:  MOV     U.CNT+2+INPRQ(R5),-(SP) ;GET INPUT BYTE AND ZERO BYTE
        CLRB    U.CNT+2+INPRQ(R5) ;CLEAR UNSOL INPUT PENDING FLAG
        BIC     #UIFP,U.CNT+2+STATS(R5) ;CLEAR UNSOL INP FORK PEND FLG

        .IF DF  T$$CCA&A$$TRP

        BIT     #CCON,U.CNT+2+ATERS(R5) ;WORRY ABOUT CONTROL C AST'S?
        BNE     1$              ;IF NE YES

        .ENDC

        .IF DF  R$$11S

        TST     $MCRPT          ;BASIC MCR AROUND?
        BEQ     10$             ;IF EQ NO -- IGNORE CHAR

        .ENDC

        MOV     U.CW4(R5),U.CNT(R5) ;SET NUMBER OF BYTES REQUESTED
        CALL    GETBF           ;GET BUFFER FOR INPUT AND SET R3
        BCS     10$             ;IF CS DID NOT GET ONE

;
; BUFFER ALLOCATED.  SET CONTROLLER AND UNIT BUSY.
;

        BISB    #US.BSY,U.STS(R5) ;SET UNIT BUSY                                ; EB208
        INCB    S.STS(R4)       ;SET CONTROLLER BUSY                            ;**-1
        BIT     #CRJT,(R3)      ;CARRIAGE RETURN JUST TYPED?
        BEQ     150$            ;IF EQ NO
        ADD     #LFBT,(R3)      ;ADD IN ONE LINE FEED
150$:   MTPS    S.PRI(R4)       ;RAISE PRIO TO ENTER OUTPUT ROUTINES
        CMPB    #3,(SP)         ;;;CONTROL C?
        BNE     35$             ;;;IF NE NO
                                                                                ; CS033
        .IF DF M$$CLI                                                           ; CS033
                                                                                ; CS033
        MOV     U.CLI(R5),(SP)  ;;;GET TERMINAL'S CLI POINTER                   ; CS033
        ADD     #2,(SP)         ;;;POINT TO CLI'S PROMPT STRING                 ; CS033
                                                                                ; CS033
        .IFF    ;M$$CLI                                                         ; CS033
                                                                                ; CS033
        MOV     #CTRLC,(SP)     ;;;SET ADDRESS OF MULTI-ECHO BUFFER
                                                                                ; CS033
        .ENDC   ;M$$CLI                                                         ; CS033
                                                                                ; CS033
152$:   BR      180$            ;;;

        .IF DF  T$$TRW!T$$RST

155$:   JMP     36$             ;;;

        .ENDC

        .IF DF  T$$TRW&T$$LWC!T$$ESC

156$:   JMP     37$             ;;;

        .ENDC

        .IF NDF T$$MIN

157$:   BR      10$             ;;;

        .ENDC                   ;;; NDF T$$MIN

;
; CONTROLLER IS BUSY ON INPUT OR OUTPUT
;

        .IIF NE MODE-100000,    .ERROR  MODE

30$:    TST     (R3)            ;;;BUSY ON INPUT?
        BMI     27$             ;;;IF MI NO
        CMPB    #3,(SP)         ;;;CONTROL C?
        BEQ     27$             ;;;IF EQ YES

;
; PROCESS NEXT INPUT BYTE
;

        .IF DF  T$$ESC

        BIT     #ESCS,ATERS(R3) ;;;IN MIDDLE OF AN ESCAPE SEQUENCE?
        BNE     156$            ;;;IF NE YES

        .ENDC

35$:                            ;;;REF LABEL

        .IF DF  T$$RUB

        CMP     STRBF(R3),CURBF(R3) ;;;THIS IS FIRST CHAR FOR BUFFER?
        BNE     350$            ;;;IF NE NO
        MOVB    HORPS(R3),IHORP(R3) ;;;SAVE CURRENT HORIZONTAL POSITION
350$:                           ;;;REF LABEL

        .ENDC

        .IF DF  T$$CTR

        CMPB    #22,(SP)        ;;;CONTROL R?
        BNE     352$            ;;;IF NE NO

        .IFF

        .IF DF  T$$BTW

        BR      352$            ;;;DO NOT TREAT CHAR AS CONTROL/R

        .ENDC

;
; CONTROL R
;

        .IFTF

        .IF DF  T$$BTW

CTRLR:                          ;;;REF LABEL

        .ENDC

        .IFT

        .IF DF  T$$RNE

        BITB    #SS.RNE,S.STS(R4) ;;;IGNORE CONTROL R IF NO ECHO
        BNE     10$             ;;;

        .ENDC

        .ENDC                   ;;; DF T$$CTR

        .IF DF  T$$BTW!T$$CTR

        BIC     #RUBP,(R3)      ;;;NEW LINE=NEW RUBOUT SEQUENCE
        BIS     #LFBT+FLBT,(R3) ;;;WANT 1 FILL CHAR AND 1 LF
        MOVB    #15,FLBYT(R3)   ;;;FILL CHAR IS A CR

        .IF DF  T$$UTB&M$$MGE

        CLR     -(SP)           ;;;ZERO TO SHOW END OF MULTIECHO
        CALL    $PTBYT          ;;;SHOVE AT END OF TASK'S INPUT
        MOV     STRBF(R3),U.BUF+2(R5) ;;;POINT AT START OF INPUT
        BIS     #MCTR,ATERS(R3)  ;;;FLAG THE NEED TO MAP MULTIECHO
        MOV     #CTRLU,(SP)     ;;;POINT AT A NONZERO BYTE

        .IFF

        CLRB    @CURBF(R3)      ;;;SHOW END OF CHARS
        MOV     STRBF(R3),(SP)  ;;;START FROM BEGINNING OF INPUT BUFFER

        .ENDC

        .IF DF  T$$RUB

        CLRB    IHORP(R3)       ;;;OUTPUT STARTS AT LEFT MARGIN

        .ENDC

        BR      180$            ;;;DO MULTI-ECHO BUFFER
352$:                           ;;;REF LABEL

        .ENDC                   ;;; DF T$$BTW!T$$CTR

        CMPB    #177,(SP)       ;;;RUBOUT?
        BNE     185$            ;;;IF NE NO

;
; RUBOUT
;

        CMP     CURBF(R3),STRBF(R3) ;;;ANY BYTES TO RUBOUT?

        .IF DF  T$$MIN

        BEQ     10$             ;;;IF EQ NO

        .IFF

        BEQ     157$            ;;;IF EQ NO

        .ENDC

        DEC     CURBF(R3)       ;;;BACK UP ONE BYTE

        .IF DF  T$$UTB&M$$MGE

        DEC     U.BUF+2(R5)     ;;;POINT AT LAST CHARCTER
        CALL    $GTBYT          ;;;PUT IT ON STACK
        DEC     U.BUF+2(R5)     ;;;POINT AT PLACE FOR NEXT INPUT CHAR
        MOV     (SP)+,(SP)      ;;;ADJUST STACK

        .IFF

        MOVB    @CURBF(R3),(SP) ;;;GET BYTE TO BE RUBBED OUT

        .ENDC

        INCB    RMBYT(R3)       ;;;INCREMENT REMAINING SPACE IN BUFFER

        .IF DF  T$$RNE

        BITB    #SS.RNE,S.STS(R4) ;;;ECHOING CHARACTERS?

        .IF DF  T$$MIN

355$:   BNE     10$             ;;;IF NE NO                                     ; EB114
                                                                                ;**-1
        .IFF

355$:   BNE     157$            ;;;IF NE NO                                     ; EB114
                                                                                ;**-1
        .ENDC

        .ENDC                   ;;; DF T$$RNE

        .IF DF  T$$RUB

        BIT     #U2.CRT,U.CW2(R5) ;;;TERMINAL A CRT?
        BEQ     58$             ;;;IF EQ NO

;
; CRT RUBOUT
;
; CHECK TO SEE IF TRYING TO RUB OUT A TAB.  IT IS THE ONLY
; CASE OF A SPECIAL CURSOR POSITIONING CHAR WE WORRY ABOUT.
; TOO BAD ABOUT THINGS LIKE BACKSPACE.
;

        CMPB    #11,(SP)        ;;;LAST CHAR A TAB?
        BEQ     50$             ;;;IF EQ YES

        .IF DF  T$$ACR

        BIS     #FKCR,ATERS(R3) ;;;FLAG DO NOT WORRY ABOUT WRAPAROUND

        .ENDC

        MOV     #CRTRUB,(SP)    ;;;OVERPRINT CHAR WITH A
        BR      180$            ;;; BACKSPACE, SPACE, BACKSPACE
50$:                            ;;;REF LABEL

        .IF DF  T$$UTB&M$$MGE

        MOV     STRBF(R3),U.BUF+2(R5) ;;;POINT AT START OF BUFFER

        .IFF

        MOV     STRBF(R3),R4    ;;;POINT AT START OF INPUT LINE

        .IFTF

        MOVB    IHORP(R3),(SP)  ;;;INITIALIZE LINE POSITION
        BR      56$             ;;;1ST CHARACTER IS A TAB?
53$:                            ;;;REF LABEL

        .IFT

        CALL    $GTBYT          ;;;PUT NEXT BYTE ON STACK
        CMPB    #11,(SP)+       ;;;IS OLD CHARACTER A TAB?

        .IFF

        CMPB    #11,(R4)+       ;;;IS OLD CHARACTER A TAB?

        .IFTF

        BNE     55$             ;;;IF NE NO
        BISB    #7,(SP)         ;;;BUMP COUNT TO NEXT TAB STOP
55$:    INCB    (SP)            ;;;COUNT THE CHARACTER
56$:                            ;;;REF LABEL

        .IFT

        CMP     U.BUF+2(R5),CURBF(R3) ;;;FOUND LAST TAB?

        .IFF

        CMP     R4,CURBF(R3)    ;;;FOUND LAST TAB?

        .IFTF

        BLT     53$             ;;;IF LT NO
        BIS     #177770,(SP)    ;;;-SPACES LAST TAB PUT OUT
        ADD     #CRTBS,(SP)     ;;;POINT AT SAME NUMBER OF BACKSPACES

        .IFF

        MOV     U.SCB(R5),R4    ;;;RESTORE R4

        .IFTF

        BR      180$            ;;;BACKUP ON LINE

        .ENDC                   ;;; DF T$$UTB&M$$MGE

58$:                            ;;;REF LABEL

        .ENDC                   ;;; DF T$$RUB

        BIT     #RUBP,(R3)      ;;;RUBOUT ALREADY IN PROGRESS?
        BNE     120$            ;;;IF NE YES
        BIS     #RUBP,(R3)      ;;;SET RUBOUT IN PROGRESS
60$:    SWAB    (SP)            ;;;SWAP BYTE TO HIGH BYTE
        MOVB    #'\,(SP)        ;;;INSERT BACKSLASH

;
; SET UP FOR MULTI-ECHO
;

MECHO1: MOV     (SP),MBUFR(R3)  ;;;SET FOR MULTI-ECHO OF 1-2 BYTES
        MOV     R3,(SP)         ;;;CALCULATE ADDR OF MULTI-ECHO BUFFER
        ADD     #MBUFR,(SP)     ;;;
180$:   MOV     (SP)+,MEBUF(R3) ;;;INSERT ADDRESS OF MULTI-ECHO BUFFER
        JMP     OUTPT1          ;;;START OUTPUT
185$:   CMPB    #25,(SP)        ;;;LINE DELETE?
        BNE     75$             ;;;IF NE NO

;
; LINE DELETE (CONTROL U)
;

        MOV     #CTRLU,(SP)     ;;;SET ADDRESS OF MULTI-ECHO BUFFER
        BIC     #RUBP,(R3)      ;;;CLEAR RUBOUT IN PROGRESS FLAG
        MOV     U.CNT(R5),RMBYT(R3) ;;;RESET REMAINING BYTES IN BUFFER
                                ;;; ALSO CLEARS FINAL BYTE INDICATOR
        MOV     STRBF(R3),CURBF(R3) ;;;RESET ADDRESS IN BUFFER

        .IF DF  T$$UTB&M$$MGE

        MOV     STRBF(R3),U.BUF+2(R5) ;;;POINT AT START OF BUFFER

        .ENDC
                                                                                ; EB114
        .IF DF  T$$RNE                                                          ; EB114
                                                                                ; EB114
        BITB    #SS.RNE,S.STS(R4) ;;;IN NO ECHO MODE?                           ; EB114
        BNE     355$            ;;;IF NE YES -- DON'T TYPE ^U                   ; EB114
                                                                                ; EB114
        .ENDC                                                                   ; EB114

        BR      180$            ;;;GO SET MULTI-ECHO BUFFER
75$:    CMPB    #33,(SP)        ;;;ESCAPE OR ALTMODE
        BNE     85$             ;;;IF NE NO

;
; ALTMODE CODE 33 (ESCAPE) AND POSSIBLY 37, 175, AND 176
;

        .IF DF  T$$ESC

        BIT     #WESC,ATERS(R3) ;;;TASK WANTS ESCAPE SEQUENCES?
        BEQ     81$             ;;;IF EQ NO
        BIT     #U2.ESC,U.CW2(R5) ;;;TERMINAL OUTPUTS ESCAPE SEQUENCES?
        BEQ     81$             ;;;IF EQ NO
        BIS     #ESCS,ATERS(R3) ;;;SHOW IN AN ESCAPE SEQUENCE
        CLR     SYNTX(R3)       ;;;SHOW HAVE ONLY THE ESC
        BR      37$             ;;;SAVE ESC IN BUFFER

        .ENDC

81$:    CLRB    (SP)            ;;;SET TO ECHO ZERO BYTE
        MOVB    #33,FNBYT(R3)   ;;;SET FINAL BYTE
        BR      115$            ;;;SET END OF LINE SEEN
85$:                            ;;;REF LABEL

        .IF DF  T$$ESC

        BIT     #U2.ESC,U.CW2(R5) ;;;TERMINAL OUTPUTS ESCAPE SEQUENCES?
        BEQ     87$             ;;;IF EQ NO
        CMPB    #37,(SP)        ;;;NEW "ESCAPE"?
        BEQ     81$             ;;;IF EQ YES
87$:                            ;;;REF LABEL

        .ENDC

        .IF DF  T$$LWC

        BIT     #U2.LWC,U.CW2(R5) ;;;TERMINAL IN LOWER CASE?
        BNE     88$             ;;;IF NE YES -- 175&176 ARE CHARS

        .ENDC

        CMPB    #175,(SP)       ;;;ALTMODE?
        BLOS    81$             ;;;IF LOS YES
88$:    CMPB    #32,(SP)        ;;;CONTROL Z?
        BNE     89$             ;;;IF NE NO

;
; CONTROL Z (END OF FILE)
;

        MOVB    #IE.EOF&377,FNBYT(R3) ;;;SET CONTROL Z FLAG
        BIS     #EOLS,(R3)      ;;;SET END OF LINE SEEN
                                                                                ; EB114
        .IF DF  T$$RNE                                                          ; EB114
                                                                                ; EB114
        BITB    #SS.RNE,S.STS(R4) ;;;IN NO ECHO MODE?                           ; EB114
        BNE     48$             ;;;IF NE  YES -- DON'T TYPE ^Z                  ; EB114
                                                                                ; EB114
        .ENDC                                                                   ; EB114
                                                                                ; EB114
        MOV     #CTRLZ,(SP)     ;;;SET ADDRESS OF MULTI-ECHO BUFFER
        BR      180$            ;;;
89$:    CMPB    #15,(SP)        ;;;CARRIAGE RETURN?
        BNE     36$             ;;;IF NE NO

;
; CARRIAGE RETURN
;

        MOVB    (SP),FNBYT(R3)  ;;;SET FINAL BYTE
115$:   BIS     #EOLS,(R3)      ;;;SET END OF LINE SEEN

        .IF DF  T$$RNE

        BITB    #SS.RNE,S.STS(R4) ;;;SHOULD ECHO CR OR ESC?
        BNE     48$             ;;;IF NE NO

        .ENDC

120$:   BIT     #LFCT,(R3)      ;;;ANY LINE FEEDS WAITING?
        BNE     MECHO1          ;;;IF NE YES
        JMP     ECHOB           ;;;ECHO BYTE ON STACK

;
; STORE BYTE IN INPUT BUFFER
;

36$:                            ;;;REFERENCE BYTE

        .IF DF  T$$LWC

        BIT     #U2.LWC,U.CW2(R5) ;;;CASE CONVERSION ENABLED?
        BNE     37$             ;;;IF NE NO
        CMPB    #173,(SP)       ;;;UPPER END GRAPHICS?
        BLOS    37$             ;;;IF LOS YES
        CMPB    #141,(SP)       ;;;LOWER CASE LETTER?
        BHI     37$             ;;;IF HI NO
        BICB    #40,(SP)        ;;;CONVERT TO UPPER CASE

        .ENDC

37$:                            ;;;REF LABEL

        .IF DF  T$$UTB&M$$MGE

        MOV     (SP),-(SP)      ;;;COPY UNKNOWN CHARCTER
        CALL    $PTBYT          ;;;PUT IT INTO TASK'S BUFFER

        .IFF

        MOVB    (SP),@CURBF(R3) ;;;STORE BYTE IN BUFFER

        .ENDC

        DECB    RMBYT(R3)       ;;;ANY REMAINING SPACE IN BUFFER
        BNE     39$             ;;;IF NE YES
        BIS     #EOLS,(R3)      ;;;TERMINATE ON BYTE COUNT
        BR      40$             ;;;
39$:    INC     CURBF(R3)       ;;;INCREMENT BUFFER ADDRESS
40$:                            ;;;REF LABEL

        .IF DF  T$$RST

        BITB    #SS.RST,S.STS(R4) ;;;READ WITH SPECIAL TERMINATORS?
        BNE     46$             ;;;IF NE YES

        .ENDC

45$:                            ;;;REF LABEL

        .IF DF  T$$ESC

        BIT     #ESCS,ATERS(R3) ;;;DOING AN ESCAPE SEQUENCE?
        BNE     200$            ;;;IF NE YES

        .ENDC

450$:                           ;;;REF LABEL

        .IF DF  T$$RNE

        BITB    #SS.RNE,S.STS(R4) ;;;SUPPOSED TO ECHO CHARACTER?
        BNE     48$             ;;;IF NE NO

        .ENDC

        .IF DF  T$$30P

        BIS     #ECHO,ATERS(R3) ;;;SHOW ECHOING CHAR

        .ENDC

        .IF DF  T$$SYN

        BIC     #UOFF!UPND,ATERS(R3) ;;;IGNORE PREVIOUS CONTROL/S

        .ENDC

        BIT     #RUBP,(R3)      ;;;RUBOUT IN PROGRESS?
        BEQ     120$            ;;;IF EQ NO
451$:   BIC     #RUBP,(R3)      ;;;CLEAR RUBOUT IN PROGRESS

        .IF DF  T$$ESC

        JMP     60$             ;;;

        .IFF

        BR      60$             ;;;

        .ENDC

        .IF DF  T$$RST

;
; TERMINATE READ ON A SPECIAL TERMINATOR.  A SPECIAL TERMINATOR IS
;       FROM A LOWERCASE TERMINAL - ANY CHAR OUTSIDE OF [40,176]
;       FROM OTHER TERMINALS - ANY CHARACTER OUTSIDE OF [40,174]
;

46$:    CMPB    (SP),#40        ;;;CHARACTER LOWER THAN RANGE?
        BLO     47$             ;;;IF LO YES -- IT IS A TERMINATOR
        CMPB    (SP),#174       ;;;CHARACTER WITHIN RANGE?
        BLOS    450$            ;;;IF LOS YES -- TREAT IT NORMALLY              ; EB116
                                                                                ;**-1
        .IF DF  T$$LWC

        BIT     #U2.LWC,U.CW2(R5) ;;;TERMINAL SET TO LOWER CASE?
        BEQ     47$             ;;;IF EQ NO -- ALT DECISION IS OKAY
        CMPB    (SP),#177       ;;;CHAR IN EXPANDED ASCII RANGE?
        BLO     450$            ;;;IF LO YES

        .ENDC

47$:    BIS     #EOLS,(R3)      ;;;SHOW TERMINATOR FOUND

; NEXT INSTRUCTION IMPLIES 7-BIT CHARACTERS (SEE AFTER INPT2)

        MOVB    (SP),FNBYT(R3)  ;;;STORE FINAL BYTE FOR I/O STATUS
        INCB    RMBYT(R3)       ;;;READJUST BYTE COUNT

        .ENDC                   ;;; DF T$$RST

        .IF DF  T$$ESC!T$$RNE!T$$RST!T$$TRW

48$:    TST     (SP)+           ;;;REMOVE CHARACTER FROM STACK
        JMP     INPPT           ;;;DO NOT ECHO CHARACTER

        .ENDC

        .IF DF  T$$ESC

;+
; GATHER AN ESCAPE SEQUENCE
;
; IN GENERAL, AN ESCAPE SEQUENCE IS
;       ESC IC FC
; WHERE ESC = 33
;       IC  = ZERO OR MORE INTERMEDIATE CHARACTERS (40-57)
;       FC  = FINAL CHARACTER (60-176)
; THE FOLLOWING VIOLATIONS OF THAT RULE ARE ALSO ESCAPE SEQUENCES:
;       ESC ; IC FC
;       ESC ? IC FC
;       ESC O IC SFC
                                                                                ; EB205
        .IF DF  ESCPIC                                                          ; EB205
                                                                                ; EB205
;       ESC P IC FC
                                                                                ; EB205
        .ENDC                                                                   ; EB205
                                                                                ; EB205
;       ESC Y CO CO
; WHERE ;   = 73
;       ?   = 77
;       O   = 117
;       P   = 120
;       Y   = 131
;       SFC = SPECIAL FINAL CHARACTER (100-176)
;       CO  = BIASED 40 COORDINATE (40-176)
; AN ESCAPE SEQUENCE TERMINATES A SOLICITED READ.  A SYNTACTICALLY
; CORRECT ESCAPE SEQUENCE RETURNS A STATUS OF IS.ESQ IN THE IOSB
; AND THE ESCAPE SEQUENCE IN THE INPUT BUFFER.  A SYNTACTICALLY
; INCORRECT ESCAPE SEQUENCE (RECEPTION OF A CHARACTER NOT IN THE
; LEGAL RANGE OF THE NEXT EXPECTED CHARACTER) RETURNS IE.IES
; (ILLEGAL ESCAPE SEQUENCE) IN THE IOSB AND THE INCORRECT ESCAPE
; SEQUENCE IN THE INPUT BUFFER.  IF THE INPUT BUFFER IS FILLED BEFORE
; A FINAL CHARACTER IS RECEIVED, IE.PES (PARTIAL ESCAPE SEQUENCE)
; IS RETURNED.  IF A RUBOUT (177) IS RECEIVED, THE PARTIAL ESCAPE
; SEQUENCE IS ERASED FROM THE INPUT BUFFER AND ESCAPE SEQUENCE
; RECOGNITION MODE IS EXITED.
;-

200$:   MOV     SYNTX(R3),R4    ;;;GET RULE TO HANDLE CHARACTER
        BNE     210$            ;;;IF NE HAVE A RULE
        MOV     #SYNTAB,SYNTX(R3) ;;;GET RULE FOR 2ND CHARACTER
204$:   BIT     #EOLS,(R3)      ;;;PARTIAL SEQUENCE FILLS BUFFER?
        BNE     245$            ;;;IF NE YES
        BIT     #RUBP,(R3)      ;;;RUBOUT IN PROGRESS?
        BEQ     225$            ;;;IF EQ NO
        MOV     U.SCB(R5),R4    ;;;RESTORE R4
        CLR     (SP)            ;;;FAKE OUT RUBOUT PROCESSING
        BR      451$            ;;;
210$:   CMPB    #37,(SP)        ;;;CHAR IN RANGE 0 -> 37?
        BGE     240$            ;;;IF GE YES -- SYNTAX VIOLATION
        CMPB    #177,(SP)       ;;;CHAR A DEL?
        BEQ     250$            ;;;IF EQ YES -- FORGET ESCAPE SEQUENCE
215$:   CMPB    (SP),(R4)+      ;;;CHAR LESS THAN LOW VALUE OF RANGE?
        BLO     230$            ;;;IF LO YES -- TRY NEXT RANGE
        CMPB    (SP),(R4)+      ;;;CHAR GREATER THAN RANGE'S HIGH VALUE?
        BHI     232$            ;;;IF HI YES -- NO MATCH
        MOV     (R4),SYNTX(R3)  ;;;SAVE NEXT SYNTAX RULE
        BNE     204$            ;;;IF NE SEQUENCE NOT COMPLETED
        COMB    FNBYT(R3)       ;;;SET A -1 TO GET IS.ESQ
220$:   BIS     #EOLS,(R3)      ;;;SHOW BUFFER COMPLETE
222$:   BIC     #ESCS,ATERS(R3) ;;;SHOW OUT OF ESCAPE SEQUENCE
225$:   MOV     U.SCB(R5),R4    ;;;RESTORE R4                                   ; EB206
        BR      48$             ;;;CLEAN UP STACK AND LEAVE WITHOUT             ;**-2
                                ;;; ECHOING
230$:   INC     R4              ;;;BUMP PAST TOP OF RANGE
232$:   TST     (R4)+           ;;;TESTED ALL RANGES OF RULE?
        BNE     215$            ;;;IF NE NO -- CHECK THE NEXT
240$:   MOVB    #IE.IES&377,FNBYT(R3) ;;;SAVE ESCAPE ERROR STATUS
        BR      220$            ;;;GET OUT
245$:   MOVB    #IE.PES&377,FNBYT(R3) ;;;PARTIAL ESCAPE SEQUENCE STATUS
        BR      220$            ;;;

;
; IGNORE THE PARTIAL ESCAPE SEQUENCE AND GET OUT OF ESCAPE SEQUENCE
; MODE
;

250$:   TSTB    RMBYT(R3)       ;;;DEL FILLED BUFFER?
        BNE     252$            ;;;IF NE NO
        INC     CURBF(R3)       ;;;MAKE UP FOR NOT BUMPING CURBF AT 39$
252$:                           ;;;REF LABEL

        .IF DF  T$$UTB&M$$MGE

        DEC     U.BUF+2(R5)     ;;;POINT AT LAST CHAR IN BUFFER
        CALL    $GTBYT          ;;;PUT IT ONTO STACK
        DEC     U.BUF+2(R5)     ;;;POINT WHERE LAST CHAR CAME FROM
        DEC     CURBF(R3)       ;;;MAKE BOTH POINTERS AGREE

        .IFF

        DEC     CURBF(R3)       ;;;POINT AT LAST CHAR IN BUFFER
        MOVB    @CURBF(R3),-(SP) ;;;PUT IT ONTO STACK

        .ENDC

        INCB    RMBYT(R3)       ;;;SHOW INCREASED ROOM IN BUFFER
        CMPB    #33,(SP)+       ;;;FOUND FIRST CHAR OF ESCAPE SEQUENCE?
        BNE     252$            ;;;IF NE NO
        BIC     #EOLS,(R3)      ;;;SHOW ARE NOT AT END OF LINE
        BR      222$            ;;;LEAVE

        .ENDC                   ;;; DF T$$ESC

        .DSABL  LSB

        .SBTTL  MISCELLANY
;+
; TTCAN - CANCEL I/O OPERATION ENTRY POINT (FORCE I/O COMPLETE)
;
; AT ENTRY:
;       R0 -> ADDR OF ACTIVE I/O PACKET
;       R1 -> ADDR OF TCB OF CURRENT TASK
;       R3 -> CONTROLLER INDEX
;       R4 -> ADDR OF SCB
;       R5 -> ADDR OF UCB
;       INTERRUPT PRIORITY=THAT OF DEVICE
;-

        .ENABL  LSB

        .IIF NE MODE-100000,    .ERROR  MODE

TTCAN:  MOV     U.CNT+2+STATS(R5),R2 ;;;UNIT BUSY ON INPUT?
        BMI     10$             ;;;IF MI NO
        BIT     #SOLI,R2        ;;;SOLICITED INPUT?
        BEQ     40$             ;;;IF EQ NO
10$:    CMP     R1,I.TCB(R0)    ;;;REQUEST FOR CURRENT TASK?
        BNE     40$             ;;;IF NE NO
15$:    BIT     #EOLS,R2        ;;;END OF LINE SEEN?
                                                                                ; EB210
        .IF DF  T$$SYN                                                          ; EB210
                                                                                ; EB210
        BEQ     18$             ;;;IF EQ NO                                     ; EB210
                                                                                ; EB210
        .IIF NE UPND-200,       .ERROR  UPND                                    ; EB210
                                                                                ; EB210
        TSTB    U.CNT+2+ATERS(R5) ;;;IS CHARACTER THAT SET EOLS                 ; EB210
                                  ;;;BEING HELD UP?                             ; EB210
        BPL     40$               ;;;IF PL NO                                   ; EB210
                                                                                ; EB210
        .IFF                                                                    ; EB210
                                                                                ; EB210
        BNE     40$             ;;;IF NE END OF LINE SEEN
                                                                                ; EB210
        .ENDC                                                                   ; EB210

        .IIF NE MODE-100000,    .ERROR  MODE

18$:    TST     R2              ;;;INPUT OR OUTPUT?                             ; EB210
        BMI     20$             ;;;IF MI OUTPUT                                 ;**-1
        BISB    #US.ECH,U.STS(R5) ;;;DISABLE INPUT CHARACTER HANDLING
20$:    MOVB    #IE.ABO&377,U.CNT+2+FNBYT(R5) ;;;SETUP FOR ABORT STATUS
        BIS     #EOLS,U.CNT+2+STATS(R5) ;;;SET END OF LINE SEEN
        MOVB    #1,S.CTM(R4)    ;;;SET TIMEOUT COUNT TO 1

        .IF DF  T$$BTW!T$$ESC!T$$RPR!T$$SYN                                     ; EB151
                                                                                ;**-1
        BIC     #ESCS!RPRM!XOFF!UPND,U.CNT+2+ATERS(R5) ;;;                      ; EB161
                                ;;; CLEAR STATUS BITS THAT MAY BE SET           ;**-1

        .ENDC

40$:    RETURN                  ;;;

;
; ROUTINE EXECUTED WHENEVER A DM11 OR DZ11 LINE HANGS UP.
; CANCEL I/O AND SAY "BYE" IF NECESSARY ON A MULTIUSER SYSTEM.
;

        .IF DF  D$$M11!D$$ZMD

TTHUP:  MOV     R2,-(SP)        ;;;SAVE R2
        CALL    80$             ;;;CANCEL I/O IF UNIT IS BUSY
        MOV     #CTRLU-1,U.CNT+2+MEBUF(R5) ;;;SUPPRESS MULTIECHO

        .IF DF  T$$ACR!T$$BTW!T$$CCA!T$$ESC!T$$HLD!T$$SYN!T$$30P                ; EB119
                                                                                ;**-1
T3=CCPN!BAKS!FKCR!ECHO!UPND!CHAR!WESC!CCON!MCTR!UOFF
        BIC     #T3,U.CNT+2+ATERS(R5) ;CLEAR ADDITIONAL TERMINAL STATUS

        .ENDC

        .IF DF  M$$MUP

        .IF DF  D$$M11

        MTPS    #0              ;;;DROP PRIORITY

        .ENDC

        BIT     #U2.LOG,U.CW2(R5) ;TERMINAL LOGGED ON?
        BNE     70$             ;IF NE NO
        MOV     R3,-(SP)        ;SAVE REGISTERS NEEDED
        MOV     R1,-(SP)        ;
        MOV     R0,-(SP)        ;
        MOV     #M$$CRB,R1      ;SET SIZE OF MCR COMMAND LINE
        CALL    $ALOCB          ;ALLOCATE MCR COMMAND LINE
        BCS     50$             ;IF CS ALLOCATION FAILURE
        MOV     R0,R1           ;COPY POINTER TO BUFFER
        TST     (R0)+           ;POINT TO UCB WORD
        MOV     R5,(R0)+        ;PASS UCB POINTER
        MOV     #"BY,(R0)+      ;STICK IN BYE COMMAND
        MOV     (PC)+,(R0)+     ;
        .ASCII  /E/<15>         ;
                                                                                ; CS033
        .IF DF M$$CLI                                                           ; CS033
                                                                                ; CS033
        MOV     $MCRPT,R0       ;POINT TO MCR'S TCB                             ; CS033
        CALL    $QCLIL          ;AND QUEUE "BYE" COMMAND                        ; CS033
                                                                                ; CS033
        .IFF    ;M$$CLI                                                         ; CS033
                                                                                ; CS033
        CALL    $QMCRL          ;QUEUE THE COMMAND
                                                                                ; CS033
        .ENDC   ;M$$CLI                                                         ; CS033
                                                                                ; CS033

        .IF DF  D$$ZMD

        CLC                     ;SHOW A SUCCESSFUL FORAY

        .ENDC

        .IF DF  D$$M11

        BR      60$             ;

        .ENDC

50$:                            ;REF LABEL

        .IF DF  D$$M11&D$$ZMD

        BIT     #U2.DZ1,U.CW2(R5) ;THIS LINE ON A DZ11?
        BNE     60$             ;IF NE YES

        .ENDC

        .IF DF  D$$M11

        BISB    #US.CRW,U.STS(R5) ;TRY AGAIN IN 4 SECONDS
        MOVB    #1,U.CNT+2+DMTIM(R5) ;SET TIMEOUT VALUE TO 4

        .ENDC

60$:    MOV     (SP)+,R0        ;RESTORE REGISTERS
        MOV     (SP)+,R1        ;
        MOV     (SP)+,R3        ;

        .ENDC                   ; DF M$$MUP

70$:    MOV     (SP)+,R2        ;;;RESTORE R2
        RETURN                  ;;;

; NEXT INSTRUCTION DEPENDS ON US.BSY=200

80$:    TSTB    U.STS(R5)       ;;;UNIT BUSY?
        BPL     40$             ;;;IF PL NO - RETURN
        CLRB    U.CNT+2+INPRQ(R5) ;;;CLEAR UNSOLICITED INPUT PENDING FLG
        MOV     U.CNT+2+STATS(R5),R2 ;;;TERMINAL STATUS WORD INTO R2
        BR      15$             ;;;BRANCH INTO CANCEL ROUTINE

        .ENDC

        .DSABL  LSB

;
; GETBF - GET AN INPUT BUFFER AND SETUP TERMINAL CONTROL BLOCK
;
; WHEN ENTERED AT GETBF
;
;       R5 -> UCB
;
; DESTROYS R0, R1, R2
; SETS R3 = UCB+U.CNT+2
; PRESERVES R4, R5, SP
;
; WHEN ENTERED AT GETBF2
;
;       R1 =  NUMBER OF BYTES TO ALLOCATE
;       R5 -> UCB
;
; DESTROYS R0, R2
; SETS R3 = UCB+U.CNT+2
; PRESERVES R4, R5, SP
;
; EITHER ENTRY POINT GETS A BUFFER FROM THE EXEC CORE POOL AND
; MAKES THE UCB POINT TO IT
;

        .ENABL  LSB

GETBF:  MOV     #M$$CRB,R1      ;SET LENGTH OF BUFFER REQUIRED

        .IF DF  T$$VBF

        CMP     #M$$CRI,U.CNT(R5) ;BUF=SCREEN SIZE TOO MUCH FOR MCR?
        BGE     GETBF2          ;IF GE NO
        MOV     #M$$CRI,U.CNT(R5) ;GIVE MCR ONLY WHAT IT CAN HANDLE

        .IFTF

GETBF2: CALL    $ALOCB          ;ALLOCATE A CORE BLOCK
        BCS     20$             ;IF CS NO BLOCK AVAILABLE

        .IFT

        TST     (R0)+           ;POINT AT SECOND WORD OF BUFFER
        MOV     R1,(R0)+        ;SAVE LENGTH OF BUFFER

        .IFF

        CMP     (R0)+,(R0)+     ;POINT TO ACTUAL BUFFER AREA

        .IFTF

        .IF DF  T$$UTB&M$$MGE

        CLR     U.BUF(R5)       ;MAKE "TASK BUFFER POINTERS" POINT AT
        MOV     R0,U.BUF+2(R5)  ; THE NEW EXECUTIVE BUFFER.  BUFFER TO
                                ; TASK TRANSFER DONE BY $FINBF WHICH
                                ; GETS MAPPING FROM I/O PACKET.

        .ENDC

INPINI: MOV     R5,R3           ;COPY UCB ADDRESS
        ADD     #U.CNT,R3       ;POINT TO NUMBER OF BYTES REQUESTED

        .IFT                    ; DF T$$VBF

        CMP     #255.,(R3)      ;BUFFER TOO BIG FOR RMBYT?
        BHIS    10$             ;IF HIS NO
        MOV     #255.,(R3)      ;CUT IT DOWN TO SIZE

        .IFF                    ; DF T$$VBF

        CMP     #M$$CRI,(R3)    ;MORE THAN ONE BUFFER?
        BHIS    10$             ;IF HIS NO
        MOV     #M$$CRI,(R3)    ;ALLOW ONLY ONE BUFFER'S WORTH

        .ENDC                   ; DF T$$VBF

10$:    MOV     (R3)+,-(SP)     ;SET LENGTH OF INPUT REQUEST
        BIC     #MODE!LFCT!CRTY!EOLS!RUBP!SOLI!CTLO!FLCT,(R3)+ ;CLEAR STATUS
        MOV     R0,(R3)+        ;SET STARTING BUFFER ADDRESS
        MOV     (SP)+,(R3)+     ;SET SPACE REMAINING IN BUFFER
        MOV     R0,(R3)         ;SET CURRENT BUFFER ADDRESS
        SUB     #CURBF,R3       ;POINT TO START OF CONTROL BLOCK

        .IF DF  T$$ESC

        BIC     #ESCS,ATERS(R3) ;CLEAR STATUS

        .ENDC

20$:    RETURN                  ;

        .DSABL  LSB

        .SBTTL  CONTROLLER-DEPENDENT DATA BASE

;
; LOCAL DATA
;
; CONTROLLER IMPURE DATA TABLES (INDEXED BY CONTROLLER (UNIT) NUMBER)
;

        .IF DF  D$$L11

CNTBL:  .BLKW   D$$L11          ;ADDRESS OF UNIT CONTROL BLOCK

        .IF NDF L$$DRV!M$$MGE!LD$TT

        .IF GT  D$$L11-1

DLTMP:  .BLKW   1               ;TEMP STORAGE FOR CONTROLLER NUMBER

        .ENDC

        .ENDC                   ; NDF L$$DRV!M$$MGE!LD$TT

        .ENDC                   ; DF D$$L11

        .IF DF  D$$H11

DHTBL:                          ;REF LABEL
N=0
        .REPT   D$$H11
        .WORD   UCBTB+N         ;POINTER TO DH11 UCB TABLE
N=N+34.
        .ENDR

UCBTB:                          ;REF LABEL
        .REPT   D$$H11
        .REPT   16.
        .WORD   0               ;ADDR OF UCB FOR LINE (PLUGGED AT TTPWF)
        .ENDR
        .WORD   0               ;ZERO SENTINEL WORD
        .ENDR

DHCSR:  .BLKW   D$$H11          ;DH11 CSR ADDRESS

        .IF NDF L$$DRV!M$$MGE!LD$TT

        .IF GT  D$$H11-1

DHTMP:  .BLKW   1               ;TEMP STORAGE FOR CONTROLLER NUMBER

        .ENDC

        .ENDC                   ; NDF L$$DRV!M$$MGE!LD$TT

        .IF DF  D$$M11

DMTBL:                          ;DM11-BB CSR ADDRESSES
        .REPT   D$$M11
        .WORD   0
        .ENDR
CLKSW:  .WORD   0               ;DM11-BB CLOCK SWITCH WORD

        .IF NDF L$$DRV!LD$TT

        .WORD   0,0,0,0,0       ;DM11-BB CLOCK QUEUE CONTROL BLOCK
        .WORD   DMTMO           ;DM11-BB TIMER SUBROUTINE ADDRESS

        .IF DF  L$$DRV&M$$MGE
        .WORD   0               ;WORD FOR APR5 BIAS
        .ENDC

        .ENDC                   ; NDF L$$DRV!LD$TT

        .ENDC                   ; DF D$$M11

        .ENDC                   ; DF D$$H11

        .IF DF  D$$Z11

DZTBL:                          ;REF LABEL
N=0
        .REPT   D$$Z11

        .WORD   UCZTB+N         ;POINTER TO DZ11 UCB TABLE (INDEXED BY
                                ; CONTROLLER NUMBER)
        .IF DF  L$$SI1
        .IF DF  D$$ZMD
N=N+10.
        .IFF
N=N+8.
        .ENDC
        .IFF
        .IF DF  D$$ZMD
N=N+18.
        .IFF
N=N+16.
        .ENDC
        .ENDC

        .ENDR

UCZTB:                          ;REF LABEL

        .REPT   D$$Z11

        .IF NDF L$$SI1
        .WORD   0,0,0,0         ;UCB ADDRESS FOR EACH LINE (INDEXED BY
        .ENDC
        .WORD   0,0,0,0         ; LINE (UNIT) NUMBER)
        .IF DF  D$$ZMD
        .WORD   0
        .ENDC

        .ENDR

DZCSR:  .BLKW   D$$Z11          ;DZ11 CSR ADDRESS

        .IF NDF L$$DRV!M$$MGE!LD$TT

        .IF GT  D$$Z11-1

DZTMP:  .WORD   0               ;TEMP STORAGE FOR CONTROLLER NUMBER

        .ENDC

        .ENDC                   ; NDF L$$DRV!M$$MGE!LD$TT

        .IF DF  D$$ZMD

DZCLKS: .WORD   0               ;DZ11 CLOCK SWITCH WORD

        .IF NDF L$$DRV!LD$TT

        .WORD   0,0,0,0,0       ;DZ11 CLOCK QUEUE ENTRY
        .WORD   DZTMO           ;DZ11 TIMEOUT ENTRY POINT

        .IF DF  L$$DRV&M$$MGE
        .WORD   0               ;WORD FOR APR5 BIAS
        .ENDC

        .ENDC                   ; NDF L$$DRV!LD$TT

        .ENDC                   ; DF D$$ZMD

        .ENDC                   ; DF D$$Z11

        .IF DF  D$$J11

DJTBL:                          ;REF LABEL
N=0

        .REPT   D$$J11
        .WORD   UCJTB+N         ;POINTER TO DJ11 UCB TABLE
N=N+32.
        .ENDR

UCJTB:                          ;REF LABEL

        .REPT   D$$J11
        .REPT   16.
        .WORD   0               ;ADDRESS OF LINE'S UCB
        .ENDR
        .ENDR

DJCSR:  .BLKW   D$$J11          ;DJ11 CSR ADDRESS

        .IF NDF L$$DRV!M$$MGE!LD$TT

        .IF GT  D$$J11-1

DJTMP:  .BLKW   1               ;TEMP STORAGE FOR CONTROLLER NUMBER

        .ENDC

        .ENDC                   ; NDF L$$DRV!M$$MGE!LD$TT

        .ENDC                   ; DF D$$J11

;+
; DRIVER DISPATCH TABLE
;
; THE $XYTBL GLOBAL SYMBOLS ARE FOR EASING THE MENTAL BURDEN WHEN
; CREATING LOADABLE USER TERMINAL DRIVERS FOR TEST PURPOSES
;-

        .IF DF  LD$$L
$DLTBL::
        .ENDC

        .IF DF  LD$$H
$DHTBL::
        .ENDC

        .IF DF  LD$$J
$DJTBL::
        .ENDC

        .IF DF  LD$$Z
$DZTBL::
        .ENDC

        .IF NDF LD$$L & LD$$H & LD$$J & LD$$Z
$TTTBL::
        .ENDC

        .IF DF  T$$BTW!T$$RPR

        .WORD   TTCHK           ;DEVICE INITIATOR ENTRY POINT

        .IFF

        .WORD   TTINI           ;DEVICE INITIATOR ENTRY POINT

        .ENDC

        .WORD   TTCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   TTOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   TTPWF           ;POWERFAIL ENTRY POINT

        .SBTTL  CONTROLLER-DEPENDENT OUTPUT INTERRUPT CODE

        .ENABL  LSB

;+
; **-$DZOUT-DZ11 TERMINAL MULTIPLEXER OUTPUT INTERRUPTS
;-

        .IF DF  D$$Z11

$DZOUT::                        ;REF LABEL
        TTSAV$  DZ,PR5,D$$Z11   ;;;SAVE R3, R4, R5 AND LOWER
                                ;;; INTERRUPT PRIORITY
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER
        MOVB    1(R4),R5        ;;;GET BYTE CONTAINING LINE NUMBER
        BIC     #177770,R5      ;;;ISOLATE LINE NUMBER
        ASL     R5              ;;;MAKE IT INTO A WORD INDEX
        MOV     R5,-(SP)        ;;;SAVE IT
        ADD     R3,R5           ;;;ADDR OF ADDR OF UCB FOR LINE
        MOV     (R5),R5         ;;;ADDR OF UCB FOR LINE
        MOV     (SP)+,R3        ;;;SET R3 TO LINE NUMBER
        BITB    #US.OUT,U.STS(R5) ;;;EXPECT INTERRUPT?
        BNE     3$              ;;;IF NE YES
        BICB    $BTMSK(R3),4(R4) ;;;SHOW NO DESIRE TO TRANSMIT
        MOV     U.SCB(R5),R4    ;;;SET R4 TO START OF SCB
        BR      40$             ;;;DONE
3$:     MOVB    U.CNT+2+DHBUF(R5),6(R4) ;;;TRANSMIT BYTE

        .IF DF  D$$J11

        BR      5$

        .ENDC

        .ENDC                   ;;; DF D$$Z11

;+
; **-$DJOUT-DJ11 TERMINAL MULTIPLEXER OUTPUT INTERRUPTS
;-


        .IF DF  D$$J11

$DJOUT::                        ;;;REF LABEL
        TTSAV$  DJ,PR5,D$$J11   ;;;SAVE R3, R4, R5 AND LOWER
                                ;;; INTERRRUPT PRIORITY
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER
        MOV     R3,R5           ;;;COPY ADDRESS OF UCB TABLE
        ADD     #7,R4           ;;;POINT TO UNIT NUMBER
        MOVB    (R4),R3         ;;;GET INTERRUPTING UNIT
        BIC     #177760,R3      ;;;CLEAR EXCESS BITS
        ASL     R3              ;;;CONVERT UNIT NUMBER TO WORD INDEX
        ADD     R3,R5           ;;;CALCULATE ADDRESS OF UCB ADDRESS
        MOV     (R5),R5         ;;;GET ADDRESS OF UCB
        BEQ     40$             ;;;IF EQ NO UCB -- IGNORE INTERRUPT
        MOVB    U.CNT+2+DHBUF(R5),-(R4) ;;;OUTPUT NEXT BYTE
        BIC     $BTMSK(R3),-(R4) ;;;CLEAR BUFFER ACTIVE

        .ENDC                   ;;; DF D$$J11

        .IF DF  D$$J11!D$$Z11

5$:     MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOV     R5,R3           ;;;CALCULATE ADDRESS OF TERMINAL STATUS
        ADD     #U.CNT+2+STATS,R3 ;;;

        .IF DF  D$$H11!D$$L11

        BR      35$             ;;;

        .ENDC

        .ENDC                   ;;; DF D$$J11!D$$Z11

;+
; **-$DHOUT-DH11 TERMINAL MULTIPLEXER OUTPUT INTERRUPTS
;-


        .IF DF  D$$H11

$DHOUT::                        ;;;REF LABEL
        TTSAV$  DH,PR5,D$$H11   ;;;SAVE R3, R4, R5 AND LOWER
                                ;;; INTERRUPT PRIORITY
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER
        BIC     #101077,(R4)    ;;;CLEAR CURRENT UNIT AND TRANSMIT INT
10$:    MOV     (R3)+,R5        ;;;UNIT EXIST?
        BEQ     40$             ;;;IF EQ NO -- DONE
        BITB    #US.OUT,U.STS(R5) ;;;OUTPUT INTERRUPT EXPECTED?
        BEQ     20$             ;;;IF EQ NO
        TST     10(R4)          ;;;ZERO BYTE COUNT?
        BEQ     30$             ;;;IF EQ YES
20$:    INC     (R4)            ;;;INCREMENT UNIT NUMBER
        BR      10$             ;;;TRY AGAIN
30$:    MOV     R4,-(SP)        ;;;SAVE R4 AND R3
        MOV     R3,-(SP)        ;;;
        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOV     R5,R3           ;;;CALCULATE ADDRESS OF TERMINAL STATUS WORD
        ADD     #U.CNT+2+STATS,R3 ;;;
        CALL    50$             ;;;FINISH OUTPUT PROCESSING
        MTPS    #PR5            ;;;OUTPT MAY RETURN THRU $FORK
        MOV     (SP)+,R3        ;;;RESTORE R3 AND R4
        MOV     (SP)+,R4        ;;;
        BR      20$             ;;;GO AGAIN

        .ENDC

;+
; **-$DLOUT-DL11 TERMINAL OUTPUT INTERRUPTS
;-

        .IF DF  D$$L11
$DLOUT::                        ;;;REF LABEL
        TTSAV$  DL,PR4,D$$L11   ;;;SAVE R3, R4, R5 AND LOWER
                                ;;; INTERRUPT PRIORITY
                                ;;; SET R3= R5+U.CNT+2
                                ;;; SET R4=ADDRESS OF SCB
                                ;;; SET R5=ADDRESS OF UCB

        .ENDC

        .IF DF  D$$J11!D$$L11!D$$Z11

35$:    BITB    #US.OUT,U.STS(R5) ;;;OUTPUT INTERRUPT EXPECTED?
        BNE     50$             ;;;IF NE YES

        .ENDC

40$:    RETURN                  ;;;IGNORE SPURIOUS INTERRUPTS
50$:    BICB    #US.OUT,U.STS(R5) ;;;CLEAR OUTPUT INTERRUPT EXPECTED
        CLRB    S.CTM(R4)       ;;;DISABLE UNIT TIMEOUT
        CALLR   OUTPT           ;;;OUTPUT NEXT BYTE, IF THERE IS ONE

        .DSABL  LSB

        .SBTTL  TERMINAL TIMEOUT ROUTINE

;+
; TTOUT - TERMINAL DRIVER TIMEOUT ENTRY POINT
;
; ENTERED AT FORK LEVEL WITH
;       R5 -> UCB
;       R4 -> SCB
;       R3 -> CONTROLLER NUMBER
;       R2 -> CSR
;       R0 -> IE.DNR
;       INTERRUPT PRIORITY = THAT OF DEVICE
;
; EXITS BY GOING TO COMMON CODE AFTER REENABLING INTERRUPTS ON
; DEVICE
;-

TTOUT:                          ;;;REF LABEL

        .IF DF  D$$H11!D$$J11!D$$Z11

        MOV     U.CW2(R5),R1    ;;;MULTIPLEXED TERMINAL?

        .IF DF  D$$L11

; NEXT INSTRUCTION DEPENDS ON U2.DH1=100000

        BPL     25$             ;;;IF PL NO

        .ENDC

        .IF DF  D$$H11

        .IF DF  D$$J11!D$$Z11

        ASL     R1              ;;;DJ11 TERMINAL?

        .IF DF  D$$J11

; NEXT INSTRUCTION DEPENDS ON U2.DJ1=U2.DH1/2

        BMI     23$             ;;;IF MI YES

        .ENDC

        .IF DF  D$$Z11

        TSTB    R1              ;;;DZ11 TERMINAL?

; NEXT INSTRUCTION DEPENDS ON U2.DZ1=100

        BMI     22$             ;;;IF MI YES

        .ENDC

        .ENDC                   ;;; DF D$$J11!D$$Z11

        BIC     #1077,(R2)      ;;;CLEAR CURRENT UNIT
        BIS     #20100,(R2)     ;;;MAKE SURE INTERRUPTS ARE ENABLED
        BISB    U.UNIT(R5),(R2) ;;;SELECT DESIRED UNIT
        CLR     10(R2)          ;;;ZERO BYTE COUNT

        .IF DF  D$$J11!D$$Z11

        BR      25$             ;;;

        .ENDC

        .IFF                    ;;; DF D$$H11

        .IF DF  D$$J11&D$$Z11

        ASL     R1              ;;;DJ11 TERMINAL?

; NEXT INSTRUCTION DEPENDS ON U2.DJ1=U2.DH1/2

        BMI     23$             ;;;IF NE YES

        .ENDC

        .ENDC                   ;;; DF D$$H11

        .IF DF  D$$Z11

22$:    BIS     #40140,(R2)     ;;;MAKE SURE INTERRUPTS ENABLED

        .IF DF  D$$J11

        BR      25$             ;;;

        .ENDC

        .ENDC                   ;;; DF D$$Z11

        .IF DF  D$$J11

23$:    BIS     #40501,(R2)     ;;;MAKE SURE INTERRUPTS ARE ENABLED

        .ENDC

        .ENDC                   ;;; DF D$$H11!D$$J11!D$$Z11

25$:    BICB    #US.OUT,U.STS(R5) ;;;CLEAR OUTPUT INTERRUPT EXPECTED
        MTPS    #0              ;;;ALLOW DEVICE INTERRUPTS
        CALLR   TTOUT1          ;

        .SBTTL  CONTROLLER-DEPENDENT OUTPUT CHAR ROUTINE

;
; OCHAR - OUTPUT A CHARACTER TO A TERMINAL
;
; AT ENTRY:
;       R5 -> UCB
;       R4 -> SCB
;       (SP) = CHAR TO OUTPUT
;       INTERRUPT PRIORITY = THAT OF OUTPUT DEVICE
;
; EXITS VIA RETURN
;

        .ENABL  LSB

OCHAR:                          ;;;REF LABEL

        .IF DF  T$$SYN                                                          ; EB119
                                                                                ;**-1
        BIT     #UOFF,U.CNT+2+ATERS(R5) ;;;OUTPUT TURNED OFF?
        BNE     100$            ;;;IF NE YES

        .IFTF

FCHAR:  MOV     S.CSR(R4),R3    ;;;GET ADDRESS OF CSR
        MOVB    S.ITM(R4),S.CTM(R4) ;;;ENABLE TIMEOUT

        .IF DF  D$$H11!D$$J11!D$$Z11

        .IF DF  D$$L11

        TST     U.CW2(R5)       ;;;MULTIPLEXED TERMINAL?

; NEXT INSTRUCTION DEPENDS ON U2.DH1=100000

        BPL     90$             ;;;IF PL NO

        .ENDC

        MOVB    (SP)+,U.CNT+2+DHBUF(R5) ;;;PUT BYTE IN OUTPUT BUFFER
        MOVB    U.UNIT(R5),R4   ;;;GET PHYSICAL UNIT NUMBER

        .IF DF  D$$H11

        .IF DF  D$$J11!D$$Z11

        BIT     #U2.DJ1!U2.DZ1,U.CW2(R5) ;;;DJ11 OR DZ11?
        BNE     83$             ;;;IF NE YES

        .IFTF

        BIC     #1077,(R3)      ;;;CLEAR CURRENT UNIT
        BIS     R4,(R3)         ;;;SELECT DESIRED UNIT
        BIC     #60,(R3)+       ;;;
        ADD     #4,R3           ;;;POINT TO CURRENT ADDRESS REGISTER
        MOV     R5,(R3)         ;;;CALCULATE ADDRESS OF BYTE BUFFER
        ADD     #U.CNT+2+DHBUF,(R3)+ ;;;
        MOV     #-1,(R3)+       ;;;SET BYTE COUNT TO MINUS ONE

        .IFT

        BR      87$             ;;;

        .ENDC

        .IFTF                   ;;; DF D$$H11

        .IF DF  D$$J11!D$$Z11

83$:    ADD     #4,R3           ;;;POINT TO BUFFER ACTIVE REGISTER

        .ENDC

87$:    ASL     R4              ;;;CONVERT UNIT NUMBER TO WORD INDEX
        BIS     $BTMSK(R4),(R3) ;;;START OUTPUT

        .IF DF  D$$L11

        BR      95$             ;;;SET OUTPUT INT EXPECTED AND EXIT

        .ENDC

        .ENDC                   ;;; DF D$$H11

        .ENDC                   ;;; DF D$$H11!D$$J11!D$$Z11

        .IF DF  D$$L11

90$:    MOVB    (SP)+,6(R3)     ;;;OUTPUT BYTE
        BIS     #100,4(R3)      ;;;ENABLE OUTPUT INTERRUPT

        .ENDC

95$:    BISB    #US.OUT,U.STS(R5) ;;;SET OUTPUT INTERRUPT EXPECTED
        RETURN                  ;;;

        .IFT                    ;;; DF T$$SYN                                   ; EB119
                                                                                ;**-1
100$:   MOVB    (SP)+,U.CNT+2+DHBUF(R5) ;;;SAVE BYTE TO OUTPUT
        BIS     #UPND,U.CNT+2+ATERS(R5) ;;;SET OUTPUT BYTE PENDING
        RETURN                  ;;;

        .ENDC                   ;;; DF T$$SYN                                   ; EB119
                                                                                ;**-1

        .DSABL  LSB

        .SBTTL  CONTROLLER-DEPENDENT INPUT INTERRUPT CODE

        .ENABL  LSB

;+
; **-$DZINP-DZ11 TERMINAL MULTIPLEXER INPUT INTERRUPTS
;-

        .IF DF  D$$Z11

$DZINP::                        ;;;REF LABEL
        TTSAV$  DZ,PR5,D$$Z11   ;;;SAVE R3, R4, R5 AND LOWER
                                ;;; INTERRUPT PRIORITY
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER

        .IF DF  D$$H11!D$$J11

        BR      1$              ;;;

        .ENDC

        .ENDC                   ;;; DF D$$Z11

;+
; **-$DJINP-DJ11 TERMINAL MULTIPLEXER INPUT INTERRUPTS
;-

        .IF DF  D$$J11

$DJINP::                        ;;;REF LABEL
        TTSAV$  DJ,PR5,D$$J11   ;;;SAVE R3, R4, R5 AND LOWER
                                ;;; INTERRUPT PRIORITY
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER

        .IF DF  D$$H11

        BR      1$              ;;;

        .ENDC

        .ENDC                   ;;; DF  D$$J11

        .IF DF  D$$H11

;+
; **-$DHINP-DH11 TERMINAL MULTIPLEXER INPUT INTERRUPTS
;-

$DHINP::                        ;;;REF LABEL
        TTSAV$  DH,PR5,D$$H11   ;;;SAVE R3, R4, R5 AND LOWER
                                ;;; INTERRUPT PRIORITY
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER

        .ENDC

        .IF DF  D$$H11!D$$J11!D$$Z11

1$:     MOV     2(R4),-(SP)     ;;;GET NEXT BYTE FROM SILO
        BPL     5$              ;;;IF PL SILO IS EMPTY
        MOVB    1(SP),R5        ;;;GET PHYSICAL UNIT NUMBER
        BIC     #177760,R5      ;;;CLEAR EXCESS BITS
        ASL     R5              ;;;CONVERT UNIT NUMBER TO WORD INDEX
        ADD     R3,R5           ;;;ADD BASE ADDRESS OF UCB TABLE
        MOV     (R5),R5         ;;;GET ADDRESS OF UCB
        BEQ     5$              ;;;IF EQ SPURIOUS INTERRUPT

        .IF DF  D$$M11&D$$H11!D$$ZMD

        BITB    #US.DSB,U.STS(R5) ;;;UNIT DISABLED?
        BNE     5$              ;;;IF NE YES

        .ENDC

        MOV     U.SCB(R5),R4    ;;;GET ADDRESS OF SCB
        MOV     R5,R3           ;;;CALCULATE ADDRESS OF TERMINAL STATUS WORD
        ADD     #U.CNT+2+STATS,R3 ;;;

        .IF DF  D$$L11

        BR      2$              ;;;FINISH IN COMMON CODE

        .ENDC

        .ENDC                   ;;; DF D$$H11!D$$J11!D$$Z11

;+
; **-$DLINP-DL11 TERMINAL INPUT INTERRUPT
;-

        .IF DF  D$$L11

$DLINP::                        ;;;REF LABEL
        TTSAV$  DL,PR4,D$$L11   ;;;SAVE R3, R4, R5 AND LOWER
                                ;;; INTERRUPT PRIORITY
                                ;;; SET R3=R5+U.CNT+2
                                ;;; SET R4=ADDRESS OF SCB
                                ;;; SET R5=ADDRESS OF UCB
        MOV     S.CSR(R4),-(SP) ;;;GET ADDRESS OF CSR
        ADD     #2,(SP)         ;;;POINT TO DATA BUFFER REGISTER
        MOV     @(SP)+,-(SP)    ;;;GET INPUT BYTE AND ERROR BITS                ; EB105
                                                                                ;**-1
        .ENDC

2$:                             ;;;REF LABEL

        .IF NDF T$$MIN

        BIT     #60000,(SP)     ;;;HAD A HARD ERROR?
        BNE     5$              ;;;IF NE YES

        .ENDC

        .IF DF  T$$TRW

        .IIF NE SS.RAL-200,     .ERROR  SS.RAL

        TSTB    S.STS(R4)       ;;;READ PASS ALL?
        BMI     3$              ;;;IF MI YES

        .ENDC

        BIC     #177600,(SP)    ;;;CLEAR PARITY BIT AND HIGH BYTE

        .IF DF  T$$HLD!T$$SYN                                                   ; EB119
                                                                                ;**-1
        CMPB    #23,(SP)        ;;;TURN OUTPUT OFF?
        BEQ     4$              ;;;IF EQ YES
        CMPB    #21,(SP)        ;;;TURN OUTPUT ON?
        BEQ     6$              ;;;IF EQ YES

        .ENDC

        .IF DF  T$$HLD!T$$SYN

        CMPB    #3,(SP)         ;;;CHARACTER A CONTROL C?
        BEQ     8$              ;;;IF EQ YES

        .ENDC

3$:     CALLR   ICHAR

        .IF DF  T$$HLD!T$$SYN                                                   ; EB119
                                                                                ;**-1
;
; TURN OUTPUT OFF (RECEIVED A XOFF)
;

4$:     BIS     #UOFF,ATERS(R3) ;;;TURN OUTPUT OFF

        .IFTF

        .IF DF  T$$MIN

        .IF DF  D$$H11!D$$J11!D$$Z11                                            ; EB119
                                                                                ;**-1
5$:     TST     (SP)+           ;;;NOW IGNORE CHARACTER
        RETURN                  ;;;RETURN FROM INTERRUPT

        .ENDC

        .IFF                    ;;; DF T$$MIN

5$:     TST     (SP)+           ;;;NOW IGNORE CHARACTER
        RETURN                  ;;;RETURN FROM INTERRUPT

        .ENDC

        .IFT                    ;;; DF T$$HLD!T$$SYN                            ; EB119
                                                                                ;**-1
;
; TURN OUTPUT ON (RECEIVED A XON)
;

6$:     BIC     #UOFF,ATERS(R3) ;;;CLEAR HOLD OUTPUT FLAG

        .IIF NE UPND-200,       .ERROR  UPND

        TSTB    ATERS(R3)       ;;;OUTPUT BYTE PENDING?
        BPL     5$              ;;;IF PL NO
7$:     MOVB    DHBUF(R3),(SP)  ;;;GET HELD UP BYTE
7000$:  BIC     #UPND,ATERS(R3) ;;;CLEAR OUTPUT BYTE PENDING FLAG
        CALLR   OCHAR           ;;;OUTPUT BYTE

        .ENDC                   ;;; DF T$$HLD!T$$SYN                            ; EB119
                                                                                ;**-1
        .IF DF  T$$HLD!T$$SYN

;
; RECEIVED A CONTROL C.  IF IN HOLD-SCREEN MODE, GET OUT OF IT.
; IF OUTPUT TURNED OFF, TURN IT ON.  IN ANY CASE, GET TO MCR.
;

8$:     BIC     #UOFF,ATERS(R3) ;;;TURN OUTPUT ON

        .ENDC

        .IF DF  T$$HLD

        BIT     #U2.HLD,U.CW2(R5) ;;;IN HOLD-SCREEN MODE?

        .IF DF  T$$SYN

        BEQ     9$              ;;;IF EQ NO

        .IFF

        BEQ     3$              ;;;IF EQ NO

        .ENDC

        BIS     #BAKS!CCPN,ATERS(R3) ;;;FLAG SPECIAL MULTI-ECHO AND
                                ;;; HAVE CONTROL/C
        BIC     #U2.HLD,U.CW2(R5) ;;;SHOW NOT IN HOLD-SCREEN MODE

;
; WANT TO GET OUT OF HOLD-SCREEN MODE (SEND "ESC \" TO TERMINAL AND
; HOPE IT EVENTUALLY PAYS ATTENTION), SEND CHAR HELD UP BY CONTROL/S,
; AND PROMPT WITH "MCR>."  ASSUME WE CANNOT IMMEDIATELY KICK TERMINAL
; OUT OF HOLD-SCREEN MODE (THE TERMINAL'S SILO AND THE INTERFACE'S
; DOUBLE BUFFERING PROBABLY HAVE STACKED UP CHARACTERS).  SO SEND HELD
; UP CHAR FIRST, BECAUSE IT IS CONVENIENT.  BECAUSE CONTROL/C IS
; CONSIDERED BY THE USER TO BE DESTRUCTIVE,  HE OR SHE SHOULD NOT BE
; CONCERNED WITH OUR ABUSE OF THE OUTPUT STREAM FLAGS.
;

        MOV     #LEVHSM,MEBUF(R3) ;;;MULTI-ECHO ESCAPE SEQUENCE
        BIC     #LFCT!FLCT,(R3) ;;;CLEAN UP FIELD FOR "MCR>"

        .IIF NE UPND-200,       .ERROR  UPND

        TSTB    ATERS(R3)       ;;;SOMETHING IN DHBUF?
        BMI     7$              ;;;IF MI YES
        TST     (SP)+           ;;;CLEAN UP STACK
        CALLR   XITHSM          ;;;START SENDING ESCAPE SEQUENCE

        .ENDC                   ;;; DF T$$HLD

        .IF DF  T$$SYN

        .IIF NE UPND-200,       .ERROR  UPND

9$:     TSTB    ATERS(R3)       ;;;OUTPUT PENDING?
        BPL     3$              ;;;IF PL NO
        BIS     #CCPN,ATERS(R3) ;;;TRY FOR AN MCR PROMPT
        BR      7$              ;;;

        .ENDC

        .DSABL  LSB

        .SBTTL  CONTROLLER-DEPENDENT POWERFAIL CODE

;+
; TTPWF - POWERFAIL AND LOADED AS LOADABLE DRIVER ENTRY POINT
;
; ENTERED AT FORK LEVEL WITH
;       R5 -> UCB
;       R4 -> SCB
;       R3 = CONTROLLER INDEX
;-

TTPWF:  MOV     S.CSR(R4),R2    ;GET ADDRESS OF CSR

        .IF DF  D$$H11!D$$J11!D$$Z11

        MOV     U.CW2(R5),R0    ;MULTIPLEXED TERMINAL?

        .IF DF  D$$L11

; NEXT INSTRUCTION DEPENDS ON U2.DH1=100000

        BPL     20$             ;IF PL NO

        .ENDC

        MOVB    U.UNIT(R5),R1   ;GET PHYSICAL UNIT NUMBER

        .IF DF  D$$H11

        ASL     R0              ;DJ11 TERMINAL?

        .IF DF  D$$J11

; NEXT INSTRUCTION DEPENDS ON U2.DJ1=U2.DH1/2

        BMI     15$             ;IF MI YES

        .ENDC

        .IF DF  D$$Z11

; NEXT INSTRUCTION DEPENDS ON U2.DZ1=100

        TSTB    R0              ;DZ11 TERMINAL?
        BMI     18$             ;IF MI YES

        .ENDC

        TST     R1              ;LINE ZERO?
        BNE     5$              ;IF NE NO
        MOV     #4000,(R2)      ;CLEAR SILO, UARTS, AND DH11 CONTROLLER
        MOV     #20100,(R2)     ;ENABLE INTERRUPTS
5$:     MOV     R2,DHCSR(R3)    ;SAVE ADDRESS OF DH11 CSR
        MTPS    S.PRI(R4)       ;;;LOCK OUT DEVICE INTERRUPTS
        BIC     #1077,(R2)      ;;;CLEAR CURRENT UNIT
        BIS     R1,(R2)         ;;;SELECT DESIRED UNIT
        MOV     U.CW3(R5),4(R2) ;;;SET UNIT PARAMETERS
        ASL     R1              ;;;CONVERT UNIT TO WORD INDEX
        ADD     DHTBL(R3),R1    ;;;CALCULATE ADDRESS TO STORE UCB ADDRESS
        MOV     R5,(R1)         ;;;SAVE ADDRESS OF UCB
        BICB    #US.CRW!US.DSB,U.STS(R5) ;;;ASSUME LOCAL UNIT

        .IF DF  D$$M11

; NEXT INSTRUCTION DEPENDS ON U2.RMT=U2.DJ1/2

        ASL     R0              ;;;LOCAL UNIT?
        BPL     14$             ;;;IF PL YES
        MOV     U.CNT+2+DMCSR(R5),R1 ;;;GET ADDRESS OF DM11-BB CSR
        MOV     @#4,-(SP)       ;;;SAVE ADDRESS OF TRAP PC
        MOV     #13$,@#4        ;;;CHANGE SO TRAP WILL COME TO US
        TST     (R1)            ;;;LIED ABOUT EXISTENCE OF DM11?
        MOV     (SP)+,@#4       ;;;RESTORE SYSTEM TRAP 4 PC
        BCS     35$             ;;;IF CS YES (13$ LOWERED
                                ;;; PRIORITY AND SET C)
        MOV     R1,DMTBL(R3)    ;;;SAVE ADDRESS OF DM11-BB CSR
        CALL    DMHUP           ;;;HANG UP UNIT IF NOT READY
        MTPS    #0              ;;;ALLOW DEVICE INTERRUPTS

        .IF DF  L$$DRV&LD$TT

        MOV     CLKSW,R0        ;CLOCK QUEUE ENTRY ALREADY MADE?
        BNE     35$             ;IF NE YES
        MOV     U.DCB(R5),R0    ;POINT AT DCB                                   ; EB154
        MOV     D.UCB(R0),R0    ;POINT AT FIRST UCB                             ; EB154
        MOV     U.SCB(R0),R0    ;POINT AT FIRST SCB                             ; EB154
        ADD     #S.DHCK,R0      ;POINT AT CLOCK QUEUE ENTRY                     ; EB154
        MOV     #DMTMO,12(R0)   ;INSERT SUBROUTINE ENTRY POINT                  ;**-2
        MOV     R0,CLKSW        ;SAVE POINTER TO CLOCK QUEUE ENTRY

        .IFF

        MOV     #CLKSW,R0       ;POINT TO CLOCK SWITCH WORD
        TST     (R0)            ;CLOCK QUEUE ENTRY ALREADY MADE?
        BNE     35$             ;IF NE YES
        MOV     PC,(R0)+        ;INDICATE CLOCK QUEUE ENTRY MADE

        .ENDC

        CALLR   DMCLK           ;INSERT ENTRY IN CLOCK QUEUE

;
; CONTROL GOES TO 13$ IF CSR OF DM11 IS NOT IN PRESENT ADDRESS SPACE
;

13$:    MOVB    #1,2(SP)        ;;;LOWER PRIORITY TO ZERO, SET C
                                ;;; AND DEVESTATE T BIT
        RTI                     ;;;BACK TO DH POWERFAIL

        .ENDC                   ;;; DF D$$M11

14$:    MTPS    #0              ;;;ALLOW DEVICE INTERRUPTS

        .IF DF  D$$J11!D$$Z11!D$$L11

        BR      35$             ;;;

        .ENDC

        .IFF                    ; DF D$$H11

        .IF DF  D$$J11&D$$Z11

        ASL     R0              ;DZ11 TERMINAL?
        BPL     18$             ;IF PL YES

        .ENDC

        .ENDC                   ; DF D$$H11

        .IF DF  D$$J11

15$:    MOV     R2,DJCSR(R3)    ;SAVE ADDRESS OF DJ11 CSR
        ASL     R1              ;CONVERT UNIT TO WORD INDEX
        BNE     17$             ;IF NE NOT LINE ZERO
        MOV     #10,(R2)        ;CLEAR SILO, UARTS, AND DJ11 CONTROLLER
16$:    BIT     #20,(R2)        ;CLR COMPLETED?
        BNE     16$             ;IF NE NO
        BIS     #40501,(R2)     ;ENABLE INTERRUPTS
17$:    ADD     DJTBL(R3),R1    ;CALCULATE ADDRESS TO STORE UCB

        .IF DF  D$$Z11

        .IF NDF D$$ZMD

        BR      192$            ;EXIT COMMONLY

        .IFF

        MOV     R5,(R1)         ;SAVE ADDRESS OF UCB
        BR      35$             ;

        .ENDC

        .IFF                    ; DF D$$Z11

        MOV     R5,(R1)         ;SAVE ADDRESS OF UCB

        .IF DF  D$$H11!D$$L11

        BR      35$             ;

        .ENDC

        .ENDC                   ; DF D$$Z11

        .ENDC                   ; DF D$$J11

        .IF DF  D$$Z11

18$:    MOV     R2,DZCSR(R3)    ;SAVE ADDR OF DZ11 CSR
        ASL     R1              ;CONVERT UNIT # TO WORD INDEX
        BNE     191$            ;IF NE NOT FIRST UNIT
        MOV     #20,(R2)        ;CLR SILO, UARTS, AND CONTROLLER
19$:    BIT     #20,(R2)        ;CLR DONE YET?
        BNE     19$             ;IF NE NO
        BIS     #40140,(R2)     ;ENABLE INTERRUPTS
191$:   ADD     DZTBL(R3),R1    ;FORM ADDR TO STORE UCB
        MOV     U.CW3(R5),2(R2) ;SET INITIAL CHARACTERISTICS
192$:   MOV     R5,(R1)         ;SAVE ADDRESS OF UCB

        .IF DF  D$$ZMD

        .IF DF  L$$DRV&LD$TT

        MOV     DZCLKS,R0       ;CLOCK QUEUE ENTRY ALREADY MADE?
        BNE     35$             ;IF NE YES
        MOV     U.DCB(R5),R0    ;POINT AT DCB                                   ; EB154
        MOV     D.UCB(R0),R0    ;POINT AT FIRST UCB                             ; EB154
        MOV     U.SCB(R0),R0    ;POINT AT FIRST SCB                             ; EB154
        ADD     #S.DZCK,R0      ;POINT AT CLOCK QUEUE ENTRY                     ; EB154
        MOV     #DZTMO,12(R0)   ;INSERT SUBROUTINE ADDRESS                      ;**-2
        MOV     R0,DZCLKS       ;SAVE POINTER TO CLOCK QUEUE ENTRY

        .IFF

        MOV     #DZCLKS,R0      ;POINT AT CLOCK SWITCH WORD
        TST     (R0)            ;CLOCK ENTRY ALREADY QUEUED?
        BNE     35$             ;IF NE YES
        MOV     PC,(R0)+        ;MARK ENTRY AS QUEUED

        .ENDC

        CALLR   DZCLK           ;INSERT ENTRY IN CLOCK QUEUE

        .IFF

        .IF DF  D$$L11

        BR      35$             ;

        .ENDC

        .ENDC                   ; DF D$$ZMD

        .ENDC                   ; DF D$$Z11

        .ENDC                   ; DF D$$H11!D$$J11!D$$Z11

        .IF DF  D$$L11

20$:    MOV     R5,CNTBL(R3)    ;SAVE ADDRESS OF UCB
        MOVB    2(R2),R0        ;CLEAR DL11 INPUT DATA BUFFER REGISTER
        BIS     #100,(R2)       ;ENABLE RECEIVER INTERRUPTS

        .ENDC

35$:    RETURN

        .SBTTL  MISCELLANEOUS CONTROLLER-DEPENDENT SUBROUTINES

        .ENABL  LSB

;
; DH11 TERMINAL MULTIPLEXER SAVE ROUTINE
;

        .IF DF  D$$H11

DHSAV:  TTSET$  DH,D$$H11,MUX   ;;;SAVE R3
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER

        .IF DF  D$$Z11!D$$J11!D$$L11

        BR      20$             ;;;FINISH IN COMMON CODE

        .ENDC

        .ENDC                   ;;; DF D$$H11

;
; DZ11 TERMINAL MULTIPLEXER SAVE ROUTINE
;

        .IF DF  D$$Z11

DZSAV:  TTSET$  DZ,D$$Z11,MUX   ;;;SAVE R3
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER

        .IF DF  D$$J11!D$$L11

        BR      20$             ;;;FINISH IN COMMON CODE

        .ENDC

        .ENDC                   ;;; DF D$$Z11

;
; DJ11 TERMINAL MULTIPLEXER SAVE ROUTINE
;

        .IF DF  D$$J11

DJSAV:  TTSET$  DJ,D$$J11,MUX   ;;;SAVE R3
                                ;;; SET R3=ADDR OF UCB TABLE
                                ;;; SET R4=CSR OF INTERRUPTER

        .IF DF  D$$L11

        BR      20$             ;;;FINISH IN COMMON CODE

        .ENDC

        .ENDC                   ;;; DF D$$J11

;
; DL11 TERMINAL SAVE ROUTINE
;

        .IF DF  D$$L11

DLSAV:  TTSET$  DL,D$$L11       ;;;SAVE R3
                                ;;; SET R5=ADDR OF UCB
        MOV     U.SCB(R5),R4    ;;;RETRIEVE ADDRESS OF SCB
        MOV     R5,R3           ;;;CALCULATE ADDRESS OF TERMINAL
        ADD     #U.CNT+2+STATS,R3 ;;; CONTROL BLOCK

        .ENDC

20$:    CALL    @(SP)+          ;;;CALL THE CALLER BACK
        MOV     (SP)+,R3        ;;;RESTORE R3
        RETURN                  ;;;EXIT FROM INTERRUPT

        .DSABL  LSB

;+
; **-$DM11B-DM11-BB MODEM CONTROL MULTIPLEXER INTERRUPTS
;-

        .IF DF  D$$M11

$DM11B::                        ;;;REF LABEL

        .IF NDF L$$DRV!M$$MGE!LD$TT

        .IF GT  D$$M11-1

        MFPS    DHTMP           ;;;SAVE CONTROLLER NUMBER

        .IFTF

        CALL    $INTSV,PR5      ;;;SAVE REGISTERS AND SET PRIORITY
        MOV     R3,-(SP)        ;;;SAVE R3 AND R2
        MOV     R2,-(SP)        ;;;

        .IFT

        MOV     DHTMP,R3        ;;;RETRIEVE SAVED PS WORD
        BIC     #177760,R3      ;;;CLEAR ALL BUT CONTROLLER NUMBER
        ASL     R3              ;;;CONVERT TO WORD INDEX

        .IFF

        CLR     R3              ;;;SET CONTROLLER NUMBER TO ZERO

        .ENDC

        .IFF                    ;;; NDF L$$DRV!M$$MGE!LD$TT

        MOV     R3,-(SP)        ;;;SAVE R3 AND R2
        MOV     R2,-(SP)        ;;;

        .IF GT  D$$M11-1

        MOV     R4,R3           ;;;EXEC INTERRUPT ROUTINES PUT
                                ;;; CONTROLLER NUMBER IN R4

        .IFF

        CLR     R3              ;;;SET CONTROLLER NUMBER TO ZERO

        .ENDC

        .ENDC                   ;;; NDF L$$DRV!M$$MGE!LD$TT

        MOV     DMTBL(R3),R4    ;;;GET ADDRESS OF DM11-BB CSR
        BEQ     50$             ;;;IF EQ SPURIOUS INTERRUPT
        MOV     (R4)+,R5        ;;;GET INTERRUPT STATUS
        MOV     R5,-(SP)        ;;;SAVE INTERRUPT STATUS
        BIC     #177760,R5      ;;;CLEAR ALL BUT UNIT NUMBER
        ASL     R5              ;;;CONVERT UNIT NUMBER TO WORD INDEX
        ADD     DHTBL(R3),R5    ;;;CALCULATE ADDRESS OF UCB ADDRESS
        MOV     (R5),R5         ;;;GET ADDRESS OF UCB
        BNE     4$              ;;;IF NE CORRESPONDING DH11 UCB EXISTS
        TST     (SP)+           ;;;REMOVE INTERRUPT STATUS FROM STACK
        BR      50$             ;;;IGNORE INTERRUPT
4$:     BIS     #7,(R4)         ;;;SET REQUEST SEND+DATA ENABLE+
                                ;;; RING ENABLE
        MOV     (R4),R2         ;;;GET UNIT STATUS
        COM     R2              ;;;COMPLEMENT UNIT STATUS
        BIC     #1200,-(R4)     ;;;REENABLE SCANNING
        ASL     (SP)+           ;;;RING, CARRIER, OR CLEAR TO SEND TRANSITION?
        BCS     10$             ;;;IF CS RING

;
; CARRIER OR CLEAR TO SEND TRANSITION
;

        MOVB    #2,U.CNT+2+DMTIM(R5) ;;;ASSUME CARRIER OR CLR TO SEND NOT SET
        BIT     #140,R2         ;;;CARRIER AND CLEAR TO SEND SET?
        BNE     40$             ;;;IF NE NO
        BITB    #US.DSB,U.STS(R5) ;;;UNIT DISABLED?
        BEQ     30$             ;;;IF EQ NO
        BR      20$             ;;;FINISH IN COMMON CODE

;
; RING TRANSITION
;

10$:    MOVB    #7,U.CNT+2+DMTIM(R5) ;;;ASSUME CARRIER OR CLR TO SEND NOT SET
        BIT     #140,R2         ;;;CARRIER AND CLEAR TO SEND SET?
        BNE     40$             ;;;IF NE NO
20$:    BICB    #US.DSB,U.STS(R5) ;;;ENABLE UNIT
        MOV     DHCSR(R3),R4    ;;;GET ADDRESS OF DH11 CSR
        BIC     #1077,(R4)      ;;;CLEAR CURRENT UNIT
        BISB    U.UNIT(R5),(R4) ;;;SELECT DESIRED UNIT
                                                                                ; EB212
        .IF NDF USESDH                                                          ; EB212
                                                                                ; EB212
        MOV     #T$$MAN,U.CW3(R5) ;;;REMEMBER SYSGEN SPECIFIED                  ; EB212
                                  ;;;ANSWER BAUD RATE                           ; EB212
                                                                                ; EB212
        .ENDC                                                                   ; EB212
                                                                                ; EB212
        MOV     U.CW3(R5),4(R4) ;;;SET LINE TO ANSWER BAUD RATE                 ; EB212
        BIC     #U2.CRT!U2.ESC!U2.HLD!U2.L3S!U2.VT5!U2.LWC,U.CW2(R5) ;;;        ;**-1
        MOV     #72.,U.CW4(R5)  ;;;SET INITIAL BUFFER SIZE                      ;**-1
        MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS                              ; EB211
        TSTB    S.STS(R4)       ;;;IS I/O IN PROGRESS?                          ; EB211
        BNE     30$             ;;;IF NE YES                                    ; EB211
        BICB    #US.BSY!US.ECH!US.OUT,U.STS(R5) ;;;CLEAR BITS THAT              ; EB211
                                                ;;;SHOULD NEVER BE SET          ; EB211
30$:    BICB    #US.CRW,U.STS(R5) ;;;CLEAR CARRIER WAIT
        BR      50$             ;;;
40$:    BISB    #US.CRW,U.STS(R5) ;;;SET CARRIER WAIT
50$:    MOV     (SP)+,R2        ;;;RESTORE R2 AND R3
        MOV     (SP)+,R3        ;;;
        RETURN                  ;;;EXIT FROM INTERRUPT

;
; SUBROUTINE TO HANG UP A DM11-BB UNIT IF NOT READY
;
; INPUTS:
;
;       R1=CSR ADDR OF DM11-BB
;       R5=UCB ADDR
;
; OUTPUTS:
;
;       NO REGISTERS ARE DESTROYED
;       UCB AND DM11-BB STATUSES ARE MODIFIED
;

DMHUP:  BICB    #US.CRW!US.DSB,U.STS(R5) ;;;CLEAR CARRIER WAIT AND ENABLE UNIT
        BIC     #1040,(R1)      ;;;DISABLE SCAN
10$:    BIT     #20,(R1)        ;;;SCAN STOPPED?
        BNE     10$             ;;;IF NE NO
        MOV     (R1),-(SP)      ;;;CANNOT USE BYTE INSTRUCTIONS
                                ;;; ON DM11-BB (UNDOCUMENTED)
        BIC     #1017,(SP)      ;;;CLEAR CURRENT UNIT
        BISB    U.UNIT(R5),(SP) ;;;SET DESIRED UNIT
        MOV     (SP)+,(R1)+     ;;;TELL DM11-BB ABOUT IT
        BIS     #7,(R1)         ;;;SET REQUEST SEND+DATA ENABLE+RING ENABLE
        MOV     (R1),-(SP)      ;;;GET CURRENT UNIT STATUS
        COM     (SP)            ;;;COMPLEMENT UNIT STATUS
        BIT     #140,(SP)+      ;;;CARRIER AND CLEAR TO SEND SET?
        BEQ     20$             ;;;IF EQ YES
        BISB    #US.DSB,U.STS(R5) ;;;DISABLE UNIT
        BIC     #17,(R1)        ;;;CLEAR CURRENT UNIT STATUS
        INC     (R1)            ;;;ENABLE RING INTERRUPT
        CLC                     ;;;INDICATE UNIT HUNG UP
20$:    BIS     #140,-(R1)      ;;;RESTART SCAN AND ENABLE INTERRUPT
        RETURN                  ;;;

;
; DMTMO - DM11-BB TIME OUT ROUTINE
;
; THIS ROUTINE IS ENTERED EVERY 4 SECONDS FROM THE TIME DEPENDENT SCHEDULER
; TO CHECK FOR DM11-BB TIMEOUTS.
;
; INPUTS:
;
;       NONE
;
; OUTPUTS:
;
;       ALL DM11-BB UNITS ARE EXAMINED FOR TIMEOUT. IF A TIMEOUT OCCURS,
;       THEN THE UNIT IS HUNG UP.
;

DMTMO:  MOV     #D$$M11,R0      ;SET NUMBER OF DM11-BB'S
        CLR     R3              ;CLEAR CONTROLLER INDEX
10$:    MOV     DHTBL(R3),R2    ;GET ADDRESS OF UCB TABLE
20$:    MTPS    #0              ;ALLOW DEVICE INTERRUTPS
        MOV     (R2)+,R5        ;GET ADDRESS OF NEXT UCB
        BEQ     30$             ;IF EQ END OF LIST
        BITB    #US.OFL,U.ST2(R5) ;IS THE LINE OFFLINE?
        BNE     30$             ;IF NE YES -- OTHERS ARE ALSO
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        MTPS    S.PRI(R4)       ;;;LOCK OUT DEVICE INTERRUPTS
        BITB    #US.CRW,U.STS(R5) ;;;WAITING FOR CARRIER?
        BEQ     20$             ;;;IF EQ NO
        DECB    U.CNT+2+DMTIM(R5) ;;;ANY TIME REMAINING?
        BNE     20$             ;;;IF NE YES
        MOV     DMTBL(R3),R1    ;;;GET ADDRESS OF DM11-BB CSR
        CALL    DMHUP           ;;;HANG UP UNIT
        BCS     20$             ;;;IF CS UNIT NOT HUNG UP
        CALL    TTHUP           ;;;DO SPECIAL I/O CANCEL FOR HANGUP
        BR      20$             ;;;
30$:    TST     (R3)+           ;ADVANCE CONTROLLER INDEX
        DEC     R0              ;ANY MORE DM11-BB'S?
        BGT     10$             ;IF GT YES

        .IF DF  L$$DRV&LD$TT

        MOV     CLKSW,R0        ;POINT AT CLOCK QUEUE CONTROL BLOCK

        .IFF

        MOV     #CLKSW+2,R0     ;GET ADDRESS OF CLOCK QUEUE CONTROL BLOCK

        .ENDC

DMCLK:  CLR     R1              ;ZERO HIGH ORDER DELTA TIME
        MOV     $TKPS,R2        ;GET CLOCK TICKS PER SECOND
        ASL     R2              ;CONVERT TO 4 SECOND INTERVAL
        ASL     R2              ;
INSCLK: MOV     #C.SYST,R4      ;SET TYPE TO SYSTEM SUBROUTINE
        CALLR   $CLINS          ;INSERT ENTRY IN CLOCK QUEUE

        .ENDC                   ; DF D$$M11

        .IF DF  D$$ZMD

;+
; DZTMO - DZ11 TIME OUT ROUTINE
;
; THIS ROUTINE IS ENTERED EVERY HALF SECOND TO CHECK FOR ANY
; CHANGE IN CARRIER STATUS ON ANY DZ11 REMOTE LINE.
;
; INPUTS:
;
;       NONE
;
; OUTPUTS:
;
;       DESTROYS R0, R1, R2, R3, R4, R5
;
;       IF A REMOTE ENABLED LINE LOSES CARRIER, IT IS HUNG UP.  IF
;       A REMOTE, DISABLED LINE ASSERTS CARRIER, IT IS ENABLED ON THE
;       ASSUMPTION THAT IT HAS RUNG AND HAS BEEN ANSWERED.  ANSWERING
;       IS AUTOMATIC FOR LINES THAT HAVE DATA TERMINAL READY ASSERTED,
;       AND LINE HANG UP IS AUTOMATIC WHEN DTR IS DEASSERTED.
;       DISABLED IS A LOGICAL STATUS WHERE TTDRV IGNORES ANY INPUT
;       FROM THE LINE AND REJECTS ANY OUTPUT TO IT.
;                                                                               ; EB213
; NOTE: NOT ALL MODEMS CAN BE CORRECTLY HANDLED BY THIS CODE.                   ; EB213
;       THIS IS A CONSEQUENCE OF SOME TELEPHONE EXCHANGES,                      ; EB213
;       SOME MODEMS, AND THE DZ11.  THE PRIMARY CONSTRAINTS                     ; EB213
;       ARE:                                                                    ; EB213
;                                                                               ; EB213
;   1)  THE DZ11 PROVIDES ONLY A FEW MODEM CONTROL SIGNALS.                     ; EB213
;                                                                               ; EB213
;   2)  THE DZ11 DOES NOT INTERRUPT ON CHANGES IN STATE OF                      ; EB213
;       MODEM CONTROL SIGNALS.  AS A CONSEQUENCE, THE                           ; EB213
;       SIGNALS MUST BE POLLED.  ANY POLLING PUTS A LOAD ON                     ; EB213
;       THE CPU.  POLLING FAST ENOUGH TO HAVE A SIGNIFICANT                     ; EB213
;       CHANCE OF CATCHING TRANSIENT SIGNALS PLACES AN                          ; EB213
;       UNACCEPTABLE, FOR MOST INSTALLATIONS, BURDEN ON                         ; EB213
;       THE CPU.                                                                ; EB213
;                                                                               ; EB213
;   3)  THE RING SIGNAL IS NOT CONDITIONED OR LATCHED.                          ; EB213
;       ITS SMOOTHNESS, SPIKINESS, DURATION, INTERVALS,                         ; EB213
;       ETC. ARE A DIRECT FUNCTION OF THE TELEPHONE                             ; EB213
;       EXCHANGE.  COMBINED WITH NUMBER 2 ABOVE, THIS                           ; EB213
;       MEANS THAT, IN GENERAL, RING CANNOT BE USED.                            ; EB213
;       THE LARGEST PART OF DEALING WITH THE TELEPHONE                          ; EB213
;       SYSTEM IS PLACED ON THE MODEM.                                          ; EB213
;-

DZTMO:  MOV     #D$$Z11,R0      ;SAVE NUMBER OF DZ11'S IN SYSTEM
        CLR     R3              ;START AT MULTIPLEXER ZERO
10$:    MOV     DZTBL(R3),R2    ;GET ADDRESS OF UCB'S FOR THIS MUX
        MOV     DZCSR(R3),R1    ;GET CSR ADDRESS FOR MULTIPLEXER
20$:    MOV     (R2)+,R5        ;GET UCB ADDRESS FOR NEXT LINE ON MUX
        BEQ     30$             ;IF EQ NO MORE LINES TO EXAMINE
        BIT     #U2.RMT,U.CW2(R5) ;THIS A REMOTE LINE?
        BEQ     20$               ;IF EQ NO                                     ; EB213
        BITB    #US.OFL,U.ST2(R5) ;IS THE LINE OFFLINE?                         ;**-1
        BNE     30$               ;IF NE YES -- OTHER UNITS ARE ALSO            ; EB213
        MOVB    U.UNIT(R5),R4   ;GET LINE NUMBER                                ;**-1
        ASL     R4              ;CONVERT TO WORD INDEX
        MOV     $BTMSK(R4),R4   ;IN R4, ASSERT BIT N FOR UNIT N
        BISB    R4,5(R1)        ;ENABLE DTR FOR THIS LINE
        BITB    R4,7(R1)        ;CARRIER ASSERTED?
        BEQ     25$             ;IF EQ NO
        BITB    #US.DSB,U.STS(R5) ;UNIT HUNGUP?
        BEQ     20$               ;IF EQ NO                                     ; EB213
                                                                                ; EB212
        .IF DF  USESDZ                                                          ; EB212
                                                                                ; EB212
        MOV     U.CW3(R5),2(R1) ;ANSWER AT BAUD RATE OF LAST                    ; EB212
                                ;SET /SPEED COMMAND                             ; EB212
                                                                                ; EB212
        .IFF                                                                    ; EB212
                                                                                ; EB212
        MOV     #T$$ZAN,-(SP)   ;GET ANSWER LINE CHARACTERISTICS                ;**-1
        BISB    U.UNIT(R5),(SP) ;MAKE THEM FOR THIS LINE
        MOV     (SP),2(R1)      ;PUT THEM INTO EFFECT
        MOV     (SP)+,U.CW3(R5) ;SAVE THEM FOR MCR AND POWERFAIL
                                                                                ; EB212
        .ENDC                                                                   ; EB212
                                                                                ; EB212
        BIC     #U2.CRT!U2.ESC!U2.HLD!U2.L3S!U2.VT5!U2.LWC,U.CW2(R5) ;
        MOV     #72.,U.CW4(R5)  ;START LINE IN A KNOWN STATE
        MOV     U.SCB(R5),R4    ;GET SCB ADDRESS                                ; EB211
        TSTB    S.STS(R4)       ;IS I/O IN PROGRESS?                            ; EB211
        BNE     23$             ;IF NE YES                                      ; EB211
        BICB    #US.BSY!US.ECH!US.OUT,U.STS(R5) ;CLEAR BITS THAT                ; EB211
                                                ;SHOULD NEVER BE SET            ; EB211
23$:    BICB    #US.DSB!US.CRW,U.STS(R5) ;ENABLE LINE (LOGICALLY                ; EB213
        BR      20$                      ;ANSWER IT)                            ; EB213
25$:    BITB    #US.CRW,U.STS(R5) ;WAITING FOR CARRIER?                         ; EB213
        BEQ     27$               ;IF EQ NO                                     ; EB213
        DECB    U.CNT+2+DZTIM(R5) ;WAITED TOO LONG?                             ; EB213
        BNE     20$               ;IF EQ NO                                     ; EB213
        BICB    #US.CRW,U.STS(R5) ;SHOW NOT WAITING FOR CARRIER                 ; EB213
        BICB    R4,5(R1)          ;CLEAR MODEM (TELL IT TO HANG UP)             ; EB213
        BR      20$               ;                                             ; EB213
27$:    BITB    #US.DSB,U.STS(R5) ;LINE ALREADY HUNG UP?                        ; EB213
        BEQ     28$               ;IF EQ NO                                     ; EB213
        BISB    #US.CRW,U.STS(R5)    ;SHOW WAITING FOR CARRIER                  ; EB213
        MOVB    #50,U.CNT+2+DZTIM(R5) ;INITIALIZE COUNTER                       ; EB213
        BR      20$             ;                                               ; EB213
28$:    BICB    R4,5(R1)        ;LOWER DTR TO HANG UP                           ; EB213
        MOV     U.SCB(R5),R4    ;TTHUP MAY NEED SCB ADDRESS                     ;**-5
        CALL    TTHUP           ;LOG OUT USER IF NECESSARY
        BCS     20$             ;IF CS TRY TO SAY BYE LATER
        BISB    #US.DSB,U.STS(R5) ;DISABLE LINE (LOGICALLY HANGUP)
        BR      20$             ;
30$:    TST     (R3)+           ;INDEX TO NEXT MULTIPLEXER
        DEC     R0              ;LOOKED AT THEM ALL?
        BGT     10$             ;IF GT NO

        .IF DF  L$$DRV&LD$TT

        MOV     DZCLKS,R0       ;POINT AT CLOCK QUEUE ENTRY

        .IFF

        MOV     #DZCLKS+2,R0    ;REINSERT CLOCK ENTRY

        .ENDC

DZCLK:  CLR     R1              ;ZERO HIGH ORDER DELTA TIME
        MOV     $TKPS,R2        ;GET CLOCK TICKS PER SECOND
        ASR     R2              ;WANT A HALF SECOND INTERVAL

        .IF DF  D$$M11

        BR      INSCLK          ;INSERT ENTRY INTO CLOCK QUEUE

        .IFF

        MOV     #C.SYST,R4      ;SET TYPE TO SYSTEM SUBROUTINE
        CALLR   $CLINS          ;INSERT ENTRY IN CLOCK QUEUE

        .ENDC

        .ENDC                   ; DF D$$ZMD

        .END
        .TITLE  TTFP
        .IDENT  /V01.11/
;
; 09-FEB-78 PETER WANNHEDEN
;
; MODIFICATIONS
;
;       DD008   06-NOV-78       DALE R. DONCHIN
;               DON'T ATTEMPT MCR CONTINUATION LINES FOR RSX11M.
;               REQUEST A SPECIAL CLI PROMPT ON NULL LINES TO SAVE POOL
;       DD009   08-NOV-78       DALE R. DONCHIN
;               FIX AND IMPROVE NOECHO HANDLING
;       CJR001  22-FEB-79       CRAIG J. RICHARDSON
;               ADD SCS-11 CONTROL/C SUPPORT
;       DD015   28-FEB-79       DALE R. DONCHIN
;               ADD SEPARATE ^C AST
;
;+
; MODULE TTFP - CONTAINS FORK LEVEL PROCESSING ROUTINES FOR THE
; FOLLOWING FORK REQUESTS:
;       FR.SUI          START OF UNSOLICITED INPUT
;       FR.AST          CHARACTER THAT CAUSES AST RECEIVED
;
; ALL THESE ROUTINES ARE CALLED BY THE FORK DISPATCHER WITH:
;       R4      POINTER TO UCBX (IF IT EXISTS)
;       R5      POINTER TO U.TSTA
;       S1.DSI  1 TO DISABLE INPUT PROCESSING
;-
;
;
.SBTTL  FPSUI - START OF UNSOLICITED INPUT.
;
        .ENABL  LSB
;
FPSUI:: CALL    GCTAB           ;GET CHARACTER THAT STARTS UNSOL. INPUT
        BCS     20$             ;NOT THERE ANY MORE - FORGET IT
        CMPB    R2,#CH.SP       ;IS IT A "FUNNY" CHARACTER (CONTROL
                                ;CHARACTER OR SPACE)?
        BHI     10$             ;N - OK, JUMP
        CMPB    R2,#CH.CR       ;OF THE FUNNY CHARACTERS, WE ONLY ALLOW
                                ;CARRIAGE RETURN AND CTRL-C TO START
                                ;UNSOLICITED INPUT
                                ;(CR WILL OF COURSE ALSO TERMINATE IT)
        BEQ     10$             ;CR - OK
        CMPB    R2,#CH.CTC      ;CTRL-C?
        BNE     40$             ;N - IGNORE
10$:    CALL    ALUCBX          ;ALLOCATE UCBX
        BCS     40$             ;FAILED - JUMP
        CALL    ALTB            ;ALLOCATE AN INPUT BUFFER
        BCS     30$             ;FAILED - JUMP
        MOV     R2,-(SP)        ;OK - SAVE POINTER
        ASSUME  U.TCI,0
        MOV     @R4,R3          ;GET CURRENT INPUT PACKET IF THERE IS ONE
        BEQ     15$             ;INPUT FREE - JUMP
        MOV     #IS.CC,@R3      ;INPUT BUSY - SET STATUS = IS.CC
                                ;(BY DEFINITION, IT MUST BE SOLICITED
                                ;INPUT)
        MOV     R4,-(SP)        ;SAVE R4
        CALL    FPIRD           ;SAY INPUT DONE
        MOV     (SP)+,R4        ;RESTORE R4
15$:    MOV     (SP)+,U.TFIB(R4) ;SET UP POINTER TO FIRST INPUT BUFFER
        MOVB    U.TCHP-U.TSTA(R5),U.TIHP(R4) ;SET UP INITIAL HOR. POS.
        CLR     U.TFPB(R4)      ;RESET CLI PROMPT ECHO STATUS FOR ^R            ; DD008

        .IF NE  T$$UTO

        MOVB    #T$$UTO/10.+1,U.TITI(R4) ;INITIALIZE TIMER (ROUNDED UP
                                         ;TO NEXT HIGHER 10 SECONDS)

        .ENDC   ;T$$UTO

        ADD     #U.TFIB,R4      ;POINT TO U.TFIB
;
;
;+
; SUBROUTINE FPSUI1 - SET UP UCB FOR UNSOLICITED INPUT.
;
; INPUT:
;       R4      POINTER TO U.TFIB
;       R5      POINTER TO U.TSTA
;       U.TFIB  POINTER TO FIRST INPUT BUFFER
;
; OUTPUT:
;       UCB SET UP.
;       R2      POINTER TO SECOND WORD OF BUFFER.
;               THIS WORD INITIALIZED TO 0.
;       R4      POINTER TO U.TIC
;
; REGISTERS ALTERED: R2,R4
;-
;
;
FPSUI1::MOV     @R4,R2          ;GET POINTER TO FIRST INPUT BUFFER
        ASSUME  U.TTIC,U.TFIB-2
        MOV     #M$$CRB-4,-(R4) ;INITIALIZE TOTAL BYTE COUNT
                                ; = 1 FULL CLI COMMAND BUFFER
        CALL    NXTIB           ;SET UP UCB FOR INPUT TRANSFER
        MOV     R2,U.TCI-U.TIC(R4) ;STORE POINTER TO SECOND WORD IN BUFFER
                                ;THIS WORD WILL RECEIVE COMPLETION STATUS
        CLR     @R2             ;INITIALIZE STATUS
        BIS     #S1.IBY!S1.IBF!S1.USI,@R5 ;SET FLAGS FOR UNSOLICITED
                                ;BUFFERED INPUT
        BIC     #S1.RST!S1.RAL!S1.RNE,@R5 ;CLEAR RST, RAL AND RNE FLAGS
        BIT     #U2.NEC,U.CW2-U.TSTA(R5) ;LINE IN NO ECHO MODE?                 ; DD009
        BEQ     20$             ;N - JUMP                                       ; DD009
        BIS     #S1.RNE,@R5     ;Y - SET RNE FLAG                               ; DD009
20$:    RETURN                  ;
;
30$:
;
; FAILED TO ALLOCATE INPUT BUFFER. WITH A LITTLE EFFORT, WE COULD
; DEALLOCATE THE UCBX, AFTER CHECKING WHETHER IT IS NEEDED FOR
; SOME OTHER PURPOSE.
;
        CALLR   BELL            ;BUFFER ALLOCATION FAILURE - OUTPUT A BELL
40$:    CALLR   RCTAB           ;REMOVE CHARACTER FROM TYPE-AHEAD BUFFER
                                ;AND FORGET IT ALL
.PAGE
.SBTTL  FPAST - CHARACTER THAT CAUSES AST RECEIVED
;

        .IF DF  T$$CCA&A$$TRP

FPAST:: CALL    GCTAB           ;GET A CHARACTER FROM THE TYPE-AHEAD BUFFER
        BCS     20$             ;NONE THERE - IGNORE
        TST     R4              ;UCBX PRESENT?
        BEQ     20$             ;N - TERMINAL MUST BE DETACHED, IGNORE
        MOV     U.TAST(R4),R1   ;GET AST BLOCK
        BEQ     20$             ;NONE - TERMINAL MUST BE DETACHED, IGNORE
        MOVB    R2,A.PRM(R1)    ;INSERT CHARACTER IN AST BLOCK
        MOVB    #3,A.PRM+4(R1)  ;SHOW AST BLOCK IN QUEUE, ASSUME
                                ;TASK WANTS NOTIFICATION ONLY SO LOCK
                                ;AST BLOCK
        CMPB    R2,#CH.CTC      ;IS CHARACTER A ^C?                             ; DD015
        BNE     43$             ;N - JUMP                                       ; DD015
        MOV     A.PRM+6(R1),R0  ;ASSUME SPECIFICATION OF ^C AST                 ; DD015
        BNE     45$             ;GOOD ASSUMPTION - JUMP                         ; DD015
43$:    MOV     A.PRM+10(R1),R0 ;GET ADDRESS OF UNSOLICITED AST ROUTINE         ; DD015
        BITB    #TF.NOT,A.PRM+5(R1) ;TASK WANTS NOTIFICATION ONLY?
        BNE     50$             ;Y - JUMP
45$:                                                                            ; DD015
        CALL    RCTAB           ;REMOVE CHARACTER FROM TYPE-AHEAD BUFFER
        ASRB    A.PRM+4(R1)     ;UNLOCK AST BLOCK
50$:    MOV     R0,A.AST(R1)    ;INSERT TASK AST ADDRESS INTO AST BLOCK         ; DD015
        MOV     U.ATT-U.TSTA(R5),R0 ;GET ATTACHING TASK'S TCB                   ; DD015
        CALLR   $QASTT          ;QUEUE AST TO TASK AND RETURN                   ;**-1

        .ENDC   ;T$$CCA&A$$TRP

        .IF DF  R$$SCS                                                          ;CJR001
                                                                                ;CJR001
;                                                                               ;CJR001
;                                                                               ;CJR001
.SBTTL  FPFLU - RECEIVED CTRL-C, FLUSH TASKS RUNNING ON TERMINAL
;                                                                               ;CJR001
FPFLU:: CALL    GCTAB           ;GET THE CTRL-C FROM THE TYPE-AHEAD BUFFER      ;CJR001
        BCS     20$             ;NOT THERE ANY MORE - FORGET IT                 ;CJR001
        CALL    ALUCBX          ;ALLOCATE UCBX IF THERE IS NONE                 ;CJR001
        BCS     40$             ;IF CS DIDN'T GET ONE - IGNORE CTRL-C           ;CJR001
        MOV     #M$$CRB,R1      ;SIZE OF MCR BUFFER                             ;CJR001
        CALL    $ALOCB          ;GET A BUFFER                                   ;CJR001
        BCS     30$             ;IF CS DIDN'T GET ONE - IGNORE CTRL-C           ;CJR001
        MOV     R0,R1           ;SAVE BUFFER ADDRESS                            ;CJR001
        TST     (R0)+           ;SKIP LINK WORD                                 ;CJR001
        MOV     R5,(R0)         ;COPY POINTER TO U.TSTA                         ;CJR001
        SUB     #U.TSTA,(R0)+   ;SUBTRACT U.TSTA TO GET UCB ADDRESS             ;CJR001
        MOV     (PC)+,(R0)+     ;FIRST 2 BYTES OF FLUSH COMMAND                 ;CJR001
        .ASCII  /FL/                                                            ;CJR001
        MOV     (PC)+,(R0)+     ;REST OF FLUSH COMMAND                          ;CJR001
        .ASCII  /U/<CH.CR>                                                      ;CJR001
        CALL    $QMCRL          ;QUEUE THE COMMAND TO MCR                       ;CJR001
        BIT     #S1.USI,@R5     ;PERFORMING UNSOLICITED INPUT?                  ;CJR001
        BNE     40$             ;Y - DON'T TRY TO TERMINATE INPUT               ;CJR001
        ASSUME  U.TCI,0                                                         ;CJR001
        MOV     @R4,R3          ;GET CURRENT INPUT PACKET IF THERE IS ONE       ;CJR001
        BEQ     40$             ;INPUT FREE - JUMP                              ;CJR001
        MOV     #IS.CC,@R3      ;INPUT BUSY - SET STATUS = IS.CC                ;CJR001
                                ;(IT MUST BE SOLICITED INPUT)                   ;CJR001
        CALL    FPIRD           ;SAY INPUT DONE                                 ;CJR001
        BR      40$             ;REMOVE CTRL-C FROM TYPE-AHEAD BUFFER           ;CJR001
                                                                                ;CJR001
        .ENDC   ;R$$SCS                                                         ;CJR001
                                                                                ;CJR001
        .DSABL  LSB
;
;
        .END
        .TITLE  TTICH
        .IDENT  /V01.45/
;
; 23-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW006   11-APR-78       PETER WANNHEDEN
;               IGNORE CTRL-O IF TERMINAL NOT ATTACHED AND OUTPUT
;               INTERRUPT IS UNEXPECTED.
;       PW007   13-APR-78       PETER WANNHEDEN
;               ADD DETECTION OF HARD RECEIVE ERRORS.
;       PW008   13-APR-78       PETER WANNHEDEN
;               DON'T CLEAR POINTER TO TYPE-AHEAD BUFFER WHEN A CHARACTER
;               IS RECEIVED FROM A LINE THAT IS DISABLED, WAITING FOR
;               CARRIER OR LOGICALLY OFFLINE.
;       PW009   13-APR-78       PETER WANNHEDEN
;               RETURN STATUS IS.TMO+1 WHEN ^U ECHO COMPLETED ON
;               UNSOLICITED INPUT.
;       PW010   14-APR-78       PETER WANNHEDEN
;               SUPPORT DEVICE-INDEPENDENT CURSOR CONTROL.
;       PW011   14-APR-78       PETER WANNHEDEN
;               ALLOW CTRL-R OF PROMPT BUFFER FOR IO.RPR ON FULL DUPLEX LINE.
;       PW018   26-APR-78       PETER WANNHEDEN
;               DO LOWER-TO-UPPER CASE CONVERSION WHERE REQUIRED FOR IO.RST.
;       PW024   03-MAY-78       PETER WANNHEDEN
;               AFTER A ^U ECHO IS FINISHED, SET UP INITIAL HOR. POS.
;               SO THAT A SUBSEQUENT RUBOUT OF HOR. TAB ON A SCOPE WILL
;               WORK CORRECTLY.
;       PW025   05-MAY-78       PETER WANNHEDEN
;               DON'T TREAT CTRL-Q AND CTRL-S AS TERMINATORS FOR IO.RST.
;               REARRANGE SOME CODE TO SAVE MEMORY.
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED:
;               USE SUBROUTINE MAPD TO MAP TT DRIVER DATA AREA.
;       PW028   12-MAY-78       PETER WANNHEDEN
;               SIMPLIFY CHECKING FOR READ-PASS-ALL.
;       PW032   31-MAY-78       PETER WANNHEDEN
;               MAKE LOWER- TO UPPER-CASE CONVERSION SUPPORT
;               UNCONDITIONAL (REMOVE PARAMETER T$$LWC).
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD002   30-AUG-78       DALE R. DONCHIN
;               FIX BUG IN ESCAPE SEQUENCE PROCESSING.
;               SUPPORT ANSI STANDARD ESCAPE SEQUENCES
;       DD003   05-SEP-78       DALE R. DONCHIN
;               ECHO THE CLI PROMPT FOR ^R DURING UNSOLICITED READ
;       DD005   06-OCT-78       DALE R. DONCHIN
;               ADD READ WITH TERMINATOR TABLE FUNCTION
;       DD009   08-NOV-78       DALE R. DONCHIN
;               ALLOW ^C TO CAUSE AN AST ON SOLICITED IO.RLB READS.
;               FIX AND IMPROVE NOECHO HANDLING
;       DD011   04-DEC-78       DALE R. DONCHIN
;               ADD TF.TBF, TF.CTS AND F2.CUP SUPPORT
;       CJR001  22-FEB-79       CRAIG J. RICHARDSON
;               ADD SCS-11 CONTROL/C SUPPORT
;       CJR002  22-FEB-79       CRAIG J. RICHARDSON
;               DON'T ALLOW UNSOLICITED INPUT ON SCS-MODE TERMINAL
;       DD015   28-FEB-79       DALE R. DONCHIN
;               UNLOCK AST BLOCK WHEN TYPE-AHEAD BUFFER IS FLUSHED.
;               ADD SEPARATE ^C AST
;       CS033   27-MAR-79       CHARLES FRANKLIN SPITZ
;               ADD MULTIPLE CLI SUPPORT FOR DECNET
;       DD018   01-MAY-79       DALE R. DONCHIN
;               ALLOW READ-PASS-ALL TO WORK FOR UNSOLICITED INPUT
;               CORRECT MAPPING WHEN DRIVER > 4K
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        .MCALL  KRBDF$

        KRBDF$                  ;DEFINE KRB SYMBOLS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        .MCALL  SCBDF$                                                          ; CS013
                                                                                ; CS013
        SCBDF$  ,,SYSDEF        ;DEFINE SCB SYMBOLS                             ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
;
;
.SBTTL  ICHAR1 - PROCESS INPUT CHARACTER BEFORE TYPE-AHEAD BUFFER
;+
; ICHAR1 - PROCESS INPUT CHARACTER.
;       THIS ROUTINE PROCESSES A CHARACTER ON THE "OUTSIDE"
;       (HARDWARE SIDE) OF THE TYPE-AHEAD BUFFER.
;
; INPUT:
;       R2      CHARACTER (LOW BYTE) AND STATUS (HIGH BYTE)
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       ANY OF THE FOLLOWING ACTIONS IS TAKEN, DEPENDENT
;       ON LINE STATUS AND THE CHARACTER ITSELF:
;
;       1. CHARACTER STORED IN TYPE-AHEAD BUFFER.
;
;       2. CHARACTER PROCESSED BY ICHAR2 (SEE DESCRIPTION OF ICHAR2).
;
;       3. OUTPUT OF BELL STARTED (OR MARKED FOR LATER OUTPUT)
;       IF UNABLE TO STORE IN TYPE-AHEAD BUFFER.
;
;       4. TYPE-AHEAD BUFFER FLUSHED (CTRL-X OR CTRL-C AND NOT PASS-ALL
;       OR SPECIAL-TERMINATORS). CTRL-C IS ALSO PROCESSED BY ICHAR2.
;
;       5. OUTPUT STOPPED (CTRL-S AND NOT PASS-ALL OR SPECIAL-TERMINATORS).
;
;       6. OUTPUT RESUMED (CTRL-Q AND NOT PASS-ALL OR SPECIAL-TERMINATORS).
;
;       7. OUTPUT ABORTED (CTRL-O AND NOT PASS-ALL OR SPECIAL-TERMINATORS).
;
;       8. CHARACTER IGNORED (UNIT OFFLINE OR DISABLED).
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
        .ENABL  LSB
;
ICHAR1::

        .IF DF  T$$MOD

        BITB    #US.DSB!US.CRW,U.STS-U.TSTA(R5)
                                ;;;UNIT DISABLED OR WAITING FOR CARRIER?
        BNE     15$             ;;;Y - IGNORE                                   ;PW008
                                                                                ;**-1
        .ENDC   ;T$$MOD

        .IF DF  R$$CON

        BITB    #US.OFL,U.ST2-U.TSTA(R5) ;;;UNIT OFFLINE?
        BNE     15$             ;;;Y - IGNORE                                   ;PW008
                                                                                ;**-1
        .ENDC

                                                                                ;PW007
        .IF DF  T$$RED                                                          ;PW007
                                                                                ;PW007
        BIC     #^C<S3.BCC!S3.DAO!S3.VER!377>,R2                                ;PW007
                                ;;;CLEAR IRRELEVANT BITS IN HIGH BYTE           ;PW007
        BIT     #S3.BCC!S3.DAO!S3.VER,R2 ;;;HARD RECEIVE ERROR?                 ;PW007
        BNE     I1DEF           ;;;Y - JUMP                                     ;PW007
                                                                                ;PW007
        .IFF                                                                    ;PW007
                                                                                ;PW007
        BIT     #S3.BCC!S3.DAO!S3.VER,R2 ;;;HARD RECEIVE ERROR?                 ;PW007
        BNE     60$             ;;;Y - JUMP                                     ;PW007
                                                                                ;PW007
        .ENDC   ;T$$RED                                                         ;PW007
                                                                                ;PW007
        BIT     #S3.RAL,4(R5)   ;;;READ-PASS-ALL?                               ; DD018
        BNE     I1DEF           ;;;Y - JUMP                                     ; DD018
        BIT     #S1.RAL,@R5     ;;;SECOND CHECK                                 ; DD018
        BNE     I1DEF           ;;;Y - JUMP                                     ;**-4
        ASSUME  S3.8BC,200                                                      ;PW010
        TSTB    4(R5)           ;;;PASS 8 BITS?                                 ;PW010
        BMI     5$              ;;;Y - JUMP                                     ;**-2
        BIC     #200,R2         ;;;N - CLEAR HIGH BIT
5$:     MOV     #I1CRT,R3       ;;;GET CHAR. RECOGNITION TABLE                  ;PW025
        CMPB    R2,(R3)+        ;;;CTRL-S?                                      ;PW025
        BEQ     I1CTS           ;;;Y - JUMP                                     ;PW025
        CMPB    R2,(R3)+        ;;;CTRL-Q?                                      ;PW025
        BEQ     I1CTQ           ;;;Y - JUMP                                     ;PW025
        BIT     #S1.RST,@R5     ;;;DOING IO.RST?                                ;PW025
        BNE     I1DEF           ;;;Y - CTRL-O, CTRL-C AND CTRL-X ARE TERMINATORS;PW025
        CMPB    R2,(R3)+        ;;;CTRL-X?                                      ;PW025
        BHI     I1DEF           ;;;IF HI - CAN'T BE IN RECOGNITION TABLE, JUMP  ;PW025
        BEQ     I1CTX           ;;;CTRL-X - JUMP                                ;PW025
        CMPB    R2,(R3)+        ;;;CTRL-O?                                      ;PW025
        BEQ     I1CTO           ;;;Y - JUMP                                     ;PW025
        CMPB    R2,(R3)+        ;;;CTRL-C?                                      ;PW025
        BNE     I1DEF           ;;;N - JUMP                                     ;PW025
;                                                                               ;PW025
; CTRL-C - FLUSH TYPE-AHEAD BUFFER, THEN PROCESS                                ;PW025
;                                                                               ;PW025
I1CTC:: CALL    I1CTX           ;;;FLUSH TABUF                                  ;PW025
        CALL    I1CTQ           ;;;RESUME OUTPUT IF IT WAS STOPPED              ;PW025
        MOVB    #CH.CTC,R2      ;;;RESTORE CHARACTER                            ;PW025
        BR      20$             ;;;GO PROCESS CTRL-C                            ;PW025
;                                                                               ;**-8
; CTRL-X - FLUSH TYPE-AHEAD BUFFER.
;
I1CTXL::CALL    LOCKI           ;LOCK OUT INTERRUPTS
I1CTX::                                                                         ;PW007
                                                                                ;PW007
        .IF DF  T$$RED                                                          ;PW007
                                                                                ;PW007
        BIC     #S3.BCC!S3.DAO!S3.VER,4(R5)                                     ;PW007
                                ;;;CLEAR HARD RECEIVE ERROR FLAGS               ;PW007
                                                                                ;PW007
        .ENDC   ;T$$RED                                                         ;PW007
                                                                                ;PW007
        MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX                                 ; DD015
        BEQ     7$              ;;;NONE - JUMP                                  ; DD015
        MOV     U.TAST(R4),R3   ;;;GET AST BLOCK IF THERE IS ONE                ; DD015
        BEQ     7$              ;;;NONE - JUMP                                  ; DD015
        BIC     #2,A.PRM+4(R3)  ;;;UNLOCK AST BLOCK IN CASE IT WAS LOCKED       ; DD015
7$:                                                                             ; DD015
        MOV     U.TTAB-U.TSTA(R5),R3 ;;;GET TABUF                               ;PW007
        BEQ     15$             ;;;NONE - JUMP                                  ;**-1
        BIT     #1,R3           ;;;SINGLE-CHAR. TABUF?
        BNE     10$             ;;;Y - JUMP
        MOVB    (R3)+,(R3)+     ;;;MAKE STORE AND RETRIEVE POINTERS SAME
        BR      27$             ;;;CLEAR NUMBER OF ACTIVE BYTES AND RETURN
10$:    CLR     U.TTAB-U.TSTA(R5) ;;;FLUSH SINGLE-CHAR. TABUF
15$:    RETURN
;                                                                               ;**-7
; "NORMAL" CHARACTER. FIRST CHECK IF THERE IS ALREADY SOMETHING
;       BUFFERED. IF SO, BUFFER THIS CHARACTER ALSO.
;
I1DEF:: MOV     U.TTAB-U.TSTA(R5),R3 ;;;GET TABUF
        BEQ     20$             ;;;NONE - JUMP
        BIT     #1,R3           ;;;SINGLE-CHAR. TABUF?
        BNE     60$             ;;;Y - TABUF FULL, JUMP
        TSTB    2(R3)           ;;;ANYTHING BUFFERED?
        BNE     25$             ;;;Y - JUMP
;
;       TRY TO PROCESS CHARACTER IMMEDIATELY
;
20$:    CALL    IPROC           ;;;CAN WE PROCESS CHARACTER NOW?
        BEQ     50$             ;;;THROW UNWANTED CHARACTER AWAY                ; DD009
        BCC     ICHAR2          ;;;Y - GO AND DO IT
;
;       CHARACTER CANNOT BE PROCESSED NOW. STORE IT IN TYPE-AHEAD BUFFER.
;
                                                                                ;PW007
        .IF DF  T$$RED                                                          ;PW007
                                                                                ;PW007
25$:    BIT     #S3.BCC!S3.DAO!S3.VER,4(R5)                                     ;PW007
                                ;;;ANY HARD RECEIVE ERROR ALREADY DETECTED?     ;PW007
        BNE     60$             ;;;Y - REJECT THIS CHARACTER                    ;PW007
        MOV     R2,-(SP)        ;;;COPY CHARACTER PLUS ERROR FLAGS              ;PW007
        CLRB    @SP             ;;;CLEAR LOW BYTE - LEAVE FLAGS IN HIGH BYTE    ;PW007
        BIS     (SP)+,4(R5)     ;;;SAVE ERROR FLAGS (IF ANY) IN                 ;PW007
                                ;;;HIGH BYTE OF STATUS WORD 3                   ;PW007
                                                                                ;PW007
        .IFTF   ;T$$RED                                                         ;PW007
                                                                                ;PW007
        MOV     U.TTAB-U.TSTA(R5),R3 ;;;GET TABUF
        BEQ     40$             ;;;NONE - JUMP
        BIT     #1,R3           ;;;SINGLE-CHAR. BUFFER?
        BNE     60$             ;;;Y - TABUF FULL, JUMP
                                                                                ;PW007
        .IFF    ;T$$RED                                                         ;PW007
                                                                                ;PW007
25$:                                                                            ;PW007
                                                                                ;PW007
        .ENDC   ;T$$RED                                                         ;PW007
                                                                                ;PW007
        MOVB    (R3)+,R4        ;;;GET OFFSET WHERE TO STORE                    ;PW007
        INC     R3              ;;;SKIP OVER 1 BYTE                             ;**-1
        CMPB    (R3)+,(R3)+     ;;;TABUF FULL?
        BEQ     60$             ;;;Y - COMPLAIN
        ADD     R3,R4           ;;;MAKE POINTER IN TABUF
        MOVB    R2,@R4          ;;;STORE CHARACTER
        INC     -(R3)           ;;;INCR. ACTIVE COUNT
        INC     -(R3)           ;;;UPDATE STORE POINTER
        CMPB    @R3,3(R3)       ;;;WRAP-AROUND?
        BNE     30$             ;;;N - JUMP
27$:    CLRB    @R3             ;;;Y - SET POINTER AT START OF BUFFER
30$:    RETURN                  ;;;RETURN
40$:    MOVB    R2,U.TTAB+1-U.TSTA(R5) ;;;STORE CHAR. IN SINGLE-CHAR. TABUF
        INCB    U.TTAB-U.TSTA(R5) ;;;MARK BUSY
50$:    RETURN
60$:    CALLR   BELL            ;;;TYPE-AHEAD BUFFER FULL - ECHO BELL
;
; CTRL-Q - RESUME OUTPUT
;
I1CTQL::CALL    LOCKI           ;LOCK OUT INTERRUPTS
I1CTQ:: BIC     #S1.CTS,@R5     ;;;CLEAR CTRL-S FLAG
        BITB    #US.OIU,U.STS-U.TSTA(R5) ;;;ARE WE EXPECTING AN OUTPUT
                                         ;;;INTERRUPT?
        BNE     50$             ;;;N - JUMP
        MOV     #4,R2           ;;;SET INDEX FOR "RESUME OUTPUT"
        BR      CTRD            ;;;CALL CONTROLLER DEPENDENT ROUTINE
;
; CTRL-S - STOP OUTPUT.
;
I1CTSL::CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ; DD011
I1CTS:: BIS     #S1.CTS,@R5     ;;;SET CTRL-S FLAG
        MOV     #6,R2           ;;;SET INDEX FOR "STOP OUTPUT"
        BR      CTRD            ;;;CALL CONTROLLER DEPENDENT ROUTINE
;
; CTRL-O - ABORT OUTPUT. IF TASK OUTPUT IN PROGRESS, ABORT OUTPUT.
; IF TERMINAL ATTACHED, COMPLEMENT CTRL-O FLAG.
;
I1CTO:: MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX
        BEQ     80$             ;;;NONE - IGNORE
        TST     U.ATT-U.TSTA(R5) ;;;TERMINAL ATTACHED?
        BEQ     100$            ;;;N - JUMP
        BIT     #S1.CTO,@R5     ;;;CTRL-O FLAG SET?
        BEQ     90$             ;;;N - JUMP
        BIC     #S1.CTO,@R5     ;;;CLEAR CTRL-O FLAG
RET3:
80$:    RETURN
90$:    BIS     #S1.CTO,@R5     ;;;SET CTRL-O FLAG
100$:   MOV     U.TCO(R4),R3    ;;;GET CURRENT OUTPUT PACKET
        BEQ     80$             ;;;NOT DOING TASK OUTPUT - JUMP
        BITB    #US.OIU,U.STS-U.TSTA(R5) ;;;OUTPUT INTERRUPT EXPECTED?          ;PW006
        BNE     80$             ;;;N - IGNORE                                   ;PW006

        .IF DF  T$$RPR

        CMPB    I.FCN+1(R3),#IO.RPR/400 ;;;IS IT AN IO.RPR?
        BEQ     110$            ;;;Y - TF.CCO FLAG IS NOT VALID

        .ENDC   ;T$$RPR

        BITB    #TF.CCO,I.FCN(R3) ;;;CANCEL CTRL-O FLAG SET?
        BNE     80$             ;;;Y - IGNORE
110$:   INC     @R3             ;;;SET STATUS = IS.SUC
        CALL    ABOX            ;;;ABORT OUTPUT                                 ;PW006
        CALLR   ODONE           ;;;SIMULATE FINAL INTERRUPT                     ;PW006
;                                                                               ;PW006
ABOXL:: CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ;**-5
ABOX::  MOV     #2,R2           ;;;SET INDEX FOR "ABORT OUTPUT"
                                ;;;FALL THRU TO "CTRD"
;
        .DSABL  LSB
.PAGE
.SBTTL  CTRD - CALL CONTROLLER DEPENDENT ROUTINE
;+
; CTRD - CALL CONTROLLER DEPENDENT ROUTINE.
;
; INPUT:
;       R2      ROUTINE INDEX:
;               0 - START OUTPUT
;               2 - ABORT OUTPUT
;               4 - RESUME OUTPUT
;               6 - STOP OUTPUT
;               10 - POWER-UP
;               12 - MODEM TIMER
;               14 - SET LINE PARAMETERS
;       R5      POINTER TO U.TSTA
;
; CALLS CONTROLLER DEPENDENT ROUTINE WITH:
;       R2      PHYSICAL UNIT NUMBER * 2
;               (ONLY IF MULTIPLEXERS IN SYSTEM)
;       R3      CSR ADDRESS
;       R4      UCBX ADDRESS
;       R5      POINTER TO U.TSTA
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
CTRD::  MOV     U.SCB-U.TSTA(R5),R3 ;;;GET SCB
        MOV     S.KRB(R3),R3    ;;;GET KRB
        MOVB    K.PRM(R3),R4    ;;;GET CONTROLLER TYPE
        ADD     CTBL(R4),R2     ;;;POINT TO DISPATCH TABLE FOR
                                ;;;THIS CONTROLLER TYPE
        MOV     @R3,R3          ;;;GET CSR
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
CTRD::  MOV     U.CTYP-U.TSTA(R5),R4 ;;;GET CONTROLLER TYPE                     ; CS013
        ADD     CTBL(R4),R2     ;;;POINT TO DISPATCH TABLE FOR                  ; CS013
                                ;;;THIS CONTROLLER TYPE                         ; CS013
        MOV     U.SCB-U.TSTA(R5),R3 ;;;GET SCB                                  ; CS013
        MOV     S.CSR(R3),R3    ;;;GET CSR                                      ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX (IF THERE IS ONE)

        .IF DF  T$$MUX

        MOV     @R2,-(SP)       ;;;PUSH ROUTINE ADDRESS
        MOVB    U.UNIT-U.TSTA(R5),R2 ;;;GET PHYS. UNIT NUMBER
        ASL     R2              ;;;MULTIPLY BY 2
        CALLR   @(SP)+          ;;;CALL ROUTINE AND RETURN

        .IFF

        CALLR   @(R2)+          ;;;CALL ROUTINE AND RETURN

        .ENDC
.PAGE
.SBTTL  ICHAR2 - PROCESS CHARACTER AFTER TYPE-AHEAD BUFFER
;+
; ICHAR2 - PROCESS INPUT CHARACTER.
;       THIS ROUTINE PROCESSES A CHARACTER ON THE "INSIDE"
;       (SOFTWARE SIDE) OF THE TYPE-AHEAD BUFFER.
;
; INPUT:
;       R2      CHARACTER
;       R5      POINTER TO U.TSTA
;       IF ECHO REQUIRED, OUTPUT MUST BE FREE.
;
; OUTPUT:
;       CHARACTER ANALYSED, STORED IN INPUT BUFFER IF NECESSARY,
;       ECHO STARTED IF NECESSARY.
;       UCB UPDATED AS REQUIRED.
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
        .ENABL  LSB

ICHAR2::MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX
        BEQ     RET3            ;;;NONE - RETURN (COULD HAPPEN FOR EXAMPLE
                                ;;;WHEN CTRL-C IS TYPED ON AN IDLE SLAVED
                                ;;;TERMINAL)
                                                                                ;PW007
        .IF DF  T$$RED                                                          ;PW007
                                                                                ;PW007
        BIT     #S3.BCC!S3.DAO!S3.VER,R2                                        ;PW007
                                ;;;ANY HARD RECEIVE ERRORS?                     ;PW007
        BEQ     5$              ;;;N - JUMP                                     ;PW007
        MOV     #IE.DAO&377,R3  ;;;YES                                          ;PW007
        ASSUME  S3.DAO,40000                                                    ;PW007
        ROL     R2              ;;;DATA OVERRUN?                                ;PW007
        BMI     4$              ;;;Y - JUMP                                     ;PW007
        MOV     #IE.BCC&377,R3  ;;;NO                                           ;PW007
        ASSUME  S3.BCC,S3.DAO/2                                                 ;PW007
        ROL     R2              ;;;FRAMING ERROR?                               ;PW007
        BMI     4$              ;;;Y - JUMP                                     ;PW007
        MOV     #IE.VER&377,R3  ;;;N - MUST BE PARITY ERROR                     ;PW007
4$:     MOV     R3,@(R4)+       ;;;STORE ERROR CODE                             ;PW007
        JMP     IDONE           ;;;FINISH INPUT REQUEST                         ;PW007
5$:                                                                             ;PW007
                                                                                ;PW007
        .ENDC   ;T$$RED                                                         ;PW007
                                                                                ;PW007
        MOVB    R2,U.TECB(R4)   ;;;SAVE CHAR.

        .IF NE  T$$UTO

        MOVB    #T$$UTO/10.+1,U.TITI(R4) ;INITIALIZE TIMER (ROUNDED UP
                                         ;TO NEXT HIGHER 10 SECONDS)

        .ENDC   ;T$$UTO

        BIT     #S1.USI,@R5     ;;;UNSOLICITED INPUT?
        BNE     10$             ;;;Y - JUMP
        ASSUME  U.TCI,0
        MOV     @R4,R3          ;;;GET PACKET
        MOVB    I.PRM+6(R3),U.TITI(R4) ;;;GET USER-DEFINED TIMER
10$:    MOV     @R5,R3          ;;;GET STATUS
;
; DETERMINE ACTION DEPENDENT ON FLAGS
;
        ASSUME  S1.RST,1
        ROR     R3              ;;;DOING READ-WITH-SPECIAL-TERMINATORS?
        BCS     I2RST           ;;;Y - JUMP
        ASSUME  S1.RUB,S1.RST*2
        ROR     R3              ;;;IN RUBOUT SEQUENCE?
        BCS     20$             ;;;Y - JUMP
        ASSUME  S1.ESC,S1.RUB*2
        ROR     R3              ;;;IN ESCAPE SEQUENCE?

        .IF DF  T$$ESC

        BCS     40$             ;;;Y - JUMP                                     ; DD005
                                                                                ;**-1
        .ENDC   ;T$$ESC

        ASSUME  S1.RAL,S1.ESC*2
        ROR     R3              ;;;DOING READ-PASS-ALL?
        BCS     I2RAL           ;;;Y - JUMP
;
; DETERMINE ACTION DEPENDENT ON CHARACTER
;
ICH2A:: CMPB    R2,#CH.RUB      ;;;RUBOUT?
        BEQ     30$             ;;;Y - JUMP
        CMPB    R2,#CH.ESC      ;;;ESCAPE?
        BHI     I2DEF           ;;;N - HIGHER, CAN'T BE IN RECOGNITION
                                ;;;TABLE - JUMP TO DEFAULT ROUTINE
        BEQ     50$             ;;;ESCAPE - JUMP                                ; DD005
        MOV     #I2CRT,R3       ;;;GET START OF CHAR. RECOGNITION TABLE         ;**-1
        JMP     CHRDSP          ;;;DISPATCH ACCORDING TO CHARACTER
;
20$:    JMP     I2RUB1          ;;;CONTINUE RUBOUT SEQUENCE
30$:    JMP     I2RUB           ;;;START RUBOUT SEQUENCE
                                                                                ; DD005
        .IF DF  T$$ESC                                                          ; DD005
                                                                                ; DD005
40$:    JMP     I2ESC2          ;;;CONTINUE ESCAPE SEQUENCE                     ; DD005
                                                                                ; DD005
        .ENDC   ;T$$ESC                                                         ; DD005
                                                                                ; DD005
50$:    JMP     I2ESC           ;;;PROCESS AN ESCAPE CHARACTER                  ; DD005

        .DSABL  LSB
.PAGE
.SBTTL  NORMAL CHARACTER
;+
; "NORMAL" CHARACTER (OR POSSIBLY ALTERNATE ESCAPE)
;-
;
I2DEF::

        .IF DF  T$$ESC

        CMPB    R2,#37          ;;;ALTERNATE ESCAPE?
        BNE     I2DEF1          ;;;N - JUMP                                     ;PW018
        BIT     #U2.ESC,U.CW2-U.TSTA(R5) ;;;DOES TERMINAL GENERATE ESC.SEQ.?    ;**-1
        BEQ     10$             ;;;N - JUMP                                     ; DD005
        JMP     I2ESC1          ;;;Y - THIS IS AN ESCAPE CHARACTER              ; DD005
10$:                                                                            ; DD005
                                                                                ;**-1
        .ENDC

I2DEF1: BIT     #U2.LWC,U.CW2-U.TSTA(R5) ;;;CASE CONVERSION ENABLED?            ;PW032
        BNE     I2RAL           ;;;N - JUMP                                     ;**-5
        CMPB    R2,#175         ;;;Y - 175 AND 176 ARE ALSO ESCAPE CHAR.S
        BHIS    I2ESC1          ;;;175 OR 176 - JUMP
                                ;;;(177 = RUBOUT HAS ALREADY BEEN CHECKED FOR)
;
; CONVERT LOWER TO UPPER CASE IF REQUIRED
;
20$:    CMPB    R2,#173         ;;;UPPER END GRAPHICS?
        BHIS    I2RAL           ;;;Y - DON'T CONVERT
        CMPB    R2,#141         ;;;LOWER CASE LETTER?
        BLO     I2RAL           ;;;N - DON'T CONVERT
        BICB    #40,R2          ;;;Y - CONVERT LOWER TO UPPER CASE
        MOVB    R2,U.TECB(R4)   ;;;UPDATE SAVED CHAR. TOO
;                                                                               ;PW032
; FALL THRU TO "I2RAL" TO PROCESS CHARACTER WITHOUT SPECIAL SIGNIFICANCE        ;**-3
;
.PAGE
.SBTTL  CHARACTER WITHOUT SPECIAL SIGNIFICANCE
;
; CHARACTER DOES NOT HAVE SPECIAL SIGNIFICANCE.
; (COME DIRECTLY HERE IF DOING READ-PASS-ALL).
;
        .ENABL  LSB
;
I2RAL:  CALL    PUTNIC          ;;;PUT CHAR. IN INPUT BUFFER
        BIT     #S1.RNE,@R5     ;;;ECHO SUPPRESSED?
        BNE     ECHD2           ;;;Y - GO CHECK FOR BUFFER FULL
EXPC:   CALL    EXPCHR          ;;;EXPAND CHARACTER TO GET PROPER ECHO
        BNE     10$             ;;;ECHO IS A STRING - JUMP
                                ;;;ELSE CHARACTER ECHOS AS ITSELF -
                                ;;;  FALL THRU TO "ECHO"
;
;
;+
; ECHO - ECHO 1 CHARACTER FROM TEMPORARY CHARACTER BUFFER
;
; INPUT:
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;       U.TECB  CHARACTER TO ECHO
;       U.TCHP  HOR. POS. AFTER ECHO
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
ECHO:   MOV     R4,R3           ;;;
        ADD     #U.TECB,R3      ;;;POINT TO SINGLE CHAR. BUFFER
        CALLR   ECHCHR          ;;;ECHO SINGLE CHARACTER IN U.TECB
;
10$:    BCC     20$             ;;;NO DEFERRED ECHOING REQUIRED - JUMP
        BIS     #S1.DEC,@R5     ;;;ELSE SET FLAG TO REMEMBER
;
; ECHO A STRING
;
; INPUT:
;       R2      LENGTH OF STRING TO ECHO
;       R3      POINTER TO STRING
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;       U.TCHP  HOR. POS. AFTER ECHO
;
;
20$:    CALLR   ECHSTR          ;;;ECHO STRING DESCRIBED BY R2,R3
;
        .DSABL  LSB
;
.SBTTL  ECHD1 - ECHO DONE
;
;+
; ECHD1 - ECHO DONE.
;       THIS ROUTINE IS ENTERED WHEN AN ECHO IS DONE. IT DOES
;       ONE OF THE FOLLOWING THINGS:
;       1. IF DEFERRED PROCESSING IS REQUIRED, PICK UP THE CHARACTER
;               SAVED IN U.TECB AND PROCESS IT FROM THE BEGINNING.
;       2. ELSE, IF DEFERRED ECHO IS REQUIRED, ECHO THE CHARACTER
;               SAVED IN U.TECB
;       3. ELSE, IF INPUT COMPLETED - FORK TO PROCESS THAT.
;       4. ELSE, IF ANY OUTPUT REQUESTS WAITING - FORK TO GET ANOTHER
;               REQUEST PACKET.
;       5. ELSE, RETURN.
;
; INPUT:
;       R3      HIGH BYTE OF U.TSTA SHIFTED 1 BIT RIGHT
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;       S1.OBY  0
;-
;
;
ECHD1:: MOVB    U.TECB(R4),R2   ;;;RETRIEVE CHAR. (IN CASE DEFERRED
                                ;;;PROCESSING OR ECHO IS REQUIRED)
        BIC     #S1.DPR!S1.DEC,@R5 ;;;CLEAR DEFERRED ECHO AND DEFERRED
                                ;;;PROCESSING FLAGS
        ASSUME  S1.DPR,1000
        ROR     R3              ;;;DEFERRED PROCESSING REQUIRED?
        BCS     ICH2A           ;;;Y - JUMP
        ASSUME  S1.DEC,S1.DPR*2
        ROR     R3              ;;;DEFERRED ECHO REQUIRED?
        BCS     EXPC            ;;;Y - JUMP
        ASSUME  U.TCI,0
ECHD2:  TSTB    @(R4)+          ;;;EOL SEEN?
        BNE     IDONE           ;;;Y - ALL DONE, JUMP
        TST     U.TIC-2(R4)     ;;;BUFFER FULL?
        BNE     20$             ;;;N - JUMP
        ASSUME  S1.IBF,100000
        TST     @R5             ;;;Y - BUFFERED INPUT?
        BPL     IDONE           ;;;N - ALL DONE, JUMP
;
; WE ARE DOING BUFFERED INPUT, AND JUST FILLED UP THE CURRENT BUFFER.
; SEE IF THERE IS ANOTHER BUFFER LINKED TO THE CURRENT (COULD BE THE
; CASE IF THE OPERATOR DID RUBOUT OR CTRL-U, OR IF WE ARE PROCESSING
; CTRL-R ECHO). IF THERE IS, UPDATE UCB. IF THERE IS NOT, FORK TO GET
; ANOTHER BUFFER.
;
        ASSUME  U.TIP,2
        MOV     @(R4)+,R2       ;;;GET NEXT BUFFER IF THERE IS ONE (U.TIP)
        BEQ     IDONE           ;;;N - GO AND FORK
        ASSUME  U.TTIC,U.TIP+6
        CMP     (R4)+,(R4)+     ;;;POINT TO U.TTIC
        CALL    NXTIB           ;;;START USING NEXT BUFFER
        BEQ     IDONE           ;;;IF CC-Z = 1 WE ARE DONE AFTER ALL
        CMP     -(R4),-(R4)     ;;;POINT TO U.TIP
;
; CONSULT INPUT STATE VARIABLE TO SEE WHAT TO DO NEXT.
;
20$:    TST     -(R4)           ;;;POINT TO START OF UCBX
                                                                                ; DD002
        .IF DF  T$$ESC                                                          ; DD002
                                                                                ; DD002
        BIT     #S1.ESC,@R5     ;;;MIDDLE OF ESCAPE SEQUENCE?                   ; DD002
        BNE     30$             ;;;Y - DON'T CHECK FOR ^R OR ^U ECHO            ; DD002
                                                                                ; DD002
        .ENDC   ;T$$ESC                                                         ; DD002
                                                                                ; DD002
        MOVB    U.TISV(R4),R2   ;;;GET STATE VARIABLE
        ASL     R2              ;;;MAKE WORD INDEX
        JMP     @ISDSP(R2)      ;;;DISPATCH
                                                                                ; DD002
        .IF DF  T$$ESC                                                          ; DD002
                                                                                ; DD002
30$:    JMP     CFGRQ           ;;;CONDITIONALLY FORK TO GET A PACKET           ; DD002
                                                                                ; DD002
        .ENDC   ;T$$ESC                                                         ; DD002
                                                                                ; DD002
;
; QUEUE FORK REQUEST FOR ONE OF FOLLOWING REASONS:
;       1. (CURRENT) BUFFER FULL
;       2. TERMINATOR SEEN - LINK WORD IN PACKET CONTAINS
;          STATUS (IF IT IS A SOLICITED READ)
;
IDONE0: TST     (SP)+           ;;;CLEAN STACK
IDONE:  MOV     #FR.IRD,R3      ;;;FORK/INPUT DONE
        CALLR   FORK            ;;;
.PAGE
.SBTTL  READ WITH SPECIAL TERMINATORS
;
; DOING READ WITH SPECIAL TERMINATORS - SEE IF THIS IS A TERMINATOR
;
;
I2RST:  MOV     @R4,R3          ;;;GET THE I/O PACKET ADDRESS                   ; DD005
        CMPB    I.FCN+1(R3),#IO.RTT/400 ;;;SPECIAL TERMINATOR FUNCTION?         ; DD005
        BNE     5$              ;;;N - JUMP                                     ; DD005
        MOV     U.TRTT(R4),R3   ;;;GET THE TERMINATOR TABLE ADDRESS             ; DD005
        MOV     R1,-(SP)        ;;;MAKE A REGISTER AVAILABLE                    ; DD005
        MOV     R2,R1           ;;;GET A COPY OF THE TYPED CHARACTER            ; DD005
        BIC     #177417,R1      ;;;CLEAR ALL BUT HIGH ORDER 4 BITS              ; DD005
        ASR     R1              ;;;DIVIDE BY 8.                                 ; DD005
        ASR     R1              ;;;                                             ; DD005
        ASR     R1              ;;;                                             ; DD005
        ADD     R1,R3           ;;;ADD OFFSET TO TABLE BASE ADDRESS             ; DD005
        MOVB    R2,R1           ;;;GET ANOTHER COPY OF CHARACTER                ; DD005
        BIC     #177760,R1      ;;;THIS TIME LOOK AT LOW ORDER 4 BITS           ; DD005
        ASL     R1              ;;;CONVERT FROM BYTE TO WORD OFFSET             ; DD005
        BIT     $BTMSK(R1),@R3  ;;;SEE IF MATCHES AGAINST TERMINATOR TABLE      ; DD005
        BEQ     20$             ;;;N - JUMP                                     ; DD005
        MOV     (SP)+,R1        ;;;RESTORE REGISTER                             ; DD005
        BR      10$             ;;;CHARACTER IS A TERMINATOR                    ; DD005
5$:     CMPB    R2,#40          ;;;LOWER THAN 40?                               ; DD005
        BLO     10$             ;;;Y - TERMINATOR                               ;**-1
        CMPB    R2,#175         ;;;HIGHER THAN 175?
        BLO     I2DEF1          ;;;N - NORMAL CHARACTER (MAY NEED LOWER         ;PW018
                                ;;;TO UPPER CASE CONVERSION)                    ;PW018
        CMPB    R2,#177         ;;;177?                                         ;**-4
        BEQ     10$             ;;;Y - TERMINATOR
        BIT     #U2.LWC,U.CW2-U.TSTA(R5) ;;;CASE CONVERSION ENABLED?
        BNE     I2RAL           ;;;N - 175-176 ARE NORMAL CHARACTERS
10$:    SWAB    R2              ;;;GET TERMINATOR IN HIGH BYTE                  ;**-3
        CLRB    R2              ;;;CLEAR LOW BYTE
        INC     R2              ;;;SET IS.SUC IN LOW BYTE
                                ;;;DON'T STORE ANYTHING IN BUFFER!
        ASSUME  U.TCI,0
        MOV     R2,@(R4)+       ;;;STORE STATUS
        BR      IDONE           ;;;ALL DONE
20$:    MOV     (SP)+,R1        ;;;RESTORE PREVIOUS REGISTER CONTENTS           ; DD005
        BR      I2RAL           ;;;PROCESS A NORMAL CHARACTER                   ; DD005
.PAGE
.SBTTL  ESCAPE CHARACTER (33)

I2ESC:

        .IF DF  T$$ESC

        .ENABL  LSB

        BIT     #S3.WES,4(R5)   ;;;DOES TASK WANT ESCAPE SEQUENCES?
        BEQ     I2ESC1          ;;;N - JUMP
        BIT     #U2.ESC,U.CW2-U.TSTA(R5) ;;;DOES TERMINAL GENERATE THEM?
        BEQ     I2ESC1          ;;;N - JUMP
        BIT     #S1.USI,@R5     ;;;SOLICITED INPUT?
        BEQ     70$             ;;;Y - JUMP

        .IFTF   ;T$$ESC

.SBTTL  ALTERNATE ESCAPE CHARACTER (OTHER THAN 33)
;
        ASSUME  U.TCI,0
I2ESC1: MOV     #IS.ESC,@(R4)+ ;;;STATUS = IS.ESC
        BR      IDONE           ;;;DO INPUT DONE (NO ECHO)

        .IFT    ;T$$ESC

.SBTTL  PROCESS ESCAPE SEQUENCE
;
I2ESC2: CMPB    R2,#37          ;;;CHAR. IN RANGE 0-37?
        BLO     50$             ;;;Y - SYNTAX ERROR
        CMPB    R2,#CH.RUB      ;;;RUBOUT?
        BEQ     RUBESC          ;;;Y - JUMP
        MOVB    U.TISV(R4),R3   ;;;GET CURRENT SYNTAX RULE
        BNE     5$              ;;;NOT FIRST TIME THRU - JUMP                   ; DD002
        CMPB    U.TTYP-U.TSTA(R5),#13 ;;;VT61?                                  ; DD002
        BNE     5$              ;;;N - JUMP                                     ; DD002
        MOV     #-6,R3          ;;;Y - ALLOW CERTAIN EXCEPTIONS                 ; DD002
5$:                                                                             ; DD002
        ADD     #ESCST,R3       ;;;GET POINTER IN ESCAPE SYNTAX RULE TABLE
10$:    CMPB    R2,(R3)+        ;;;CHAR. IN RANGE?
        BLO     30$             ;;;N - JUMP
        CMPB    R2,(R3)+        ;;;
        BHI     40$             ;;;
        MOVB    @R3,U.TISV(R4)  ;;;OK - SAVE NEXT SYNTAX RULE
        BNE     80$             ;;;NOT DONE YET - JUMP
;
; ESCAPE SEQUENCE COMPLETE - SET STATUS IS.ESQ
;
        MOV     #IS.ESQ,@U.TCI(R4) ;;;SET RETURN STATUS
        BR      60$             ;;;ESCAPE SEQUENCE COMPLETE
;
; CHARACTER DIDN'T MATCH CURRENT RANGE - GET NEXT RANGE FOR
; CURRENT SYNTAX RULE
;
30$:    INC     R3              ;;;UPDATE POINTER
40$:    TSTB    (R3)+           ;;;ANY MORE RANGES FOR THIS RULE?
        BNE     10$             ;;;Y - LOOP
;
; ESCAPE SEQUENCE SYNTAX ERROR - SET STATUS IE.IES
;
50$:    MOV     #IE.IES&377,@U.TCI(R4) ;;;SET ERROR STATUS
60$:    CALL    90$             ;;;GET OUT OF ESCAPE SEQUENCE MODE
        BR      80$             ;;;
70$:    BIS     #S1.ESC,@R5     ;;;ENTER ESCAPE SEQUENCE MODE
80$:    CALL    PUTNIC          ;;;STORE CHARACTER
                                ;;;DON'T ECHO ANYTHING
        JMP     ECHD2           ;;;TEST FOR COMPLETION                          ; DD002
;                                                                               ;**-1
;
; RUBESC - DELETE THE ENTIRE ESCAPE SEQUENCE FROM INPUT BUFFER
; AND EXIT FROM ESCAPE SEQUENCE MODE.
;
RUBESC::CALL    GETPIC          ;;;GET PREVIOUS CHARACTER
        CMPB    R2,#CH.ESC      ;;;ESCAPE?
        BNE     RUBESC          ;;;N - LOOP TILL WE FIND IT
90$:    BIC     #S1.ESC,@R5     ;;;GET OUT OF ESCAPE MODE
        CLRB    U.TISV(R4)      ;;;CLEAR STATE VARIABLE

        .DSABL  LSB

        .ENDC   ;T$$ESC

RET1:   RETURN                  ;;;RETURN

.PAGE
.SBTTL  CARRIAGE-RETURN
;
; CARRIAGE RETURN - TERMINATE INPUT WITH STATUS IS.CR
;
        .ENABL  LSB
;
I2CR::  CLR     -(SP)           ;;;ZERO ADJUSTMENT FLAG
        ASSUME  U.TCI,0
        MOV     #IS.CR,@(R4)+   ;;;STATUS = IS.CR
        BR      10$             ;;;
;
;
.SBTTL  CTRL-Z
;
; CTRL-Z - TERMINATE INPUT WITH STATUS IE.EOF
;
I2CTZ:: MOV     #2,-(SP)        ;;;SET ADJUSTMENT FLAG = 2
        ASSUME  U.TCI,0
        MOV     #IE.EOF&377,@(R4)+ ;;;STATUS = IE.EOF
10$:    TST     -(R4)           ;;;RESTORE UCBX POINTER
        BIT     #S1.RNE,@R5     ;;;ECHO SUPPRESSED?
        BNE     IDONE0          ;;;Y - DON'T ECHO ANYTHING
        CALL    EXCR1           ;;;EXPAND A CARRIAGE RETURN
        BCC     20$             ;;;NO LEADING LF REQUIRED - JUMP
        BIS     #S1.DPR,@R5     ;;;ELSE DEFER PROCESSING OF CR OR CTRL-Z
        CLR     @SP             ;;;CLEAR FLAG
20$:    ADD     @SP,R2          ;;;ADJUST BYTE COUNT
        SUB     (SP)+,R3        ;;;ADJUST BUFFER POINTER
        CALLR   ECHSTR          ;;;ECHO STRING                                  ; DD003
;                                                                               ;**-1
        .DSABL  LSB
.PAGE
.SBTTL  CTRL-U
;
; CTRL-U - ECHO "^U <CR>"
;       OR      "^U <CR> <PROMPT STRING>"
;
;
        .ENABL  LSB
;
I2CTU:: BIT     #S1.RNE,@R5     ;;;ECHO SUPPRESSED?
        BNE     I2CTU3          ;;;Y - JUMP
        MOVB    #SV.CU1,U.TISV(R4) ;;;INITIALIZE STATE VARIABLE
        MOV     #ASCTU,R3       ;;;GET CTRL-U STRING

        .IF DF  T$$CTR

        BR      5$              ;;;ECHO ^U
;
;
.SBTTL  CTRL-R
;
; CTRL-R - ECHO "^R <CR> <INPUT BUFFER>"
;       OR      "^R <CR> <PROMPT STRING> <INPUT BUFFER>"
;
I2CTR:: BIT     #S1.RNE,@R5     ;;;ECHO SUPPRESSED?
        BEQ     3$              ;;;N - WE CAN PERFORM THE ^R FUNCTION           ; DD009
        CALLR   CFGRQ           ;;;Y - IGNORE. PROCESS AN OUTPUT REQUEST        ; DD009
3$:     MOV     U.TIP+2(R4),U.TTOC(R4) ;;;SAVE POS. OF LAST BYTE + 1            ; DD009
        MOVB    #SV.CR1,U.TISV(R4) ;;;INITIALIZE STATE VARIABLE                 ;**-2
        MOV     #ASCTR,R3       ;;;GET CTRL-R STRING

        .IFTF

5$:     BIT     #S2.FLF,2(R5)   ;;;FORCE LF?
        BEQ     6$              ;;;N - JUMP
        BIS     #S1.DPR,@R5     ;;;Y - DEFER PROCESSING OF ^U OR ^R
        CALL    EXPCHR          ;;;EXPAND CHARACTER IN R2 (JUST TO FORCE
                                ;;;THE LINE FEED)
        CALLR   ECHSTR          ;;;                                             ; DD003
6$:     MOV     R3,-(SP)        ;;;SAVE R3                                      ;**-1
        ASSUME  U.TCI,0
        MOV     (R4)+,R3        ;;;GET CURRENT INPUT PACKET
        MOV     #UPUNB,-(SP)    ;;;ASSUME UNBUFFERED INPUT                      ;PW025
        ASSUME  S1.IBF,100000
        TST     @R5             ;;;BUFFERED INPUT?
        BPL     20$             ;;;N - JUMP
        ADD     #U.TFIB-2,R4    ;;;Y - POINT TO U.TFIB
        MOV     @R4,R2          ;;;GET FIRST INPUT BUFFER
        MOV     #FPSUI1,@SP     ;;;ASSUME UNSOLICITED INPUT                     ;PW025
        BIT     #S1.USI,@R5     ;;;UNSOLICITED INPUT?
        BNE     20$             ;;;Y - JUMP                                     ;PW025
        MOV     I.PRM+4(R3),-(R4) ;;;SOLICITED INPUT - GET TOTAL BYTE COUNT     ;**-1
        MOV     #NXTIB,@SP      ;;;                                             ;PW025
20$:    CALL    @(SP)+          ;;;CALL UPUNB OR FPSUI1 OR NXTIB                ;PW025
                                ;;;TO UPDATE UCB                                ;PW025
30$:    MOV     U.TUX-U.TSTA(R5),R4 ;;;RESTORE UCBX POINTER                     ;**-6
        MOV     (SP)+,R3        ;;;POINT TO ^U OR ^R STRING
        MOV     #2,R2           ;;;LENGTH OF ^U OR ^R STRING
;
; DON'T WORRY ABOUT UPDATING CURRENT HORIZONTAL POSITION FOR 2 CHARACTERS,
; WE ARE GOING TO DO A CARRIAGE RETURN IMMEDIATELY AFTER
;
        CALLR   ECHSTR          ;;;GO ECHO STRING                               ; DD003
;                                                                               ;**-1
; ^R OR ^U HAS BEEN ECHOED. SET UP TO ECHO CARRIAGE-RETURN (PLUS FILLERS)
;
I2CTU1::
I2CTR1::INCB    U.TISV(R4)      ;;;UPDATE STATE VARIABLE
        BIT     #S1.USI,@R5     ;;;UNSOLICITED INPUT?                           ;**-3
        BNE     50$             ;;;Y - JUMP                                     ; DD003
                                                                                ; DD003
        .IF DF  T$$RPR                                                          ; DD003
                                                                                ; DD003
        ASSUME  U.TCI,0                                                         ;**-5
        MOV     @R4,R3          ;;;GET CURRENT INPUT PACKET
        CMPB    I.FCN+1(R3),#IO.RPR/400 ;;;IO.RPR?
        BEQ     50$             ;;;Y - JUMP
                                                                                ; DD003
        .IFTF   ;T$$RPR                                                         ; DD003
                                                                                ; DD003
40$:    INCB    U.TISV(R4)      ;;;N - BYPASS NEXT STATE
50$:    CALL    EXCR1           ;;;EXPAND A CARRIAGE-RETURN                     ;**-3
ECHOS:: CALLR   ECHSTR          ;;;ECHO STRING AND RETURN
;                                                                               ;**-3
; CARRIAGE RETURN HAS BEEN ECHOED. ECHO PROMPT BUFFER.
;
I2CTU2::
I2CTR2::INCB    U.TISV(R4)      ;;;UPDATE STATE VARIABLE
;
; SET CURRENT HORIZONTAL POSITION = INITIAL HORIZONTAL POSITION
; FOR THE READ PORTION OF IO.RPR. WE DON'T CARE ABOUT INCORRECT
; HOR. POS. DURING THE ECHO OF THE PROMPT STRING. FURTHERMORE,
; IT IS POSSIBLE THAT THE ORIGINAL PROMPT STARTED AT A POSITION
; OTHER THAN FIRST COLUMN. IF SO, WE CAN ONLY HOPE THAT THE
; PROMPT BUFFER CONTAINS AN EXPLICIT CURSOR POSITIONING COMMAND.
; IF NOT, HOR. POS. WILL BE INCORRECT WHILE DOING THE NEXT READ.
;
; WE KNOW THAT THE LAST CHARACTER THAT WAS EXPANDED BY EXPCHR WAS
; A CARRIAGE RETURN, SO THE FORCE-LINE-FEED FLAG (S2.FLF) IS NOW
; SET. IF THE INITIAL HOR. POS. IS NOT COLUMN 1, WE MUST CLEAR THE
; FLAG.
;
        MOVB    U.TIHP(R4),U.TCHP-U.TSTA(R5)
        BEQ     55$             ;;;AT COLUMN 1 - LEAVE S2.FLF SET
        BIC     #S2.FLF,2(R5)   ;;;ELSE CLEAR IT
55$:                                                                            ; DD003
                                                                                ; DD003
        .IFT    ;T$$RPR                                                         ; DD003
                                                                                ; DD003
        BIT     #S1.USI,@R5     ;;;ECHO CLI PROMPT?                             ; DD003
        BNE     56$             ;;;Y - JUMP                                     ; DD003
        MOV     U.TFPB(R4),U.TFOB(R4) ;;;GET FIRST PROMPT BUFFER                ; DD003
        CALLR   STAXL           ;;;ECHO PROMPT STRING                           ; DD003
56$:                                                                            ; DD003
                                                                                ; DD003
        .IFTF                                                                   ; DD003
                                                                                ; DD003
        MOV     #ASCLP,R3       ;;;ASSUME ECHO ANGLE BRACKET ONLY               ; DD003
        MOV     #2,R2           ;;;TWO BYTES LENGTH (INCLUDES LF)               ; DD003
        TST     U.TFPB(R4)      ;;;DID WE ASSUME CORRECTLY?                     ; DD003
        BEQ     58$             ;;;Y - JUMP                                     ; DD003
                                                                                ; DD003
        .IF DF  R$$MPL!M$$CLI                                                   ; CS033
                                                                                ; DD003
        MOV     U.CLI-U.TSTA(R5),R3 ;;;GET POINTER TO CLI                       ; DD003
        TST     (R3)+           ;;;POINT PAST CLI TCB                           ; DD003
        MOV     R3,R2           ;;;COPY POINTER TO CLI NAME                     ; DD003
57$:    TSTB    (R2)+           ;;;SEARCH FOR END OF ASCIZ NAME AND PROMPT      ; DD003
        BNE     57$             ;;;                                             ; DD003
        SUB     R3,R2           ;;;GET LENGTH OF CLI PROMPT                     ; DD003
        BR      58$             ;;;ECHO PROMPT                                  ; DD003
                                                                                ; DD003
        .ENDC   ;R$$MPL!M$$CLI                                                  ; CS033
                                                                                ; DD003
        MOV     #ASCLI,R3       ;;;GET ADDRESS OF FULL CLI PROMPT               ; DD003
        MOV     #5,R2           ;;;GET PROMPT LENGTH                            ; DD003
58$:    CALLR   ECHSTR          ;;;ECHO CLI PROMPT                              ; DD003
                                                                                ;**-1
        .ENDC

        .IFT

;                                                                               ; DD009
; SAVE THE PRESENT ECHO STATUS, THEN FORCE ICHAR2 TO ECHO INPUT                 ; DD009
;                                                                               ; DD009
I2CTR3::INCB    U.TISV(R4)      ;;;UPDATE STATE VARIABLE                        ; DD009
        MOVB    @R5,U.TVFC(R4)  ;;;SAVE U.TSTA IN VERT. FORMAT FIELD            ; DD009
        BIC     #S1.RNE,@R5     ;;;FORCE ECHO MODE                              ; DD009
;
; ECHO INPUT BUFFER. THIS IS DONE BY "RECYCLING" ALL CHARACTERS
; THAT HAVE BEEN INPUT SO FAR THRU THE INPUT LOGIC.
;
I2CTR4::MOV     U.TIP+2(R4),R3  ;;;GET POINTER TO NEXT BYTE TO PROCESS          ; DD009
        CMP     R3,U.TTOC(R4)   ;;;ALL DONE?                                    ;**-1
        BEQ     I2CTR5          ;;;Y - ALL DONE, JUMP                           ; DD009
        CALL    GETRIC          ;;;GET THE CHARACTER                            ;**-1
        CALLR   ICHAR2          ;;;RECYCLE CHARACTER THRU INPUT LOGIC

        .IFTF

;
; ALL DONE
;
I2CTU3::CLRB    U.TISV(R4)      ;;;CLEAR STATE VARIABLE
        MOVB    U.TCHP-U.TSTA(R5),U.TIHP(R4)                                    ;PW024
                                ;;;SET INITIAL HOR. POS. = CURRENT              ;PW024
        BIT     #S1.USI,@R5     ;;;UNSOLICITED INPUT?
        BEQ     60$             ;;;N - JUMP
        ASSUME  U.TCI,0
        MOV     #IS.TMO+1,@(R4)+ ;;;Y - SET STATUS = IS.TMO+1                   ;PW009
        JMP     IDONE           ;;;INPUT DONE                                   ;**-1
;

        .IFT

I2CTR5::MOVB    U.TVFC(R4),@R5  ;;;RESTORE STATE VARIABLE                       ; DD009
        CLRB    U.TISV(R4)      ;;;CLEAR STATE VARIABLE                         ; DD009
                                                                                ;**-1
        .ENDC

60$:    CALLR   CFGRQ           ;;;CONDITIONALLY FORK TO GET AN
                                ;;;OUTPUT REQUEST FROM QUEUE
;
        .DSABL  LSB
.PAGE
.SBTTL  CTRL-O, CTRL-Q, CTRL-S, CTRL-X
;
; CTRL-Q, CTRL-S, CTRL-O AND CTRL-X.
; IF ANY OF THESE CHARACTERS IS RECEIVED WHEN AN IO.RAL OR IO.RST
; IS ACTIVE, STORED IN THE TYPE-AHEAD BUFFER (FOR EXAMPLE, BECAUSE
; ECHO IS REQUIRED AND OUTPUT IS BUSY), THE READ TERMINATES AND
; THE NEXT READ IS AN IO.RLB, THEN THESE SPECIAL CHARACTERS WILL
; APPEAR HERE. WE DON'T WANT TO PASS THEM TO THE TASK, SO WE
; JUST IGNORE THEM.
;
; THE SAME IS DONE FOR CTRL-C FROM A SLAVED TERMINAL, AND FOR CTRL-R
; IN A SYSTEM THAT DOES NOT SUPPORT CTRL-R.
;
I2CTQ::
I2CTS::
I2CTO::
I2CTX::

        .IF NDF T$$CTR

I2CTR::

        .ENDC   ;T$$CTR

RET2:   RETURN                  ;;;IGNORE
.PAGE
.SBTTL  CTRL-C
;
; CTRL-C - START (OR RESTART) UNSOLICITED INPUT.
;
;
        ASSUME  U2.SLV,200
I2CTC:: TSTB    U.CW2-U.TSTA(R5) ;;;SLAVED TERMINAL?
        BMI     RET2            ;;;Y - IGNORE
                                                                                ;CJR001
        .IF DF  R$$SCS                                                          ;CJR001
                                                                                ;CJR001
        MOV     #FR.FLU,R3      ;;;FORK/FLUSH TASKS RUNNING ON TERMINAL         ;CJR001
        CALLR   FORK            ;;;QUEUE FORK REQUEST                           ;CJR001
                                                                                ;CJR001
        .IFF    ;R$$SCS                                                         ;CJR001
                                                                                ;CJR001
        ADD     #U.TFIB,R4      ;;;POINT TO U.TFIB
        CALL    FPSUI1          ;;;SET UP UCB FOR UNSOL. INPUT
        MOV     SP,U.TFPB-U.TIC(R4) ;;;ECHO A FULL CLI PROMPT FOR ^R            ; DD009
;
; FILL INPUT BUFFER WITH THE FOLLOWING PROMPT STRING:
;
;       <ESC> \ <CR> <FILLERS> <LF> <FILLERS> XXX>
;
; WHERE "<ESC> \" TAKES THE TERMINAL OUT OF HOLD-SCREEN MODE
; (INSERTED ONLY IF TERMINAL IS IN HOLD-SCREEN MODE)
; AND "XXX" IS THE CLI NAME. OUTPUT THE PROMPT.
;
        MOV     R1,-(SP)        ;;;SAVE R1
        ASSUME  U.TIP+2,U.TIC-2
        MOV     -(R4),R1        ;;;GET START OF OUTPUT BUFFER
        BIT     #U2.HLD,U.CW2-U.TSTA(R5) ;;;IN HOLD-SCREEN MODE?
        BEQ     5$              ;;;N - JUMP
        MOV     (PC)+,(R1)+     ;;;INSERT <ESC> \ - EXIT HOLD SCREEN MODE
        .BYTE   CH.ESC,CH.BSL
;
; NOW EXPAND CARRIAGE RETURN TWICE. THIS HAS THE FOLLOWING EFFECT:
;       1. IF THE LAST EXPANDED CHARACTER WAS NOT CARRIAGE RETURN,
;          THE FIRST CR EXPANDS AS CR, AND THE SECOND ONE AS LF.
;       2. ELSE, THE FIRST CR EXPANDS AS LF AND THE SECOND ONE AS CR.
; IN CASE 2, THE FLAG S2.FLF WILL BE SET AFTER THE SECOND EXPANSION
; AND MUST BE CLEARED.
;
5$:     CALL    EXCR1           ;;;EXPAND A CARRIAGE RETURN
10$:    MOVB    (R3)+,(R1)+     ;;;INSERT
        SOB     R2,10$          ;;;LOOP
        CALL    EXCR1           ;;;EXPAND CR AGAIN
20$:    MOVB    (R3)+,(R1)+     ;;;INSERT
        SOB     R2,20$          ;;;LOOP
        BIC     #S2.FLF,2(R5)   ;;;DON'T FORCE ANOTHER LF
                                                                                ; CS033
        .IF DF R$$MPL!M$$CLI                                                    ; CS033
                                                                                ; CS033
        MOV     U.CLI-U.TSTA(R5),R3 ;;;GET POINTER TO CLI NAME
        ADD     #4,R3           ;;;                                             ; CS033
30$:    MOVB    (R3)+,(R1)+     ;;;INSERT                                       ;**-1
        BNE     30$             ;;;LOOP
                                                                                ; CS013
        .IFF    ;R$$MPL!M$$CLI                                                  ; CS033
                                                                                ; CS013
        MOVB    #'M,(R1)+       ;;;INSERT M                                     ; CS013
        MOVB    #'C,(R1)+       ;;;       C                                     ; CS013
        MOVB    #'R,(R1)+       ;;;       R                                     ; CS013
        MOVB    #'>,(R1)+       ;;;       >                                     ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL!M$$CLI                                                  ; CS033
                                                                                ; CS033
        MOV     @R4,R3          ;;;GET START OF PROMPT STRING (U.TIP+2)
        CMP     -(R4),-(R4)     ;;;RESTORE UCBX POINTER
        MOV     R1,R2           ;;;
        SUB     R3,R2           ;;;GET LENGTH OF IT
        MOV     (SP)+,R1        ;;;RESTORE R1
        MOVB    #4,U.TCHP-U.TSTA(R5) ;;;SET UP CURRENT HOR. POS.
        MOVB    #4,U.TIHP(R4)   ;;;SET INITIAL HOR. POS.
        BIC     #U2.HLD,U.CW2-U.TSTA(R5) ;;;CLEAR HOLD-SCREEN FLAG
                                                                                ;CJR001
        .ENDC   ;R$$SCS                                                         ;CJR001
                                                                                ;CJR001
ECHOS1: CALLR   ECHSTR          ;;;ECHO PROMPT STRING                           ; DD003
.PAGE                                                                           ;**-1
.SBTTL  RUBOUT
;
; RUBOUT
;
;
        .ENABL  LSB
;
I2RUB:: CALL    GETPIC          ;;;GET (AND REMOVE) PREVIOUS CHARACTER
        BCS     RET2            ;;;NONE - JUMP
        BIT     #S1.RNE,@R5     ;;;ECHO SUPPRESSED?
        BNE     RET2            ;;;Y - JUMP
        TSTB    U.TCHP-U.TSTA(R5) ;;;AT LEFT MARGIN?
        BEQ     RET2            ;;;Y - DON'T ECHO ANYTHING

        .IF DF  T$$RUB

        BIT     #U2.CRT,U.CW2-U.TSTA(R5) ;;;SCOPE?
        BEQ     70$             ;;;N - JUMP
;
; SCOPE RUBOUT. HORIZONTAL TAB ECHOS AS A NUMBER OF BACKSPACES (1-8).
; ANYTHING ELSE ECHOS AS BACKSPACE-SPACE-BACKSPACE.
;
        CMPB    R2,#CH.HT       ;;;HTAB?
        BEQ     10$             ;;;Y - JUMP
        MOV     #ASRBS,R3       ;;;POINT TO BSP-SP-BSP STRING
        MOV     #3,R2           ;;;SET LENGTH
        DECB    U.TCHP-U.TSTA(R5) ;;;UPDATE HOR. POS.
        BR      ECHOS1          ;;;GO ECHO
;
; FIND PREVIOUS HORIZONTAL POSITION
;
10$:    MOVB    U.TCHP-U.TSTA(R5),-(SP) ;;;SAVE CURRENT HOR. POS.
        MOVB    U.TIHP(R4),U.TCHP-U.TSTA(R5)
                                ;;;RESET CURRENT POS. TO INITIAL POS.
        MOV     R3,-(SP)        ;;;SAVE R3 (POINTS TO THE HTAB)
        ASSUME  U.TCI,0
        MOV     @R4,R3          ;;;GET CURRENT PACKET (IF SOLICITED INPUT)
        MOV     I.PRM+2(R3),R3  ;;;GET START OF TASK BUFFER
;
; NOTE - THE 2 INSTRUCTIONS ABOVE ASSUME THAT THE CURRENT INPUT IS UNBUFFERED
; SOLICITED INPUT.
; OF COURSE "I.PRM+2(R3)" MAKES NO SENSE IF THE INPUT IS UNSOLICITED, BUT
; NO ADDRESSING ERROR CAN OCCUR.
;
        CLR     -(SP)           ;;;SET UP A VERY LARGE LOOP COUNT
        ASSUME  S1.IBF,100000
        TST     @R5             ;;;BUFFERED INPUT?
        BPL     30$             ;;;N - JUMP
        MOV     U.TFIB(R4),R3   ;;;Y - GET FIRST INPUT BUFFER
20$:    CMP     (R3)+,(R3)+     ;;;POINT TO START OF DATA AREA
        MOV     #T$$BFL-4,@SP   ;;;SET MAX BYTES IN BUFFER
;
; THE FOLLOWING IS A LOOP THAT GOES THROUGH ALL CHARACTERS THAT HAVE BEEN
; INPUT SO FAR AND EXPANDS THEM. THE PURPOSE IS TO UPDATE THE CURRENT
; HORIZONTAL POSITION (U.TCHP) TO THE VALUE IT HAD BEFORE THE LAST
; CHARACTER (THE TAB) WAS INPUT.
;
30$:    CMP     R3,2(SP)        ;;;POINTING TO THE RUBBED-OUT CHAR.?
        BEQ     50$             ;;;Y - JUMP
40$:    CALL    GETRIC          ;;;N - GET THE CHARACTER POINTED TO BY R3
        MOV     R3,-(SP)        ;;;SAVE R3
        CALL    EXPCHR          ;;;EXPAND CHARACTER
        MOV     (SP)+,R3        ;;;RESTORE R3
        BCS     40$             ;;;EXPAND CHARACTER AGAIN
        INC     R3              ;;;UPDATE POINTER
        DEC     @SP             ;;;DECR. LOOP COUNT
        BNE     30$             ;;;MORE IN THIS BUFFER - LOOP
        MOV     -T$$BFL(R3),R3  ;;;LOOP COUNT RAN OUT - THIS CAN ONLY HAPPEN
                                ;;;IF WE ARE DOING BUFFERED INPUT
                                ;;;GET LINK TO NEXT BUFFER (THERE MUST BE ONE)
        BR      20$             ;;;BIG LOOP
;
; WE ARE BACK AT WHERE WE STARTED - U.TCHP CONTAINS NEW (BACKSPACED)
; HORIZONTAL POSITION.
;
50$:    CMP     (SP)+,(SP)+     ;;;CLEAN STACK
        MOV     @SP,R2          ;;;GET OLD HOR. POS.
        MOVB    U.TCHP-U.TSTA(R5),@SP ;;;GET NEW HOR. POS.
        SUB     (SP)+,R2        ;;;CALCULATE NUMBER OF BACKSPACES REQUIRED
        BGT     60$             ;;;.GT. 0 - JUMP
        MOV     #8.,R2          ;;;THE TAB WE WANT TO RUB OUT CAUSED AN
                                ;;;AUTO CR-LF - SPACE BACK TO LEFT MARGIN
60$:    MOV     #ASBSP,R3       ;;;POINT TO STRING WITH BACKSPACES
        BR      ECHOS1          ;;;ECHO THE STRING

        .ENDC

70$:    MOVB    R2,U.TECB(R4)   ;;;SAVE RUBBED-OUT CHAR.
        BIT     #S1.RUB,@R5     ;;;ALREADY IN RUBOUT SEQUENCE?
        BNE     90$             ;;;Y - JUMP
        BIS     #S1.RUB!S1.DEC,@R5 ;;;N - SET RUBOUT AND DEFERRED ECHO FLAGS
80$:    MOV     #ASBSL,R3       ;;;POINT TO \
        INCB    U.TCHP-U.TSTA(R5) ;;;UPDATE HOR. POS.
        JMP     ECHCHR          ;;;ECHO 1 CHARACTER POINTED TO BY R3
90$:    JMP     EXPC            ;;;EXPAND AND ECHO CHARACTER IN R2 AND U.TECB
;
; ALREADY IN RUBOUT MODE
;
I2RUB1: CMPB    R2,#CH.RUB      ;;;THIS ALSO A RUBOUT?
        BEQ     I2RUB           ;;;Y - HANDLE AS SUCH
        BIC     #S1.RUB,@R5     ;;;N - GET OUT OF RUBOUT MODE
        BIS     #S1.DPR,@R5     ;;;SET DEFERRED PROCESSING FLAG
        BR      80$             ;;;ECHO \ NOW - DEFER PROCESSING
                                ;;;OF CHARACTER IN U.TECB
;
        .DSABL  LSB
.PAGE
.SBTTL  IPROC - DETERMINE WHETHER AN INPUT CHARACTER CAN BE PROCESSED NOW.
;
;+
; IPROC - DETERMINE WHETHER AN INPUT CHARACTER CAN BE PROCESSED NOW.
;
; INPUT:
;       R2      CHARACTER
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF CHARACTER CAN BE PROCESSED NOW:
;       CC-C    0
;
;       IF CHARACTER CAN NOT BE PROCESSED NOW:
;       CC-C    1
;
;       IF CHARACTER IS TO BE THROWN AWAY:                                      ; DD009
;       CC-Z    1                                                               ; DD009
;                                                                               ; DD009
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
        .ENABL  LSB                                                             ;PW007
;                                                                               ;PW007
IPROC:: BIT     #S1.DSI,@R5     ;;;INPUT PROCESSING DISABLED?
        BNE     RETCS           ;;;Y - CAN'T PROCESS NOW, JUMP
        CMP     R2,#CH.CTC      ;;;CTRL-C (AND NO HARD RECEIVE ERROR)?          ;PW007
        BNE     20$             ;;;N - JUMP                                     ;**-1
;
; CHARACTER IS CTRL-C
;
        ASSUME  S1.IBY,200
        TSTB    @R5             ;;;INPUT BUSY?
        BMI     5$              ;;;Y - JUMP                                     ; DD018

        .IF DF  T$$CCA&A$$TRP

;                                                                               ;**-1
; CTRL-C AND INPUT NOT BUSY.
; CHECK WHETHER CTRL-C SHOULD CAUSE AN AST OR NOT.
;
        MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX IF THERE IS ONE
        BEQ     10$             ;;;THERE ISN'T - JUMP
        MOV     U.TAST(R4),R3   ;;;GET AST BLOCK IF THERE IS ONE
        BEQ     4$              ;;;NO AST SET UP - JUMP                         ; DD018
        BITB    #TF.XCC,A.PRM+5(R3) ;;;WANT CTRL-C PASSED TO AST?               ;**-1
        BNE     10$             ;;;N - JUMP
3$:     TST     A.PRM+6(R3)     ;;;NEED TO CHECK FOR LOCKED AST BLOCK?          ; DD015
        BEQ     50$             ;;;Y - CHECK THAT POSSIBILITY                   ; DD015
        BIT     #1,A.PRM+4(R3)  ;;;IS AST STILL IN QUEUE?                       ; DD015
        BNE     RETCS           ;;;Y - CAN'T PROCESS ^C NOW                     ; DD015
        BR      55$             ;;;N - JUMP                                     ; DD015
4$:                                                                             ; DD018
                                                                                ;**-1
        .IFTF   ;T$$CCA$A$$TRP                                                  ; DD018
                                                                                ;**-1
        BIT     #S3.RAL,4(R5)   ;;;READ-PASS-ALL IN EFFECT?                     ; DD018
        BNE     RETCS           ;;;Y - PUT ^C IN TYPE-AHEAD BUFFER              ; DD018
        BR      10$             ;;;N - SEE IF TERMINAL IS SLAVED                ; DD018
;                                                                               ;**-4
; CHARACTER IS CTRL-C AND INPUT IS BUSY.
;       1. IF DOING IO.RAL OR IO.RST, OR IF ALREADY DOING UNSOLICITED
;          INPUT, TRY TO PROCESS IMMEDIATELY (DEPENDENT ON OUTPUT BUSY
;          AND ECHOING REQUIREMENT).
;       2. ELSE, IF TERMINAL SLAVED, "PROCESS" IMMEDIATELY
;          (THE PROCESSING WILL BE TO DISCARD THE CHARACTER).
;       3. ELSE, IF AST IS NOT SPECIFIED, FORK TO ABORT SOLICITED               ; DD009
;                INPUT AND START UNSOLICITED INPUT.                             ; DD009
;       4. ELSE, QUEUE AN AST                                                   ; DD009
;                                                                               ;**-2
5$:     BIT     #S1.RAL!S1.RST!S1.USI,@R5
                                ;;;DOING IO.RAL OR IO.RST OR UNSOL. INPUT?
        BNE     30$             ;;;Y - JUMP
                                                                                ; DD009
        .IFT    ;T$$CCA&A$$TRP                                                  ; DD009
                                                                                ; DD009
        MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX                                 ; DD009
        MOV     U.TAST(R4),R3   ;;;GET AST BLOCK IF THERE IS ONE                ; DD009
        BEQ     10$             ;;;ASTS NOT SPECIFIED - JUMP                    ; DD009
        BITB    #TF.XCC,A.PRM+5(R3) ;;;PASS ^C TO AST?                          ; DD009
        BNE     10$             ;;;N - JUMP                                     ; DD009
        BIT     #1,A.PRM+4(R3)  ;;;IS AN AST ALREADY QUEUED?                    ; DD009
        BEQ     3$              ;;;N - AST MAY BE POSSIBLE.  TEST FURTHER       ; DD009
        SEZ                     ;;;Y - THROW AWAY ^C TO PREVENT QUEUEING        ; DD009
                                ;;;ANOTHER AST WHILE A READ IS IN PROGRESS      ; DD009
        RETURN                  ;;;RETURN WITH CC-Z = 1                         ; DD009
                                                                                ; DD009
        .ENDC   ;T$$CCA&A$$TRP                                                  ; DD009
                                                                                ; DD009
        ASSUME  U2.SLV,200
10$:    TSTB    U.CW2-U.TSTA(R5) ;;;SLAVED TERMINAL?
        BMI     RETCC           ;;;Y - PROCESS NOW (THE "PROCESSING" WILL
                                ;;;IGNORE CTRL-C)
                                                                                ;CJR001
        .IF DF  R$$SCS                                                          ;CJR001
                                                                                ;CJR001
        MOV     #FR.FLU,R3      ;;;FORK/FLUSH TASKS ON TERMINAL                 ;CJR001
        BR      80$             ;;;                                             ;CJR001
                                                                                ;CJR001
        .IFF    ;R$$SCS                                                         ;CJR001
                                                                                ;CJR001
        BR      70$             ;;;N - JUMP
                                                                                ;CJR001
        .ENDC   ;R$$SCS                                                         ;CJR001
                                                                                ;CJR001
;
; NOT CTRL-C
;
        ASSUME  S1.IBY,200
20$:    TSTB    @R5             ;;;INPUT BUSY?
        BPL     40$             ;;;N - JUMP
;
; NOT CTRL-C, AND INPUT IS BUSY.
;       1. IF ECHO IS REQUIRED AND OUTPUT IS BUSY, RETURN
;          WITH CC-C = 1 (CHARACTER CAN NOT BE PROCESSED NOW).
;       2. ELSE, RETURN WITH CC-C = 0 (CHARACTER CAN BE PROCESSED NOW).
;
30$:    BIT     #S1.OBY,@R5     ;;;OUTPUT BUSY?
        BNE     RETCS           ;;;Y - CAN'T PROCESS NOW, JUMP                  ; DD009
RETCC:  .WORD   CLC!CLZ         ;;;RETURN WITH CC-C = 0, CC-Z = 0               ; DD009
        RETURN                                                                  ;PW007
;                                                                               ;**-4
; NOT CTRL-C, AND INPUT NOT BUSY.
;       1. IF UNSOLICITED INPUT AST SET UP, FORK TO THE FORK LEVEL
;          ROUTINE THAT QUEUES AN AST.
;          SPECIAL CASE - IF THE AST BLOCK IS "LOCKED", DO NOT FORK.
;          THE AST BLOCK IS LOCKED WHEN IT IS STILL IN THE TASK'S
;          AST QUEUE, OR WHEN TF.NOT WAS SPECIFIED AT ATTACH AND
;          THE TASK HAS NOT DONE A READ SINCE THE PREVIOUS AST
;          WAS QUEUED.
;       2. ELSE, IF TERMINAL ATTACHED, RETURN.
;       3. ELSE, FORK TO START UNSOLICITED INPUT.
;
; IN ALL OF THE ABOVE CASES, RETURN WITH CC-C = 1 TO INDICATE
; THAT CHARACTER CAN NOT BE PROCESSED IMMEDIATELY.
;
40$:    TST     U.ATT-U.TSTA(R5) ;;;TERMINAL ATTACHED?

        .IF DF  T$$CCA&A$$TRP

        BEQ     60$             ;;;N - JUMP
        MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX (TERMINAL IS ATTACHED
                                    ;;;SO THERE MUST BE ONE)
        MOV     U.TAST(R4),R3   ;;;GET AST BLOCK ADDRESS
        BEQ     RETCS           ;;;NONE - JUMP
        TST     A.PRM+10(R3)    ;;;ASTS WANTED FOR OTHER THAN ^C?               ; DD015
        BEQ     RETCS           ;;;N - JUMP                                     ; DD015
50$:    TSTB    A.PRM+4(R3)     ;;;AST BLOCK LOCKED?
        BNE     RETCS           ;;;Y - JUMP
55$:                            ;;;REF LABEL                                    ; DD015
                                                                                ;PW007
        .IF DF  T$$RED                                                          ;PW007
                                                                                ;PW007
        BIT     #S3.BCC!S3.DAO!S3.VER,R2                                        ;PW007
                                ;;;HARD RECEIVE ERROR?                          ;PW007
        BNE     RETCS           ;;;Y - DON'T CAUSE AST                          ;PW007
                                                                                ;PW007
        .ENDC   ;T$$RED                                                         ;PW007
                                                                                ;PW007
        MOV     #FR.AST,R3      ;;;FORK/AST
        BR      80$             ;;;

        .IFF    ;T$$CCA&A$$TRP

        BNE     RETCS           ;;;ATTACHED - CAN'T PROCESS NOW, JUMP

        .ENDC   ;T$$CCA&A$$TRP

60$:    TSTB    U.CW2-U.TSTA(R5) ;;;SLAVED TERMINAL?
        BMI     RETCS           ;;;Y - CAN'T PROCESS NOW
                                                                                ;CJR002
        .IF DF  R$$SCS                                                          ;CJR002
                                                                                ;CJR002
        BIT     #U2.SCS,U.CW2-U.TSTA(R5) ;;;SCS-11 TERMINAL?                    ;CJR002
        BNE     RETCS           ;;;Y - CAN'T PROCESS NOW                        ;CJR002
                                                                                ;CJR002
        .ENDC   ;R$$SCS                                                         ;CJR002
                                                                                ;CJR002
70$:    MOV     #FR.SUI,R3      ;;;FORK/START OF UNSOL. INPUT
80$:    CALL    FORK            ;;;QUEUE FORK REQUEST
RETCS:  SEC                     ;;;RETURN WITH CC-C = 1
        CLZ                     ;;;RETURN WITH CC-Z = 0                         ; DD009
        RETURN                  ;;;
;                                                                               ;PW007
        .DSABL  LSB                                                             ;PW007
;
;
.SBTTL  GCTAB - GET A CHARACTER FROM THE TYPE-AHEAD BUFFER.
;
;+
; GCTAB - GET A CHARACTER FROM THE TYPE-AHEAD BUFFER.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF CHARACTER WAS OBTAINED:
;       CC-C    0
;       R2      CHARACTER (CHARACTER IS NOT REMOVED FROM TYPE-AHEAD
;               BUFFER!)
;
;       IF NO CHARACTER OBTAINED:
;       CC-C    1
;
; REGISTERS ALTERED: R2,R3
;-
;
;
GCTAB:: MOV     R5,R3           ;;;
        ADD     #U.TTAB-U.TSTA,R3 ;;;POINT TO U.TTAB
                                ;;;(ALSO CLEARS CC-C)                           ;PW007
        MOV     @R3,R2          ;;;GET TABUF
        BEQ     RETCS           ;;;NONE - RETURN WITH ERROR
        BITB    #1,(R3)+        ;;;SINGLE-CHAR. TABUF?
        BNE     10$             ;;;Y - JUMP
        INC     R2              ;;;POINT TO RETRIEVE POINTER
        MOVB    (R2)+,R3        ;;;GET RETRIEVE POINTER AND POINT
                                ;;;TO ACTIVE COUNT
        TSTB    (R2)+           ;;;BUFFER EMPTY?
        BEQ     RETCS           ;;;Y - RETURN WITH ERROR
        ADD     R2,R3           ;;;MAKE POINTER IN BUFFER                       ;PW007
        INC     R3              ;;;POINT TO NEXT CHAR. TO RETRIEVE              ;PW007
                                                                                ;PW007
        .IF DF  T$$RED                                                          ;PW007
                                                                                ;PW007
        CMPB    -(R2),#1        ;;;IS THIS THE LAST CHAR. IN TABUF?             ;PW007
        BNE     10$             ;;;N - JUMP (ELSE CC-C = 0)                     ;PW007
        MOV     4(R5),R2        ;;;RETRIEVING LAST CHARACTER - GET HARD         ;PW007
                                ;;;RECEIVE ERROR FLAGS                          ;PW007
        BIC     #^C<S3.BCC!S3.DAO!S3.VER>,R2                                    ;PW007
                                ;;;CLEAR IRRELEVANT BITS                        ;PW007
        BR      20$             ;;;                                             ;PW007
                                                                                ;PW007
        .ENDC   ;T$$RED                                                         ;PW007
                                                                                ;PW007
10$:    CLR     R2              ;;;CLEAR R2 AND CC-C                            ;PW007
20$:    BISB    @R3,R2          ;;;PUT CHARACTER IN LOW BYTE                    ;PW007
        RETURN                  ;;;RETURN WITH CC-C = 0                         ;PW007
;                                                                               ;**-5
;
.SBTTL  RCTAB - REMOVE A CHARACTER FROM THE TYPE-AHEAD BUFFER.
;
;+
; RCTAB - REMOVE A CHARACTER FROM THE TYPE-AHEAD BUFFER.
;       MUST BE CALLED ONLY IF THERE IS A CHARACTER TOR REMOVE!!
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT: NONE
;
; REGISTERS ALTERED: R3
;-
;
;
RCTAB:: MOV     U.TTAB-U.TSTA(R5),R3 ;;;GET START OF TABUF
        BIT     #1,R3           ;;;SINGLE-CHAR. TABUF?
        BNE     20$             ;;;Y - JUMP
        INC     R3              ;;;POINT TO RETRIEVE POINTER                    ;PW007
        INCB    @R3             ;;;UPDATE RETRIEVE POINTER                      ;PW007
        CMPB    @R3,2(R3)       ;;;WRAP-AROUND?                                 ;**-3
        BNE     10$             ;;;N - JUMP
        CLRB    @R3             ;;;Y - RESET POINTER TO START OF BUFFER
10$:    DECB    1(R3)           ;;;DECREMENT ACTIVE COUNT                       ;PW007
                                                                                ;PW007
        .IF DF  T$$RED                                                          ;PW007
                                                                                ;PW007
        BEQ     30$             ;;;LAST CHARACTER REMOVED - JUMP                ;PW007
                                                                                ;PW007
        .IFTF   ;T$$RED                                                         ;PW007
                                                                                ;PW007
        RETURN                  ;;;RETURN                                       ;PW007
20$:    CLR     U.TTAB-U.TSTA(R5) ;;;MARK SINGLE-CHAR. TABUF EMPTY              ;**-1
                                                                                ;PW007
        .IFT    ;T$$RED                                                         ;PW007
                                                                                ;PW007
30$:    BIC     #S3.BCC!S3.DAO!S3.VER,4(R5)                                     ;PW007
                                ;;;CLEAR HARD RECEIVE ERROR FLAGS               ;PW007
                                                                                ;PW007
        .ENDC                                                                   ;PW007
                                                                                ;PW007
        RETURN
;
;
.SBTTL  GETPIC - GET PREVIOUS CHARACTER FROM INPUT BUFFER
;
;+
; GETPIC - GET PREVIOUS CHARACTER FROM INPUT BUFFER
;
; INPUT:
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF THERE IS A PREVIOUS CHARACTER:
;       CC-C    0
;       R2      CHARACTER
;       R3      POINTER TO CHARACTER
;       U.TIP, U.TIP+2, U.TIC AND U.TTIC "DOWN-DATED"
;         (CHARACTER LOGICALLY REMOVED FROM INPUT BUFFER)
;
;       IF THERE IS NO CHARACTER:
;       CC-C    1
;
; REGISTERS ALTERED: R2,R3
;-
;
;
        .ENABL  LSB
;
GETPIC: MOV     R4,-(SP)        ;;;SAVE R4
        ASSUME  U.TCI,0
        MOV     (R4)+,R3        ;;;GET CURRENT PACKET (IF SOLICITED INPUT)
        ASSUME  U.TIP,U.TCI+2
        MOV     (R4)+,R2        ;;;GET CURRENT BUFFER (IF BUFFERED INPUT)
        ADD     #4,R2           ;;;POINT AT START OF DATA AREA
        ASSUME  S1.IBF,100000
        TST     @R5             ;;;BUFFERED INPUT?
        BMI     10$             ;;;Y - JUMP
        MOV     I.PRM+2(R3),R2  ;;;GET START ADDRESS OF TASK BUFFER
10$:    MOV     @R4,R3          ;;;GET CURRENT CHAR. POINTER (U.TIP+2)
        CMP     R3,R2           ;;;POINTING AT START OF (CURRENT) BUFFER?
        BHI     40$             ;;;N - ALL IS FINE, JUMP
        TST     @R5             ;;;Y - BUFFERED INPUT?
        BPL     25$             ;;;N - INPUT BUFFER EMPTY, EXIT WITH ERROR
        MOV     U.TFIB-<U.TIP+2>(R4),R3 ;;;GET FIRST INPUT BUFFER
        CMP     R3,-(R4)        ;;;ARE WE IN FIRST BUFFER?
        BEQ     25$             ;;;Y - EXIT WITH ERROR
        CLR     U.TIC-U.TIP(R4) ;;;CLEAR U.TIC (SWITCHING BACK TO PREVIOUS
                                ;;;BUFFER, WHICH IS FULL JUST NOW)
        ADD     -(R2),U.TTIC-U.TIP(R4) ;;;UPDATE U.TTIC
;
; SCAN LIST OF INPUT BUFFERS UNTIL THE BUFFER PREVIOUS TO
; THE ONE POINTED TO BY R2 IS FOUND
;
20$:    CMP     @R3,@R4         ;;;POINTING TO OUR BUFFER?
        BEQ     30$             ;;;Y - JUMP
        MOV     @R3,R3          ;;;N - GET NEXT
        BR      20$             ;;;LOOP
;
; NO CHARACTERS IN BUFFER - EXIT WITH CC-C = 1
;
25$:    MOV     (SP)+,R4        ;;;RESTORE R4
        BR      RETCS           ;;;RETURN WITH CC-C = 1
;
; PREVIOUS BUFFER FOUND - R3 POINTS TO IT
;
30$:    MOV     R3,(R4)+        ;;;MAKE THIS CURRENT BUFFER
        ADD     #T$$BFL,R3      ;;;POINT JUST AFTER LAST CHAR. IN BUFFER
;
; WE NOW HAVE R3 POINTING JUST AFTER THE LAST CHARACTER IN THE
; INPUT BUFFER. UCBX IS UPDATED IF WE HAD TO GO TO THE PREVIOUS BUFFER.
;
40$:    DEC     R3              ;;;STEP BACK 1 CHAR.
        MOV     R3,(R4)+        ;;;UPDATE U.TIP+2
        INC     @R4             ;;;UPDATE U.TIC
        MOV     (SP)+,R4        ;;;RESTORE R4
                                ;;;FALL THRU TO "GETRIC"
;
        .DSABL  LSB
;
;
.SBTTL  GETRIC - GET A RANDOM INPUT CHARACTER
;
;+
; GETRIC - GET A RANDOM INPUT CHARACTER
;
; INPUT:
;       R3      POINTER TO CHARACTER
;       R4      POINTER TO UCBX
;
; OUTPUT:
;       R2      CHARACTER
;       CC-C    0
;
; REGISTERS ALTERED: R2
;-
;
;
GETRIC: CALL    MAPIB           ;;;MAP INPUT BUFFER AND CLEAR CC-C
        MOVB    @R3,R2          ;;;GET CHARACTER
        RETURN                  ;;;RETURN TO COROUTINE THAT DOESN'T
                                ;;;CHANGE CC-C!
;
;
.SBTTL  PUTNIC - PUT NEXT INPUT CHARACTER IN BUFFER
;
;+
; PUTNIC - PUT NEXT INPUT CHARACTER IN BUFFER
;
; INPUT:
;       R2      CHARACTER
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       CHARACTER STORED IN INPUT BUFFER.
;       U.TIP+2 AND U.TIC UPDATED.
;
; REGISTERS ALTERED: R3
;-
;
;
PUTNIC: MOV     U.TIP+2(R4),R3  ;;;GET CHAR. POINTER
        CALL    MAPIB           ;;;MAP INPUT BUFFER
        MOVB    R2,@R3          ;;;STORE CHARACTER
        CALL    @(SP)+          ;;;RESTORE MAPPING
        INC     U.TIP+2(R4)     ;;;UPDATE CHARACTER POINTER
        DEC     U.TIC(R4)       ;;;UPDATE CHARACTER COUNT
        RETURN                  ;;;
;                                                                               ;PW026
;                                                                               ;PW026
.SBTTL  MAPD - MAP DRIVER DATA SPACE
;                                                                               ;PW026
;+                                                                              ;PW026
; MAPD - MAP DRIVER DATA SPACE                                                  ;PW026
;-                                                                              ;PW026
;                                                                               ;PW026
;                                                                               ;PW026
                                                                                ;PW026
        .IF DF  T$$COM                                                          ;PW026
                                                                                ;PW026
MAPD::  MOV     #0,KDSAR5               ;;;MAP TTCOM IN D-SPACE APR 5           ;PW026
PAR5S==.-4                              ;;;FILLED IN AT VIRGIN INITIALIZATION   ;PW026
        MOV     #0,KINAR6               ;;;MAP TOP 4K OF DRIVER                 ; DD018
PAR6I==.-4                              ;;;FILLED IN AT VIRGIN INITIALIZATION   ; DD018
        BR      RESM                    ;;;                                     ;PW026
                                                                                ;PW026
        .ENDC   ;T$$COM                                                         ;PW026
                                                                                ;PW026
;
;
.SBTTL  MAPIB - MAP INPUT BUFFER
;
;+
; MAPIB - MAP INPUT BUFFER
;
; INPUT:
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       INPUT BUFFER MAPPED IN KISAR6.
;       CALLER CALLED BACK AS COROUTINE - WITH CC-C = 0.
;       "RETURN" LEADS BACK TO THIS ROUTINE WHICH THEN RESTORES
;       KISAR6 AND RETURNS TO CALLER'S CALLER WITH CC-C PRESERVED.
;
;       NOTE - WHEN THE CALLER IS CALLED AS COROUTINE, THE UCBX
;       MAY NOT BE MAPPED!
;
; REGISTERS ALTERED: NONE
;-
;
;
        ASSUME  S1.IBF,100000
MAPIB:  TST     @R5             ;;;BUFFERED INPUT?
                                ;;;(CLEAR CC-C)
        BMI     10$             ;;;Y - JUMP
        MOV     U.TIP(R4),KISAR6 ;;;N - MAP TASK BUFFER
10$:    CALL    @(SP)+          ;;;CALL CALLER BACK
                                                                                ;PW026
        .IF NDF T$$COM                                                          ;PW026
                                                                                ;PW026
MAPD::                                                                          ;PW026
                                                                                ;PW026
        .ENDC   ;NOT T$$COM                                                     ;PW026
                                                                                ;PW026
RESM::                                                                          ;PW026
        MOV     PAR6S,KISAR6    ;;;RESTORE KISAR6
        RETURN                  ;;;
;
;
        .END
        .TITLE  TTINI
        .IDENT  /V01.23/
;
; 02-FEB-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW003   10-APR-78       PETER WANNHEDEN
;               FIX BUG IN ACCEPTANCE ROUTINE FOR $GSPKT.
;       PW012   14-APR-78       PETER WANNHEDEN
;               MODIFIED USAGE OF I.PRM+16 IN I/O PACKET.
;       PW015   24-APR-78       PETER WANNHEDEN
;               FIX INCORRECT CONDITIONALIZATION WHEN T$$SMC NOT DEFINED.
;               GENERAL MEMORY-SAVING IMPROVEMENTS AND CLEANUP.
;       PW016   24-APR-78       PETER WANNHEDEN
;               ALWAYS TRY TO DEALLOCATE UCB EXTENSION IF NO PACKET
;               CAN BE DEQUEUED.
;       PW019   26-APR-78       PETER WANNHEDEN
;               CHANGES REQUIRED FOR CHECKPOINTABLE COMMON SUPPORT.
;       PW026   05-MAY-78       PETER WANNHEDEN
;               USE SUBROUTINE MAPD TO MAP TT DRIVER DATA AREA.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD005   06-OCT-78       DALE R. DONCHIN
;               ADD READ WITH TERMINATOR TABLE FUNCTION
;       DD017   23-APR-79       DALE R. DONCHIN
;               SUPPORT SINGLE SCB PER CONTROLLER
;
;+
; TTINI - REQUEST INITIATION ENTRY POINT.
;
;       COME HERE FROM DRQIO TO CHECK A PACKET, SET UP THE BITMASK
;       FOR THE ACCEPTANCE ROUTINE, VALIDATE THE PROMPT BUFFER
;       FOR AN IO.RPR REQUEST OR THE TERMINATOR TABLE ADDRESS FOR               ; DD005
;       AN IO.RTT REQUEST AND QUEUE THE PACKET.                                 ; DD005
;                                                                               ;**-1
; INPUT:
;       R1      POINTER TO REQUEST PACKET
;       R4      POINTER TO SCB
;       R5      POINTER TO UCB
;-
;
;
        .ENABL  LSB

TTINI:: CALL    MAPD            ;MAP DATA AREA                                  ;PW026
        MOV     R1,R3           ;COPY PACKET POINTER                            ;**-1
        MOVB    I.FCN+1(R3),R0  ;GET FUNCTION CODE
        ASL     R0              ;MAKE WORD INDEX                                ; DD005
        JMP     @QPDSP-2(R0)    ;DISPATCH                                       ;**-9

        .IF DF  T$$RPR                                                          ; DD005
                                                                                ;**-1
;
; IO.RPR
;
QPRPR:: MOV     I.PRM+10(R3),R0 ;GET VIRTUAL ADDRESS OF PROMPT BUFFER           ;PW012
        MOV     I.PRM+12(R3),R1 ;GET BUFFER SIZE                                ;PW012
                                                                                ;**-5
        .IF DF  A$$CHK

        BEQ     ERRSPC          ;LENGTH = 0 - ERROR
        CMP     R1,#20000-100   ;.GT. 8K - 64 BYTES?
        BHI     ERRBAD          ;Y - ERROR
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        CALL    $ACHRO          ;ADDRESS CHECK READ-ONLY BUFFER                 ; CS013
        BCS     ERRSPC          ;ERROR - JUMP                                   ; CS013
        MOV     W.BATT(R2),R4   ;GET ATT. DESCRIPTOR FOR TRANSFER               ; CS013
        INCB    A.IOC(R4)       ;INCREMENT I/O COUNT                            ; CS013
        MOV     R4,I.AADA+2(R3) ;SAVE ATT. DESCRIPTOR ADDRESS IN I/O PACKET     ; CS013
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        CALL    $ACHKB          ;ADDRESS CHECK BUFFER
        BCS     ERRSPC          ;ERROR - JUMP
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013

        .ENDC   ;A$$CHK

        CALL    $RELOC          ;RELOCATE BUFFER ADDRESS
        MOV     R1,I.PRM+10(R3) ;SAVE 1.ST WORD OF ADDRESS DOUBLE WORD          ;PW012
        MOV     R2,I.PRM+16(R3) ;SAVE 2.ND WORD OF ADDRESS DOUBLE WORD          ;PW012
        MOV     #S2.IRQ!S2.ORQ,R4 ;MUST WAIT FOR READ AND WRITE                 ;PW012
        BR      70$                                                             ;**-5

        .ENDC   ;T$$RPR

        .IF DF  T$$GTS!T$$GMC!T$$SMC

;
;
; IO.GTS, SF.SMC, SF.GMC
;
QPSPC::
                                                                                ;PW015
        .IF DF  T$$GTS!T$$GMC                                                   ;PW015
                                                                                ;PW015
        CLR     R4              ;ASSUME IO.GTS OR SF.GMC - PROCESSED            ;PW015
                                ;SYNCHRONOUSLY (NOT QUEUED)                     ;PW015
                                                                                ;PW015
        .ENDC   ;T$$GTS!T$$GMC                                                  ;PW015
                                                                                ;PW015
        .IF DF  T$$GTS                                                          ;PW015
                                                                                ;PW015
        CMP     I.FCN(R3),#IO.GTS ;IO.GTS?                                      ;PW015
                                                                                ;PW015
        .IF DF  T$$GMC!T$$SMC                                                   ;PW015
                                                                                ;PW015
        BEQ     40$             ;Y - JUMP                                       ;PW015
                                                                                ;PW015
        .IFF    ;T$$GMC!T$$SMC                                                  ;PW015
                                                                                ;PW015
        BNE     ERRIFC          ;N - JUMP                                       ;PW015
                                                                                ;PW015
        .ENDC   ;T$$GMC!T$$SMC                                                  ;PW015
                                                                                ;PW015
        .ENDC   ;T$$GTS                                                         ;PW015
                                                                                ;PW015
        .IF DF  T$$GMC                                                          ;PW015
                                                                                ;PW015
        CMP     I.FCN(R3),#SF.GMC ;SF.GMC?                                      ;PW015
                                                                                ;PW015
        .IF DF  T$$SMC                                                          ;PW015
                                                                                ;PW015
        BEQ     40$             ;Y - JUMP                                       ;PW015
                                                                                ;PW015
        .IFF    ;T$$SMC                                                         ;PW015
                                                                                ;PW015
        BNE     ERRIFC                                                          ;PW015
                                                                                ;PW015
        .ENDC   ;T$$SMC                                                         ;PW015
                                                                                ;PW015
        .ENDC   ;T$$GMC                                                         ;PW015
                                                                                ;**-37
        .IF DF  T$$SMC

        CMP     I.FCN(R3),#SF.SMC ;SF.SMC?
        BNE     ERRIFC          ;N - JUMP
        MOV     I.TCB(R3),R0    ;GET ISSUING TASK'S TCB
        CMP     T.UCB(R0),R5    ;IS THIS TERMINAL HIS TI:?
        BEQ     10$             ;Y - JUMP                                       ;PW015
        BIT     #T3.PRV,T.ST3(R0) ;IS THE TASK PRIVILEGED?                      ;**-1
        BEQ     ERRPRI          ;N - ERROR
10$:    MOV     #S2.IRQ!S2.ORQ!S2.SRQ,R4                                        ;PW012
                                ;MUST WAIT FOR BOTH READ AND WRITE              ;**-1
                                ;FLAG AS "SPECIAL" FUNCTION

        .ENDC   ;T$$SMC

40$:

        .IF DF  A$$CHK

        MOV     I.PRM+2(R3),-(SP) ;GET BUFFER ADDRESS                           ;PW015
        BIS     I.PRM+4(R3),@SP ;OR WITH BUFFER LENGTH                          ;PW015
        ROR     (SP)+           ;ADDRESS OR LENGTH ODD?                         ;PW015
        BCS     ERRSPC          ;Y - ERROR, JUMP                                ;PW015
                                                                                ;**-4
        .ENDC   ;A$$CHK

        BR      70$             ;GO AND CHECK BUFFER LENGTH

        .ENDC   ;T$$GTS!T$$GMC!T$$SMC

;
;
; IO.RLB
;
QPRLB:: MOV     #S2.IRQ!140000,R4 ;MUST WAIT FOR READ
        CMPB    I.FCN+1(R3),#IO.RTT/400 ; IS THIS AN IO.RTT FUNCTION?           ; DD005
        BNE     70$             ;N - JUMP                                       ; DD005
        MOV     I.PRM+10(R3),R0 ;GET ADDRESS OF TERMINATOR TABLE                ; DD005
        BIT     #1,R0           ;IS TABLE ON A WORD BOUNDARY?                   ; DD005
        BNE     ERRSPC          ;N - ERROR                                      ; DD005
        MOV     #32.,R1         ;LENGTH OF TABLE IS FIXED AT 32. BYTES          ; DD005
                                                                                ; DD005
        .IF DF  A$$CHK                                                          ; DD005
                                                                                ; DD005
        .IF DF  R$$MPL                                                          ; DD005
                                                                                ; DD005
        CALL    $ACHRO          ;ADDRESS CHECK TERMINATOR TABLE                 ; DD005
        BCS     ERRSPC          ;ERROR - JUMP                                   ; DD005
                                                                                ; DD005
        .IFF    ;R$$MPL                                                         ; DD005
                                                                                ; DD005
        CALL    $ACHKB          ;ADDRESS CHECK TERMINATOR TABLE                 ; DD005
        BCS     ERRSPC          ;ERROR - JUMP                                   ; DD005
                                                                                ; DD005
        .ENDC   ;R$$MPL                                                         ; DD005
                                                                                ; DD005
        .ENDC   ;A$$CHK                                                         ; DD005
                                                                                ; DD005
        CALL    $RELOC          ;RELOCATE TABLE ADDRESS                         ; DD005
        MOV     R1,I.PRM+10(R3) ;SAVE 1.ST WORD OF ADDRESS DOUBLE WORD          ; DD005
        MOV     R2,I.PRM+16(R3) ;SAVE 2.ND WORD OF ADDRESS DOUBLE WORD          ; DD005
        BR      70$
;
;
; IO.WLB
;
QPWLB::                                                                         ;PW012
                                                                                ;PW012
        .IF DF  T$$CUP                                                          ;PW012
                                                                                ;PW012
        MOV     I.PRM+6(R3),I.PRM+10(R3) ;MOVE VFC/CURSOR-CONTROL TO I.PRM+10   ;PW012
                                                                                ;PW012
        .ENDC   ;T$$CUP                                                         ;PW012
                                                                                ;PW012
        MOV     #S2.ORQ,R4      ;MUST WAIT FOR WRITE                            ;PW012
                                                                                ;**-1
        .IF DF  T$$BTW

        BITB    #TF.WBT,I.FCN(R3) ;WRITE-BREAKTHROUGH?
        BEQ     70$             ;N - JUMP
        MOV     I.TCB(R3),R0    ;Y - GET ISSUER'S TCB
        BIT     #T3.PRV,T.ST3(R0) ;PRIVILEGED TASK?
        BEQ     ERRPRI          ;N - ERROR
        MOVB    #251.,I.PRI(R3) ;QUEUE WITH PRIORITY 251.
        BIS     #TF.CCO,I.FCN(R3) ;IO.WBT IMPLIES CANCEL CTRL-O
        MOV     U.TSTA(R5),I.PRM+12(R3) ;SAVE CURRENT STATUS WORD 1 IN PACKET
        MOV     #S2.ORQ!S2.BRQ,R4 ;MUST WAIT FOR WRITE AND SET S2.BRQ           ;PW012
                                ;IN STATUS WORD 2                               ;PW012
                                                                                ;**-2
        .ENDC   ;T$$BTW

        .IF DF  A$$CHK


;
; CHECK THAT BUFFER LENGTH IS WITHIN (1,8K-64) BYTES
;

70$:    MOV     I.PRM+4(R3),R1  ;GET LENGTH
        BEQ     ERRSPC          ;0 - ERROR
        CMP     R1,#20000-100   ;TOO LARGE?
        BLOS    QUEUE           ;N - JUMP                                       ;PW015
;                                                                               ;PW015
;                                                                               ;PW015
; ERROR RETURNS                                                                 ;PW015
;                                                                               ;PW015
ERRBAD: MOV     #IE.BAD&377,R0  ;ERROR - BAD PARAMETER(S)                       ;PW015
        BR      IOFIN                                                           ;PW015
ERRSPC: MOV     #IE.SPC&377,R0  ;ERROR - ILLEGAL BUFFER                         ;PW015
        BR      IOFIN                                                           ;PW015
                                                                                ;PW015
        .IFF    ;A$$CHK                                                         ;PW015
                                                                                ;PW015
70$:    BR      QUEUE                                                           ;PW015
                                                                                ;PW015
        .ENDC   ;A$$CHK                                                         ;PW015
                                                                                ;PW015
        .IF DF  T$$BTW!T$$SMC                                                   ;PW015
                                                                                ;PW015
ERRPRI: MOV     #IE.PRI&377,R0  ;ERROR - PRIVILEGE VIOLATION                    ;PW015
        BR      IOFIN                                                           ;PW015
                                                                                ;PW015
        .ENDC   ;T$$BTW!T$$SMC                                                  ;PW015
                                                                                ;PW015
        .IF DF  T$$GTS!T$$GMC!T$$SMC                                            ;PW015
                                                                                ;PW015
ERRIFC: MOV     #IE.IFC&377,R0  ;ERROR - ILLEGAL FUNCTION CODE                  ;PW015
        BR      IOFIN                                                           ;PW015
                                                                                ;PW015
        .ENDC   ;T$$GTS!T$$GMC!T$$SMC                                           ;PW015
                                                                                ;PW015
        .IF DF  T$$GTS!T$$GMC!T$$SMC!T$$BTW!A$$CHK                              ;PW015
                                                                                ;PW015
        .=.-2                   ;OVERLAY LAST "BR IOFIN" INSTRUCTION            ;PW015
                                                                                ;PW015
        .ENDC   ;T$$GTS!T$$GMC!T$$SMC!T$$BTW!A$$CHK                             ;PW015
                                                                                ;PW015
IOFIN:: CLR     R1              ;CLEAR SECOND WORD OF IOSB                      ;PW015
        CALLR   $IOFIN          ;FINISH IO AND RETURN                           ;PW015
                                                                                ;**-4
;
; IO.ATT, IO.DET
;
QPATT::
QPDET:: MOV     #S2.IRQ!S2.ORQ!S2.SRQ,R4 ;MUST WAIT FOR READ AND WRITE          ;PW012
                                ;MARK AS "SPECIAL" FUNCTION                     ;PW012
                                ;MARK AS "SPECIAL" FUNCTION                     ;**-2
                                                                                ;**-9
        .DSABL  LSB

;
; R4 NOW CONTAINS FLAGS TO BE USED BY THE ACCEPTANCE ROUTINE FO
; GETTING PACKETS FROM THE QUEUE VIA $GSPKT. SAVE THE FLAGS IN
; I.PRM+7 OF THE I/O PACKET.                                                    ;PW012
;                                                                               ;**-1
;                                                                               ;PW012
QUEUE:  MOVB    R4,I.PRM+7(R3)  ;SAVE FLAGS IN I/O PACKET                       ;PW012
                                                                                ;**-10
        .IF DF  T$$GTS!T$$GMC

        BNE     10$             ;PACKET CANNOT BE PROCESSED
                                ;IMMEDIATELY - JUMP
        JMP     PPSPC1          ;PROCESS IMMEDIATELY

        .ENDC   ;T$$GTS!T$$GMC

10$:    BICB    #S2.SRQ!S2.BRQ,I.PRM+7(R3)                                      ;PW012
                                ;CLEAR SRQ AND BRQ FLAGS IN PACKET              ;**-1
        MOV     U.SCB(R5),R0    ;GET I/O QUEUE LISTHEAD
        MOV     R3,R1           ;GET PACKET POINTER
        CALL    $QINSP          ;INSERT PACKET
        ADD     #U.TSTA,R5      ;POINT TO U.TSTA
        BIT     #S2.SRQ,R4      ;SPECIAL FUNCTION (IO.ATT, IO.DET, IO.SMC)?
        BEQ     20$             ;N - JUMP
        MOV     #S2.SRQ,R4      ;Y - CLEAR ALL OTHER BITS
20$:    BISB    R4,2(R5)        ;SET FLAGS TO INDICATE WHAT WE
                                ;PUT IN THE QUEUE
                                ;NOTE - MUST BE DONE  A F T E R  WE
                                ;PUT PACKET IN THE QUEUE!!

        .IF DF  M$$PRO

        MOV     #FR.GRQ,R3      ;COME BACK AT FPGRQ
        CALL    SWCPU           ;SWITCH TO CORRECT CPU
;
; IF WE FALL THRU HERE, WE ARE ALREADY ON THE CORRECT CPU
;

        .ENDC   ;M$$PRO

        CALL    SETDSI          ;DISABLE INPUT PROCESSING
                                ;FALL THRU TO "FPGRQ"                           ;PW015
.PAGE                                                                           ;**-41
;
;+
; FPGRQ - GET A REQUEST PACKET FROM THE I/O QUEUE.
;       THIS SUBROUTINE IS ENTERED EITHER FROM THE REQUEST INITIATOR,
;       OR FROM THE FORK DISPATCHER.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;       S1.DSI  1 TO PREVENT PROCESSING OF INPUT
;
; OUTPUT:
;       IF THERE IS AN IO.WBT PACKET IN THE QUEUE, A CTRL-Q IS
;       SIMULATED.
;
;       AS MANY PACKETS AS CAN BE DEQUEUED FROM THE IO QUEUE
;       ARE STARTED.
;
; REGISTERS ALTERED: R0,R1,R2,R3,R4
;-
;
;
FPGRQ:: BITB    #FR.PFP,U.TFRQ-U.TSTA(R5) ;POST-FORK PROCESSING REQUESTED?
        BNE     80$             ;Y - DON'T DEQUEUE ANYTHING                     ;PW003
                                                                                ;**-1
        .IF DF  T$$BTW

        BIT     #S2.BRQ,2(R5)   ;ANY IO.WBT'S IN QUEUE?
        BEQ     10$             ;N - JUMP
        CALL    I1CTQL          ;RESUME OUTPUT WITH INTERRUPTS LOCKED OUT

        .ENDC   ;T$$BTW

10$:    MOV     #DEUCBX,-(SP)   ;IF TSTRQ FAILS, DEALLOCATE UCB EXTENSION       ;PW016
        CALL    TSTRQ           ;TEST IF ANYTHING TO DEQUEUE                    ;PW016
                                ;IF NOT, DEALLOCATE UCBX AND RETURN TO CALLER   ;PW016
        MOV     R3,@SP          ;THERE MAY BE SOMETHING - SAVE FLAGS            ;PW016
        SUB     #U.TSTA,R5      ;POINT TO START OF UCB                          ;**-3
        MOV     #70$,R2         ;POINT TO ACCEPTANCE ROUTINE
        MOV     R5,-(SP)        ;SAVE POINTER TO UCB                            ; DD017
        CALL    $GSPKT          ;GET A PACKET
        MOV     (SP)+,R5        ;RESTORE POINTER TO UCB                         ; DD017
        BCS     130$            ;FAILED - JUMP
;
; WE GOT A PACKET - ADDRESS IN R1
;
        TST     (SP)+           ;CLEAN STACK

        .IF DF  T$$BTW

        MOV     U.SCB(R5),R3    ;GET POINTER TO SCB                             ; DD017
15$:    MOV     @R3,R3          ;GET POINTER TO NEXT I/O PACKET IN QUEUE        ; DD017
        BEQ     20$             ;NONE - JUMP                                    ;**-1
        CMP     I.UCB(R3),R5    ;IS THAT PACKET FOR THIS UCB?                   ; DD017
        BNE     15$             ;N - SKIP THIS PACKET                           ; DD017
        CMPB    I.PRI(R3),#251. ;IS IT AN IO.WBT?
        BEQ     25$             ;Y - JUMP
20$:    BIC     #S2.BRQ,U.TSTA+2(R5) ;N - SHOW NO MORE IO.WBT'S IN QUEUE

        .ENDC   ;T$$BTW

25$:    ADD     #U.TSTA,R5      ;POINT TO U.TSTA
        MOV     R1,R3           ;COPY PACKET POINTER
        CLR     @R3             ;CLEAR LINK WORD
        MOVB    I.FCN+1(R3),R1  ;GET FUNCTION CODE                              ;**-1
;                                                                               ;**-9
; NOTE - HERE WE ASSUME NUMERIC VALUES FOR FUNCTION CODES ACCORDING
; TO WHAT IS DESCRIBED IN MODULE TTDAT!
;
30$:    CMP     R1,#IO.RTT/400  ;DOES REQUEST NEED A UCB EXTENSION?             ; DD005
                                ;(FUNCTIONS > IO.RTT DON'T)                     ; DD005
        BHI     60$             ;N - JUMP                                       ; DD005
        CMP     R1,#IO.RPR/400  ;CHECK AGAIN                                    ; DD005
                                ;(IO.RTT AND IO.RPR REQUIRE ONE)                ; DD005
        BHIS    35$             ;Y - JUMP                                       ; DD005
        CMP     R1,#IO.ATT/400  ;CHECK AGAIN                                    ; DD005
                                ;(IO.DET, IO.GTS, SF.GMC, SF.SMC DON'T)         ; DD005
        BHI     60$             ;N - JUMP                                       ;**-2

        .IF DF  T$$MOD

        BEQ     40$             ;IO.ATT - JUMP
35$:                                                                            ; DD005
        BITB    #US.DSB!US.CRW,U.STS-U.TSTA(R5)
                                ;IO.RLB, IO.WLB OR IO.RPR - IS LINE
                                ;DISABLED OR WAITING FOR CARRIER?
        BEQ     40$             ;N - JUMP
        MOV     #IE.DNR&377,R0  ;Y - ERROR "DEVICE NOT READY"
        BR      50$

        .IFF    ;T$$MOD                                                         ; DD005
                                                                                ; DD005
35$:                                                                            ; DD005
                                                                                ; DD005
        .ENDC   ;T$$MOD

40$:    CALL    ALUCBX          ;ALLOCATE UCBX IF IT ISN'T THERE
        BCC     60$             ;OK - JUMP
;
; FAILED TO ALLOCATE UCBX - FINISH REQUEST
;
45$:                                                                            ; DD005
        MOV     #IE.NOD&377,R0  ;ERROR - NO DYNAMIC MEMORY AVAILABLE
50$:    CALL    IOFIN           ;FINISH IO
        BR      10$             ;TRY AGAIN
;
60$:    CMPB    I.FCN+1(R3),#IO.RTT/400 ; IS THIS AN IO.RTT?                    ; DD005
        BNE     65$             ;N - JUMP                                       ; DD005
        CALL    ALTB            ;ALLOCATE A TABLE                               ; DD005
        BCS     45$             ;ERROR - NO FREE POOL                           ; DD005
        MOV     R2,U.TRTT(R4)   ;COPY ITS ADDRESS INTO THE UCBX                 ; DD005
65$:    ASL     R1              ;GET WORD INDEX                                 ; DD005
        CALL    @PPDSP-2(R1)    ;DO OR START FUNCTION                           ;**-1
        BR      10$             ;LOOP
;
;
; ACCEPTANCE ROUTINE FOR $GTPKS
;
70$:    CMP     I.UCB(R1),G$$SPA(SP) ;IS THIS PACKET FOR THE CURRENT UCB?       ; DD017
        BEQ     75$             ;Y - JUMP                                       ; DD017
        SEC                     ;N - DON'T ACCEPT IT                            ; DD017
        RETURN                                                                  ; DD017
75$:    BITB    I.PRM+7(R1),U.TSTA(R5) ;CAN WE PROCESS THIS PACKET?             ;PW012
        BNE     90$             ;N - JUMP                                       ;**-1

        .IF DF  T$$BTW

        ASSUME  S2.FDX,100000                                                   ;**-2
        TST     U.TSTA+2(R5)    ;FULL DUPLEX LINE? (CLEAR CC-C)                 ;PW003
        BMI     80$             ;Y - ACCEPT                                     ;**-1
        BIT     #S1.IBY!S1.OBY,U.TSTA(R5) ;ANYTHING BUSY?                       ;PW003
        BEQ     80$             ;N - ACCEPT                                     ;PW003
;
; THE LINE IS NOT IN FULL DUPLEX MODE, AND EITHER INPUT OR OUTPUT IS
; BUSY. IN THIS CASE, THE ONLY PACKET WE CAN ACCEPT IS IO.WBT.
; IO.WBT PACKETS HAVE PRIORITY 251., AND ALL OTHERS HAVE LOWER
; PRIORITY. IF THIS PACKET IS NOT AN IO.WBT, WE KNOW THAT THERE
; ARE NO IO.WBT'S FURTHER DOWN THE QUEUE EITHER, SO WE ABORT THE SCAN.
;
        CMPB    I.PRI(R1),#251. ;IS THIS AN IO.WBT? (CLEAR CC-C IF YES)         ;PW003
        BNE     120$            ;N - REJECT                                     ;**-1
;                                                                               ;**-3
; ACCEPT PACKET
;
                                                                                ;PW003
        .IFF    ;T$$BTW                                                         ;PW003
                                                                                ;PW003
        CLC                     ;ACCEPT - CLEAR CC-C                            ;PW003
                                                                                ;PW003
        .ENDC   ;T$$BTW                                                         ;PW003
                                                                                ;PW003
80$:    RETURN                  ;RETURN                                         ;PW003
;                                                                               ;PW003
; IF PACKET REQUIRES BOTH INPUT AND OUTPUT TO BE FREE,                          ;PW003
; ABORT SCAN. ELSE REJECT PACKET (RETURN WITH CC-C = 1).                        ;PW003
;                                                                               ;**-4
        ASSUME  S2.ORQ,100
        ASSUME  S2.IRQ,200
90$:    CMPB    I.PRM+7(R1),#S1.IBY!S1.OBY                                      ;PW003
        BLO     80$             ;REJECT IF NOT BOTH INPUT AND OUTPUT REQUIRED   ;PW003
                                ;TO BE FREE (BRANCH WITH CC-C = 1)              ;PW003
;                                                                               ;**-5
; FOUND A PACKET THAT REQUIRES BOTH INPUT AND OUTPUT TO BE FREE.
; ABORT SCAN SO THE PACKET WILL GET A CHANCE TO BE DEQUEUED ONCE
; ALL REQUESTS IN FRONT OF IT ARE DONE.
;
120$:   ADD     #G$$SPA,SP      ;FLUSH STACK
        MOV     (SP)+,R5        ;RESTORE POINTER TO UCB                         ; DD017
        CLR     @SP             ;DON'T CHANGE FLAGS IN U.TSTA+2
;
; NO PACKET CAN BE DEQUEUED
;
130$:   ADD     #U.TSTA,R5      ;POINT TO U.TSTA
        BIC     (SP)+,2(R5)     ;UPDATE FLAGS TO REFLECT QUEUE CONTENTS
        CALLR   DEUCBX          ;DEALLOCATE UCBX IF POSSIBLE AND RETURN
;
;
;+
; SUBROUTINE TSTRQ - TEST I/O QUEUE.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF THERE IS (POTENTIALLY) A PACKET IN THE I/O QUEUE THAT
;       CAN BE PROCESSED:
;       RETURN TO CALLER WITH R3 = MASK OF BITS TO CLEAR IN U.TSTA+2
;       IF NO PACKET COULD BE DEQUEUED
;
;       IF NOT:
;       RETURN TO CALLER'S CALLER.
;
; REGISTERS ALTERED: R3
;-
;
;
TSTRQ:: MOV     @R5,R3          ;GET STATUS WORD 1
        COM     R3              ;INVERT
        BIC     #^C<S1.IBY!S1.OBY>,R3 ;CLEAR ALL BUT INPUT AND OUTPUT BUSY FLAGS
        BIS     #S2.SRQ,R3      ;OR WITH S2.SRQ FLAG
        BIT     R3,2(R5)        ;ANYTHING IN QUEUE THAT CAN BE PROCESSED?
        BEQ     10$             ;N - JUMP
        BIT     #S2.FDX!S2.BRQ,2(R5) ;Y - FULL DUPLEX LINE, OR IO.WBT IN QUEUE?
        BNE     20$             ;Y - JUMP
        BIT     #S1.IBY!S1.OBY,@R5 ;N - ANYTHING BUSY?
        BEQ     20$             ;N - JUMP
10$:    TST     (SP)+           ;RETURN TO CALLER'S CALLER
20$:    RETURN                  ;RETURN
;
;
        .END
        .TITLE  TTJZ
        .IDENT  /V01.05/
;
; 27-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;
;
;+
; COMMON ROUTINES FOR DJ-11 AND DZ-11 CONTROLLERS.
;-
;
;

        .IF DF  D$$J11!D$$Z11

        .MCALL  UCBDF$, SCBDF$
;
        UCBDF$                  ;DEFINE UCB SYMBOLS
        SCBDF$                  ;DEFINE SCB SYMBOLS
;
;
;+
; YJSTAX/YZSTAX - START OUTPUT.                                                 ;PW026
;                                                                               ;**-1
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.TOP+2         BUFFER ADDRESS
;       U.TOC           BYTE COUNT
;       S1.CTO          0
;-
;
;
        .ENABL  LSB
;
YJSTAX::                                                                        ;PW026
YZSTAX::BIT     #S1.CTS,@R5     ;;;OUTPUT STOPPED BY CTRL-S?                    ;PW026
        BNE     10$             ;;;Y - IGNORE                                   ;**-1
;
;
;+
; YJRESX/YZRESX - RESUME OUTPUT.                                                ;PW026
;                                                                               ;**-1
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       S1.CTS          0
;-
;
;
YJRESX::                                                                        ;PW026
YZRESX::BIS     $BTMSK(R2),4(R3) ;;;ENABLE TRANSMIT INTERRUPTS                  ;PW026
                                ;;;THE FIRST INTERRUPT WILL START               ;**-1
                                ;;;(OR RESUME) OUTPUT.
10$:    RETURN                  ;;;
;
;
;+
; JZOUT - COMMON OUTPUT INTERRUPT PROCESSING FOR DJ-11 AND DZ-11.
;
; INPUT:
;       2(SP)   POINTER TO CONTROLLER REGISTER (BYTE)
;               THAT CONTAINS INTERRUPTING LINE NUMBER IN BITS 0-3
;       R3      CSR ADDRESS
;       R4      KRB ADDRESS (RSX-11M+)                                          ; CS013
;       R4      ADDRESS OF UCB LIST (RSX-11M)                                   ; CS013
;                                                                               ;**-1
; OUTPUT:
;       FIRST, ALL LINES THAT REQUIRE OUTPUT WORK ARE SERVICED.
;       NEXT, IF ANY LINE REQUIRES INPUT WORK, THE SILO IS EMPTIED.
;       IF AT THAT TIME OUTPUT WORK IS AGAIN REQUIRED (THERE WILL BE
;       IF THERE WAS ANY INPUT THAT REQUIRES ECHO), THE LOOP
;       LOOKING FOR OUTPUT WORK IS REENTERED.
;       ON RETURN, ALL OUTPUT AND INPUT WORK THAT CAN BE DONE IS DONE.
;
; REGISTERS ALTERED: R2,R5
;-
;
;
JZOUT:: MOVB    @2(SP),R5       ;;;GET INTERRUPTING LINE NUMBER
        CALL    MUXUCB          ;;;CHECK LINE NUMBER AND GET UCB ADDRESS
        MOV     $BTMSK(R2),R2   ;;;GET BITMASK FOR XMIT ENABLE
        BCS     30$             ;;;BAD LINE - JUMP
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        MOV     R4,-(SP)        ;;;SAVE KRB POINTER
        CALL    OUTISR          ;;;DO COMMON OUTPUT INTERRUPT PROCESSING
        MOV     (SP)+,R4        ;;;RESTORE KRB POINTER
        MOV     @R4,R3          ;;;RESTORE CSR POINTER
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        MOV     R3,-(SP)        ;;;SAVE CSR                                     ; CS013
        MOV     R4,-(SP)        ;;;SAVE ADDRESS OF UCB LIST                     ; CS013
        CALL    OUTISR          ;;;DO COMMON OUTPUT INTERRUPT PROCESSING        ; CS013
        MOV     (SP)+,R4        ;;;RESTORE ADDRESS OF UCB LIST                  ; CS013
        MOV     (SP)+,R3        ;;;RESTORE CSR ADDRESS                          ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
20$:    TST     @R3             ;;;XMIT READY?
        BMI     JZOUT           ;;;Y - LOOP
;
; NO MORE LINES REQUIRE OUTPUT WORK. SEE IF ANY INPUT WORK TO DO.
;
        MOV     2(R3),R5        ;;;GET A CHARACTER FROM SILO
        BPL     10$             ;;;NONE - EXIT
        CALL    MUXIN1          ;;;OK - PROCESS INPUT CHARACTER
                                ;;;MUXIN1 RETURNS TO OUR CALLER IF
                                ;;;NO OUTPUT WORK TO DO
        BR      JZOUT           ;;;OUTPUT WORK TO DO - LOOP
;
; OUTPUT INTERRUPT OCCURRED ON A LINE THAT WE DON'T RECOGNIZE.
; I DON'T KNOW HOW IT GOT HERE BUT LET'S TRY TO PREVENT IT
; FROM HAPPENING AGAIN.
;
30$:    BIC     R2,4(R3)        ;;;DISABLE XMIT ON THAT LINE
        BR      20$             ;;;
;
        .DSABL  LSB

        .ENDC   ;D$$J11!D$$Z11

;
;
        .END
.NLIST
;+
; TTMAC - ASSEMBLY PREFIX FILE FOR TTDRV.
;-
;
; 13-FEB-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW001   06-APR-78       PETER WANNHEDEN
;               REMOVE DEFINITIONS FOR TEST PURPOSES (T$$ESC AND T$$SMC)
;       PW010   14-APR-78
;               SUPPORT DEVICE-INDEPENDENT CURSOR POSITIONING.
;       PW011   14-APR-78       PETER WANNHEDEN
;               ALLOW CTRL-R OF PROMPT BUFFER FOR IO.RPR ON FULL DUPLEX LINE.
;       PW027   11-MAY-78       PETER WANNHEDEN
;               REMOVE A FEW DEFINITIONS THAT ARE NOW IN TTSYM$.
;               MAKE LOADABLE CTB UNCONDITIONAL.
;       PW030   26-MAY-78       PETER WANNHEDEN
;               TURN OFF DEBUG CODE.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD005   06-OCT-78       DALE R. DONCHIN
;               ADD READ WITH TERMINATOR TABLE FUNCTION
;       DD007   06-NOV-78       DALE R. DONCHIN
;               CONDITIONALIZE EIS INSTRUCTIONS ON R$$EIS
;       CJR001  22-FEB-79       CRAIG J. RICHARDSON
;               ADD SCS-11 CONTROL/C SUPPORT
;
;
        .MCALL  UCBDF$, TTSYM$
;
        UCBDF$  ,,TTDEF         ;DEFINE UCB OFFSETS
        TTSYM$                  ;DEFINE TC.XXX SYMBOLS
;
;
; ***   TEMPORARY ASSEMBLY PARAMETERS
;
; DEFINE A FEW ASSEMBLY PARAMETERS THAT WILL BE DEFINED IN                      ;**-5
; OTHER PLACES IN THE FUTURE
;
T$$BFL= 40.                     ;BUFFER LENGTH
M$$ANS= 15.                     ;SECONDS TO WAIT FOR CARRIER AFTER RING         ;**-2
M$$CAR= 2                       ;SECONDS TO WAIT FOR LOST CARRIER TO RETURN
TTPRI=  240                     ;PRIORITY 5
M$$CRI= M$$CRB-4                ;NUMBER OF BYTES OF INFORMATION                 ;**-8
                                ;IN CLI COMMAND BUFFER
;                                                                               ;**-1
; TURN ON DEBUGGING CODE IF XDT IS IN SYSTEM
;
.IIF DF X$$DBT DEBUG=   1
;
; ***   END OF TEMPORARY DEFINITIONS
;
.IIF DF T$$BTW,T$$CTR=0                 ;T$$BTW FORCES T$$CTR
.IIF DF D$$M11!D$$ZMD!D$$LMD,T$$MOD=0   ;MODEM SUPPORT
.IIF DF D$$H11!D$$J11!D$$Z11,T$$MUX=0   ;MULTIPLEXER SUPPORT
.IIF DF R$$MPL,R$$EIS=0                 ;EIS SUPPORT                            ; DD007
;
;
        .MACRO  TTSET$  TYPE
        JSR     R2,TTSET

                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
                                                                                ;**-1
        .WORD   'TYPE'CTBP

        .IFF

        .WORD   TTT'TYPE                                                        ; CS013
                                                                                ;**-1
        .ENDC

        .ENDM   TTSET$
;
                                                                                ; CS013
        .IF NDF R$$MPL                                                          ; CS013
                                                                                ; CS013
;                                                                               ; CS013
; DEFINE CONTROLLER TYPES (RSX-11M)                                             ; CS013
;                                                                               ; CS013
TTTDL=0                                                                         ; CS013
TTTDZ=2                                                                         ; CS013
TTTDH=4                                                                         ; CS013
TTTDJ=6                                                                         ; CS013
TTTDM=10        ;DM11-BB                                                        ; CS013
                                                                                ; CS013
;                                                                               ; CS013
                                                                                ; CS013
        .ENDC   ;NDF R$$MPL                                                     ; CS013
                                                                                ; CS013
;                                                                               ; CS013
;
; DEFINE CHARACTERS WITH SPECIAL SIGNIFICANCE
;
CH.BSL= 134
CH.BSP= 10
CH.CR=  15
CH.CTC= 3
CH.CTO= 17
CH.CTQ= 21
CH.CTR= 22
CH.CTS= 23
CH.CTU= 25
CH.CTX= 30
CH.CTZ= 32
CH.DOL= '$
CH.ESC= 33
CH.FF=  14
CH.HT=  11
CH.LF=  12
CH.NUL= 0
CH.ONE= '1
CH.PLU= '+
CH.RUB= 177
CH.SP=  40
CH.VT=  13
CH.ZER= '0
;
;
; DEFINE OFFSETS IN UCB EXTENSION (UCBX)
;
        .ASECT
.=      0
U.TCI:  .BLKW   1               ;IF SOLICITED INPUT IN PROGRESS:
                                ;  POINTER TO CURRENT INPUT REQUEST PACKET
                                ;IF UNSOLICITED INPUT IN PROGRESS:
                                ;  POINTER TO SECOND WORD IN FIRST BUFFER
                                ;IF INPUT IDLE:
                                ;  0
U.TIP:  .BLKW   2               ;IF BUFFERED INPUT IN PROGRESS:
                                ;  FIRST WORD = POINTER TO CURRENT BUFFER
                                ;  SECOND WORD = POINTER TO NEXT BYTE
                                ;  IN CURRENT BUFFER
                                ;IF NON-BUFFERED INPUT IN PROGRESS:
                                ;  FIRST WORD = KISAR6 BIAS FOR TASK BUFFER
                                ;   SECOND WORD = VIRTUAL ADDRESS IN KISAR6
                                ;   OF NEXT BYTE IN TASK BUFFER
U.TIC:  .BLKW   1               ;REMAINING BYTES IN CURRENT INPUT BUFFER
U.TTIC: .BLKW   1               ;TOTAL REMAINING BYTES TO INPUT
                                ;(EXCLUDING CURRENT BUFFER)
U.TFIB: .BLKW   1               ;POINTER TO FIRST INPUT BUFFER (ONLY WITH
                                ;BUFFERED INPUT)
U.TCO:  .BLKW   1               ;IF TASK OUTPUT IN PROGRESS:
                                ;  POINTER TO CURRENT OUTPUT REQUEST PACKET
                                ;IF ECHO IN PROGRESS, OR OUTPUT IDLE:
                                ;  0
U.TOP:  .BLKW   2               ;FIRST WORD = POINTER TO CURRENT OUTPUT BUFFER
                                ;SECOND WORD = POINTER TO NEXT BYTE IN
                                ;CURRENT OUTPUT BUFFER
U.TOC:  .BLKW   1               ;REMAINING BYTES IN CURRENT OUTPUT BUFFER
U.TTOC: .BLKW   1               ;TOTAL REMAINING BYTES TO OUTPUT
                                ;(EXCLUDING CURRENT BUFFER)
U.TFOB: .BLKW   1               ;POINTER TO FIRST OUTPUT BUFFER
U.TFPB: .BLKW   1               ;FIRST PROMPT BUFFER FOR IO.RPR                 ;PW011
U.TAST: .BLKW   1               ;POINTER TO AST BLOCK
                                ;0 IF NO AST SET UP
U.TISV: .BLKB   1               ;INPUT STATE VARIABLE
U.TIHP: .BLKB   1               ;INITIAL HORIZONTAL POSITION FOR INPUT
U.TECB: .BLKB   1               ;ECHO BUFFER
U.TVFC: .BLKB   1               ;VERTICAL FORMAT CONTROL
U.TITI: .BLKB   1               ;INPUT TIMER
U.TOTI: .BLKB   1               ;OUTPUT TIMER
U.TSHP: .BLKB   1               ;SAVED HORIZONTAL POSITION                      ;PW010
U.TSVP: .BLKB   1               ;SAVED VERTICAL POSITION                        ;PW010
;
U.TRTT: .BLKW   1               ;SPECIAL TERMINATORS TABLE                      ; DD005
        .PSECT
;
;
; DEFINE BITS IN FORK REQUEST BYTE (U.TFRQ).
; FORK REQUESTS ARE PROCESSED IN ASCENDING BIT ORDER.
; NOTE - INPUT DONE (FR.IRD) MUST BE PROCESSED BEFORE OUTPUT DONE
; (FR.ORD) FOR THE SIMULATED CTRL-R FOLLOWING AN IO.WBT TO WORK.
; SEE NOTE IN MODULE TTRW.
;
FR.IRD= 1                       ;INPUT DONE
FR.ORD= 2                       ;OUTPUT DONE
FR.SUI= 4                       ;START OF UNSOLICITED INPUT
X=      4

        .IF DF  T$$CCA&A$$TRP

X=      X*2
FR.AST= X                       ;CHARACTER THAT CAUSES AST RECEIVED

        .ENDC   ;T$$CCA&A$$TRP

        .IF DF  M$$PRO

X=      X*2
FR.TIM= X                       ;TIME-OUT (ON MULTI-CPU SYSTEM ONLY)

        .ENDC   ;M$$PRO

X=      X*2
FR.GRQ= X                       ;GET REQUEST PACKET
                                                                                ;CJR001
        .IF DF  R$$SCS                                                          ;CJR001
                                                                                ;CJR001
X=      X*2                                                                     ;CJR001
FR.FLU= X                       ;FLUSH TASKS RUNNING ON TERMINAL                ;CJR001
                                                                                ;CJR001
        .ENDC   ;R$$SCS                                                         ;CJR001
                                                                                ;CJR001
X=      X*2
FR.PFP= X                       ;PROCESS CHARACTER IN U.TECB AT END
                                ;OF FORK PROCESSING. NOTE - THIS MUST BE
                                ;THE HIGHEST USED BIT IN U.TFRQ!!
;
;
.LIST
        .TITLE  TTMIS
        .IDENT  /V01.04/
;
; 23-JAN-78 PETER WANNHEDEN
;
;       MODIFICATIONS:
;
;       CS013   25-MAY-78       CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;
;+
; COMMON MULTIPLEXER INTERRUPT SERVICE ROUTINES.
; USED BY FOLLOWING CONTROLLERS: DH, DJ, DZ.
;-
;
;

        .IF DF  T$$MUX

        .MCALL  UCBDF$,SCBDF$                                                   ; CS013
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        .MCALL  KRBDF$                                                          ; CS013
                                                                                ; CS013
        KRBDF$                  ;DEFINE KRB SYMBOLS                             ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        UCBDF$                  ;DEFINE UCB SYMBOLS                             ;**-3
        SCBDF$                  ;DEFINE SCB SYMBOLS
;
;
;+
; MUXINP - INPUT INTERRUPT SERVICE FOR MULTIPLEXERS.
;
; INPUT:
;       R3      CSR ADDRESS
;       R4      KRB ADDRESS (RSX-11M+)                                          ; CS013
;       R4      ADDRESS OF UCB LIST (RSX-11M)                                   ; CS013
;                                                                               ;**-1
; ALTERNATE ENTRY - MUXIN1.
;
; INPUT:
;       R3      CSR ADDRESS
;       R4      KRB ADDRESS (RSX-11M+)                                          ; CS013
;       R4      ADDRESS OF UCB LIST (RSX-11M)                                   ; CS013
;       R5      CHARACTER + STATUS FROM SILO                                    ;**-1
;       CC-N    1 IF R5 CONTAINS VALID CHARACTER
;
; OUTPUT FROM BOTH:
;       SILO EMPTIED. IF TRANSMIT READY IS SET IN CSR,
;       A RETURN TO CALLER IS MADE WITH R3 AND R4 UNCHANGED.
;       ELSE A RETURN TO CALLER'S CALLER IS MADE.
;
; REGISTERS ALTERED: R2,R5
;-
;
;
MUXIN1::MOV     R5,-(SP)        ;;;SAVE CHAR
        SWAB    R5              ;;;GET LINE NUMBER IN LOW BYTE
        CALL    MUXUCB          ;;;GET UCB IN R5
        MOV     (SP)+,R2        ;;;RETRIEVE CHAR + STATUS
        BCS     MUXINP          ;;;BAD LINE - IGNORE CHARACTER
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        MOV     R4,-(SP)        ;;;OK - SAVE KRB ADDRESS
        CALL    ICHAR1          ;;;DO COMMON INPUT INTERRUPT PROC.
        MOV     (SP)+,R4        ;;;RESTORE KRB ADDRESS
        MOV     @R4,R3          ;;;RESTORE CSR ADDRESS
                                                                                ; CS013
        .IFF                                                                    ; CS013
        MOV     R3,-(SP)        ;;;SAVE CSR                                     ; CS013
        MOV     R4,-(SP)        ;;;SAVE ADDR OF UCB LIST                        ; CS013
        CALL    ICHAR1          ;;;DO COMMON INPUT INTERRUPT PROC.              ; CS013
        MOV     (SP)+,R4        ;;;RESTORE ADDR OF UCB LIST                     ; CS013
        MOV     (SP)+,R3        ;;;RESTORE CSR                                  ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
MUXINP::MOV     2(R3),R5        ;;;GET NEXT CHARACTER FROM SILO
        BMI     MUXIN1          ;;;OK - JUMP
;
; SILO IS NOW EMPTY. SEE IF CONTROLLER IS READY TO TRANSMIT
;
        TST     @R3             ;;;XMIT RDY SET?
        BMI     10$             ;;;Y - RETURN
        TST     (SP)+           ;;;N - POP 1.ST RETURN ADDRESS
10$:    RETURN                  ;;;RETURN
;
;
;+
; MUXUCB - GET UCB FROM LINE NUMBER.
;
; INPUT:
;       R4      KRB ADDRESS (RSX-11M+)                                          ; CS013
;       R4      ADDRESS OF UCB LIST (RSX-11M)                                   ; CS013
;       R5      LINE NUMBER IN BITS 0-3                                         ;**-1
;
; OUTPUT:
;       R2      LINE NUMBER * 2
;       R5      POINTER TO U.TSTA (IF VALID LINE)
;       CC-C    0 IF VALID LINE
;               1 IF INVALID LINE
;
; REGISTERS ALTERED: R2,R5
;-
;
;
MUXUCB::BIC     #^C17,R5        ;;;CLEAR IRRELEVANT BITS
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        MOV     R5,R2           ;;;COPY LINE NUMBER
        ASL     R2              ;;;MAKE INDEX FOR UCB TABLE
        CMPB    K.HPU(R4),R5    ;;;LINE IN USE?
        BLO     10$             ;;;N - EXIT WITH CC-C SET
        MOV     R4,R5           ;;;GET KRB ADDRESS
        ADD     K.OFF(R4),R5    ;;;ADD OFFSET TO UCB LIST
        ADD     R2,R5           ;;;ADD LINE NUMBER * 2 - YIELDING
                                ;;;POINTER TO UCB POINTER
        MOV     @R5,R5          ;;;GET UCB POINTER
        ADD     #U.TSTA,R5      ;;;POINT TO U.TSTA AND CLEAR CC-C
10$:    RETURN                  ;;;RETURN

        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        ASL     R5              ;;;GET UNIT NUMBER * 2                          ; CS013
        MOV     R5,R2           ;;;SAVE IT                                      ; CS013
        ADD     R4,R5           ;;;GET UCB POINTER                              ; CS013
        MOV     (R5),R5         ;;;POINT TO UCB                                 ; CS013
        BEQ     10$             ;;;LINE NOT IN USE                              ; CS013
        ADD     #U.TSTA,R5      ;;;POINT TO U.TSTA AND CLEAR CC-C               ; CS013
        RETURN                  ;;;RETURN                                       ; CS013
                                                                                ; CS013
10$:    SEC                     ;;;SET CC-C                                     ; CS013
        RETURN                  ;;;RETURN                                       ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        .ENDC   ;T$$MUX

;
;
        .END
        .TITLE  TTMOD
        .IDENT  /V01.10/
;
; 26-FEB-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW002   07-APR-78       PETER WANNHEDEN
;               TERMINATE "BYE" COMMAND TO MCR (ON HANG-UP) WITH ESCAPE.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       CS033   27-MAR-79       CHARLES FRANKLIN SPITZ
;               ADD MULTIPLE CLI SUPPORT FOR DECNET
;       DD018   01-MAY-79       DALE R. DONCHIN
;               INITIALIZE FULL LINE STATUS WHEN ANSWERING A REMOTE LINE
;
;
;+
; TTMOD - MODEM SUPPORT ROUTINES.
;       CONTAINS THE FOLLOWING ROUTINES:
;
;       MODISR  INTERRUPT SERVICE ROUTINE FOR DM11-BB AND DL11-E
;               CONTROLLERS
;       MTIM    SUBROUTINE TO SERVICE TIME-OUT FOR DM11-BB AND DL11-E
;       MANS    SUBROUTINE TO ANSWER A CALL ON A LINE
;       MHUP    SUBROUTINE TO HANG UP A LINE
;-
;
;

        .IF DF  T$$MOD

; EQUATED SYMBOLS
;
DTR     =       2               ;DATA TERMINAL READY
RTS     =       4               ;REQUEST TO SEND
;
;
        .ENABL  LSB

        .IF DF  D$$M11!D$$LMD

;+
; MODISR - INTERRUPT SERVICE ROUTINE FOR DATASET STATUS CHANGE INTERRUPT
; ON DM11-BB OR DL11-E.
;
; INPUT:
;       R3      POINTER TO LINE STATUS REGISTER
;               (CONTAINING DTR AND RTS BITS)
;       R4      BIT 7:  1 IF RING HAS OCCURRED (DM11-BB)
;                       1 IF LINE IS RINGING (DL11-E)
;               BIT 6:  1 IF DATASET SHOWS "CLEAR TO SEND"
;               BIT 5:  1 IF DATASET SHOWS "CARRIER ON"
;       R5      POINTER TO U.TSTA
;       2(SP)   VALUE TO LOAD IN U.CW3 IF A CALL IS ANSWERED.
;
; OUTPUT:
;       1.      IF LINE IS OFFLINE OR NOT REMOTE, NO ACTION.
;       2.      IF LINE IS DISABLED AND NOT WAITING FOR CARRIER:
;       2.1     IF RING SEEN, SET DTR AND RTS. SET A TIMER FOR
;               M$$ANS SECONDS.
;               (ANSWER A CALL AND WAIT FOR CARRIER).
;       2.2     IF NO RING SEEN, NO ACTION.
;       3.      IF LINE IS DISABLED AND WAITING FOR CARRIER:
;               (RING FLAG IS IGNORED)
;       3.1     IF CARRIER AND CTS ARE ON, CLEAR WAITING FLAG
;               AND ENTER SUBROUTINE "MANS".
;               (CARRIER APPEARED WITHIN WAITING PERIOD M$$ANS
;               AFTER ANSWERING A CALL).
;       3.2     IF CARRIER OR CTS IS OFF, NO ACTION.
;       4.      IF LINE IS ENABLED AND NOT WAITING FOR CARRIER:
;       4.1     IF RING SEEN, SET A TIMER FOR 1 SECOND AND SET
;               CARRIER WAIT FLAG.
;               (WAIT FOR THE NEXT "TICK" TO LOG OFF CURRENT USER).
;       4.2     IF RING NOT SEEN AND CARRIER AND CTS ARE BOTH ON,
;               NO ACTION.
;       4.3     IF RING NOT SEEN AND CARRIER OR CTS IS OFF, SET A TIMER
;               FOR M$$CAR SECONDS AND SET WAITING FLAG.
;               (CARRIER LOST, WAIT FOR IT TO RETURN).
;       5.      IF LINE IS ENABLED AND WAITING FOR CARRIER:
;               (NOTE - THIS IS THE STATE THE LINE SHOULD STAY IN
;               UNTIL A BYE COMMAND HAS BEEN SUCCESSFULLY QUEUED
;               AFTER HAVING FAILED EARLIER AS RESULT OF HANG-UP.
;               IN THIS STATE, DTR SHOULD BE OFF SO THAT CARRIER
;               WILL NEVER BE SEEN - CASE 5.2 SHOULD NEVER HAPPEN).
;       5.1     IF RING SEEN, SAME AS 4.1.
;       5.2     IF RING NOT SEEN AND CARRIER AND CTS ARE BOTH ON,
;               CLEAR WAITING FLAG.
;               (LINE RETURNED TO NORMAL CONDITION AFTER TEMPORARY
;               LOSS OF CARRIER).
;       5.2     IF RING NOT SEEN AND CARRIER OR CTS IS OFF, NO ACTION.
;               (LINE STILL WITHOUT CARRIER, WAIT FOR CARRIER TO RETURN).
;
;       IN EITHER CASE:
;       STACK CLEANED (INPUT PARAMETER REMOVED).
;       CC-C    0 IF A CALL WAS ANSWERED
;               1 ELSE
;
; REGISTERS ALTERED: R4
;-
;
;
MODISR::BITB    #US.OFL,U.ST2-U.TSTA(R5) ;;;OFF-LINE?
        BNE     30$             ;;;Y - IGNORE
        BIT     #U2.RMT,U.CW2-U.TSTA(R5) ;;;REMOTE LINE?
        BEQ     30$             ;;;N - IGNORE
        COMB    R4              ;;;INVERT FLAGS
        MOVB    R4,-(SP)        ;;;SAVE FLAGS
        MOVB    U.STS-U.TSTA(R5),R4 ;;;GET DSB AND CRW FLAGS
        BIC     #^C<US.DSB!US.CRW>,R4 ;;;CLEAR JUNK BITS
        ASSUME  US.DSB,2
        ASSUME  US.CRW,4
        ROLB    @SP             ;;;GET INVERTED RING FLAG IN CC-C
        BITB    #300,(SP)+      ;;;GET CON&CTS IN CC-Z
        JMP     @MDSP(R4)       ;;;DISPATCH ACCORDING TO DSB AND CRW FLAGS
;
; CASE 2 - DISABLED AND NOT WAITING FOR CARRIER
;
MODI2:: BCS     70$             ;;;NO RING - IGNORE
        BIS     #DTR!RTS,@R3    ;;;SET DTR AND RTS
        MOVB    #M$$ANS+1,U.TMTI-U.TSTA(R5) ;;;SET TIMER = M$$ANS SECONDS
        BR      20$             ;;;GO AND WAIT FOR CARRIER
;
; CASE 3 - DISABLED AND WAITING FOR CARRIER
;
MODI3:: BNE     30$             ;;;CARRIER AND CTS NOT BOTH ON - JUMP
        BR      MANS            ;;;ANSWER CALL
;
; CASE 4 - ENABLED AND NOT WAITING FOR CARRIER
;
MODI4:: BCC     10$             ;;;RING - JUMP (SHOULD NOT HAPPEN)
        BEQ     70$             ;;;CARRIER AND CTS BOTH ON - IGNORE
        MOVB    #M$$CAR+1,U.TMTI-U.TSTA(R5) ;;;SET TIMER FOR M$$CAR SECONDS
        BR      20$             ;;;GO AND SET WAIT FLAG
;
; CASE 5 - ENABLED AND WAITING FOR CARRIER
;
MODI5:: BCC     10$             ;;;RING - JUMP
        BNE     70$             ;;;CARRIER AND CTS NOT BOTH ON - JUMP
        BR      60$             ;;;BOTH ON - CLEAR WAITING FLAG
                                ;;;AND EXIT WITH CC-C = 1
10$:    MOVB    #1,U.TMTI-U.TSTA(R5) ;;;SET TIMER = 1 SECOND
20$:    BISB    #US.CRW,U.STS-U.TSTA(R5) ;;;SET CARRIER-WAIT FLAG
30$:    SEC                     ;;;SHOW NO CALL ANSWERED
        BR      70$             ;;;RETURN

        .ENDC   ;D$$M11!D$$LMD

;
;
;+
; SUBROUTINE MANS - ANSWER A CALL.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;       2(SP)   VALUE TO LOAD IN U.CW3
;
; OUTPUT:
;       UCB IS INITIALIZED. DISABLE AND CARRIER-WAIT FLAGS CLEARED.
;       STACK CLEANED (INPUT PARAMETER REMOVED).
;       CC-C    0 TO INDICATE CALL ANSWERED.
;
; REGISTERS ALTERED: NONE
;-
;
;
MANS::  CLR     @R5             ;;;INITIALIZE STATUS WORD 1
                                ;;;AND CLEAR CC-C
        MOV     #S2.ACR!S2.FLF,2(R5) ;;;AND STATUS WORD 2
        BIC     #^C<S3.TAB>,4(R5) ;;;AND STATUS WORD 3                          ; DD018
        BIC     #U2.CRT!U2.HLD!U2.L3S!U2.VT5!U2.LWC,U.CW2-U.TSTA(R5)
                                ;;;INITIALIZE CHARACTERISTICS WORD 2
        MOV     2(SP),U.CW3-U.TSTA(R5) ;;;AND WORD 3
        MOV     #72.,U.CW4-U.TSTA(R5) ;;;AND WORD 4
                                                                                ; CS033
        .IF DF R$$MPL!M$$CLI                                                    ; CS033
                                                                                ; CS033
        MOV     #$MCRPT,U.CLI-U.TSTA(R5) ;;;SET MCR AS CLI
                                                                                ; CS013
        .ENDC                                                                   ; CS013
                                                                                ; CS013
60$:    BICB    #US.DSB!US.CRW,U.STS-U.TSTA(R5)
                                ;;;ENABLE LINE AND CLEAR WAITING FLAG
70$:    MOV     (SP)+,(SP)      ;;;CLEAN STACK
        RETURN                  ;;;RETURN

        .DSABL  LSB


        .IF DF  D$$M11!D$$LMD

;+
; HLMTIM - TIME-OUT ON DM11-BB OR DL11-E.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF CARRIER-WAIT FLAG = 0:
;       RETURN TO CALLER'S CALLER
;
;       ELSE:
;       CALLER CALLED AS COROUTINE WITH INTERRUPTS LOCKED OUT.
;       ON RETURN FROM CALLER, THE FOLLOWING IS EXPECTED:
;
;       R5      UNCHANGED
;       DTR AND RTS DROPPED.
;-
;
;
HLMTIM::MTPS    #TTPRI          ;LOCK OUT INTERRUPTS
        BITB    #US.CRW,U.STS-U.TSTA(R5) ;;;ARE WE STILL WAITING?
        BNE     20$             ;;;Y - JUMP
        MTPS    #0              ;;;N - AN INTERRUPT HAS CHANGED THINGS
        TST     (SP)+           ;ALLOW INTERRUPTS AND RETURN TO CALLER'S CALLER
10$:    BICB    #US.CRW,U.STS-U.TSTA(R5) ;CLEAR WAITING FLAG
        RETURN                  ;RETURN
20$:    CALL    @(SP)+          ;;;CALL COROUTINE
        MTPS    #0              ;;;ALLOW INTERRUPTS
        BITB    #US.DSB,U.STS-U.TSTA(R5) ;LINE ENABLED?
        BNE     10$             ;N - CLEAR WAITING FLAG AND RETURN
                                ;ELSE FALL THRU TO "MHUP" TO HANG UP

        .ENDC   ;D$$M11!D$$LMD

;
;
;+
; SUBROUTINE MHUP - HANG UP.
;       MAY ONLY BE CALLED AT SYSTEM STATE!
;
; INPUT:
;       R5      POINTER TO U.TSTA
;       US.DSB  0 TO PREVENT THAT A RING IS ANSWERED BEFORE THE
;               TERMINAL IS LOGGED OFF
;       LINE PHYSICALLY HUNG UP (DTR AND RTS DROPPED).
;
; OUTPUT:
;       IF ANY I/O WAS ACTIVE, IT IS KILLED.
;       IF TERMINAL WAS LOGGED ON, A BYE COMMAND IS QUEUED.
;       IF BYE COMMAND SUCCESSFULLY QUEUED:
;               US.DSB  1 (LINE DISABLED)
;               US.CRW  0 (NOT WAITING)
;       ELSE:
;               US.DSB  0 (LINE ENABLED)
;               US.CRW  1 (WAITING)
;
; REGISTERS ALTERED: R0,R1,R2,R3,R4
;-
;
;
MHUP::  BISB    #US.CRW,U.STS-U.TSTA(R5) ;ASSUME FAILURE TO SEND BYE COMMAND
                                ;THIS ALSO PREVENTS PROCESSING OF INPUT
                                ;INTERRUPTS
        CALL    I1CTXL          ;FLUSH TYPE-AHEAD BUFFER
        MOV     U.TUX-U.TSTA(R5),R4 ;GET UCBX
        BEQ     20$             ;NONE - JUMP
        ASSUME  U.TITI&1,0      ;U.TITI MUST BE EVEN
        ASSUME  U.TOTI,U.TITI+1
        CLR     U.TITI(R4)      ;CLEAR INPUT AND OUTPUT TIMERS
        MOV     #IE.DNR,R0      ;GET STATUS TO RETURN TO TASK
        CALL    KILLI1          ;KILL INPUT (IF ANY IN PROGRESS)
        CALL    KILLO1          ;KILL OUTPUT (IF ANY IN PROGRESS)
                                ;WITH STATUS IE.DNR
20$:

        .IF DF  M$$MUP

        BIT     #U2.LOG,U.CW2-U.TSTA(R5) ;TERMINAL LOGGED ON?
        BNE     30$             ;N - JUMP
        MOV     #M$$CRB,R1      ;GET CLI COMMAND BUFFER LENGTH
        CALL    $ALOCB          ;ALLOCATE A CLI CMD BUFFER
        BCS     40$             ;FAILED - EXIT
        MOV     R0,R1           ;COPY BUFFER POINTER
        TST     (R0)+           ;SKIP OVER LINK WORD
        MOV     R5,R2           ;
        SUB     #U.TSTA,R2      ;GET UCB ADDRESS
        MOV     R2,(R0)+        ;INSERT UCB ADDRESS
        MOV     #"BY,(R0)+      ;INSERT "BYE" COMMAND
        MOV     #'E!<CH.ESC*400>,(R0)+                                          ;PW002
                                                                                ;PW002
        .IF DF R$$MPL!M$$CLI                                                    ; CS033
                                                                                ; CS033
        MOV     $MCRPT,R0       ;GET MCR'S TCB                                  ;**-1
        CALL    $QCLIL          ;QUEUE COMMAND TO MCR
                                                                                ; CS033
        .IFF    ;R$$MPL!M$$CLI                                                  ; CS033
                                                                                ; CS033
        CALL    $QMCRL          ;QUEUE COMMAND TO MCR                           ; CS033
                                                                                ; CS033
        .ENDC   ;R$$MPL!M$$CLI                                                  ; CS033
                                                                                ; CS033

        .ENDC   ;M$$MUP

; THE LINE MAY HAVE BECOME NON-REMOTE. IF SO, LEAVE IT ENABLED.
;
30$:    BIT     #U2.RMT,U.CW2-U.TSTA(R5) ;REMOTE LINE?
        BEQ     35$             ;N - JUMP
        BISB    #US.DSB,U.STS-U.TSTA(R5) ;Y - DISABLE
35$:    BICB    #US.CRW,U.STS-U.TSTA(R5) ;CLEAR CARRIER-WAIT FLAG
40$:    RETURN                  ;

        .ENDC   ;T$$MOD

;
;
        .END
        .TITLE  TTODN
        .IDENT  /V01.14/
;
; 30-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW005   11-APR-78       PETER WANNHEDEN
;               PREVENT BELL OUTPUT WHEN COMPLETING TASK OUTPUT.
;       PW031   31-MAY-78       PETER WANNHEDEN
;               SUPPORT TF.XOF.
;
;+
; ODONE - OUTPUT DONE PROCESSING.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       THE DATABASE IS UPDATED AS REQUIRED.
;       ANOTHER OUTPUT OPERATION MAY BE INITIATED.
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
        .ENABL  LSB
;
.SBTTL  ODONE - OUTPUT DONE
;
ODONE:: BITB    #US.OIU,U.STS-U.TSTA(R5) ;;;OUTPUT INTERRUPT UNEXPECTED?
                                ;;;(COULD HAPPEN FOR EXAMPLE IF WE COME
                                ;;;HERE WHEN ABORTING OUTPUT)
        BNE     60$             ;;;Y - JUMP
        ASSUME  US.OIU,1
        INCB    U.STS-U.TSTA(R5) ;;;NOW IT IS UNEXPECTED
10$:    MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX
        BEQ     60$             ;;;NONE - JUMP (THIS CAN ONLY HAPPEN IF
                                ;;;WE COME HERE TO DO A SPECIAL ECHO
                                ;;;SUCH AS BELL)
        CLRB    U.TOTI(R4)      ;;;CLEAR OUTPUT TIMER
        TST     U.TCO(R4)       ;;;DOING TASK OUTPUT?                           ;PW005
        BNE     40$             ;;;Y - JUMP                                     ;PW005
        MOVB    1(R5),R3        ;;;GET UPPER BYTE OF FIRST STATUS WORD
        ASSUME  S1.BEL,400
        ROR     R3              ;;;BELL ECHO REQUESTED?
        BCS     BELL1           ;;;Y - JUMP
        ASSUME  S1.OBY,100      ;S1.OBY MUST BE IN LOW BYTE                     ;**-2
        BICB    #S1.OBY,@R5     ;;;SET OUTPUT FREE
        ASSUME  S1.IBY,200
        BPL     CFGRQ           ;;;INPUT FREE - JUMP
        CALL    ECHD1           ;;;INPUT BUSY - ENTER INPUT ROUTINES
                                ;;;FALL THRU TO "NXTIC"
.PAGE
.SBTTL  NXTIC - GET NEXT INPUT CHARACTER FROM TYPE-AHEAD BUFFER
;
;+
; NXTIC - GET NEXT INPUT CHARACTER FROM TYPE-AHEAD BUFFER.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF A CHARACTER CAN BE OBTAINED FROM THE TYPE-AHEAD BUFFER,
;       AND THE CHARACTER CAN BE PROCESSED, IT IS REMOVED FROM
;       THE TYPE-AHEAD BUFFER AND ICHAR2 IS CALLED TO PROCESS
;       THE CHARACTER.
;
;       ELSE A RETURN IS EXECUTED.
;-
;
;
NXTIC:: CALL    GCTAB           ;;;GET A CHARACTER FROM TABUF
        BCS     60$             ;;;NONE THERE - RETURN
        CALL    IPROC           ;;;CAN WE PROCESS IT?
        BCS     60$             ;;;N - RETURN
        CALL    RCTAB           ;;;Y - REMOVE CHARACTER FROM TABUF
        CALL    ICHAR2          ;;;PROCESS CHARACTER
        BR      NXTIC           ;;;LOOP
.PAGE
.SBTTL  CFGRQ - CONDITIONALLY FORK TO GET A REQUEST PACKET FROM QUEUE
;
;+
; CFGRQ - CONDITIONALLY FORK TO GET A REQUEST PACKET FROM QUEUE.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF THERE IS A PACKET IN THE QUEUE THAT MAY BE PROCESSED NOW,
;       A FORK REQUEST IS QUEUED TO GET A REQUEST PACKET.
;-
;
;
CFGRQ:: CALL    TSTRQ           ;;;TEST I/O QUEUE
                                ;;;RETURN IF NOTHING WORTH FORKING IN QUEUE
        MOV     #FR.GRQ,R3      ;;;FORK/GET REQUEST PACKET
        BR      50$             ;;;
;
40$:    MOV     #FR.ORD,R3      ;;;FORK/OUTPUT REQUEST DONE (AT LEAST PARTIALLY)
50$:    CALLR   FORK            ;;;QUEUE FORK REQUEST
;
;
.SBTTL  BELL - OUTPUT A BELL
;
;+
; BELL - OUTPUT A BELL.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF ECHO IS SUPPRESSED, IMMEDIATE RETURN (NO ACTION).
;       ELSE A BELL IS OUTPUT IF POSSIBLE, OR FLAGGED FOR
;       OUTPUT AT FIRST OPPORTUNITY.
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
BELLL:: CALL    LOCKI           ;LOCK OUT INTERRUPTS
BELL::  BIT     #S1.RNE,@R5     ;;;ECHO SUPPRESSED?
        BNE     60$             ;;;Y - RETURN
        MOV     #S1.BEL,R3      ;;;GET BELL FLAG
                                ;;;FALL THRU TO "SPECH"
;
;
;+
; SPECH - DO A SPECIAL ECHO.
;
; INPUT:
;       R3      BIT IN U.TSTA FOR SPECIAL ECHO REQUESTED
;               S1.BEL = ECHO BELL
;               (OTHER FLAGS MAY BE IMPLEMENTED FOR OUTPUT
;               OF XON AND XOFF WHEN TYPE-AHEAD BUFFER
;               BECOMES NON-FULL AND FULL RESPECTIVELY)
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF TRANSMITTER IS FREE, THE SPECIAL ECHO IS STARTED.
;       IF TRANSMITTER IS BUSY, THE FLAG IS SET IN U.TSTA
;       TO FORCE THE SPECIAL ECHO AT FIRST OPPORTUNITY.
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
SPECH:: BIS     R3,@R5          ;;;SET FLAG
        BIT     #S1.DSI!S1.OBY,@R5 ;;;OUTPUT BUSY OR FORK PROCESSING BUSY?
        BEQ     10$             ;;;NEITHER - DO IT NOW
;
; A SPECIAL ECHO MAY BE DELAYED BECAUSE FORK PROCESSING IS BUSY (S1.DSI SET).
;
60$:    RETURN                  ;;;Y - WAIT
;
        .DSABL  LSB
;
;
BELL1:  BIC     #S1.BEL,@R5     ;;;CLEAR BELL FLAG
        MOV     #ASBELL,R3      ;;;POINT TO BELL CHAR.
        BR      ECHCHR          ;;;GO AND OUTPUT A SINGLE CHARACTER             ;PW031
;                                                                               ;**-1
;
.PAGE
.SBTTL  ECHSTR, ECHCHR - ECHO A STRING OR A CHARACTER
;
;+
; ECHSTR - ECHO A STRING.
;
; INPUT:
;       R2      STRING LENGTH
;       R3      POINTER TO THE STRING
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;
; ALTERNATE ENTRY - ECHCHR
;       SAME AS ECHSTR, BUT PRESETS R2 TO 1 TO ECHO 1 CHARACTER.
; ALTERNATE ENTRY - ECHRL                                                       ;PW031
;       SAME AS ECHCHR, BUT LOCKS OUT INTERRUPTS BEFORE THE OPERATION           ;PW031
;       AND ALLOWS INTERRUPTS BEFORE RETURN.                                    ;PW031
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
ECHRL:: CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ;PW031
ECHCHR::MOV     #1,R2           ;;;STRING LENGTH = 1
ECHSTR::ADD     #U.TOP,R4       ;;;POINT TO U.TOP
        CLR     (R4)+           ;;;U.TOP <-- 0 (ECHO)
        MOV     R3,(R4)+        ;;;U.TOP+2 <-- BUFFER ADDRESS
        ASSUME  U.TOC,U.TOP+4
        MOV     R2,@R4          ;;;U.TOC <-- BYTE COUNT
        BR      STARTX          ;;;START TRANSMISSION
;
;
;+
; STARTX - START TRANSMISSION OF A BUFFER.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;       U.TOP+2 BUFFER ADDRESS
;       U.TOC   BYTE COUNT
;
; CALLS CONTROLLER-DEPENDENT ROUTINE TO START OUTPUT.
; NOTE - MUST BE CALLED ON DEVICE PRIORITY!
;
; ALTERNATE ENTRY: STAXL - START TRANSMISSION OF A LIST OF BUFFERS.
;
; INPUT:
;       R4      POINTER TO UCBX
;       R5      POINTER TO UCB
;       U.TFOB  POINTER TO FIRST OUTPUT BUFFER
;               EACH BUFFER CONTAINS A LINK TO THE NEXT BUFFER IN THE
;               FIRST WORD, AND BYTE COUNT IN THE SECOND WORD.
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;
STAXL:: MOV     U.TFOB(R4),R2   ;;;GET FIRST BUFFER
        ADD     #U.TOP,R4       ;;;POINT TO U.TOP
        CALL    UPUB            ;;;SET UP UCBX FOR OUTPUT
STARTX::BIS     #S1.OBY,@R5     ;;;SET OUTPUT BUSY
        ASSUME  US.OIU,1
        DECB    U.STS-U.TSTA(R5) ;;;SET OUTPUT INTERRUPT EXPECTED

        .IF DF  DEBUG

        BPL     1$
        BPT
1$:

        .ENDC

        MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCBX
        MOVB    #5,U.TOTI(R4)   ;;;INITIALIZE OUTPUT TIMER
;
; THE LONGEST POSSIBLE OUTPUT (IN TIME) IS 36(10) CHARACTERS AT 110 BAUD,
; SO 5 SECONDS SHOULD BE ENOUGH
;
        CLR     R2              ;;;SET INDEX FOR "START OUTPUT"
        CALLR   CTRD            ;;;CALL CONTROLLER DEPENDENT ROUTINE
;
;
        .END
        .TITLE  TTOIS
        .IDENT  /V01.04/
;
; 23-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW026   05-MAY-78       PETER WANNHEDEN
;               USE SUBROUTINE RESM TO RESTORE DRIVER DATA SPACE MAPPING.
;
;+
; COMMON OUTPUT INTERRUPT SERVICE ROUTINE.
; USED BY FOLLOWING CONTROLLER TYPES: DJ, DL, DZ.
;
; INPUT:
;       R2      BITMASK FOR TRANSMIT ENABLE
;       R3      CSR ADDRESS
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       NEXT CHARACTER IS OUTPUT, IF THERE IS ONE.
;       IF NECESSARY, A SWITCH IS MADE TO THE NEXT OUTPUT BUFFER
;       (ONLY IF DOING BUFFERED OUTPUT).
;       IF NO MORE CHARACTERS TO OUTPUT, ODONE IS CALLED TO
;       PERFORM OUTPUT-DONE PROCESSING.
;
; REGISTERS ALTERED: R2,R3,R4
;-
;
;

        .IF DF  D$$J11!D$$L11!D$$Z11

        .MCALL  UCBDF$
;
        UCBDF$                  ;DEFINE UCB SYMBOLS
;
;
OUTISR::BITB    #US.DSB!US.OIU,U.STS-U.TSTA(R5) ;;;DISABLED OR OUTPUT
                                ;;;INTERRUPT UNEXPECTED?
        BNE     50$             ;;;Y - IGNORE
        BIT     #S1.CTS,@R5     ;;;OUTPUT STOPPED BY CTRL-S?
        BNE     50$             ;;;Y - IGNORE

        .IF DF  R$$CON

        BITB    #US.OFL,U.ST2-U.TSTA(R5) ;;;OFFLINE?
        BNE     50$             ;;;Y - IGNORE

        .ENDC

;
; GET NEXT CHARACTER TO OUTPUT.
;
        MOV     R2,-(SP)        ;;;SAVE R2
        MOV     U.TUX-U.TSTA(R5),R4 ;;;GET UCB EXTENSION

        .IF DF  DEBUG

        BNE     1$
        BPT
1$:

        .ENDC

        ADD     #U.TOC,R4       ;;;POINT TO U.TOC
10$:    DEC     @R4             ;;;DECREMENT BYTE COUNT (U.TOC)
        BPL     20$             ;;;MORE TO DO - JUMP
        CLR     @R4             ;;;THIS BUFFER EXHAUSTED - CLEAR U.TOC
        TST     -(R4)           ;;;POINT TO U.TOP+2
        CALL    NXTOB           ;;;GET NEXT OUTPUT BUFFER IF THERE IS ONE
        BNE     10$             ;;;DO IT ALL OVER AGAIN WITH NEW BUFFER
        BR      40$             ;;;ALL DONE - JUMP
20$:    TST     (SP)+           ;;;CLEAN STACK                                  ;PW026

        .IF DF  S1.OBF

        ASSUME  <U.TOP+2>,<U.TOC-2>
        MOV     -(R4),R2        ;;;GET POINTER TO NEXT CHAR. (U.TOP+2)          ;PW026
        INC     @R4             ;;;UPDATE POINTER                               ;PW026
        BIT     #S1.OBF,@R5     ;;;BUFFERED OUTPUT?                             ;**-1
        BNE     30$             ;;;Y - JUMP
        MOV     -2(R4),KISAR6   ;;;N - MAP TASK BUFFER (U.TOP)
30$:    MOVB    @R2,6(R3)       ;;;OUTPUT CHARACTER
        CALLR   RESM            ;;;RESTORE MAPPING AND RETURN                   ;PW026
                                                                                ;PW026
        .IFF                                                                    ;PW026
                                                                                ;PW026
        MOVB    @-(R4),6(R3)    ;;;OUTPUT CHARACTER                             ;PW026
        INC     @R4             ;;;UPDATE POINTER                               ;PW026
        RETURN                  ;;;RETURN                                       ;PW026
                                                                                ;PW026
        .ENDC                                                                   ;PW026
                                                                                ;PW026
40$:    MOV     @SP,R2          ;;;RESTORE R2                                   ;**-11
        MOV     #ODONE,@SP      ;;;DO OUTPUT DONE PROCESSING BEFORE
                                ;;;INTERRUPT IS DISMISSED
50$:    BIC     R2,4(R3)        ;;;DISABLE TRANSMISSION ON THIS LINE
        RETURN                  ;;;

        .ENDC   ;D$$J11!D$$L11!D$$Z11

;
;
        .END
        .TITLE  TTRW
        .IDENT  /V01.38/
;
; 25-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW009   13-APR-78       PETER WANNHEDEN
;               ECHO ^U ON ALL ERROR TERMINATIONS OF UNSOLICITED
;               INPUT (EXCEPT IE.EOF).
;       PW010   14-APR-78       PETER WANNHEDEN
;               SUPPORT DEVICE-INDEPENDENT CURSOR CONTROL.
;       PW011   14-APR-78       PETER WANNHEDEN
;               ALLOW CTRL-R OF PROMPT BUFFER FOR IO.RPR ON FULL DUPLEX LINE.
;       PW012   14-APR-78       PETER WANNHEDEN
;               MODIFIED USAGE OF I.PRM+16 IN I/O PACKET.
;       PW017   25-APR-78       PETER WANNHEDEN
;               SCAN I/O QUEUE AFTER UNSOLICITED INPUT IS TERMINATED.
;       PW023   03-MAY-78       PETER WANNHEDEN
;               DON'T GENERATE ^U AFTER UNSOLICITED INPUT ERROR ON A REMOTE
;               LINE THAT HAS GONE INTO DISABLED OR WAITING-FOR-CARRIER STATE.
;       PW024   05-MAY-78       PETER WANNHEDEN
;               FIX BUG IN HANDLING OF CONTINUATION LINES.
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED.
;       PW031   31-MAY-78       PETER WANNHEDEN
;               SUPPORT TF.XOF.
;       DD005   06-OCT-78       DALE R. DONCHIN
;               ADD READ WITH TERMINATOR TABLE FUNCTION
;       DD008   06-NOV-78       DALE R. DONCHIN
;               DON'T ATTEMPT MCR CONTINUATION LINES FOR RSX11M
;               REQUEST A SPECIAL CLI PROMPT ON NULL LINES TO SAVE POOL
;       DD015   26-FEB-79       DALE R. DONCHIN
;               FIX IO.RPR ^O BUG
;       DD016   22-MAR-79       DALE R. DONCHIN
;               ALLOW A READ TO CANCEL ^O
;       DD017   23-APR-79       DALE R. DONCHIN
;               SUPPORT SINGLE SCB PER CONTROLLER
;       DD018   01-MAY-79       DALE R. DONCHIN
;               MAKE SURE THE CLI TASK IS INSTALLED BEFORE QUEUEING TO IT
;
;+
; TTRW - THIS MODULE CONTAINS THE CODE TO START READ AND WRITE REQUESTS.
;       THE FORK LEVEL ROUTINES TO HANDLE COMPLETION OF READ AND WRITE
;       REQUESTS ARE ALSO INCLUDED (EVEN COMPLETION OF UNSOLICITED
;       READ). THE COMPLETION ROUTINES CHECK FOR PARTIAL COMPLETION,
;       IN WHICH CASE THE NECESSARY WORK IS DONE TO CONTINUE THE
;       TRANSFER.
;-
;
;
        .MCALL  TTSYM$
        TTSYM$                  ;DEFINE TF.XXX SYMBOLS
;
;
.SBTTL  PPRLB - PROCESS AN IO.RLB REQUEST
;
; INPUT:
;       R3      I/O PACKET ADDRESS
;               I.LNK = 0 (UNLESS THIS IS THE READ PORTION
;                       OF A READ AFTER PROMPT REQUEST)
;       R4      UCBX ADDRESS
;       R5      POINTER TO U.TSTA
;
;
        ASSUME  U.TCI,0
PPRLB:: MOV     R3,(R4)+        ;SAVE PACKET ADDRESS

        .IF DF  T$$CCA&A$$TRP

        MOV     U.TAST-2(R4),R0 ;GET AST BLOCK IF THERE IS ONE
        BEQ     10$             ;THERE ISN'T - JUMP
        BIC     #2,A.PRM+4(R0)  ;UNLOCK AST BLOCK IN CASE IT WAS LOCKED
                                ;BECAUSE OF TF.NOT

        .ENDC   ;T$$CCA&A$$TRP

10$:    MOV     4(R5),R0        ;GET STATUS WORD 3                              ;PW031
        ASSUME  S1.RST,TF.RST                                                   ;**-6
        ASSUME  S1.RAL,TF.RAL
        BIC     #^C<S3.RAL>,R0  ;CLEAR ALL BUT RAL FLAG
        BISB    I.FCN(R3),R0    ;OR SUBFUNCTIONS INTO MASK                      ;PW031
        ASSUME  TF.TMO,200                                                      ;PW031
        BMI     15$             ;TIME-OUT SPECIFIED - JUMP                      ;PW031
        CLRB    I.PRM+6(R3)     ;ELSE CLEAR TIME-OUT PERIOD                     ;PW031
15$:    MOVB    I.PRM+6(R3),U.TITI-2(R4) ;INITIALIZE TIMER                      ;PW031
        BIC     #^C<TF.RST!TF.RAL!TF.RNE>,R0                                    ;PW031
                                ;CLEAR ALL BUT RST, RAL AND RNE FLAGS           ;PW031
                                ;IN MASK                                        ;PW031
        BIC     #TF.RST!TF.RAL!TF.RNE!S1.CTO,@R5 ;CLEAR OLD FLAGS IN STATUS WORD; DD016
        BIS     R0,@R5          ;OR COMBINED MASK INTO STATUS WORD 1            ;**-5
        BIT     #U2.NEC,U.CW2-U.TSTA(R5) ;LINE IN NO ECHO MODE?
        BEQ     17$             ;N - JUMP
        BIS     #S1.RNE,@R5     ;Y - SET RNE FLAG
17$:    BIT     #S1.RNE,(R5)+   ;ECHO REQUIRED?
        BNE     18$             ;N - JUMP
        ASSUME  S2.FDX,100000
        BIT     #S2.FLF!S2.FDX,@R5 ;FORCE LINE-FEED?
        BLE     18$             ;NO, OR LINE IN FULL DUPLEX MODE - JUMP
        MOV     #PRLF,-(SP)     ;OUTPUT LEADING LF BEFORE EXIT
18$:    BIS     #S1.IBY!S1.IBF,-(R5) ;SET INPUT BUSY
                                ;ASSUME BUFFERED INPUT
        MOVB    U.TCHP-U.TSTA(R5),U.TIHP-2(R4) ;SAVE INITIAL CURSOR POS.
        CMPB    I.FCN+1(R3),#IO.RTT/400 ;SPECIAL TERMINATORS FUNCTION?          ; DD005
        BNE     19$             ;N - JUMP                                       ; DD005
        MOV     U.TRTT-U.TIP(R4),R1 ;GET THE RTT TABLE ADDRESS                  ; DD005
        MOV     #16.,R0         ;COPY A 16 WORD TABLE                           ; DD005
185$:   MOV     I.PRM+10(R3),KISAR6 ;MAP USER'S TABLE                           ; DD005
        MOV     I.PRM+16(R3),R2 ;RETRIEVE AN ENTRY FROM HIS TABLE               ; DD005
        MOV     @R2,R2          ;                                               ; DD005
        MOV     PAR6S,KISAR6    ;MAP DRIVER TABLE                               ; DD005
        MOV     R2,(R1)+        ;COPY ENTRY                                     ; DD005
        ADD     #2,I.PRM+16(R3) ;POINT TO NEXT ENTRY                            ; DD005
        DEC     R0              ;DONE?                                          ; DD005
        BNE     185$            ;LOOP UNTIL ENTIRE TABLE HAS BEEN COPIED        ; DD005
19$:                                                                            ; DD005

        .IF DF  T$$RPR

        TST     @R3             ;DOING AN IO.RPR?
        BEQ     20$             ;N - JUMP
        CLR     @R3             ;Y - REINITIALIZE STATUS
        TST     I.PRM+16(R3)    ;DID THE PROMPT SUCCESSFULLY INITIALIZE
                                ;INTERMEDIATE BUFFERING?
        BEQ     UNBI            ;N - GO AND DO UNBUFFERED READ
        MOV     U.TFIB-U.TIP(R4),R2 ;Y - GET FIRST INPUT BUFFER
                                ;(ALLOCATED ALREADY BEFORE PROMPTING)
        BR      30$             ;DO BUFFERED READ

        .ENDC   ;T$$RPR

20$:    CALL    $TSTBF          ;TEST IF WE SHOULD DO BUFFERED READ
        BCS     UNBI            ;N - JUMP
        CALL    ALTB            ;GET A BUFFER
        BCS     UNBI            ;FAILED - DO UNBUFFERED INPUT
        MOV     R2,-(SP)        ;SAVE BUFFER ADDRESS                            ; PW026
        CALL    $INIBF          ;OK - INITIALIZE INTERMEDIATE BUFFERING
        MOV     (SP)+,R2        ;RESTORE BUFFER ADDRESS                         ; PW026
;
;
; SET UP FOR BUFFERED INPUT
;
.SBTTL  DO BUFFERED INPUT
;
30$:    ADD     #U.TTIC-U.TIP,R4 ;POINT TO U.TTIC
        MOV     R4,R1           ;COPY POINTER
        MOV     I.PRM+4(R3),(R1)+ ;SET UP MAXIMUM BYTE COUNT
        ASSUME  U.TFIB,U.TTIC+2
;
READ1:  MOV     R2,@R1          ;LINK FIRST BUFFER TO U.TFIB
;
;
;+
; NXTIB - GET NEXT INPUT BUFFER.
;
; INPUT:
;       R2      NEW INPUT BUFFER ADDRESS
;       R4      POINTER TO U.TTIC
;       U.TTIC  TOTAL REMAINING BYTE COUNT
;
; OUTPUT:
;       R4      POINTER TO U.TIC
;       NEW BUFFER LINKED TO OLD BUFFER.
;       SECOND WORD OF NEW BUFFER SET UP WITH LOGICAL BUFFER LENGTH.
;       U.TIP, U.TIP+2, U.TIC AND U.TTIC UPDATED.
;       CC-Z    0 IF INPUT BYTE COUNT NOT YET EXHAUSTED
;               1 ELSE
;
; REGISTERS ALTERED: R2,R3,R4
;
; NOTE - THIS ROUTINE IS CALLED AT DEVICE PRIORITY FROM THE
; INPUT ISR.
;-
;
;
NXTIB:: TST     (R2)+           ;POINT TO SECOND WORD OF BUFFER
        MOV     #T$$BFL-4,@R2   ;SET LOGICAL LENGTH OF BUFFER
        SUB     @R2,@R4         ;ADJUST U.TTIC
        BPL     10$             ;STILL .GE. 0 - JUMP
        ADD     @R4,@R2         ;WENT BELOW ZERO - ADJUST LOG. BUFFER LENGTH
        CLR     @R4             ;U.TTIC <-- 0
        ASSUME  U.TIP,U.TTIC-6
10$:    CMP     -(R4),-(R4)     ;POINT TO U.TIP+2
        CMP     -(R4),-(R2)     ;POINT R4 TO U.TIP
                                ;POINT R2 TO START OF BUFFER
;
;
;
;+
; UPUB - UPDATE PARAMETERS IN UCBX FOR BUFFERED INPUT OR OUTPUT.
;
; INPUT:
;       R2      BUFFER ADDRESS
;               LOGICAL BUFFER LENGTH STORED IN 2(R2)
;       R4      POINTER TO U.TIP (INPUT) OR U.TOP (OUTPUT) IN UCBX
;
; OUTPUT:
;       R2      POINTER TO SECOND WORD OF BUFFER
;       R4      POINTER TO U.TIC/U.TOC
;       U.TIP, U.TIP+2, U.TIC (OR U.TOP, U.TOP+2, U.TOC)
;       UPDATED FOR NEXT PARTIAL TRANSFER.
;       CC-Z    0 IF THERE IS MORE WORK TO DO
;               1 IF NOT
;
; REGISTERS ALTERED: R2,R4
;
; NOTE - THIS ROUTINE IS CALLED IN THREE SITUATIONS:
;       1. AT PRIORITY 0 TO START INPUT
;       2. AT DEVICE PRIORITY TO START OUTPUT
;       3. AT DEVICE PRIORITY FROM OUTPUT OR INPUT ISR TO SWITCH
;          FROM THE CURRENT PARTIAL BUFFER TO THE NEXT.
;-
;
;
UPUB::  MOV     R2,(R4)+        ;U.TIP+0/U.TOP+0 <-- BUFFER ADDRESS
        CMP     (R2)+,(R2)+     ;SKIP OVER LINK AND LENGTH WORDS
        MOV     R2,(R4)+        ;U.TIP+2/U.TOP+2 <-- START OF DATA IN BUFFER
        MOV     -(R2),@R4       ;U.TIC/U.TOC <-- BYTE COUNT FOR THIS
                                ;(POSSIBLY PARTIAL) TRANSFER
        RETURN
.PAGE
.SBTTL  DO UNBUFFERED INPUT
;
UNBI:   CLR     I.PRM+16(R3)    ;USE $IOFIN AT END
        BIC     #S1.IBF,@R5     ;SHOW UNBUFFERED INPUT
        ASSUME  U.TIP,<U.TCI+2>
;
;
;+
; UPUNB - UPDATE UCB FOR NON-BUFFERED INPUT.
;
; INPUT:
;       R3      POINTER TO IO PACKET
;       R4      POINTER TO U.TIP
;
; OUTPUT:
;       R4      POINTER TO U.TTIC
;       U.TIP, U.TIP+2, U.TIC, U.TTIC UPDATED FOR NON-BUFFERED INPUT.
;
; REGISTERS ALTERED: R3,R4
;-
;
UPUNB:: ADD     #I.PRM,R3       ;POINT TO PARAMETERS IN PACKET
        MOV     (R3)+,(R4)+     ;U.TIP+0 <-- BUFFER ADDRESS (ADRS DOUBLE WORD)
        MOV     (R3)+,(R4)+     ;U.TIP+2 <-- 2.ND HALF OF ADDRESS DOUBLE WORD
        ASSUME  U.TIC,<U.TIP+4>
        MOV     (R3)+,(R4)+     ;U.TIC <-- BYTE COUNT
        ASSUME  U.TTIC,<U.TIC+2>
        CLR     @R4             ;U.TTIC <-- 0
        RETURN
;
;
;+
; NXTOB - GET NEXT OUTPUT BUFFER.
;
; INPUT:
;       R4      POINTER TO U.TOP+2
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF THERE IS ANOTHER OUTPUT BUFFER LINKED:
;       CC-Z    0
;       R4      POINTER TO U.TOC
;       U.TOP, U.TOP+2, U.TOC UPDATED FOR NEXT BUFFER.
;
;       IF NOTHING MORE TO OUTPUT:
;       CC-Z    1
;       R4      POINTER TO U.TOP
;
; REGISTERS ALTERED: R2,R4
;
; NOTE - THIS ROUTINE IS CALLED AT DEVICE PRIORITY FROM THE
; OUTPUT ISR.
;-
;
NXTOB:: .IF DF  S1.OBF

        BIT     #S1.OBF,@R5     ;;;BUFFERED OUTPUT?
        BEQ     10$             ;;;N - RETURN WITH CC-Z = 1

        .ENDC   ;S1.OBF

        MOV     -(R4),R2        ;;;GET START OF CURRENT BUFFER (U.TOP)
        BEQ     10$             ;;;THIS WAS AN ECHO - EXIT WITH CC-Z = 1
        MOV     @R2,R2          ;;;GET START OF NEXT BUFFER
        BEQ     10$             ;;;NONE - RETURN WITH CC-Z = 1
        MOVB    #5,U.TOTI-U.TOP(R4) ;;;SET UP OUTPUT TIMER
        BR      UPUB            ;;;GO AND UPDATE UCB
10$:    RETURN                  ;;;RETURN WITH CC-Z = 1
;
.PAGE
.SBTTL  FPIRD - INPUT REQUEST DONE
;+
; FPIRD - INPUT REQUEST DONE.
;       COME HERE IN ANY OF THE FOLLOWING SITUATIONS:
;       1. END OF LINE RECEIVED (OR HARD RECEIVE ERROR)
;       2. INTERMEDIATE BUFFER IS FULL
;       3. TASK BUFFER IS FULL (NON-BUFFERED SOLICITED INPUT)
;
;       THIS ROUTINE IS ENTERED FROM THE FORK DISPATCHER WITH:
;       R4      UCBX ADDRESS
;       R5      POINTER TO U.TSTA
;-
;
;
        .ENABL  LSB
;
        ASSUME  U.TCI,0
FPIRD:: MOV     (R4)+,R3        ;GET PACKET
        ASSUME  U.TIP,U.TCI+2
        MOV     (R4)+,R1        ;GET CURRENT BUFFER (IF BUFFERED INPUT)
        ASSUME  U.TIC,U.TIP+4
        TST     (R4)+           ;POINT TO U.TIC
        ASSUME  U.TTIC,U.TIC+2
        ADD     (R4)+,@R4       ;ADD U.TIC TO U.TTIC TO GET TOTAL
                                ;REMAINING BYTES TO READ
        BEQ     10$             ;NONE - BUFFER FULL, JUMP
        TST     @R3             ;STATUS ALREADY PRESENT?
        BNE     10$             ;Y - JUMP
;
; BUFFERED INPUT, CURRENT BUFFER FULL. TRY TO ALLOCATE ANOTHER BUFFER.
; NOTE - THE INPUT ISR HAS ALREADY CHECKED WHETHER THERE IS ANOTHER
; BUFFER ALLOCATED (THIS COULD BE THE CASE IF THE OPERATOR DID
; RUBOUT OR CTRL-U). IF THERE IS ANOTHER BUFFER ALLOCATED ALREADY,
; WE DON'T COME HERE.
;
        CALL    ALTB            ;GET ANOTHER INPUT BUFFER
        BCC     READ1           ;OK - LINK TO PREVIOUS BUFFER AND CONTINUE
                                ;INPUT
        BIT     #S1.USI,@R5     ;SOLICITED INPUT?
        BEQ     5$              ;Y - JUMP
;
; UNSOLICITED INPUT REQUIRES ANOTHER BUFFER, WHICH WE FAILED TO
; ALLOCATE. OUTPUT A BELL.
;
        CALLR   BELLL           ;OUTPUT A BELL WITH INTERRUPTS LOCKED
                                ;OUT AND THEN RETURN
;
; SOLICITED INPUT REQUIRES ANOTHER BUFFER, WHICH WE FAILED TO
; ALLOCATE. RETURN PARTIAL INPUT WITH STATUS IE.NOD.
;
5$:     MOV     #IE.NOD,@R3     ;SET ERROR STATUS
;
; INPUT COMPLETED
;
10$:    CLRB    U.TITI-U.TTIC(R4) ;CLEAR INPUT TIMER
        ASSUME  S1.IBF,100000
        TST     @R5             ;BUFFERED INPUT?
        BPL     20$             ;N - JUMP (MUST BE SOLICITED INPUT)
        MOV     @R1,R2          ;Y - GET NEXT BUFFER (IF THERE IS ONE)
        CALL    DELTB           ;DEALLOCATE ALL REMAINING BUFFERS
        CLR     @R1             ;THIS IS NOW LAST BUFFER
        BIT     #S1.USI,@R5     ;SOLICITED INPUT?
        BNE     80$             ;N - UNSOL. INPUT - JUMP
;
; SOLICITED INPUT COMPLETED
;
;       REGISTER SUMMARY:
;       R3      POINTER TO I/O PACKET
;       R4      POINTER TO U.TTIC
;       R5      POINTER TO U.TSTA
;
20$:    BIC     #S1.IBY!S1.RST!S1.RAL,@R5 ;SET INPUT FREE
        CLR     U.TCI-U.TTIC(R4) ;CLEAR PACKET POINTER (U.TCI)

        .IF DF  T$$RPR&T$$CTR

        CMPB    I.FCN+1(R3),#IO.RPR/400 ;WAS THIS AN IO.RPR?
        BNE     30$             ;N - JUMP
        MOV     U.TFPB-U.TTIC(R4),R2 ;Y - GET PROMPT BUFFER LIST                ;PW011
        CALL    DELTB           ;DEALLOCATE ALL PROMPT BUFFERS                  ;PW011
                                                                                ;**-2
        .ENDC   ;T$$RPR&T$$CTR

30$:    MOV     I.PRM+4(R3),R1  ;GET MAX BYTE COUNT
        SUB     (R4)+,R1        ;SUBTRACT REMAINING BYTES TO READ
                                ;YIELDING BYTES ACTUALLY READ

        .IF DF  DEBUG

        BPL     31$
        BPT
31$:

        .ENDC

        TST     @R3             ;STATUS ALREADY PRESENT?
        BNE     50$             ;Y - JUMP
        INC     @R3             ;BUFFER FULL - SET STATUS = IS.SUC

        .IF DF  T$$ESC

        BIT     #S1.ESC,@R5     ;IN THE MIDDLE OF AN ESCAPE SEQUENCE?
        BEQ     50$             ;N - ALL IS OK
        MOV     #IE.PES&377,@R3 ;Y - SET ERROR "PARTIAL ESCAPE SEQUENCE"
        BIC     #S1.ESC,@R5     ;GET OUT OF ESCAPE SEQUENCE MODE
        CLRB    U.TISV-U.TFIB(R4) ;CLEAR STATE VARIABLE

        .ENDC   ;T$$ESC

50$:    TST     @R5             ;BUFFERED INPUT?
        BPL     70$             ;N - JUMP
        ASSUME  U.TFIB,U.TTIC+2
        MOV     @R4,R4          ;GET FIRST INPUT BUFFER (U.TFIB)
        MOV     R4,I.PRM+12(R3) ;STORE POINTER IN PACKET FOR $FINBF
        MOV     KISAR5,I.PRM+14(R3) ;STORE MAPPING INFO FOR $FINBF              ;PW026
60$:    MOV     (R4)+,R2        ;GET LINK TO NEXT BUFFER, POINT TO BYTE COUNT
        MOV     #T$$BFL,@R4     ;SET TOTAL LENGTH OF BUFFER
        MOV     R2,R4           ;GET NEXT BUFFER
        BNE     60$             ;LOOP IF THERE IS ONE
70$:    BIT     #TF.XOF,I.FCN(R3) ;SEND XOFF AT INPUT COMPLETION?               ;PW031
        BEQ     75$             ;N - JUMP                                       ;PW031
        ASSUME  S2.FDX,100000                                                   ;PW031
        TST     2(R5)           ;FULL DUPLEX LINE?                              ;PW031
        BMI     75$             ;Y - IGNORE TF.XOF                              ;PW031
                                ;(TRANSMIT MAY BE BUSY)                         ;PW031
        MOV     R3,-(SP)        ;SAVE R3                                        ;PW031
        MOV     #ASXOFF,R3      ;POINT TO XOFF CHAR.                            ;PW031
        MOV     U.TUX-U.TSTA(R5),R4 ;GET UCBX                                   ;PW031
        CALL    ECHRL           ;"ECHO" XOFF WITH INTERRUPTS LOCKED OUT         ;PW031
        MOV     (SP)+,R3        ;RESTORE R3                                     ;PW031
75$:    JMP     DONE            ;DONE                                           ;PW031
;                                                                               ;**-1
;
; UNSOLICITED INPUT COMPLETED.
; ALLOCATE A CLI COMMAND BUFFER IN THE SYSTEM POOL.
; COPY ALL BUFFERS INTO CLI BUFFER, AND QUEUE IT TO THE CLI TASK.
; IF CONTINUATION LINES ARE TO FOLLOW (LAST CHARACTER OF THIS
; BUFFER IS A HYPHEN), SIMULATE A CTRL-C.
;
; WHEN WE COME HERE, STATUS IS SET UP AS FOLLOWS
; (IN SECOND WORD OF FIRST RECEIVE BUFFER):
;       <0      - ERROR                                                         ;PW009
;       0       - BUFFER FULL                                                   ;**-1
;       IS.SUC  - SUCCESS
;       IS.TMO  - TIME-OUT
;       >IS.TMO - CTRL-U COMPLETED                                              ;PW009
;
80$:    MOV     #M$$CRB-4+1,-(SP) ;GET MAX LENGTH OF CLI COMMAND                ;PW024
                                  ;PLUS 1 FOR TERMINATOR                        ;PW024
        SUB     (R4)+,@SP       ;GET NUMBER OF BYTES READ PLUS 1                ;PW024
        CMP     @R3,#IS.TMO     ;TIME-OUT?                                      ;**-2
        BEQ     135$            ;Y - JUMP
        CMPB    (R3)+,#IS.SUC   ;TEST STATUS                                    ;PW009
        BLO     140$            ;BUFFER FULL - JUMP                             ;PW009
        BLT     136$            ;ERROR - JUMP                                   ;PW009
        BGT     120$            ;CTRL-U COMPLETED - JUMP                        ;PW009
                                ;ELSE SUCCESS!                                  ;**-3
                                                                                ; DD018
        .IF DF  R$$MPL!M$$CLI                                                   ; DD018
                                                                                ; DD018
        TST     @U.CLI-U.TSTA(R5) ;IS CLI TCB POINTER NULL?                     ; DD018
        BEQ     140$            ;IF YES THEN IT ISN'T THERE                     ; DD018
                                                                                ; DD018
        .ENDC   ;R$$MPL!M$$CLI                                                  ; DD018
                                                                                ; DD018
        CMP     @SP,#1          ;ONE BYTE READ? (MUST BE A RETURN)              ; DD008
        BNE     85$             ;N - JUMP                                       ; DD008
        MOV     #4,R1           ;Y - ONLY ALLOCATE 4 BYTES FROM THE DSR         ; DD008
        CALL    $ALOCB          ;                                               ; DD008
        BCS     140$            ;FAILED - JUMP                                  ; DD008
        MOV     R0,R1           ;SAVE ADDRESS                                   ; DD008
        TST     (R0)+           ;SKIP PAST LINK WORD                            ; DD008
        MOV     R5,@R0          ;INSERT UCB ADDRESS                             ; DD008
        SUB     #U.TSTA-1,@R0   ;+1 TO INDICATE A SPECIAL MCR PACKET            ; DD008
        BR      115$            ;QUEUE THIS SHORT PACKET TO THE CLI             ; DD008
85$:                                                                            ; DD008
        MOV     #M$$CRB,R1      ;GET SIZE OF CLI BUFFER
        CALL    $ALOCB          ;ALLOCATE CLI BUFFER
        BCS     140$            ;FAILURE - JUMP
        MOVB    @R3,@U.TIP+2-U.TFIB(R4) ;STORE TERMINATOR IN BUFFER             ;PW024
        MOV     @SP,R2          ;GET TOTAL NUMBER OF CHARACTERS READ            ;PW024
                                ;PLUS TERMINATOR                                ;PW024
        MOV     R0,-(SP)        ;SAVE CLI COMMAND BUFFER ADDRESS                ;PW024
        TST     (R0)+           ;SKIP LINK WORD                                 ;PW024
        MOV     R5,@R0          ;INSERT UCB ADDRESS                             ;PW024
        SUB     #U.TSTA,(R0)+   ;                                               ;PW024
        MOV     @R4,R1          ;GET FIRST BUFFER (U.TFIB)                      ;PW024
90$:    MOV     (R1)+,-(SP)     ;SAVE LINK TO NEXT BUFFER                       ;**-15
        TST     (R1)+           ;SKIP SECOND WORD
        MOV     #T$$BFL-4,R3    ;GET MAX NUMBER OF BYTES IN BUFFER              ;PW024
        CMP     R3,R2           ;TOO MANY?                                      ;PW024
        BLE     100$            ;N - JUMP                                       ;PW024
        MOV     R2,R3           ;Y - ADJUST                                     ;PW024
100$:   SUB     R3,R2           ;GET NUMBER OF BYTES STILL TO GO                ;PW024
110$:   MOVB    (R1)+,(R0)+     ;COPY INTO CLI BUFFER                           ;PW024
        SOB     R3,110$         ;LOOP                                           ;PW024
112$:   MOV     (SP)+,R1        ;GET NEXT BUFFER                                ;**-9
        BNE     90$             ;THERE IS ONE - LOOP
                                ;(IF TOTAL BYTE COUNT IS EXHAUSTED,
                                ;THERE SHOULDN'T BE ONE)
        MOV     (SP)+,R1        ;GET CLI COMMAND BUFFER
        DEC     @SP             ;WAS THE INPUT LINE EMPTY?                      ;PW024
        BEQ     115$            ;Y - JUMP                                       ;PW024
        MOVB    -2(R0),@SP      ;N - SAVE LAST INPUT CHARACTER                  ;PW024
115$:   CALL    $QMCRL          ;QUEUE CLI COMMAND BUFFER                       ;PW024
                                                                                ; DD008
        .IF DF  R$$MPL                                                          ; DD008
                                                                                ; DD008
        CMPB    @SP,#'-         ;WAS LAST CHARACTER A HYPHEN?                   ;**-1
        BEQ     130$            ;Y - CONTINUATION LINES TO FOLLOW, JUMP
                                                                                ; DD008
        .ENDC   ;R$$MPL                                                         ; DD008
                                                                                ; DD008
120$:   TST     (SP)+           ;CLEAN STACK
        BIC     #S1.IBY!S1.USI,@R5 ;CLEAR UNSOL. INPUT FLAGS
        BISB    #FR.GRQ,U.TFRQ-U.TSTA(R5) ;TRY TO GET ANOTHER REQUEST PACKET    ;PW016
        CLR     U.TCI-U.TFIB(R4) ;CLEAR PACKET POINTER (U.TCI)
        MOV     @R4,R2          ;GET FIRST INPUT BUFFER
        CALLR   DELTB           ;DEALLOCATE ALL INPUT BUFFERS AND RETURN        ;PW016
;                                                                               ;**-2
; CLI COMMAND CONTINUATION EXPECTED
;
130$:   MOVB    #CH.CTC,@SP     ;GET CTRL-C CHARACTER
                                ;(OVERWRITE OLD WORD ON STACK)
        BR      150$            ;REQUEST POST-FORK PROCESSING OF CTRL-C
;
; ERROR DURING UNSOLICITED INPUT. THESE ERRORS ARE:
;       1. FAILURE TO ALLOCATE CLI COMMAND BUFFER
;       2. TIME-OUT
;       3. BUFFER FULL WITH NO TERMINATOR
; IN EITHER CASE, SIMULATE A CTRL-U.
;
135$:   BIT     #S1.OBY,@R5     ;OUTPUT BUSY?
        BNE     120$            ;Y - TIME-OUT WITH ECHO IN PROGRESS
                                ;THIS MUST BE A HARDWARE ERROR AND WE
                                ;CAN'T DO ANYTHING BUT GIVE UP
        BR      140$            ;                                               ;PW009
136$:   CMPB    -(R3),#IE.EOF   ;END-OF-FILE (CTRL-Z TYPED)?                    ;PW009
        BEQ     120$            ;Y - DON'T ECHO ^U (^Z ALREADY ECHOED)          ;PW009
140$:   MOVB    #CH.CTU,@SP     ;GET CTRL-U CHARACTER
                                ;(OVERWRITE OLD WORD ON STACK)
150$:                                                                           ;PW023
                                                                                ;PW023
        .IF DF  T$$MOD                                                          ;PW023
                                                                                ;PW023
        BITB    #US.DSB!US.CRW,U.STS-U.TSTA(R5)                                 ;PW023
                                ;LINE DISABLED OR WAITING FOR CARRIER?          ;PW023
        BNE     120$            ;Y - JUMP                                       ;PW023
                                                                                ;PW023
        .ENDC   ;T$$MOD                                                         ;PW023
                                                                                ;PW023
        MOVB    (SP)+,U.TECB-U.TFIB(R4) ;LOAD CHARACTER FOR POST-FORK           ;PW023
                                ;PROCESSING IN ECHO BUFFER                      ;**-1
        BISB    #FR.GRQ!FR.PFP,U.TFRQ-U.TSTA(R5)
                                ;TRY TO GET ANOTHER PACKET (FR.GRQ)
                                ;REQUEST POST-FORK PROCESSING (FR.PFP)
        RETURN                  ;RETURN
;
        .DSABL  LSB
.PAGE
;
NOBUF:  MOV     #IE.NOD&377,R0  ;ERROR - NO BUFFER AVAILABLE
        BR      FIN
SKIP:   MOV     #IS.SUC,R0      ;SUCCESS
FIN:    JMP     IOFIN
;
;
.SBTTL  PPWLB - PROCESS AN IO.WLB REQUEST
;
; INPUT:
;       R3      I/O PACKET ADDRESS
;               I.LNK = 0
;       R4      UCBX ADDRESS
;       R5      POINTER TO U.TSTA
;
;

        .ENABL  LSB

        .IF DF  T$$RPR

PPRPR:: MOV     R3,R2           ;COPY PACKET POINTER                            ;PW012
        ADD     #I.PRM+16,R2    ;POINT TO I.PRM+16                              ;PW012
        MOV     @R2,-(SP)       ;SAVE 2.ND WORD OF ADDRESS DOUBLE WORD          ;PW012
        MOV     -(R2),2(R2)     ;MOVE VFC/CURSOR-CONTROL TO I.PRM+16            ;PW012
        MOV     -(R2),2(R2)     ;MOVE BYTE COUNT TO I.PRM+14                    ;PW012
        MOV     (SP)+,@R2       ;MOVE 2.ND WORD OF ADW TO I.PRM+12              ;PW012
        INC     @R3             ;SET STATUS NON-ZERO TO INDICATE IO.RPR         ;**-1
                                ;(FOR EASIER CHECKING)
        CLR     U.TFOB(R4)      ;CLEAR POINTER TO FIRST OUTPUT BUFFER           ;PW011
        BR      10$             ;BYPASS TF.CCO CHECK                            ;PW011
                                                                                ;**-1
        .ENDC   ;T$$RPR

PPWLB::                                                                         ;PW012
                                                                                ;PW012
        .IF DF  T$$CUP                                                          ;PW012
                                                                                ;PW012
        MOV     I.PRM+10(R3),I.PRM+6(R3) ;MOVE VFC TO RIGHT PLACE               ;PW012
                                                                                ;PW012
        .ENDC   ;T$$CUP                                                         ;PW012
                                                                                ;PW012
        BIT     #TF.CCO,I.FCN(R3) ;CANCEL CTRL-O?                               ;**-11
        BEQ     15$             ;N - JUMP                                       ; DD015
10$:    BIC     #S1.CTO,@R5     ;Y - DO IT                                      ; DD015
15$:    BIT     #S1.CTO,@R5     ;OUTPUT STOPPED BY CTRL-O?                      ; DD015
                                ;(CAN ONLY HAPPEN IF TERM. IS ATTACHED)         ;**-3
        BNE     SKIP            ;Y - FINISH DIRECTLY
        CALL    ALTB            ;ALLOCATE AN INTERMEDIATE BUFFER
        BCS     NOBUF           ;FAILED - JUMP
        MOV     R3,U.TCO(R4)    ;U.TCO <-- PACKET ADDRESS
        MOVB    I.FCN(R3),R0    ;GET IO SUBFUNCTION CODE

        .IF DF  T$$RPR

        TST     @R3             ;PROMPT FOR IO.RPR?
        BEQ     20$             ;N - JUMP
        ASSUME  TF.WAL,TF.BIN*4
        ASL     R0              ;SHIFT SUBF. CODE LEFT 2 BITS
        ASL     R0
                                                                                ;PW010
        .IF DF  T$$CUP                                                          ;PW010
                                                                                ;PW010
        BIC     #TF.RCU,R0      ;CAN'T DO CURSOR RESTORE WITH IO.RPR            ;PW010
                                                                                ;PW010
        .ENDC   ;T$$CUP                                                         ;PW010
                                                                                ;PW010
        BIS     #S1.IBY,@R5     ;SET INPUT BUSY
        ADD     #10,R3          ;ADVANCE PACKET POINTER SO OFFSET I.PRM
                                ;FROM R3 POINTS AT PROMPT PARAMETERS
        MOV     R2,U.TFPB(R4)   ;SAVE POINTER TO FIRST PROMPT BUFFER            ;PW011

        .ENDC   ;T$$RPR

        ASSUME  S3.WAL,TF.WAL*400
        ASSUME  S3.RCU,TF.RCU*400                                               ;PW010
20$:    BIC     #^C<TF.WAL!TF.RCU>,R0                                           ;PW010
                                ;CLEAR ALL BUT WAL AND RCU SUBFUNCTIONS         ;PW010
        CMP     (R5)+,(R5)+     ;POINT TO STATUS WORD 3                         ;PW010
        BIC     #S3.WAL!S3.PCU!S3.RCU,@R5 ;CLEAR OLD FLAGS                      ;PW010
        BISB    R0,1(R5)        ;OR INTO STATUS WORD 3                          ;**-3
        MOV     R4,R1
        ADD     #U.TOC,R1       ;POINT TO U.TOC
        CLR     (R1)+           ;CLEAR U.TOC
        ASSUME  U.TTOC,U.TOC+2
        MOV     I.PRM+4(R3),(R1)+ ;U.TTOC <-- TOTAL BYTE COUNT
        ASSUME  U.TFOB,U.TTOC+2
        MOV     R2,@R1          ;LINK BUFFER TO LISTHEAD
;
; INTERPRETE AND SAVE VERTICAL FORMAT CONTROL
;
        BIC     #S2.CR,-(R5)    ;ASSUME NO TRAILING CR
                                                                                ;PW010
        .IF DF  T$$CUP                                                          ;PW010
                                                                                ;PW010
        TSTB    I.PRM+7(R3)     ;CURSOR POSITION SPECIFIED?                     ;PW010
        BEQ     25$             ;N - JUMP                                       ;PW010
        MOV     I.PRM+6(R3),U.TOC(R4) ;Y - SAVE CURSOR POS. IN U.TOC            ;PW010
        BIS     #S3.PCU,2(R5)   ;SET FLAG                                       ;PW010
        BR      50$             ;                                               ;PW010
                                                                                ;PW010
        .ENDC   ;T$$CUP                                                         ;PW010
                                                                                ;PW010
25$:    MOV     #VFCRT,R0       ;POINT TO RECOGNITION TABLE FOR VFC             ;PW010
30$:    TSTB    (R0)+           ;END OF TABLE?                                  ;**-1
        BMI     40$             ;Y - JUMP
        CMPB    -1(R0),I.PRM+6(R3) ;MATCH?
        BNE     30$             ;N - LOOP
40$:    SUB     #CHRT+1,R0      ;GET INDEX IN CHRD TABLE
        ASL     R0              ;MAKE WORD INDEX
        MOVB    CHRD(R0),U.TVFC(R4) ;STORE ENCODED VFC IN UCB
                                ;(SEE MODULE "TTDAT" FOR CODING)
        .IIF GT S2.CR-200 .ERROR ;S2.CR MUST BE IN LOW BYTE
        BISB    CHRD+1(R0),@R5  ;SAVE CR FLAG IN U.TSTA+2
50$:    TST     -(R5)           ;POINT TO STATUS WORD 1                         ;PW010
                                                                                ;**-1
        .IF DF  T$$RPR

        MOV     U.TCO(R4),R0    ;GET REAL PACKET POINTER
        MOV     SP,I.PRM+16(R0) ;ASSUME WE CAN BUFFER ALL OUTPUT IN
                                ;ONE LIST - MAKE I.PRM+16 NON-ZERO

        .IFF    ;T$$RPR

        MOV     SP,I.PRM+16(R3) ;ASSUME WE CAN BUFFER ALL OUTPUT IN
                                ;ONE LIST - MAKE I.PRM+16 NON-ZERO

        .ENDC   ;T$$RPR


        .DSABL  LSB

.PAGE
.SBTTL  WRITE1 - FILL OUTPUT BUFFERS
;+
; WRITE1 - FILL OUTPUT BUFFERS WITH OUTPUT DATA.
;
; INPUT:
;       U.TFOB  POINTER TO FIRST OUTPUT BUFFER
;       R3      POINTER TO PACKET
;               (ADVANCED 4 WORDS IF IO.RPR)
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;       U.TCHP  CURRENT HORIZONTAL POSITION
;       U.TCVP  CURRENT VERTICAL POSITION
;       U.TVFC  ENCODED VERTICAL FORMAT CONTROL
;-
;
;
WRITE1:

        .IF DF  T$$RPR

        ASSUME  U.TCHP&1,0
        ASSUME  U.TCVP,U.TCHP+1
        MOV     U.TCHP-U.TSTA(R5),-(SP) ;SAVE CURRENT HOR. AND VERT. POS.

        .ENDC

                                                                                ;PW010
        .IF DF  T$$CUP                                                          ;PW010
                                                                                ;PW010
;       SAVE CURRENT HORIZONTAL AND VERTICAL POSITION IN CASE                   ;PW010
;       CURSOR RESTORE IS REQUESTED.                                            ;PW010
;                                                                               ;PW010
        ASSUME  U.TSHP&1,0                                                      ;PW010
        ASSUME  U.TSVP,U.TSHP+1                                                 ;PW010
                                                                                ;PW010
        .IF DF  T$$RPR                                                          ;PW010
                                                                                ;PW010
        MOV     @SP,U.TSHP(R4)                                                  ;PW010
                                                                                ;PW010
        .IFF    ;T$$RPR                                                         ;PW010
                                                                                ;PW010
        MOV     U.TCHP-U.TSTA(R5),U.TSHP(R4)                                    ;PW010
                                                                                ;PW010
        .ENDC   ;T$$RPR                                                         ;PW010
                                                                                ;PW010
        .IFTF   ;T$$CUP                                                         ;PW010
                                                                                ;PW010
        MOV     U.TFOB(R4),R0   ;GET FIRST BUFFER IN R0
        MOV     #SETBUF,-(SP)   ;FIRST SET UP NEW BUFFER
                                                                                ;PW010
        .IFT    ;T$$CUP                                                         ;PW010
                                                                                ;PW010
        ASSUME  S3.PCU,100000                                                   ;PW010
        TST     4(R5)           ;CURSOR POS. REQUESTED?                         ;PW010
        BPL     5$              ;N - JUMP                                       ;PW010
        MOV     U.TOC(R4),R2    ;Y - GET CURSOR COORDINATES                     ;PW010
        SUB     #401,R2         ;ADJUST TO BASE 0                               ;PW010
        MOV     #CPOS,EXPCP     ;SET POINTER TO CURSOR POS. ROUTINE             ;PW010
        CALL    @(SP)+          ;CALL COROUTINE                                 ;PW010
        BIC     #S3.PCU,4(R5)   ;CLEAR FLAG                                     ;PW010
        BR      30$             ;                                               ;PW010
5$:                                                                             ;PW010
                                                                                ;PW010
        .ENDC   ;T$$CUP                                                         ;PW010
                                                                                ;PW010
;
; CHECK IF ANY LEADING LF'S SHOULD BE INSERTED
;
        MOVB    U.TVFC(R4),R2   ;GET VFC CHARACTER
        BEQ     30$             ;NO LEADING LF OR FF - JUMP
        BPL     20$             ;FF - JUMP
10$:    MOVB    #CH.LF,R2       ;ONE OR MORE LF'S
20$:    CALL    @(SP)+          ;INSERT
        INCB    U.TVFC(R4)      ;ANY MORE LF'S?
        BEQ     30$             ;N - JUMP
        BMI     10$             ;Y - LOOP
        CLRB    U.TVFC(R4)      ;JUST DID A FF - CLEAR
;
; INSERT CHARACTERS FROM TASK BUFFER
;
30$:    TST     U.TTOC(R4)      ;ANY MORE CHARACTERS FROM TASK BUFFER?
                                ;(THERE WON'T BE IF WE COME HERE FROM
                                ;"FPORD" TO OUTPUT A TRAILING CR)
        BEQ     50$             ;N - JUMP
40$:    MOV     I.PRM+2(R3),R2  ;GET POINTER IN TASK BUFFER
        MOV     I.PRM(R3),KISAR6 ;MAP TASK BUFFER
        MOVB    @R2,R2          ;GET NEXT CHARACTER
        MOV     PAR6S,KISAR6    ;RESTORE DRIVER MAPPING
        CALL    @(SP)+          ;INSERT CHARACTER
        INC     I.PRM+2(R3)     ;UPDATE POINTER IN TASK BUFFER
        DEC     U.TTOC(R4)      ;DECREMENT TOTAL BYTE COUNT
        BNE     40$             ;MORE TO DO - LOOP
;
; CHECK IF TRAILING CARRIAGE RETURN REQUIRED
;
50$:    BIT     #S2.CR,2(R5)    ;INSERT CR AT END?
        BEQ     60$             ;N - JUMP
        MOVB    #CH.CR,R2       ;Y - DO IT
        CALL    @(SP)+          ;
        BIC     #S2.CR,2(R5)    ;CLEAR CR FLAG
60$:
                                                                                ;PW010
        .IF DF  T$$CUP                                                          ;PW010
                                                                                ;PW010
        BIT     #S3.RCU,4(R5)   ;CURSOR RESTORE REQUESTED?                      ;PW010
        BEQ     65$             ;N - JUMP                                       ;PW010
        MOV     U.TSHP(R4),R2   ;Y - GET SAVED CURSOR POS.                      ;PW010
        MOV     #CPOS,EXPCP     ;SET POINTER TO CURSOR POS. ROUTINE             ;PW010
        CALL    @(SP)+          ;CALL COROUTINE                                 ;PW010
        BIC     #S3.RCU,4(R5)   ;CLEAR FLAG                                     ;PW010
65$:                                                                            ;PW010
                                                                                ;PW010
        .ENDC   ;T$$CUP                                                         ;PW010
                                                                                ;PW010

        .IF DF  T$$RPR

        MOV     U.TCO(R4),R3    ;RESTORE REAL PACKET POINTER

        .ENDC   ;T$$RPR

        TST     I.PRM+16(R3)    ;DID WE MANAGE TO BUFFER ALL THE DATA
                                ;IN ONE BUFFER LIST?
        BEQ     WRITE2          ;N - JUMP
        CALL    $TSTBF          ;Y - TEST IF TASK CAN BE CHECKPOINTED
        BCS     CLR16           ;N - JUMP

        .IF DF  T$$RPR&T$$CTR

        TST     @R3             ;IS THIS AN IO.RPR?
        BEQ     70$             ;N - JUMP
        CALL    ALTB            ;Y - ALLOCATE FIRST INPUT BUFFER
        BCS     CLR16           ;FAILED - JUMP
        MOV     R2,U.TFIB(R4)   ;OK - SAVE BUFFER POINTER

        .ENDC   ;T$$RPR$T$$CTR

70$:    CALL    $INIBF          ;INITIALIZE INTERM. BUFFERING
        BR      WRITE2          ;START OUTPUT
CLR16:  CLR     I.PRM+16(R3)    ;USE $IOFIN AT END
WRITE2:

        .IF DF  T$$RPR

        CLR     @R3             ;INITIALIZE STATUS
        CMP     (SP)+,(SP)+     ;CLEAN STACK

        .IFF    ;T$$RPR

        TST     (SP)+           ;CLEAN STACK

        .ENDC   ;T$$RPR

        MOV     #STAXL,-(SP)    ;START OUTPUT OF BUFFER LIST
        BR      LOCKI           ;
;
; OUTPUT LEADING LF FOR SOLICITED INPUT AT LEFT MARGIN
;
PRLF:   MOV     U.TUX-U.TSTA(R5),R4 ;GET UCBX
        CALL    EXCR1           ;EXPAND A CARRIAGE RETURN (YIELDING LF!)
        MOV     #ECHSTR,-(SP)   ;OUTPUT LF
;
;
;+
; LOCKI - LOCK OUT INTERRUPTS.
;       THIS IS A COROUTINE THAT WORKS AS FOLLOWS:
;       1. RAISE PRIORITY TO LOCK OUT INTERRUPTS
;       2. CALL CALLER (OR CALL ROUTINE WHOSE ADDRESS
;          IS ON TOP OF STACK)
;       3. DROP PRIORITY
;       4. RETURN
;-
;
;
LOCKI:: MTPS    #TTPRI          ;LOCK OUT INTERRUPTS
        CALL    @(SP)+          ;;;CALL COROUTINE
        MTPS    #0              ;;;ALLOW INTERRUPTS
        RETURN                  ;RETURN
;
;
; JUMP AIDS
;
JWRIT1: BR      WRITE1
.PAGE
.SBTTL  INSERT - INSERT (EXPANSION OF) CHARACTER IN OUTPUT BUFFER.
;+
; INSERT - INSERT (THE EXPANSION OF) ONE CHARACTER IN THE
; CURRENT OUTPUT BUFFER.
;
; INPUT:
;       R0      CURRENT POINTER IN OUTPUT BUFFER
;       R1      POINTER TO SECOND WORD IN CURRENT OUTPUT BUFFER
;       R2      CHARACTER TO INSERT
;       R4      POINTER TO UCBX
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       1. IF (THE EXPANSION OF) THE CHARACTER FITS IN THE CURRENT BUFFER,
;       OR IF IT DOES NOT BUT ANOTHER BUFFER IS SUCCESSFULLY ALLOCATED
;       AND LINKED TO THE OLD BUFFER, THE CHARACTER IS INSERTED
;       AND THE CALLER IS CALLED BACK AS A COROUTINE WITH:
;       R0      UPDATED
;       R1      POINTER TO SECOND WORD IN CURRENT BUFFER
;               (MAY BE A NEW BUFFER)
;       R2      DESTROYED
;       R3-R5   UNCHANGED
;       THE CALLER MAY NOW LOAD ANOTHER CHARACTER IN R2 AND
;       HAVE IT INSERTED BY A "CALL @(SP)+" INSTRUCTION.
;
;       2. ELSE, IF THIS IS THE PROMPT FOR AN IO.RPR, THE HORIZONTAL
;       AND VERTICAL POSITION AND THE WRAP-AROUND CONTEXT
;       IS RESTORED, AND THE ERROR IE.NOD IS RETURNED TO
;       THE TASK. (NO RETURN TO CALLER).
;
;       3. ELSE, OUTPUT IS STARTED WITH THE CURRENT LIST OF BUFFERS.
;       (NO RETURN TO CALLER).
;-
;
;
        .ENABL  LSB
;
INSERT: MOV     R3,-(SP)        ;SAVE R3
10$:    CLR     -(SP)           ;CLEAR FLAG
        MOV     R2,-(SP)        ;SAVE CHARACTER
        ASSUME  U.TCHP&1,0
        ASSUME  U.TCVP,U.TCHP+1
        MOV     U.TCHP-U.TSTA(R5),-(SP) ;SAVE CURRENT POSITION
        MOV     2(R5),-(SP)     ;SAVE WRAP-AROUND CONTEXT
                                ;(IF EXPANDED STRING DOES NOT FIT)
        BIC     #S2.FLF,2(R5)   ;CLEAR FORCE-LF FLAG (LF IS FORCED ONLY
                                ;ON ECHO, NOT ON TASK OUTPUT)
                                                                                ;PW010
        .IF DF  T$$CUP                                                          ;PW010
                                                                                ;PW010
        CALL    @EXPCP          ;EXPAND CHAR. OR CURSOR POS. COMMAND            ;PW010
                                                                                ;PW010
        .IFF    ;T$$CUP                                                         ;PW010
                                                                                ;PW010
        CALL    EXPC3           ;EXPAND CHARACTER                               ;PW010
                                                                                ;PW010
        .ENDC   ;T$$CUP                                                         ;PW010
                                                                                ;PW010
        BEQ     30$             ;SINGLE CHARACTER EXPANSION - JUMP              ;**-3
        ROL     6(SP)           ;SAVE CC-C
        ADD     R2,@R1          ;UPDATE BUFFER BYTE COUNT
        CMP     @R1,#T$$BFL-4   ;DOES STRING FIT?
        BHI     70$             ;N - JUMP
20$:    MOVB    (R3)+,(R0)+     ;COPY STRING INTO BUFFER
        SOB     R2,20$          ;LOOP
        BR      40$
30$:    CMP     @R1,#T$$BFL-4   ;ROOM FOR ONE MORE CHAR. IN BUFFER?
        BHIS    80$             ;N - JUMP
        MOVB    R2,(R0)+        ;Y - INSERT CHARACTER
        INC     @R1             ;UPDATE BYTE COUNT
40$:    CMP     (SP)+,(SP)+     ;POP SAVED POSITION AND WRAP-AROUND CONTEXT
        MOV     (SP)+,R2        ;RESTORE CHARACTER
        ROR     (SP)+           ;NEED TO CALL EXPCHR AGAIN WITH THIS CHARACTER?
        BCS     10$             ;Y - LOOP
        MOV     (SP)+,R3        ;N - RESTORE R3
        CALL    @(SP)+          ;CALL CALLER BACK
        BR      INSERT          ;DO IT AGAIN
;
; CHARACTER EXPANSION DOES NOT FIT IN BUFFER.
; RESTORE CURRENT HORIZONTAL AND VERTICAL POSITION AND STATE VARIABLE.
;
70$:    SUB     R2,@R1          ;RESTORE BUFFER BYTE COUNT
80$:    MOV     (SP)+,2(R5)     ;RESTORE STATUS WORD 2
                                ;NOTE - THIS WORD IS MODIFIED ONLY AT
                                ;SYSTEM STATE, OR FOR CHARACTER ECHOING.
                                ;ECHOING CAN NOT INTERRUPT US HERE BECAUSE
                                ;INPUT PROCESSING IS DISABLED BY S1.DSI.
        ASSUME  U.TCHP&1,0
        ASSUME  U.TCVP,U.TCHP+1
        MOV     (SP)+,U.TCHP-U.TSTA(R5) ;RESTORE CURRENT POSITION
;
; ALLOCATE ANOTHER OUTPUT BUFFER
;
        CALL    ALTB            ;ALLOCATE ANOTHER BUFFER
        MOV     R2,R0           ;GET BUFFER ADDRESS (IF WE GOT ONE)
        MOV     (SP)+,R2        ;RESTORE CHARACTER
        MOV     R2,(SP)+        ;POP FLAG WORD (DON'T TOUCH CC-C)
        MOV     (SP)+,R3        ;RESTORE R3

        .IF DF  T$$RPR

        BCS     90$             ;FAILED - JUMP

        .IFF    ;T$$RPR

        BCS     CLR16           ;FAILED - CLEAR I.PRM+16 AND
                                ;START OUTPUT

        .ENDC   ;T$$RPR

        MOV     R0,-(R1)        ;LINK NEW BUFFER TO OLD
SETBUF: TST     (R0)+           ;POINT TO SECOND WORD
        MOV     R0,R1           ;SAVE POINTER IN R1
        CLR     (R0)+           ;INITIALIZE BYTE COUNT AND POINT
                                ;TO START OF DATA AREA
        BR      INSERT          ;START USING NEW BUFFER
;
; FAILED TO ALLOCATE BUFFER
;
        .IF DF  T$$RPR

90$:    MOV     U.TCO(R4),R3    ;GET REAL PACKET POINTER
        TST     @R3             ;IO.RPR?
        BEQ     CLR16           ;N - START PARTIAL OUTPUT
                                ;AFTER CLEARING I.PRM+16
        TST     (SP)+           ;POP RETURN ADDRESS
        ASSUME  U.TCHP&1,0
        ASSUME  U.TCVP,U.TCHP+1
        MOV     (SP)+,U.TCHP-U.TSTA(R5) ;RESTORE CURRENT POSITION
        BIC     #S2.WRA,2(R5)   ;CLEAR WRAP-AROUND CONTEXT
        MOV     #IE.NOD&377,@R3 ;GET STATUS FOR "NO BUFFER AVAILABLE"
        CLR     I.PRM+16(R3)    ;USE $IOFIN
                                ;FALL THRU TO "FPORD" TO FINISH REQUEST

        .ENDC   ;T$$RPR

        .DSABL  LSB
.PAGE
.SBTTL  FPORD - OUTPUT REQUEST DONE
;+
; FPORD - OUTPUT REQUEST DONE.
;       COME HERE WHEN ALL OUTPUT BUFFERS HAVE BEEN OUTPUT.
;       TRANSFER MAY OR MAY NOT BE COMPLETED - IF IT IS,
;       STATUS IS STORED IN THE LINK WORD OF THE IO PACKET.
;
;       THIS ROUTINE IS ENTERED FROM THE FORK DISPATCHER WITH:
;       R4      UCBX ADDRESS
;       R5      POINTER TO U.TSTA
;-
;
;
        .ENABL  LSB
;
FPORD:: MOV     U.TCO(R4),R3    ;GET I/O PACKET
        TST     @R3             ;STATUS PRESENT?
        BNE     ORD2            ;Y - JUMP
        TST     U.TTOC(R4)      ;ALL DONE?
        BNE     JWRIT1          ;N - MORE TO DO, JUMP
                                ;NOTE - THIS CANNOT HAPPEN WHEN DOING IO.RPR!
        BIT     #S2.CR,2(R5)    ;TRAILING CR REQUIRED?
        BNE     JWRIT1          ;Y - JUMP
        INC     @R3             ;SET STATUS = IS.SUC
;
; OUTPUT DONE.
;
ORD2:   CLR     U.TCO(R4)       ;CLEAR POINTER TO PACKET TO SHOW
                                ;NOT DOING TASK OUTPUT ANY MORE
        BIC     #S1.OBY,@R5     ;SET OUTPUT FREE

        .IF DF  T$$RPR

        CMPB    I.FCN+1(R3),#IO.RPR/400 ;WAS THIS THE PROMPT FOR AN IO.RPR?
        BNE     20$             ;N - JUMP
        TSTB    @R3             ;HAVE AN ERROR ALREADY?
        BMI     15$             ;Y - JUMP

        .IF NDF T$$CTR

        MOV     U.TFOB(R4),U.TFIB(R4) ;USE PROMPT BUFFER LIST FOR INPUT

        .ENDC   ;NOT T$$CTR

        BISB    #FR.GRQ,U.TFRQ-U.TSTA(R5) ;TRY ANOTHER PACKET WHEN INPUT        ;PW011
                                ;HAS BEEN STARTED (LINE MAY BE FULL DUPLEX)     ;PW011
        JMP     PPRLB           ;NOW DO THE READ
                                ;(LEAVE LINK WORD NON-ZERO TO INDICATE
                                ;DOING IO.RPR)
15$:    BIC     #S1.IBY,@R5     ;SET INPUT FREE

        .ENDC   ;T$$RPR

20$:    MOV     U.TFOB(R4),R2   ;GET FIRST OUTPUT BUFFER
        CALL    DELTB           ;DEALLOCATE ALL BUFFERS
        MOV     I.PRM+4(R3),R1  ;GET NUMBER OF BYTES REQUESTED
        SUB     U.TTOC(R4),R1   ;SUBTRACT U.TTOC
;
; IF A REQUEST IS ABORTED (BY TIME-OUT OR IO.KIL), WE RETURN THE
; NUMBER OF BYTES TRANSFERRED, INCLUDING THE CURRENT (PARTIAL)
; BUFFER. THERE IS NO WAY WE CAN FIND OUT HOW MANY BYTES FROM
; THE TASK'S BUFFER CORRESPOND TO THE NUMBER OF EXPANDED BYTES
; THAT WE SENT FROM THE CURRENT BUFFER.
;

        .IF DF  T$$BTW

        CMPB    I.PRI(R3),#251. ;WAS THIS AN IO.WBT?
        BNE     60$             ;N - JUMP
        ASSUME  S2.FDX,100000
        TST     2(R5)           ;FULL DUPLEX LINE?
        BMI     60$             ;Y - JUMP
        ASSUME  S1.IBY,200
        TSTB    @R5             ;INPUT BUSY?
        BPL     40$             ;N - JUMP
;
; WE JUST FINISHED AN IO.WBT THAT BROKE THROUGH AN INPUT ON A
; NON-FULL-DUPLEX LINE. FAKE A CTRL-R TO REDISPLAY THE CURRENT
; INPUT LINE.
;
; THERE CANNOT BE A FORK REQUEST PENDING FOR INPUT DONE (OR PARTIAL
; INPUT DONE) SINCE INPUT FORK REQUESTS ARE PROCESSED BEFORE OUTPUT
; FORK REQUESTS.
;
        MOVB    #CH.CTR,U.TECB(R4) ;PUT CTRL-R CHAR. IN ECHO BUFFER             ;**-9
        BISB    #FR.PFP,U.TFRQ-U.TSTA(R5)
                                ;REQUEST POST-FORK PROCESSING

        .IF DF  T$$ESC

;
; IF WE ARE IN THE MIDDLE OF AN ESCAPE SEQUENCE, WE MUST RUB IT OUT
; SINCE THE ESCAPE SEQUENCE AND CTRL-R ROUTINES SHARE U.TISV.
; FURTHERMORE, CTRL-R DOES NOT WORK IF S1.ESC IS SET.
;
        BIT     #S1.ESC,@R5     ;IN ESCAPE SEQUENCE?
        BEQ     60$             ;N - JUMP
        MOV     R3,-(SP)        ;SAVE R3
        CALL    RUBESC          ;Y - RUBOUT THE ESCAPE SEQUENCE
        MOV     (SP)+,R3        ;RESTORE R3

        .ENDC

        BR      60$             ;ALL DONE
;
; WE FINISHED AN IO.WBT ON A NON-FULL-DUPLEX LINE, AND DID NOT BREAK
; THROUGH A READ. IF NO MORE IO.WBT REQUESTS ARE WAITING IN THE QUEUE,
; RESTORE CTRL-S AND CTRL-O FLAGS. ELSE, PASS THE SAVED STATUS
; OVER TO THE NEXT IO.WBT PACKET IN THE QUEUE.
;
40$:    MOV     I.PRM+12(R3),-(SP) ;GET SAVED STATUS
        MOV     R5,R0           ;COPY U.TSTA ADDRESS                            ; DD017
        SUB     #U.TSTA,R0      ;GET UCB ADDRESS                                ; DD017
        MOV     U.SCB(R0),R4    ;GET POINTER TO SCB                             ; DD017
45$:    MOV     @R4,R4          ;GET NEXT PACKET IN QUEUE                       ; DD017
        BEQ     50$             ;NONE - JUMP                                    ;**-1
        CMP     I.UCB(R4),R0    ;IS THAT PACKET FOR THIS UCB?                   ; DD017
        BNE     45$             ;N - SKIP THIS PACKET                           ; DD017
        CMPB    I.PRI(R4),#251. ;IS IT AN IO.WBT?
        BNE     50$             ;N - JUMP
        MOV     (SP)+,I.PRM+12(R4) ;Y - PASS SAVED STATUS OVER TO HIM
        BR      60$             ;
50$:    BIC     #^C<S1.CTO!S1.CTS>,@SP ;CLEAR ALL BUT CTRL-O AND CTRL-S
                                ;FLAGS IN SAVED STATUS
        BIS     (SP)+,@R5       ;RESTORE CTRL-O AND CTRL-S FLAGS

        .ENDC   ;T$$BTW

60$:    CLR     I.PRM+12(R3)    ;TELL $FINBF NO BUFFERS TO COPY OR DEALLOCATE
;
; FALL THRU TO "DONE"
;
        .DSABL  LSB
.PAGE
.SBTTL  I/O DONE
;+
; DONE - DO I/O COMPLETION PROCESSING.
;
; INPUT:
;       R1      IOSB WORD 2
;       R3      POINTER TO PACKET
;               I.LNK = IOSB WORD 1
;       R5      POINTER TO U.TSTA
;       I.PRM+16        0 IF $IOFIN TO BE USED,
;                       NON-0 IF $QUEBF TO BE USED
;
; OUTPUT:
;       I/O REQUEST FINISHED.
;
; REGISTERS ALTERED: R0,R1,R2,R3,R4
;-
;
;
DONE::  BISB    #FR.GRQ,U.TFRQ-U.TSTA(R5) ;TIME TO TRY TO GET ANOTHER PACKET
        MOV     @R3,R0          ;GET IOSB WORD 1
        TST     I.PRM+16(R3)    ;USE $QUEBF?
        BEQ     20$             ;N - JUMP
        CALLR   $QUEBF          ;FINISH IO
20$:    CALLR   $IOFIN          ;FINISH IO
;
;
        .END
        .TITLE  TTSUB
        .IDENT  /V01.18/
;
; 02-FEB-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW004   11-APR-78       PETER WANNHEDEN
;               MODIFY DEBUG CODE FOR BUFFER DEALLOCATION
;       PW010   14-APR-78       PETER WANNHEDEN
;               SUPPORT DEVICE-INDEPENDENT CURSOR POSITIONING.
;       PW026   05-MAY-78       PETER WANNHEDEN
;               USE SUBROUTINE MAPD TO MAP TT DRIVER DATA AREA.
;       DD005   06-OCT-78       DALE R. DONCHIN
;               ADD READ WITH TERMINATOR TABLE FUNCTION
;       DD009   08-NOV-78       DALE R. DONCHIN
;               FIX AND IMPROVE NOECHO HANDLING
;       DD015   28-FEB-79       DALE R. DONCHIN
;               ADD CLEAR SCREEN TO CURSOR POSITIONING.
;               SOFTWARE EMULATE DIVIDE FOR THOSE WITHOUT EIS
;       DD018   01-MAY-79       DALE R. DONCHIN
;               MAINTAIN CORRECT VERTICAL POSITION FOR CRT'S
;       DD020   16-MAY-79       DALE R. DONCHIN
;               DON'T INTERPRETE OUTPUT CHARACTER IF SIGN BIT IS SET
;
;
;+
; TTSUBR - MISCELLANEOUS SUBROUTINES FOR TERMINAL DRIVER.
;-
;
;
.SBTTL  ALUCBX - ALLOCATE A UCB EXTENSION BLOCK
;
;+
; ALUCBX - ALLOCATE A UCB EXTENSION (UCBX).
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF SUCCESS, OR IF UCBX ALREADY EXISTS:
;       CC-C    0
;       R4      POINTER TO UCBX
;       U.TUX   POINTS TO UCBX
;       UCBX INITIALIZED (ONLY IF UCBX WAS ALLOCATED)
;
;       IF FAILURE:
;       CC-C    1
;
; REGISTERS ALTERED: R0,R2,R4
;-
;
;
        .ENABL  LSB
;
        ASSUME  U.TUX,U.TSTA-2
ALUCBX::MOV     -(R5),R4        ;IS THERE ALREADY A UCBX?
        CLC                     ;ASSUME YES
        BNE     10$             ;Y - EXIT WITH CC-C = 0
        CALL    ALTB            ;N - ALLOCATE A BUFFER
        BCS     10$             ;FAILED - EXIT WITH CC-C = 1
        MOV     R2,@R5          ;SAVE POINTER
;
; INITIALIZE A FEW CELLS
;
        ASSUME  U.TCI,0
                                ;U.TCI ALREADY CLEARED BY ALTB
        CLR     U.TCO(R2)       ;NO CURRENT OUTPUT REQUEST
        CLR     U.TAST(R2)      ;NO AST BLOCK
        CLRB    U.TISV(R2)      ;INITIALIZE STATE VARIABLE
        ASSUME  U.TITI&1,0
        ASSUME  U.TOTI,U.TITI+1
        CLR     U.TITI(R2)      ;CLEAR INPUT AND OUTPUT TIMERS
        CLR     U.TRTT(R2)      ;ASSUME NOT A RTT FUNCTION                      ; DD005
                                ;EXIT WITH CC-C = 0
10$:    MOV     (R5)+,R4        ;RESTORE R5 AND GET UCBX IN R4
                                ;(OR 0 IF COMING FROM DEUCBX)
20$:    RETURN                  ;RETURN
;
;
.SBTTL  DEUCBX - DEALLOCATE A UCB EXTENSION BLOCK
;
;+
; DEUCBX - DEALLOCATE UCBX IF POSSIBLE.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;
; OUTPUT:
;       IF LINE IS IDLE (BOTH INPUT AND OUTPUT), NOT ATTACHED
;       AND THERE ARE NO FORK REQUESTS PENDING,
;       THE UCBX (IF THERE IS ONE) IS DEALLOCATED.
;
; REGISTERS ALTERED: R0,R2,R4
;-
;
;
DEUCBX::MOV     -(R5),R0        ;GET UCBX                                       ; DD005
        BEQ     10$             ;NONE - EXIT                                    ; DD005
        MOV     U.TRTT(R0),R2   ;GET THE TERMINATOR TABLE ADDRESS               ; DD005
        BEQ     30$             ;BRANCH IF NONE                                 ; DD005
        BIT     #S1.RST,2(R5)   ;IS TABLE STILL IN USE?                         ; DD005
        BNE     30$             ;Y - DON'T DEALLOCATE IT JUST YET               ; DD005
        CLR     U.TRTT(R0)      ;CLEAR POINTER IN UCBX                          ; DD005
        CALL    DETB            ;DEALLOCATE THE TABLE                           ; DD005
30$:    MOV     (R5)+,R2        ;GET UCBX AGAIN                                 ; DD005
        MOV     @R5,-(SP)       ;GET STATUS WORD 1                              ; DD005
        BIC     #^C<S1.IBY!S1.OBY>,@SP ;CLEAR ALL BUT INPUT AND                 ;**-1
                                ;OUTPUT BUSY FLAGS
        BISB    U.TFRQ-U.TSTA(R5),@SP ;OR WITH FORK REQUEST FLAGS
        BIS     U.ATT-U.TSTA(R5),(SP)+ ;OR WITH ATTACH POINTER
        BNE     20$             ;IF NE DON'T DEALLOCATE
        CLR     -2(R5)          ;OK - CLEAR POINTER                             ; DD005
                                ;FALL THRU TO "DETB"                            ;**-3
;
        .DSABL  LSB
;
;
.SBTTL  DEALLOCATE A TERMINAL BUFFER
;
;+
; DETB - DEALLOCATE TERMINAL BUFFER.
;
; INPUT:
;       R2      BUFFER ADDRESS
;
; OUTPUT:
;       BUFFER DEALLOCATED TO TT-DRIVER POOL OR SYSTEM POOL.
;
; REGISTERS ALTERED: R0,R2
;-
;
;
DETB::  CMP     R2,#120000      ;IN TT-DRIVER POOL?
        BLO     10$             ;N - JUMP
        MOV     FREEB,@R2       ;Y - ADD TO FRONT OF FREE BUFFER LIST
        MOV     R2,FREEB
        RETURN
10$:    MOV     R1,-(SP)        ;SAVE R1,R3
        MOV     R3,-(SP)
        MOV     R2,R0           ;GET BUFFER ADDRESS
        MOV     #T$$BFL,R1      ;GET LENGTH
        CALL    $DEACB          ;DEALLOCATE TO SYSTEM POOL
        MOV     (SP)+,R3        ;RESTORE REG'S
        MOV     (SP)+,R1
        RETURN
;
;
;+
; DELTB0 - DRIVER ENTRY POINT TO DEALLOCATE INTERMEDIATE BUFFERS
; FOR INPUT REQUEST. CALLED FROM $FINBF.
;
; INPUT:
;       R0      POINTER TO FIRST INPUT BUFFER
;-
;
;
DELTB0::CALL    MAPD            ;MAP DATA AREA                                  ;PW026
        MOV     R0,R2           ;GET FIRST BUFFER                               ;**-1
                                ;FALL THRU TO "DELTB1"
;
;
.SBTTL  DELTB - DEALLOCATE A LINKED LIST OF TERMINAL BUFFERS
;
;+
; DELTB - DEALLOCATE A LIST OF TERMINAL BUFFERS.
;
; INPUT:
;       R2      ADDRESS OF FIRST BUFFER IN LIST, OR 0
;       CC-Z    0 IF R2 POINTS TO A BUFFER
;
; OUTPUT:
;       BUFFER POINTED TO BY R2 AND ALL FOLLOWING BUFFERS DEALLOCATED.
;
; REGISTERS ALTERED: R0,R2
;-
;
;
        .ENABL  LSB

10$:    MOV     @R2,-(SP)       ;SAVE LINK TO NEXT
        CALL    DETB            ;DEALLOCATE THIS BUFFER
        MOV     (SP)+,R2        ;GET NEXT BUFFER
DELTB:: BNE     10$             ;THERE IS ONE - LOOP
        RETURN

        .DSABL  LSB
;
;
.SBTTL  ALTB - ALLOCATE A TERMINAL BUFFER
;
;+
; ALTB - ALLOCATE TERMINAL BUFFER.
;
; INPUT:
;       NONE
;
; OUTPUT:
;       IF SUCCESS:
;       CC-C    0
;       R2      POINTER TO BUFFER WITH LENGTH T$$BFL BYTES.
;               FIRST WORD CLEARED.
;
;       IF FAILURE:
;       CC-C    1
;
; REGISTERS ALTERED: R0,R2
;-
;
;
ALTB::  MOV     FREEB,R2        ;GET FIRST FREE BUFFER
        BEQ     20$             ;NONE - JUMP

        .IF DF  DEBUG

        CMP     R2,#TTPOOL
        BLO     1$
        CMP     R2,POOLE                                                        ;PW004
        BLOS    2$                                                              ;**-1
1$:     BPT
2$:

        .ENDC

        MOV     @R2,FREEB       ;POINT TO NEXT FREE BUFFER
10$:    CLR     @R2             ;CLEAR LINK WORD
        RETURN
20$:    MOV     R1,-(SP)        ;SAVE R1
        MOV     #T$$BFL,R1      ;SET DESIRED LENGTH
        CALL    $ALOCB          ;ALLOCATE IN SYSTEM POOL
        MOV     (SP)+,R1        ;RESTORE R1
        MOV     R0,R2           ;GET BUFFER IN R2
        BCC     10$             ;OK - JUMP
        RETURN                  ;ELSE RETURN WITH CARRY SET
.PAGE
.SBTTL  CKTAB - CHECK FOR TYPE-AHEAD BUFFER ALLOCATION OR DEALLOCATION
;
;+
; CKTAB - CHECK WHETHER TYPE-AHEAD BUFFER SHOULD BE ALLOCATED
;       OR DEALLOCATED.
;
; INPUT:
;       R5      POINTER TO U.TSTA
;       S3.TAB  0 DEALLOCATE TYPE-AHEAD BUFFER IF ONE IS ALLOCATED
;                 (LOSING ALL CHARACTERS STORED IN IT)
;               1 ALLOCATE TYPE-AHEAD BUFFER IF NONE IS ALLOCATED
;                 (LOSING SINGLE CHARACTER IF THERE IS ONE)
;
; REGISTERS ALTERED: R0,R2
;-
;
;
CKTAB:: CALL    LOCKI           ;LOCK OUT INTERRUPTS
        MOV     U.TTAB-U.TSTA(R5),R2 ;;;GET TYPE-AHEAD BUFFER
        BEQ     10$             ;;;NONE - JUMP
        BIT     #1,R2           ;;;SINGLE-CHARACTER BUFFER?
        BNE     10$             ;;;Y - JUMP
;
; TYPE-AHEAD BUFFER EXISTS
;
        BIT     #S3.TAB,4(R5)   ;;;DEALLOCATE BUFFER?
        BNE     20$             ;;;N - JUMP
        CALL    DETB            ;;;Y - DO IT
        CLR     U.TTAB-U.TSTA(R5) ;;;SHOW NO BUFFER ANY MORE
        BR      20$             ;;;
;
; TYPE-AHEAD BUFFER DOES NOT EXIST
;
10$:    BIT     #S3.TAB,4(R5)   ;;;ALLOCATE BUFFER?
        BEQ     20$             ;;;N - JUMP
        CALL    ALTB            ;;;Y - DO IT
        BCS     20$             ;;;FAILED - JUMP
        MOV     R2,U.TTAB-U.TSTA(R5) ;;;SAVE POINTER TO BUFFER
        CLR     (R2)+           ;;;INITIALIZE HEADER
        MOV     #<T$$BFL-4>*400,@R2 ;;;
;
; ALL DONE
;
20$:    RETURN                  ;;;RETURN VIA COROUTINE THAT DROPS
                                ;;;PRIORITY
.PAGE
.SBTTL  EXPCHR - EXPAND AN OUTPUT CHARACTER
;
;+
; EXPCHR - THIS MODULE CONTAINS THE ROUTINES TO EXPAND CHARACTERS
;       INTO STRINGS ON OUTPUT AS REQUIRED.
;
;       THESE ROUTINES ARE CALLED BOTH AT SYSTEM STATE (WHEN SETTING
;       UP A WRITE REQUEST) AND FROM THE INPUT INTERRUPT SERVICE
;       ROUTINE (TO GENERATE AN ECHO). THEREFORE, THE MODULE MUST
;       BE REENTRANT.
;-
;
;
; EXPAND A CHARACTER
;
;+
; EXPCHR - EXPAND A CHARACTER.
;
; INPUT:
;       R2      CHARACTER
;       R5      POINTER TO U.TSTA
;       U.TCHP  CURRENT HORIZONTAL POSITION
;       U.TCVP  CURRENT VERTICAL POSITION
;       S2.FLF  1 IF LINE FEED MUST BE OUTPUT BEFORE NEXT ECHO
;
; OUTPUT:
;       IF THE EXPANSION IS A SINGLE CHARACTER:
;               CC-Z    1
;               R2      UNCHANGED
;       IF THE EXPANSION IS A STRING:
;               CC-Z    0
;               R2      LENGTH OF EXPANDED STRING
;               R3      POINTER TO EXPANDED STRING
;       IF CHARACTER SHOULD BE KEPT AND PRESENTED AGAIN ON
;       NEXT CALL TO EXPCHR (ONLY RELEVANT IF CC-Z = 0):
;               CC-C    1
;       IF CHARACTER SHOULD NOT BE PRESENTED AGAIN:
;               CC-C    0
;       ALWAYS:
;               U.TCHP  UPDATED TO POSITION AFTER STRING HAS BEEN OUTPUT
;               U.TCVP  UPDATED TO POSITION AFTER STRING HAS BEEN OUTPUT
;               S2.FLF  1 IF A CARRIAGE RETURN WAS RETURNED
;               0 ELSE
;
; REGISTERS ALTERED: R2,R3
;
; THE PROPER WAY TO USE EXPCHR IS TO FIRST SAVE THE CHARACTER,
; THEN CALL EXPCHR, THEN OUTPUT THE STRING DESCRIBED BY R2,R3.
; IF CC-C WAS SET ON RETURN FROM EXPCHR, ON THE NEXT CALL TO
; EXPCHR THE SAME CHARACTER MUST BE PRESENTED IN R2, OTHERWISE
; THE NEXT CHARACTER.
;-
;
;
        .ENABL  LSB
;
EXCR1:: MOVB    #CH.CR,R2       ;EXPAND A CARRIAGE RETURN
        BR      EXPCHR          ;                                               ;PW010
;                                                                               ;PW010
EXPC3:: BIT     #S3.WAL,4(R5)   ;WRITE PASS ALL?                                ;PW010
        BEQ     EXPCHR          ;N - JUMP                                       ;PW010
5$:     SEZ                     ;Y - EXIT WITH CC-Z = 1                         ; DD020
        RETURN                  ;                                               ;PW010
;
EXPCHR::TST     R2              ;IS HIGH-ORDER BIT SET?                         ; DD020
        BMI     5$              ;Y - TREAT AS WRITE-PASS-ALL                    ; DD020
        CLR     -(SP)           ;INITIALIZE FLAG TO 0 TO EXIT WITH:             ; DD020
                                ;       CC-C = 0 (DON'T KEEP CHAR)              ;**-1
                                ;       CC-Z = 1 (OUTPUT CHAR)
        MOVB    U.TCHP-U.TSTA(R5),@SP ;GET CURRENT HOR. POSITION
        TST     (R5)+           ;POINT TO U.TSTA+2
        MOVB    @R5,R3          ;GET CONTEXT FOR WRAP-AROUND
        BIC     #^C<S2.WRA>,R3  ;CLEAR IRRELEVANT BITS
        ASSUME  S2.WRA,6
        JMP     @OSDSP(R3)      ;DISPATCH
;
;
; DEFAULT CASE - NO SPECIAL THINGS IN PROGRESS
;
EXPC0:: BIT     #S2.FLF,@R5     ;FORCE A LINE FEED?
        BNE     20$             ;Y - JUMP
        CMPB    R2,#CH.CR       ;CARRIAGE RETURN?
        BHI     EXDEF           ;N - HIGHER, CAN'T BE IN RECOGNITION
                                ;TABLE - JUMP TO DEFAULT ROUTINE
        BEQ     EXCR            ;CARRIAGE RETURN - JUMP
        MOV     #EXCRT,R3       ;POINT TO START OF CHAR. RECOGNITION TABLE
                                ;FALL THRU TO "CHRDSP"
;
;
; DISPATCH ACCORDING TO CHARACTER
;
;+
; CHRDSP - DISPATCH ACCORDING TO CHARACTER.
;
; INPUT:
;       R2      CHARACTER
;       R3      START OF CHARACTER RECOGNITION TABLE
;
; OUTPUT:
;       JUMPS TO CHARACTER PROCESSING ROUTINE WITH R2 UNCHANGED.
;-
;
;
CHRDSP::TSTB    (R3)+           ;END OF TABLE?
        BEQ     10$             ;Y - JUMP
        CMPB    R2,-1(R3)       ;MATCH?
        BNE     CHRDSP          ;N - LOOP
10$:    SUB     #CHRT+1,R3      ;GET OFFSET FROM CHRT
        ASL     R3              ;MAKE WORD INDEX
        JMP     @CHRD(R3)       ;JUMP TO ROUTINE
.PAGE
;
; FORCE LINE FEED
;
20$:    CMPB    R2,#CH.LF       ;IS THE CHARACTER A LINE FEED?
        BEQ     EXLF            ;Y - JUMP
        BR      EXVT            ;N - NEED CHARACTER AGAIN
;
; DO THE LINE FEED FOR WRAP-AROUND
;
EXPC1:: ADD     #S2.WRB,@R5     ;NEXT TIME GO TO EXPC2 TO DO THE
                                ;CHARACTER ITSELF
        BR      EXVT            ;
;
;
; EXPAND FORM FEED IF NECESSARY
;
EXFF::  BIT     #S2.HFF,@R5     ;SIMULATE FORM FEEDS?
        BNE     130$            ;N - JUMP
;
; EXPAND VERTICAL TAB
;
EXVT::  COMB    1(SP)           ;WE NEED CHARACTER AGAIN, EXIT WITH:
                                ;       CC-C = 1 (KEEP CHAR)
                                ;       CC-Z = 0 (OUTPUT STRING)
;
;
; EXPAND LINE FEED
;
EXLF::  BIC     #S2.FLF,@R5     ;CLEAR FORCE-LF FLAG
        MOV     #ASLF,R3        ;POINT TO LF                                    ; DD018
        BIS     #400,@SP        ;EXIT WITH:
                                ;       CC-C = ? (NO CHANGE)
                                ;       CC-Z = 0 (OUTPUT STRING)
        INCB    U.TCVP-<U.TSTA+2>(R5) ;UPDATE CURRENT VERTICAL POS.
        CALL    140$            ;RESET POSITION IF CROSSED A PAGE LIMIT         ; DD018
        BHIS    25$             ;BRANCH IF CROSSED A PAGE LIMIT                 ; DD018
        CMPB    R2,#CH.FF       ;FORMFEED?                                      ; DD018
        BEQ     45$             ;Y - JUMP                                       ; DD018
        BR      30$             ;N - JUMP                                       ; DD018
25$:    CMPB    R2,#CH.FF       ;IS THE CHARACTER A FF?                         ; DD018
        BEQ     40$             ;Y - JUMP                                       ;**-5
30$:    CMPB    R2,#CH.VT       ;IS THIS A VT?
        BNE     50$             ;N - JUMP
        BITB    #7,U.TCVP-<U.TSTA+2>(R5) ;ARE WE AT A VERT. TAB STOP?
        BNE     45$             ;N - JUMP                                       ; DD018
40$:    BIC     #100000,@SP     ;Y - DON'T WANT CHAR. AGAIN, EXIT WITH:         ;**-1
                                ;       CC-C = 0 (DON'T KEEP)
                                ;       CC-Z = 0 (OUTPUT STRING)
45$:    BIT     #U2.CRT,U.CW2-<U.TSTA+2>(R5) ;CRT?                              ; DD018
        BEQ     50$             ;N - JUMP                                       ; DD018
        MOV     #4,R2           ;Y - ECHO 4 LF'S IN PLACE OF FF OR VT           ; DD018
        SUB     R2,R3           ;POINT TO FIRST OF 4 LINE FEEDS                 ; DD018
        MOVB    U.TCVP-<U.TSTA+2>(R5),-(SP) ;UPDATE VERTICAL POSITION           ; DD018
        ADD     #3,@SP          ;(ADD 3 SINCE 1 LF WAS ALREADY COUNTED)         ; DD018
        MOVB    (SP)+,U.TCVP-<U.TSTA+2>(R5) ;MUCH PAIN FOR ADD TO ODD ADRS      ; DD018
        CALL    140$            ;CORRECT POSITION IF CROSSED A PAGE LIMIT       ; DD018
        BIC     #100000,@SP     ;DON'T KEEP CHARACTER                           ; DD018
        BR      55$             ;JOIN UP WITH NON-CRT CODE                      ; DD018
50$:    MOV     #1,R2           ;ASSUME NO FILLERS REQUIRED                     ; DD018
55$:    BIT     #S2.VFL,@R5     ;VERTICAL FILL REQUIRED?                        ; DD018
        BEQ     130$            ;N - JUMP                                       ;**-3
        ADD     #NLFF,R2        ;Y - ADD NUMBER OF FILL CHARACTERS              ; DD018
        BR      130$            ;DON'T CHANGE HOR.POS. OR BYTE COUNT            ;**-1
;
;
; EXPAND BACKSPACE
;
EXBSP:: TSTB    @SP             ;AT LEFT MARGIN?
        BEQ     130$            ;Y - EXIT (DON'T CHANGE HOR. POS.)
        DECB    @SP             ;N - BACKSPACE
        BR      120$            ;EXIT
;
;
; CR AND LF FOR WRAP-AROUND HAVE BEEN DONE. DO THE CHARACTER ITSELF.
; NOTE - THE CHARACTER MUST BE EITHER A HORIZONTAL TAB OR A
; "NORMAL" CHARACTER, SINCE ONLY THOSE CAUSE WRAP-AROUND.
;
EXPC2:: BIC     #S2.WRA,@R5     ;CLEAR WRAP-AROUND CONTEXT
        CMPB    R2,#CH.HT       ;HORIZONTAL TAB?
        BNE     EXDEF           ;N - JUMP
;
;
; EXPAND HORIZONTAL TAB
;
EXHT::  MOV     @SP,R3          ;GET CURRENT HOR.POS.
        BIS     #7,@SP          ;POINT JUST BEFORE NEXT TAB STOP
        BIT     #S2.HHT,@R5     ;HARDWARE HOR. TAB PRESENT?
        BNE     60$             ;Y - JUMP
        MOV     R3,R2           ;GET CURRENT HOR. POS.
        SUB     @SP,R2          ;GET NUMBER OF SPACES NECESSARY
                                ;NEGATED AND OFF BY 1
        NEG     R2              ;MAKE POSITIVE
        INC     R2              ;ADJUST
        MOV     #ASHT,R3        ;POINT TO HTAB
        BIS     #400,@SP        ;OUTPUT IS A STRING, EXIT WITH:
                                ;       CC-C    0 (DON'T KEEP CHAR.)
                                ;       CC-Z    0 (OUTPUT STRING)
        BR      60$             ;CHECK FOR WRAP-AROUND
;
;
; EXPAND NORMAL CHARACTER
;
EXDEF:: BIT     #140,R2         ;NON-SPACING CHARACTER?
        BEQ     130$            ;Y - EXIT
60$:    CMPB    @SP,U.CW4-<U.TSTA+2>(R5) ;AT RIGHT MARGIN?
        BLO     110$            ;N - JUMP
        BIT     #S1.RNE,-2(R5)  ;NO-ECHO MODE?                                  ; DD009
        BNE     130$            ;Y - JUMP                                       ; DD009
        BIT     #S2.ACR,@R5     ;AUTO CR-LF WANTED?
        BEQ     130$            ;N - JUMP
        COMB    1(SP)           ;NEED CHARACTER AGAIN, EXIT WITH:
                                ;       CC-C = 1 (KEEP CHAR)
                                ;       CC-Z = 0 (OUTPUT STRING)
        ADD     #S2.WRB,@R5     ;SET STATE VARIABLE TO COME BACK AT EXPC1
                                ;TO DO THE LINE FEED
                                ;FIRST DO A CARRIAGE RETURN
;
;
; EXPAND A CARRIAGE RETURN
;
EXCR::  BIS     #400,@SP        ;EXIT WITH:
                                ;       CC-C = ? (NO CHANGE)
                                ;       CC-Z = 0 (OUTPUT STRING)
        ASSUME  S2.HFL,7*400
        MOVB    1(R5),R2        ;GET HOR. FILL REQUIREMENT
        BIC     #^C<S2.HFL/400>,R2 ;CLEAR OTHER BITS
        CMP     R2,#7           ;FILL FOR LA30S?
        BNE     70$             ;N - JUMP
        MOVB    @SP,R2          ;Y - GET CURRENT HOR.POS.
        ASR     R2              ;DIVIDE BY 8
        ASR     R2
        ASR     R2
        CMP     R2,#9.          ;WITHING TABLE RANGE?
        BLOS    65$             ;Y - JUMP
        MOV     #9.,R2          ;N - SET TO HIGHEST VALUE
65$:    MOVB    HORFT(R2),R2    ;GET FILL COUNT FROM TABLE
70$:    MOV     #ASCR,R3        ;POINT TO CR
        MOVB    #-1,@SP         ;INITIALIZE CURRENT HOR. POS.
                                ;BOTH BYTE COUNT AND HOR. POS.
                                ;WILL BE INCREMENTED ON EXIT
        BIS     #S2.FLF,@R5     ;FORCE A LINEFEED ON NEXT ECHO
;
;
100$:   INC     R2              ;INCR. BYTE COUNT
110$:   INCB    @SP             ;UPDATE HOR.POS.
120$:   MOVB    @SP,U.TCHP-<U.TSTA+2>(R5) ;STORE UPDATED HOR.POS.
130$:   TST     -(R5)           ;POINT TO U.TSTA
        CLRB    @SP             ;CLEAR LOW BYTE
        ROL     (SP)+           ;GET FLAGS TO GENERATE PROPER
                                ;CONDITION CODES
        RETURN                  ;
;
140$:   CMPB    U.TCVP-<U.TSTA+2>(R5),U.TLPP-<U.TSTA+2>(R5)                     ; DD018
                                ;CROSSED A PAGE LIMIT?                          ; DD018
        BLO     150$            ;N - RETURN                                     ; DD018
        CLRB    U.TCVP-<U.TSTA+2>(R5) ;Y - RESET TO 0                           ; DD018
        BIT     #U2.CRT,U.CW2-<U.TSTA+2>(R5) ;CRT?                              ; DD018
        BEQ     150$            ;N - RETURN                                     ; DD018
        MOVB    U.TLPP-<U.TSTA+2>(R5),U.TCVP-<U.TSTA+2>(R5)                     ; DD018
                                ;Y - CRT'S SCROLL, NOT ROLL                     ; DD018
        DECB    U.TCVP-<U.TSTA+2>(R5) ;CURSOR STAYS ON BOTTOM LINE              ; DD018
150$:   RETURN                                                                  ; DD018
;                                                                               ; DD018
        .DSABL  LSB
;
;
                                                                                ;PW010
        .IF DF  T$$CUP                                                          ;PW010
                                                                                ;PW010
.PAGE                                                                           ;PW010
.SBTTL  CPOS - SUBROUTINE TO EXPAND CURSOR POSITIONING COMMAND
;                                                                               ;PW010
;+                                                                              ;PW010
; CPOS - EXPAND CURSOR COORDINATES TO CURSOR POSITIONING COMMAND                ;PW010
;       SUITABLE FOR THE TERMINAL TYPE.                                         ;PW010
;                                                                               ;PW010
; INPUT:                                                                        ;PW010
;       R2      LOW BYTE: COLUMN NUMBER (STARTING AT 1)                         ;PW010
;               HIGH BYTE: LINE NUMBER (STARTING AT 1)                          ;PW010
;       R5      POINTER TO U.TSTA                                               ;PW010
;                                                                               ;PW010
; OUTPUT:                                                                       ;PW010
;       R2      LENGTH OF CURSOR POSITIONING COMMAND                            ;PW010
;       R3      POINTER TO CURSOR POSITIONING COMMAND                           ;PW010
;       CC-C    0                                                               ;PW010
;       CC-Z    0                                                               ;PW010
;                                                                               ;PW010
; REGISTERS ALTERED: R2,R3                                                      ;PW010
;-                                                                              ;PW010
;                                                                               ;PW010
;                                                                               ;PW010
CPOS::  MOV     #EXPC3,EXPCP    ;RESTORE POINTER TO EXPC3                       ;PW010
;                                                                               ;PW010
;       USE U.TTYP TO DETERMINE HOW TO EXPAND COMMAND.                          ;PW010
;                                                                               ;PW010
        MOVB    U.TTYP-U.TSTA(R5),R3 ;GET TERMINAL TYPE                         ;PW010
        BEQ     CPOS0           ;NOT RECOGNIZED - JUMP                          ;PW010
        CMP     R3,#TTPHI       ;RECOGNIZED?                                    ;PW010
        BHI     CPOS0           ;N - JUMP                                       ;PW010
        MOVB    TTYP1-1(R3),R3  ;Y - GET CURSOR POS. TYPE IN BITS 6-7           ;PW010
        ASL     R3              ;SHIFT INTO BITS 9-10                           ;PW010
        ASL     R3              ;                                               ;PW010
        ASL     R3              ;                                               ;PW010
        SWAB    R3              ;GET IT IN BITS 1-2                             ;PW010
        BIC     #^C6,R3         ;CLEAR ALL OTHER BITS                           ;PW010
        BEQ     CPOS0           ;NO CURSOR POSITIONING IMPLEMENTED - JUMP       ;PW010
        MOV     R2,-(SP)        ;SAVE ORIGINAL COORDINATES                      ; DD015
        BIC     #100000,R2      ;CLEAR SCREEN CLEAR BIT                         ; DD015
        MOV     R2,U.TCHP-U.TSTA(R5) ;SET NEW CURSOR POSITION                   ;PW010
        JMP     @CPOST-2(R3)    ;JUMP VIA JUMP TABLE                            ;PW010
                                                                                ; DD015
        .ENABL  LSB                                                             ; DD015
                                                                                ; DD015
;                                                                               ;PW010
; TYPE 0 - CURSOR POSITIONING NOT IMPLEMENTED                                   ;PW010
;                                                                               ;PW010
CPOS0:  CLR     R2              ;EXPAND INTO A SINGLE NULL                      ;PW010
        RETURN                  ;RETURN WITH CC-C = 0, CC-Z = 1                 ;PW010
;                                                                               ;PW010
; TYPE 1 - VT05                                                                 ;PW010
;                                                                               ;PW010
CPOS1:: ADD     #401*40,R2      ;BIAS BOTH COORDINATES BY 40                    ;PW010
        MOVB    R2,CP1+20       ;STORE X COORD.                                 ; DD015
        SWAB    R2              ;GET Y COORD. AND CLEAR CC-C                    ;PW010
        MOVB    R2,CP1+13       ;STORE Y COORD.                                 ; DD015
        MOV     #7,R2           ;STRING LENGTH = 7                              ;PW010
        MOV     #CP1+12,R3      ;POINTER TO STRING                              ; DD015
        TST     (SP)+           ;CLEAR SCREEN REQUESTED?                        ; DD015
        CLZ                     ;(LEAVE CC-Z CLEAR)                             ; DD015
        BPL     3$              ;N  - RETURN                                    ; DD015
        SUB     #12,R3          ;POINT TO CLEAR SCREEN ESCAPE SEQUENCE          ; DD015
        ADD     #12,R2          ;ADD THAT TO CURSOR POSITION OUTPUT             ; DD015
3$:     RETURN                  ;RETURN                                         ; DD015
;                                                                               ;PW010
; TYPE 2 - VT52 AND VT50H                                                       ;PW010
;                                                                               ;PW010
CPOS2:: SWAB    R2              ;GET COLUMN IN HIGH BYTE, LINE IN LOW BYTE      ;PW010
        ADD     #401*40,R2      ;BIAS BOTH COORDINATES BY 40                    ;PW010
        MOV     #CP2+6,R3       ;POINT TO COMMAND STRING + 2                    ; DD015
        MOV     R2,@R3          ;STORE COORDINATES                              ;PW010
        TST     -(R3)           ;POINT TO START OF STRING AND CLEAR CC-C        ;PW010
        MOV     #4,R2           ;LENGTH = 4                                     ;PW010
        TST     (SP)+           ;CLEAR SCREEN REQUESTED?                        ; DD015
        CLZ                     ;(LEAVE CC-Z CLEAR)                             ; DD015
        BPL     3$              ;N - RETURN                                     ; DD015
        SUB     #4,R3           ;Y - POINT TO CLEAR SCREEN ESCAPE SEQUENCE      ; DD015
        BR      5$              ;FINISH IT OFF                                  ; DD015
;                                                                               ;PW010
; TYPE 3 - VT100                                                                ;PW010
;                                                                               ;PW010
CPOS3:: MOV     R0,-(SP)        ;SAVE R0, R1                                    ;PW010
        MOV     R1,-(SP)        ;                                               ;PW010
        MOV     #CP3A,R3        ;POINT AT FINAL CHARACTER                       ;PW010
        CALL    10$             ;EXPAND X-COORD. TO ASCII                       ;PW010
        MOVB    #';,-(R3)       ;INSERT DELIMITER                               ;PW010
        SWAB    R2              ;GET Y-COORD.                                   ;PW010
        CALL    10$             ;EXPAND IT                                      ;PW010
        MOV     (SP)+,R1        ;RESTORE R0, R1                                 ;PW010
        MOV     (SP)+,R0        ;                                               ;PW010
        MOVB    #'[,-(R3)       ;INSERT CONTROL SEQUENCE INTRODUCER             ;PW010
        MOVB    #CH.ESC,-(R3)   ; .. (BACKWARDS)                                ;PW010
        MOV     #CP3A+1,R2      ;                                               ;PW010
        SUB     R3,R2           ;GET STRING LENGTH AND CLEAR CC-C AND CC-Z      ;PW010
        TST     (SP)+           ;WAS CLEAR SCREEN REQUESTED?                    ; DD015
        CLZ                     ;(LEAVE CC-Z CLEAR)                             ; DD015
        BPL     3$              ;N - RETURN                                     ; DD015
        MOVB    #'J,-(R3)       ;INSERT...                                      ; DD015
        MOVB    #'2,-(R3)       ;...CLEAR SCREEN ESCAPE SEQUENCE...             ; DD015
        MOVB    #'[,-(R3)       ;...INTO OUTPUT STRING...                       ; DD015
        MOVB    #CH.ESC,-(R3)   ;...BACKWARDS                                   ; DD015
5$:     ADD     #4,R2           ;ADD THAT TO CURSOR POSITION OUTPUT             ; DD015
        RETURN                  ;RETURN                                         ; DD015
10$:    CLR     R1              ;                                               ;PW010
        BISB    R2,R1           ;GET NUMERIC VALUE                              ;PW010
        INC     R1              ;ADJUST TO BASE 1                               ;PW010
                                                                                ; DD015
        .IF DF  R$$EIS                                                          ; DD015
                                                                                ; DD015
20$:    CLR     R0              ;CLEAR HIGH ORDER DIVIDEND                      ;PW010
        DIV     #10.,R0         ;DIVIDE BY 10                                   ;PW010
                                                                                ; DD015
        .IFF    ;R$$EIS                                                         ; DD015
                                                                                ; DD015
20$:    MOV     R1,R0           ;GET DIVIDEND                                   ; DD015
        MOV     #10.,R1         ;GET DIVISOR                                    ; DD015
        CALL    $DIV            ;DIVIDE BY 10                                   ; DD015
                                                                                ; DD015
        .ENDC   ;R$$EIS                                                         ; DD015
                                                                                ; DD015
        BIS     #'0,R1          ;BIAS REMAINDER BY ASCII /0/                    ;PW010
        MOVB    R1,-(R3)        ;STORE IN STRING                                ;PW010
        MOV     R0,R1           ;GET QUOTIENT                                   ;PW010
        BNE     20$             ;NON-ZERO - DO IT AGAIN                         ;PW010
        RETURN                  ;RETURN                                         ;PW010
                                                                                ;PW010
        .ENDC   ;T$$CUP                                                         ;PW010
                                                                                ;PW010
        .DSABL  LSB                                                             ; DD015
                                                                                ; DD015
        .END
        .TITLE  TTTBL
        .IDENT  /V01.04/
;
; 08-MAY-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       CS013   25-MAY-78       CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD010   15-NOV-78       DALE R. DONCHIN
;               ADD SUPPORT FOR ONLINE RECONFIGURATION
;       DD018   01-MAY-79       DALE R. DONCHIN
;               CORRECT MAPPING WHEN DRIVER > 4K
;
;+
; THIS MODULE CONTAINS THE DRIVER DISPATCH TABLE.
; IN A SYSTEM THAT SUPPORTS KERNEL DATA SPACE, THIS MODULE MUST
; BE BUILT INTO THE TASK IMAGE "TTDRV".
; THIS IS IN CONTRAST TO ALL OTHER DRIVER DATA, WHICH IS CONTAINED
; IN THE MODULE "TTDAT" AND IS BUILT INTO THE TASK IMAGE "TTCOM".
;-
;
;
; DRIVER DISPATCH TABLE
;
        .WORD   DELTB0          ;ROUTINE TO DEALLOCATE BUFFERS
$TTTBL::.WORD   TTINI           ;REQUEST INITIATOR
        .WORD   TTCAN           ;CANCEL I/O
        .WORD   $NLTMO          ;TIME-OUT - USE SPECIAL NULL TIME-OUT ROUTINE
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
        .WORD   TTPWFL          ;POWERFAIL ENTRY POINT                          ; DD010
        .WORD   TTKRB           ;KRB STATUS CHANGE ENTRY POINT                  ; DD010
        .WORD   TTUCB           ;UCB STATUS CHANGE ENTRY POINT                  ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
        .WORD   TTPWUP          ;POWER-UP                                       ; DD010
                                                                                ; DD010
        .ENDC                                                                   ; DD010
                                                                                ; DD010
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        .IRP    X,<L,H,J,Z,M>                                                   ;**-1

        .IF DF  D$$'X'11

        .ASCII  /Y'X'/

        .IF IDN X,M

        .WORD   $DM11B

        .IFF

        .WORD   $Y'X'INP
        .WORD   $Y'X'OUT

        .ENDC

        .WORD   0
Y'X'CTBP::.WORD 0

        .ENDC

        .ENDR

$TTTBE::.WORD   0               ;END OF TABLE
;
;

        .IF DF  T$$COM

; POINTER TO PCB FOR COMMON BLOCK "TTCOM"
;
$TTCOM::.BLKW   1               ;TO BE FILLED IN BY VMR
                                ;CLEARED BY DRIVER INITIALIZATION ROUTINE

        .ENDC   ;T$$COM

                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$NLTMO::CLR     S$$SPC+2(SP)    ;FORCE $SCDVT ON TO NEXT DCB                    ; CS013
        INCB    S.CTM(R4)       ;RESET TIMEOUT COUNT FOR THE NEXT TIME          ; CS013
        RETURN                  ;                                               ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
TTPWFL:                                                                         ; DD010
                                                                                ; DD018
        .IF DF  T$$COM                                                          ; DD018
                                                                                ; DD018
        MOV     KINAR6,-(SP)    ;SAVE KERNEL INSTRUCTION APR 6                  ; DD018
                                                                                ; DD018
        .IFTF   ;T$$COM                                                         ; DD018
                                                                                ; DD018
        BCC     10$             ;BRANCH ON UNIT POWERFAIL                       ; D0010
        MOV     #12,R4          ;GET CONTROLLER POWERFAIL OFFSET CODE           ; D0010
        BR      TTDSP           ;GO TO COMMON CONTROLLER DISPATCHER             ; D0010
10$:    ADD     #U.TSTA,R5      ;POINT TO UCB TRIPLE-STATUS WORD                ; D0010
        MOV     #14,R2          ;GET UNIT POWERFAIL OFFSET CODE                 ; D0010
        BR      TTCRD           ;GO TO UNIT DEPENDENT ROUTINE                   ; D0010
                                                                                ; D0010
TTKRB:                                                                          ; D0010
                                                                                ; D0018
        .IFT    ;T$$COM                                                         ; D0018
                                                                                ; D0018
        MOV     KINAR6,-(SP)    ;SAVE KERNEL INSTRUCTION APR 6                  ; D0018
                                                                                ; D0018
        .IFTF   ;T$$COM                                                         ; D0018
                                                                                ; D0018
        BCS     20$             ;BRANCH IF CONTROLLER OFFLINE                   ; DD010
                                                                                ; DD010
        .IFT    ;T$$COM                                                         ; DD018
                                                                                ; D0010
        TST     $TTCOM          ;GET TTCOM PCB ADDRESS                          ; D0010
        BEQ     10$             ;ALREADY INITIALIZED - JUMP                     ; D0010
                                                                                ; D0010
        .IFF    ;T$$COM                                                         ; D0010
                                                                                ; D0010
        TST     PAR6S           ;GET KISAR6 MAPPING                             ; D0010
        BNE     10$             ;ALREADY INITIALIZED - JUMP                     ; D0010
                                                                                ; D0010
        .IFTF   ;T$$COM                                                         ; DD018
                                                                                ; DD010
        MOV     R2,-(SP)        ;SAVE R2                                        ; DD010
        CALL    TTINIT          ;INITIALIZE THE WORLD                           ; DD010
        MOV     (SP)+,R2        ;RESTORE R2                                     ; DD010
10$:    MOV     #16,R4          ;GET CONTROLLER ONLINE OFFSET CODE              ; DD010
        BR      TTDSP           ;GO TO COMMON CONTROLLER DISPATCHER             ; DD010
20$:    MOV     #20,R4          ;GET CONTROLLER OFFLINE OFFSET CODE             ; DD010
        BR      TTDSP           ;GO TO COMMON CONTROLLER DISPATCHER             ; DD010
                                                                                ; DD010
TTUCB:                                                                          ; DD010
                                                                                ; DD018
        .IFT    ;T$$COM                                                         ; DD018
                                                                                ; DD018
        MOV     KINAR6,-(SP)    ;SAVE KERNEL INSTRUCTION APR 6                  ; DD018
                                                                                ; DD018
        .IFTF   ;T$$COM                                                         ; DD018
                                                                                ; DD018
        BCS     10$             ;BRANCH IF WANT TO SET UNIT OFFLINE             ; DD010
        ADD     #U.TSTA,R5      ;POINT TO UCB STATUS TRIPLEWORD                 ; DD010
        CALL    MAPD            ;MAP DATA AREA                                  ; DD010
        CALL    CKTAB           ;ALLOCATE TYPE-AHEAD BUFFER IF NECESSARY        ; DD010
                                                                                ; DD010
        .IF DF  T$$MOD                                                          ; DD010
                                                                                ; DD010
        BICB    #US.CRW!US.DSB,U.STS-U.TSTA(R5)                                 ; DD010
                                ;ASSUME LOCAL LINE                              ; DD010
                                                                                ; DD010
        .ENDC                                                                   ; DD010
                                                                                ; DD010
        MOV     #22,R2          ;SET ROUTINE INDEX FOR UNIT ONLINE              ; DD010
        BR      TTCRD           ;GO TO UNIT DEPENDENT ROUTINE DISPATCHER        ; DD010
10$:    ADD     #U.TSTA,R5      ;ADVANCE UCB POINTER                            ; DD010
        MOV     #24,R2          ;SET ROUTINE INDEX FOR UNIT OFFLINE             ; DD010
        BR      TTCRD           ;ON TO COMMON UNIT ROUTINE DISPATCHER           ; DD010
                                                                                ; DD010
TTDSP:  MOV     KISAR6,-(SP)    ;SAVE CURRENT APR 6 MAPPING                     ; DD010
        CALL    MAPD            ;MAP DRIVER DATA AREA                           ; DD010
        MOV     @R2,R3          ;GET CSR                                        ; DD010
        MOVB    K.PRM(R2),R1    ;GET CONTROLLER TYPE                            ; DD010
        ADD     CTBL(R1),R4     ;GET DISPATCH TABLE POINTER                     ; DD010
        CALL    @(R4)+          ;CALL CONTROLLER DEPENDENT ROUTINE              ; DD010
        BR      TTRET           ;GO TO COMMON RETURN CODE                       ; DD010
                                                                                ; DD010
TTCRD:  MOV     KISAR6,-(SP)    ;SAVE CURRENT APR 6 MAPPING                     ; DD010
        CALL    MAPD            ;MAP DRIVER DATA AREA                           ; DD010
        CALL    CTRD            ;CALL UNIT DEPENDENT ROUTINE                    ; DD010
TTRET:  MOV     (SP)+,KISAR6    ;RESTORE ENTRY APR 6 MAPPING                    ; DD010
                                                                                ; D0018
        .IFT    ;T$$COM                                                         ; D0018
                                                                                ; D0018
        MOV     (SP)+,KINAR6    ;RESTORE KERNEL INSTRUCTION APR 6               ; D0018
                                                                                ; D0018
        .ENDC   ;T$$COM                                                         ; D0018
                                                                                ; D0018
        RETURN                                                                  ; D0018
                                                                                ; D0018
        .ENDC   ;R$$CON                                                         ; D0018
                                                                                ; D0018
;
;
        .END
        .TITLE  TTYH
        .IDENT  /V01.15/
;
; 27-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW017   25-APR-78       PETER WANNHEDEN
;               USE SUBR. "LOCKI" TO LOCK OUT INTERRUPTS.
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED.
;       PW027   11-MAY-78       PETER WANNHEDEN
;               MAKE LOADABLE CTB UNCONDITIONAL.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD010   15-NOV-78       DALE R. DONCHIN
;               ADD SUPPORT FOR ONLINE RECONFIGURATION
;       DD015   28-FEB-79       DALE R. DONCHIN
;               USE TWO STOP BITS FOR SPEEDS LESS THAN 150 BAUD
;
;+
; CONTROLLER-DEPENDENT ROUTINES FOR DH-11.
;-
;
;

        .IF DF  D$$H11

                                                                                ; CS013
        .MCALL  UCBDF$                                                          ; CS013
                                                                                ; CS013
        UCBDF$                  ;DEFINE UCB SYMBOLS                             ;**-3
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        .MCALL  KRBDF$                                                          ; CS013
                                                                                ; CS013
        KRBDF$                  ;DEFINE KRB SYMBOLS                             ; CS013
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        .MCALL  SCBDF$                                                          ; CS013
                                                                                ; CS013
        SCBDF$                  ;DEFINE SCB SYMBOLS                             ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
;
;
; EQUATED SYMBOLS
;
; DH-11 REGISTER DEFINITIONS
;
SCR     =       0               ;SYSTEM CONTROL REG.
NRC     =       2               ;NEXT RECEIVED CHAR. REG.
LPR     =       4               ;LINE PARAMETER REG.
CAR     =       6               ;CURRENT ADDRESS REG.
BCR     =       10              ;BYTE COUNT REG.
BAR     =       12              ;BUFFER ACTIVE REG.
;
;
;+                                                                              ;**-24
; YHSTAX - START OUTPUT.
;       NOTE - NON-BUFFERED OUTPUT CURRENTLY NOT SUPPORTED.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.TOP+2         BUFFER POINTER
;       U.TOC           BYTE COUNT
;
; OUTPUT:
;       OUTPUT STARTED.
;       U.TOP+2         UNCHANGED
;       U.TOC           UNCHANGED
;
; REGISTERS ALTERED: R4
;-
;
;
        .ENABL  LSB
;
YHSTAX::ADD     #U.TOP+2,R4     ;;;POINT TO U.TOP+2                             ;PW026
        CALL    SELLIN          ;;;SELECT LINE                                  ;**-1
STAX1:

        .IF DF  M$$EXT

        MOV     (R4)+,CAR(R3)   ;;;SET BUFFER ADDRESS (U.TOP+2)

        .IFF    ;M$$EXT

        MOV     (R4)+,-(SP)     ;;;GET VIRTUAL BUFFER ADDRESS
        CMP     @SP,#120000     ;;;IN SYSTEM POOL?
        BLO     20$             ;;;Y - VIRTUAL ADDRESS = PHYS. ADDRESS, JUMP
        ADD     RELC+2,@SP      ;;;ADD RELOCATION CONSTANT TO VIRTUAL ADDRESS
        MOV     RELC,-(SP)      ;;;
        BCC     10$             ;;;NO CARRY - JUMP
        ADD     #20,@SP         ;;;ADD CARRY TO HIGH 2 BITS
        BIC     #^C<60>,@SP     ;;;NORMALIZE HIGH 2 BITS
10$:    BISB    (SP)+,@R3       ;;;LOAD 2 HIGH BITS OF 18-BIT ADDRESS
20$:    MOV     (SP)+,CAR(R3)   ;;;LOAD CAR

        .ENDC   ;M$$EXT

        ASSUME  U.TOC,<U.TOP+4>
        MOV     @R4,BCR(R3)     ;;;SET BYTE COUNT (U.TOC) IN BCR
        NEG     BCR(R3)         ;;;NEGATE IT
        BIT     #S1.CTS,@R5     ;;;OUTPUT STOPPED BY CTRL-S?
        BNE     30$             ;;;Y - JUMP
;
;
;+
; YHRESX - RESUME OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       S1.CTS          0
;-
;
;
YHRESX::BIS     $BTMSK(R2),BAR(R3) ;;;SET BIT IN BAR TO START TRANSMISSION      ;PW026
30$:                                                                            ;**-1

        .IF NDF D$$M11

YHMTIM::                                                                        ;PW026
                                                                                ;**-1
        .ENDC   ;D$$M11

        RETURN                  ;;;
;
        .DSABL  LSB
;
;
;+
; YHABOX - ABORT OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;
; REGISTERS ALTERED: R3
;-
;
;
YHABOX::CALL    YHSTOX          ;;;STOP TRANSMISSION                            ;PW026
        CALL    SELLIN          ;;;SELECT LINE                                  ;**-1
        CLR     BCR(R3)         ;;;CLEAR BYTE COUNT
        CLR     BCR(R3)         ;;;DO IT AGAIN - CONTROLLER MAY HAVE BEEN
                                ;;;DOING A READ-MODIFY-WRITE CYCLE ON
                                ;;;THE BYTE COUNT REGISTER WHEN WE CLEARED
                                ;;;IT FIRST TIME
        RETURN                  ;;;
;
;
;+
; YHSTOX - STOP OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       S1.CTS          1
;-
;
;
YHSTOX::BIC     $BTMSK(R2),BAR(R3) ;;;CLEAR BIT IN BAR TO STOP TRANSMISSION     ;PW026
        RETURN                  ;;;                                             ;**-1
;
;

        .ENABL  LSB

        .IF DF  T$$GMC!T$$SMC

;+
; YHLPAR - GET/SET LINE PARAMETERS.
;
; INPUT:
;       R0      BIT 15: 0 = GET/SET RECEIVE SPEED
;                       1 = GET/SET TRANSMIT SPEED
;               BIT 8:  0 = GET SPEED
;                       1 = SET SPEED
;               IF SET SPEED:
;               BITS 0-7: NEW SPEED PARAMETER (S.XXX SYMBOL)
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;
; OUTPUT:
;       IF GET SPEED REQUESTED:
;       R2      BITMASK TO RELEVANT SPEED BITS IN U.CW3
;       R4      POINTER TO DH11 SPEED TABLE
;       CC-C    0
;
;       IF SET SPEED REQUESTED:
;       CC-C    0 IF OK
;               1 IF ILLEGAL SPEED SPECIFIED
;-
;
;
;
YHLPAR::MOV     R0,R4           ;SAVE INPUT PARAMETER                           ;PW026
        MOV     #1700,R2        ;ASSUME RECEIVE SPEED SPECIFIED                 ;**-1
        SWAB    R4              ;WELL?
        BPL     10$             ;CORRECT - JUMP
        MOV     #36000,R2       ;TRANSMIT SPEED - GET BITMASK
10$:

        .IF DF  T$$GMC&T$$SMC

        ASRB    R4              ;GET OR SET?
        BCS     20$             ;SET - JUMP

        .ENDC

        .IF DF  T$$GMC

        MOV     #SPDH,R4        ;POINT TO DH11 SPEED TABLE
        RETURN                  ;RETURN WITH CC-C = 0

        .ENDC   ;T$$GMC

        .IF DF  T$$SMC

20$:

        .IF NDF T$$GMC

        SEC                     ;ASSUME ILLEGAL SPEED

        .ENDC   ;NOT T$$GMC

        BIC     #177400,R0      ;CLEAR R0 HIGH BYTE
        MOVB    SPDH-1(R0),R0   ;GET SPEED BITS
        BMI     80$             ;NOT SUPPORTED - JUMP
        BIC     #4,U.CW3-U.TSTA(R5) ;ASSUME ONE STOP BIT FOR NEW SPEED          ; DD015
        CMPB    R0,#3           ;CHECK THAT ASSUMPTION                          ; DD015
        BGT     25$             ;IT WAS CORRECT - JUMP                          ; DD015
        BIS     #4,U.CW3-U.TSTA(R5) ;NOBODY'S PERFECT - SET 2 STOP BITS         ; DD015
25$:                                                                            ; DD015
        SWAB    R0              ;GET INTO HIGH BYTE
        TSTB    R4              ;RECEIVE OR TRANSMIT SPEED?
        BMI     30$             ;TRANSMIT - JUMP
        ASR     R0              ;RECEIVE - SHIFT INTO BITS 6-9
        ASR     R0              ;
        BR      40$             ;
30$:    ASL     R0              ;TRANSMIT - SHIFT INTO BITS 10-13
        ASL     R0              ;
40$:    BIC     R2,U.CW3-U.TSTA(R5) ;CLEAR OLD SPEED BITS
        BIS     R0,U.CW3-U.TSTA(R5) ;SET NEW BITS
        BR      70$             ;GO AND LOAD INTO LPR

        .ENDC   ;T$$SMC

        .IF DF  D$$M11&R$$CON                                                   ; DD010
                                                                                ; DD010
YMLPAR::RETURN                                                                  ; DD010
                                                                                ; DD010
        .ENDC                                                                   ; DD010
                                                                                ; DD010
        .ENDC   ;T$$GMC!T$$SMC

;
;+
; YHPWUP - POWER-UP.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.STS   SET UP FOR LOCAL LINE:
;               US.CRW  0
;               US.DSB  0
;-
;
;
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YHCONL::                                                                        ; DD010
                                                                                ; DD010
        .IF DF  M$$EXT                                                          ; DD010
                                                                                ; DD010
        MOV     #UMR5S,R0       ;GET ADDRESS OF SAVED UMR 5                     ; DD010
        MOV     #UBMPR+<5*4>,R1 ;POINT AT UMR 5                                 ; DD010
        MOV     (R0)+,(R1)+     ;SET UP UMR 5                                   ; DD010
        MOV     (R0)+,(R1)+     ;                                               ; DD010
        MOV     (R0)+,(R1)+     ;SET UP UMR 6                                   ; DD010
        MOV     (R0)+,(R1)+     ;                                               ; DD010
                                                                                ; DD010
        .ENDC   ;M$$EXT                                                         ; DD010
                                                                                ; DD010
YHCPUP::                                                                        ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
YHPWUP::TST     R2              ;IS THIS LINE ZERO?                             ;PW026
        BNE     60$             ;N - JUMP                                       ;**-1
                                                                                ; DD010
        .IFTF                                                                   ; DD010
                                                                                ; DD010
        MOV     #4000,@R3       ;CLEAR SILO, UARTS, CONTROLLER
        MOV     #20100,@R3      ;ENABLE INTERRUPTS
                                                                                ; DD010
        .IFT                                                                    ; DD010
                                                                                ; DD010
        RETURN                                                                  ; DD010
YHUONL::                                                                        ; DD010
YHUPUP::                                                                        ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
60$:

        .IF DF  D$$M11

        BIT     #U2.RMT,U.CW2-U.TSTA(R5) ;REMOTE LINE?
        BEQ     70$             ;N - JUMP
                                                                                ; DD010
        .IF NDF R$$MPL                                                          ; DD010
                                                                                ; DD010
        TST     U.DMCS-U.TSTA(R5) ;IS THERE REMOTE SUPPORT FOR LINE?            ; DD010
        BNE     61$             ;Y - JUMP                                       ; DD010
        BIC     #U2.RMT,U.CW2-U.TSTA(R5) ;N - SET LINE LOCAL                    ; DD010
        BR      70$             ;FORGET THAT IT WAS EVER REMOTE                 ; DD010
61$:    INCB    U.TMTI-U.TSTA(R5) ;SET TIMER SO TIMEOUT WILL ENABLE             ; DD010
                                ;INTERRUPTS ON DM11-BB                          ; DD010
                                                                                ; DD010
        .ENDC   ;NDF R$$MPL                                                     ; DD010
                                                                                ; DD010
        BISB    #US.CRW,U.STS-U.TSTA(R5) ;SET WAITING FOR CARRIER FLAG          ; DD010
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
        MOV     U.SCB-U.TSTA(R5),R0 ;GET SCB                                    ; DD010
        MOV     S.KRB(R0),R0    ;GET DH11 KRB                                   ; DD010
        MOVB    K.CON(R0),R0    ;GET CONTROLLER INDEX                           ; DD010
        ADD     YMCP1,R0        ;POINT TO POINTER TO DM11-BB KRB                ; DD010
        MOV     @R0,R0          ;GET DM11-BB KRB                                ; DD010
        MOVB    U.UNIT-U.TSTA(R5),R1 ;GET UNIT NUMBER OF THIS LINE              ; DD010
        ASL     R1              ;CONVERT FROM BYTE OFFSET TO WORD OFFSET        ; DD010
        BIS     $BTMSK(R1),K.PRM-2(R0) ;SET ENABLE BIT FOR THIS LINE            ; DD010
        BIT     #KS.OFL,K.STS(R0) ;IS DM CONTROLLER OFFLINE?                    ; DD010
        BNE     70$             ;Y - JUMP                                       ; DD010
        MOV     R3,-(SP)        ;SAVE YH CSR                                    ; DD010
        MOV     @R0,R3          ;GET YM CSR                                     ; DD010
        CALL    YHMTMA          ;LET DM KNOW ABOUT THIS LINE NOW                ; DD010
        MOV     (SP)+,R3        ;RESTORE YH CSR                                 ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ;**-4
        .ENDC

70$:    CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ;PW017
        CALL    SELLIN          ;;;SELECT THE LINE                              ;**-1
        MOV     U.CW3-U.TSTA(R5),LPR(R3) ;;;LOAD LINE PARAMETERS
;                                                                               ;PW017
; WHEN RETURNING VIA COROUTINE "LOCKI", CC-C IS CLEARED                         ;PW017
;                                                                               ;PW017
80$:    RETURN                  ;RETURN                                         ;**-1

        .DSABL  LSB
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YHCOFF::                                                                        ; DD010
        CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ; DD010
        MOV     #4000,@R3       ;;;CLEAR SILO, UARTS, CONTROLLER                ; DD010
        RETURN                                                                  ; DD010
YHUOFF::                                                                        ; DD010
        CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ; DD010
        CALL    SELLIN          ;;;SELECT THE LINE                              ; DD010
        MOV     U.CW3-U.TSTA(R5),-(SP) ;;;GET THE LINE PARAMETERS               ; DD010
        BIC     #37700,@SP      ;;;SET TO 0 BAUD TO DISABLE LINE                ; DD010
        MOV     (SP)+,LPR(R3)   ;;;LOAD LINE PARAMETERS                         ; DD010
        RETURN                  ;;;DROP PRIORITY                                ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
;
;
;+
; INPUT INTERRUPT SERVICE ROUTINE.
;-
;
;
        .ENABL  LSB
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$YHINP::TTSET$  YH              ;;;SAVE R2, R3 AND SET UP:
                                ;;; R3 = CSR ADDRESS
                                ;;; R4 = KRB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DHINP::TTSET$  DH              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF UCB LIST                    ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        CALL    MUXINP          ;;;DO COMMON MULTIPLEXER INPUT
                                ;;;CHARACTER PROCESSING
                                ;;;MUXINP DISMISSES INTERRUPT IF NO OUTPUT WORK
        BR      10$             ;;;XMIT READY - GO DO OUTPUT WORK
;
;
;+
; OUTPUT INTERRUPT SERVICE ROUTINE.
;-
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$YHOUT::TTSET$  YH              ;;;SAVE R2, R3 AND SET UP:
                                ;;; R3 = CSR ADDRESS
                                ;;; R4 = KRB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DHOUT::TTSET$  DH              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF UCB LIST                    ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
10$:    BIC     #100077,@R3     ;;;CLEAR TRANSMIT DONE, UNIT NUMBER AND
                                ;;;2 HIGH BITS OF UNIBUS ADDRESS
        MOV     R4,-(SP)        ;;;SAVE KRB ADDRESS
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        ADD     K.OFF(R4),R4    ;;;GET START OF UCB TABLE
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
30$:    MOV     (R4)+,R5        ;;;GET NEXT UCB ADDRESS
        CMP     R5,#-1          ;;;END OF LIST?
        BEQ     70$             ;;;Y - JUMP
        BITB    #US.DSB!US.OIU,U.STS(R5) ;;;DISABLED OR OUTPUT
                                         ;;;INTERRUPT UNEXPECTED?
        BNE     60$             ;;;Y - JUMP

        .IF DF  R$$CON

        BITB    #US.OFL,U.ST2(R5) ;;;OFFLINE?
        BNE     60$             ;;;Y - JUMP

        .ENDC   ;R$$CON

        TST     BCR(R3)         ;;;HAS THIS LINE COMPLETED TRANSMISSION?
        BNE     60$             ;;;N - JUMP
        MOV     R4,-(SP)        ;;;THIS LINE HAS COMPLETED - SAVE R4
        MOV     R3,-(SP)        ;;;SAVE CSR
        ADD     #U.TUX,R5       ;;;POINT TO UCBX POINTER
        MOV     (R5)+,R4        ;;;GET UCBX

        .IF DF  DEBUG

        BNE     31$
        BPT
31$:

        .ENDC

        ADD     #U.TOP+2,R4     ;;;POINT TO U.TOP+2
        ASSUME  U.TSTA,<U.TUX+2>
        CALL    NXTOB           ;;;GET NEXT OUTPUT BUFFER IF THERE IS ONE
        BEQ     40$             ;;;N - JUMP
;
; WE GOT ANOTHER OUTPUT BUFFER - START OUTPUTTING IT.
;
        TST     -(R4)           ;;;POINT TO U.TOP+2
        MOV     (SP)+,R3        ;;;GET CSR
        MOVB    U.UNIT-U.TSTA(R5),R2 ;;;GET UNIT NUMBER
        ASL     R2              ;;; .. TIMES 2
        CALL    STAX1           ;;;START OUTPUT
        BR      50$             ;;;
40$:    CALL    ODONE           ;;;DO OUTPUT DONE PROCESSING
        MOV     (SP)+,R3        ;;;RESTORE CSR POINTER
50$:    MOV     (SP)+,R4        ;;;RESTORE R4
        BICB    #60,@R3         ;;;CLEAR 2 HIGH BITS OF UNIBUS ADDRESS
                                ;;;TO AVOID OVERFLOW INTO BIT 6 WHEN
                                ;;;INCREMENTING LINE NUMBER
60$:    INCB    @R3             ;;;INCREMENT LINE NUMBER
        BR      30$             ;;;GO TRY NEXT LINE
;
; ALL LINES SCANNED. SEE IF ANY LINE COMPLETED TRANSMIT
; "BEHIND" US IN THE SCAN LOOP.
;
70$:    MOV     (SP)+,R4        ;;;RESTORE KRB ADDRESS
                                ;;; OR ADDRESS OF UCB LIST (RSX-11M)            ; CS013
        TST     @R3             ;;;XMIT RDY SET?
        BMI     10$             ;;;Y - DO IT ALL OVER AGAIN
;
; ALL OUTPUT WORK DONE. SEE IF ANY INPUT WORK NEEDED.
;
        MOV     NRC(R3),R5      ;;;GET A CHARACTER FROM SILO
        BPL     80$             ;;;NONE - EXIT
        CALL    MUXIN1          ;;;PROCESS AS INPUT INTERRUPT
        BR      10$             ;;;OUTPUT WORK TO DO - JUMP
                                ;;;MUXIN1 DISMISSES INTERRUPT IF NO OUTPUT WORK
;
;
;
;
; SUBROUTINE TO SELECT LINE ON DH11.
;
;
SELLIN: BICB    #77,@R3         ;;;CLEAR LINE NUMBER AND 2 HIGH BITS
                                ;;;OF 18-BIT ADDRESS
        BISB    U.UNIT-U.TSTA(R5),@R3 ;;;SELECT LINE
80$:    RETURN                  ;;;
;
        .DSABL  LSB

        .IF DF  D$$M11

        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YMCONL::                                                                        ; DD010
YMCPUP::                                                                        ; DD010
        CALL    LOCKI           ;RAISE OUR PRIORITY                             ; DD010
        BIC     #1040,@R3       ;;;STOP DM11-BB SCAN                            ; DD010
10$:    BIT     #20,@R3         ;;;SCAN STOPPED?                                ; DD010
        BNE     10$             ;;;N - WAIT                                     ; DD010
        CLR     R0              ;;;INITIALLY SET TO LINE 0                      ; DD010
20$:    MOV     R0,@R3          ;;;SELECT LINE                                  ; DD010
        ASL     R0              ;;;CONVERT TO WORD OFFSET                       ; DD010
        BIT     $BTMSK(R0),K.PRM-2(R2) ;;;SHOULD WE ENABLE THIS LINE?           ; DD010
        BEQ     30$             ;;;N - JUMP                                     ; DD010
        BIS     #1,2(R3)        ;;;Y - SET DM11-BB LINE ENABLE                  ; DD010
30$:    ASR     R0              ;;;RESTORE COUNT                                ; DD010
        INC     R0              ;;;INCREMENT TO NEXT LINE                       ; DD010
        CMP     R0,#15          ;;;GONE THRU EVERY LINE?                        ; DD010
        BLE     20$             ;;;N - LOOP                                     ; DD010
        BIS     #140,@R3        ;;;ENABLE SCAN AND INTERRUPTS                   ; DD010
        RETURN                  ;;;RETURN WILL LOWER PRIORITY                   ; DD010
YMCOFF::                                                                        ; DD010
        CALL    LOCKI           ;LOCK OUT INTERRUPTS                            ; DD010
        BIC     #1140,@R3       ;;;DISABLE SCAN AND INTERRUPTS                  ; DD010
YMSTAX::                                                                        ; DD010
YMABOX::                                                                        ; DD010
YMRESX::                                                                        ; DD010
YMSTOX::                                                                        ; DD010
YMMTIM::                                                                        ; DD010
YMUPUP::                                                                        ; DD010
YMUONL::                                                                        ; DD010
YMUOFF::                                                                        ; DD010
        RETURN                  ;;;                                             ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
;+
; DM11-BB DATASET STATUS CHANGE INTERRUPT
;-
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$DM11B::TTSET$  YM              ;;;SAVE R2, R3 AND SET UP:
                                ;;; R3 = CSR ADDRESS
                                ;;; R4 = KRB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DM11B::TTSET$  DM              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF DH UCB LIST                 ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        BIC     #240,@R3        ;;;CLEAR DONE FLAG AND DISABLE SCAN
        MOV     (R3)+,R5        ;;;GET LINE NUMBER IN BITS 0-3
        CALL    MUXUCB          ;;;GET POINTER TO U.TSTA
        BCS     10$             ;;;UNKNOWN LINE - JUMP
        MOV     @R3,R4          ;;;GET MODEM STATUS
        MOV     #T$$MAN,-(SP)   ;;;GET ANSWERING PARAMETERS
        CALL    MODISR          ;;;DO COMMON MODEM INTERRUPT PROCESSING
10$:    BIS     #40,-(R3)       ;;;REENABLE SCAN
        BCS     20$             ;;;NO CALL ANSWERED - JUMP
        MOV     U.SCB-U.TSTA(R5),R3 ;;;GET SCB
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        MOV     @S.KRB(R3),R3   ;;;GET DH CSR ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        MOV     S.CSR(R3),R3    ;;;GET DH CSR ADDRESS                           ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        CALL    SELLIN          ;;;SELECT LINE
        MOV     #T$$MAN,LPR(R3) ;;;SET LINE PARAMETERS
20$:    RETURN                  ;;;DISMISS INTERRUPT
;
;
;+
; YHMTIM - MODEM TIME-OUT
;-
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
YHMTIM::MOV     U.SCB-U.TSTA(R5),R3 ;GET SCB                                    ; CS013
        MOV     S.KRB(R3),R3    ;GET DH11 KRB                                   ;**-1
        MOVB    K.CON(R3),R3    ;GET CONTROLLER INDEX
        ADD     YMCP1,R3        ;POINT TO POINTER TO DM11-BB KRB                ;PW026
        MOV     @(R3)+,R3       ;GET DM11-BB CSR                                ;**-4
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
YHMTIM::MOV     U.DMCS-U.TSTA(R5),R3 ;GET DM11-BB CSR                           ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
YHMTMA:                                                                         ; DD010
        CALL    HLMTIM          ;DO COMMON MODEM TIME-OUT PROCESSING            ;**-7
;
;       COME BACK AT RAISED PRIORITY
;
        BIC     #1040,@R3       ;;;STOP SCAN
10$:    BIT     #20,@R3         ;;;SCAN STOPPED?
        BNE     10$             ;;;N - WAIT
        BIC     #17,@R3         ;;;CLEAR LINE NUMBER
;
;       NOTE - CANNOT USE BYTE INSTRUCTIONS ON DM11-BB
;
        MOVB    U.UNIT-U.TSTA(R5),R4 ;;;GET LINE NUMBER
        BIS     R4,(R3)+        ;;;SELECT LINE
        BIC     #17,@R3         ;;;DROP DTR, RTS, SEC. XMIT
        INC     @R3             ;;;SET LINE ENABLE
        BIS     #140,-(R3)      ;;;ENABLE SCAN AND INTERRUPTS
        RETURN                  ;;;RETURN FROM COROUTINE

        .ENDC   ;D$$M11

        .ENDC   ;D$$H11


        .END
        .TITLE  TTYJ
        .IDENT  /V01.04/
;
; 27-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD010   15-NOV-78       DALE R. DONCHIN
;               ADD SUPPORT FOR ONLINE RECONFIGURATION
;
;+
; CONTROLLER-DEPENDENT ROUTINES FOR DJ-11.
;-
;
;

        .IF DF  D$$J11

; EQUATED SYMBOLS
;
; DJ-11 REGISTER DEFINITIONS
;
CSR     =       0               ;CONTROL AND STATUS REG.
RBUF    =       2               ;RECEIVER BUFFER REG.
TCR     =       4               ;TRANSMIT CONTROL REG.
TBUF    =       6               ;TRANSMITTER BUFFER REG.
;
;
;+                                                                              ;**-28
; YJPWUP - POWER UP.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.STS   SET UP FOR LOCAL LINE:
;               US.CRW  0
;               US.DSB  0
;-
;
;
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YJCONL::                                                                        ; DD010
YJCPUP::                                                                        ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
YJPWUP::TST     R2              ;IS THIS LINE ZERO?                             ;PW026
        BNE     20$             ;N - RETURN                                     ;**-1
                                                                                ; DD010
        .IFTF                                                                   ; DD010
                                                                                ; DD010
        MOV     #10,@R3         ;CLEAR SILO, UARTS, CONTROLLER
10$:    BIT     #20,@R3         ;CLR COMPLETED?
        BNE     10$             ;N - WAIT
        BIS     #40501,@R3      ;ENABLE INTERRUPTS
                                                                                ; DD010
        .IFT                                                                    ; DD010
                                                                                ; DD010
YJUONL::                                                                        ; DD010
YJUPUP::                                                                        ; DD010
YJUOFF::                                                                        ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
20$:
YJMTIM::RETURN                  ;RETURN                                         ;PW026
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YJCOFF::                                                                        ; DD010
        MOV     #10,@R3         ;CLEAR SILO, UARTS, CONTROLLER                  ; DD010
10$:    BIT     #20,@R3         ;CLR COMPLETED?                                 ; DD010
        BNE     10$             ;N - LOOP                                       ; DD010
        RETURN                                                                  ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
;                                                                               ;**-1
;
;+
; INPUT INTERRUPT SERVICE ROUTINE.
;-
;
;
        .ENABL  LSB
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$YJINP::TTSET$  YJ              ;;;SAVE R2, R3 AND SET UP:
                                ;;; R3 = CSR ADDRESS
                                ;;; R4 = KRB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DJINP::TTSET$  DJ              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF UCB LIST                    ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        CALL    MUXINP          ;;;DO COMMON MULTIPLEXER INPUT
                                ;;;CHARACTER PROCESSING
                                ;;;MUXINP DISMISSES INTERRUPT IF NO OUTPUT WORK
        BR      10$             ;;;XMIT READY - GO DO OUTPUT WORK
;
;
;+
; OUTPUT INTERRUPT SERVICE ROUTINE.
;-
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$YJOUT::TTSET$  YJ              ;;;SAVE R2, R3 AND SET UP:
                                ;;; R3 = CSR ADDRESS
                                ;;; R4 = KRB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DJOUT::TTSET$  DJ              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF UCB LIST                    ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
10$:    MOV     R3,-(SP)        ;;;
        ADD     #TBUF+1,@SP     ;;;POINT TO BYTE CONTAINING
                                ;;;INTERRUPTING LINE NUMBER (TBUF HIGH BYTE)
        CALL    JZOUT           ;;;DO OUTPUT INTERRUPT PROCESSING
                                ;;;COMMON FOR DJ-11 AND DJ-11
        TST     (SP)+           ;;;CLEAN STACK
;
;
;+
; YJABOX - ABORT OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.TOC           0
;       U.TTOC          0
;
; YJSTOX - STOP OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       S1.CTS          1
;-
;
;
YJABOX::                                                                        ;PW026
YJSTOX::RETURN                  ;;;RETURN                                       ;PW026
;                                                                               ;**-2
        .DSABL  LSB

        .ENDC   ;D$$J11

;
;
        .END
        .TITLE  TTYL
        .IDENT  /V01.11/
;
; 27-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD010   15-NOV-78       DALE R. DONCHIN
;               ADD SUPPORT FOR ONLINE RECONFIGURATION
;       DD012   6-DEC-78        DALE R. DONCHIN
;               FIX BUG WHEN HAVE ONLY 1 DL-11.
;               RESCAN FOR FORK REQUESTS AFTER PROCESSING TYPE-AHEAD
;
;+
; CONTROLLER-DEPENDENT ROUTINES FOR DL-11.
;-
;
;

        .IF DF  D$$L11

                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
        .MCALL  KRBDF$                                                          ; CS013
                                                                                ; CS013
        KRBDF$                  ;DEFINE KRB SYMBOLS                             ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        .MCALL  UCBDF$                                                          ; CS013
        UCBDF$                  ;DEFINE UCB SYMBOLS                             ;**-3
;
;
; EQUATED SYMBOLS
;
; DL-11 REGISTER DEFINITIONS
;
RCSR    =       0               ;RECEIVER STATUS REG.
RBUF    =       2               ;RECEIVER DATA BUFFER REG.
XCSR    =       4               ;TRANSMITTER STATUS REG.
XBUF    =       6               ;TRANSMITTER DATA BUFFER REG.
;
;
;+                                                                              ;**-27
; YLRESX - RESUME OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       S1.CTS          0
;-
;
;
YLRESX::BIS     #100,XCSR(R3)   ;SET XMIT INTERRUPT ENABLE                      ;PW026
;                                                                               ;**-1
;
;+
; YLABOX - ABORT OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.TOC           0
;       U.TTOC          0
;
; YLSTOX - STOP (SUSPEND) OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       S1.CTS          1
;-
;
;
YLABOX::                                                                        ;PW026
YLSTOX::                                                                        ;PW026
                                                                                ;**-2
        .IF NDF D$$LMD

YLMTIM::                                                                        ;PW026
                                                                                ;**-1
        .ENDC   ;D$$LMD

        RETURN                  ;;;
;
;
;+
; YLPWUP - POWER-UP.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.STS   SET UP FOR LOCAL LINE:
;               US.CRW  0
;               US.DSB  0
;-
;
;
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YLCONL::                                                                        ; DD010
YLCPUP::                                                                        ; DD010
YLUONL::                                                                        ; DD010
YLUPUP::                                                                        ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
YLPWUP::                                                                        ;PW026
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
        MOVB    RBUF(R3),R0     ;EMPTY RBUF                                     ;PW026
                                                                                ;**-1
        .IF DF  D$$LMD

        BIS     #140,@R3        ;ENABLE DATASET AND RECEIVE INTERRUPTS

        .IFF    ;D$$LMD

        BIS     #100,@R3        ;ENABLE RECEIVE INTERRUPTS

        .IFTF   ;D$$LMD

        RETURN                  ;RETURN
;

        .IFT    ;D$$LMD

;
;+
; YLMTIM - MODEM TIMER.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;-
;
;
        .ENABL  LSB
;
YLMTIM::CALL    HLMTIM          ;CALL COMMON MODEM TIMER ROUTINE                ;PW026
                                ;;;COME BACK AT DEVICE PRIORITY                 ;**-1
        BICB    #17,@R3         ;;;CLEAR DTR, RTS, READER ENABLE AND
                                ;;;SECONDARY XMIT
10$:    RETURN                  ;;;RETURN TO COROUTINE THAT HANGS
                                ;;;UP LINE IF NECESSARY

        .IFTF   ;D$$LMD

                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YLCOFF::                                                                        ; DD010
YLUOFF::                                                                        ; DD010
        CLR     @R3             ;DISABLE THE WORLD                              ; DD010
        RETURN                                                                  ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
;
;
;+
; INPUT INTERRUPT SERVICE ROUTINE.
;-
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$YLINP::                                                                        ; DD011
                                                                                ; DD011
        .IF EQ  D$$L11-1                                                        ; DD011
                                                                                ; DD011
        CLR     R4              ;;;SET UP DL CONTROLLER INDEX                   ; DD011
                                                                                ; DD011
        .ENDC                                                                   ; DD011
                                                                                ; DD011
        TTSET$  YL              ;;;SAVE R2, R3 AND SET UP:                      ; DD011
                                ;;; R3 = CSR ADDRESS                            ;**-1
                                ;;; R4 = KRB ADDRESS
        MOV     K.OWN(R4),R5    ;;;GET UCB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DLINP::                                                                        ; CS013
                                                                                ; DD011
        .IF EQ  D$$L11-1                                                        ; DD011
                                                                                ; DD011
        CLR     R4              ;;;SET UP DL CONTROLLER INDEX                   ; DD011
                                                                                ; DD011
        .ENDC                                                                   ; DD011
                                                                                ; DD011
        TTSET$  DL              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF UCB LIST                    ; CS013
                                                                                ; CS013
        MOV     (R4),R5         ;;;GET UCB ADDRESS                              ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        ADD     #U.TSTA,R5      ;;;POINT TO U.TSTA

        .IFT    ;D$$LMD

        MOV     @R3,R2          ;;;SAVE INTERRUPT STATUS
        BPL     20$             ;;;NO DATASET INTERRUPT - JUMP
        MOV     R2,R4           ;;;GET A COPY
        ASL     R4              ;;;GET RING BIT IN BIT 15
        SWAB    R4              ;;;GET IT IN BIT 7
        CLR     -(SP)           ;;;PUSH DUMMY WORD (TO SET IN U.CW3
                                ;;;IF A CALL IS ANSWERED)
        CALL    MODISR          ;;;CALL COMMON MODEM ISR
20$:    TSTB    R2              ;;;RECEIVER INTERRUPT?
        BPL     10$             ;;;N - EXIT

        .ENDC   ;D$$LMD

        MOV     RBUF(R3),R2     ;;;GET RECEIVED CHARACTER
        CALLR   ICHAR1          ;;;DO COMMON INPUT CHARACTER
                                ;;;PROCESSING AND RETURN
;
        .DSABL  LSB
;
;
;+
; OUTPUT INTERRUPT SERVICE ROUTINE
;-
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$YLOUT::                                                                        ; DD011
                                                                                ; DD011
        .IF EQ  D$$L11-1                                                        ; DD011
                                                                                ; DD011
        CLR     R4              ;;;SET UP DL CONTROLLER INDEX                   ; DD011
                                                                                ; DD011
        .ENDC                                                                   ; DD011
                                                                                ; DD011
        TTSET$  YL              ;;;SAVE R2, R3 AND SET UP:                      ; DD011
                                ;;; R3 = CSR ADDRESS                            ;**-1
                                ;;; R4 = KRB ADDRESS
        MOV     K.OWN(R4),R5    ;;;GET UCB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DLOUT::                                                                        ; CS013
                                                                                ; DD011
        .IF EQ  D$$L11-1                                                        ; DD011
                                                                                ; DD011
        CLR     R4              ;;;SET UP DL CONTROLLER INDEX                   ; DD011
                                                                                ; DD011
        .ENDC                                                                   ; DD011
                                                                                ; DD011
        TTSET$  DL              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF UCB LIST                    ; CS013
                                                                                ; CS013
        MOV     (R4),R5         ;;;GET UCB ADDRESS                              ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        ADD     #U.TSTA,R5      ;;;POINT TO U.TSTA
;
;
;+
; YLSTAX - START OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.TOP+2         BUFFER POINTER
;       U.TOC           BYTE COUNT
;-
;
;
YLSTAX::MOV     #100,R2         ;;;GET BITMASK FOR XMIT INTERRUPT               ;PW026
        BIS     R2,XCSR(R3)     ;;;ENABLE XMIT INTERRUPT                        ;**-1
        CALLR   OUTISR          ;;;DO COMMON OUTPUT INTERRUPT PROCESSING

        .ENDC   ;D$$L11

;
;
        .END
        .TITLE  TTYZ
        .IDENT  /V01.11/
;
; 27-JAN-78 PETER WANNHEDEN
;
; MODIFICATIONS:
;
;       PW026   05-MAY-78       PETER WANNHEDEN
;               MODIFICATIONS TO MOVE DRIVER DATA INTO COMMON BLOCK (TTCOM)
;               WHEN SEPARATE KERNEL DATA SPACE MAPPING IS SUPPORTED.
;       CS013   3-JUN-78        CHUCK SPITZ
;               ADD CONDITIONALS FOR RSX-11M
;       DD010   15-NOV-78       DALE R. DONCHIN
;               ADD SUPPORT FOR ONLINE RECONFIGURATION
;       DD015   28-FEB-79       DALE R. DONCHIN
;               USE TWO STOP BITS FOR SPEEDS LESS THAN 150 BAUD
;
;+
; CONTROLLER-DEPENDENT ROUTINES FOR DZ-11.
;-
;
;

        .IF DF  D$$Z11

; EQUATED SYMBOLS
;
; DZ-11 REGISTER DEFINITIONS
;
CSR     =       0               ;CONTROL AND STATUS REG.
RBUF    =       2               ;RECEIVER BUFFER REG. (READ-ONLY)
LPR     =       2               ;LINE PARAMETER REG. (WRITE-ONLY)
TCR     =       4               ;TRANSMIT CONTROL REG.
MSR     =       6               ;MODEM STATUS REG. (READ-ONLY)
TBUF    =       6               ;TRANSMITTER BUFFER REG. (WRITE-ONLY)
;
;
                                                                                ;**-24
        .ENABL  LSB

        .IF DF  T$$GMC!T$$SMC

;+
; YZLPAR - GET/SET LINE PARAMETERS.
;
; INPUT:
;       R0      BIT 8:  0 = GET SPEED
;                       1 = SET SPEED
;               IF SET SPEED:
;               BITS 0-7: NEW SPEED PARAMETER (S.XXX SYMBOL)
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;
; OUTPUT:
;       IF GET SPEED REQUESTED:
;       R2      BITMASK TO RELEVANT SPEED BITS IN U.CW3
;       R4      POINTER TO DZ11 SPEED TABLE
;       CC-C    0
;
;       IF SET SPEED REQUESTED:
;       CC-C    0 IF OK
;               1 IF ILLEGAL SPEED SPECIFIED
;-
;
;
YZLPAR::MOV     #7400,R2        ;SET UP BITMASK                                 ;PW026
                                                                                ;**-1
        .IF DF  T$$GMC&T$$SMC

        MOV     R0,R4           ;COPY SPEED
        SWAB    R4              ;GET FLAGS IN LOW BYTE
        ASRB    R4              ;GET OR SET SPEED?
        BCS     10$             ;SET - JUMP

        .ENDC   ;T$$GMC&T$$SMC

        .IF DF  T$$GMC

        MOV     #SPDZ,R4        ;POINT TO DZ11 SPEED TABLE
        RETURN                  ;RETURN WITH CC-C = 0

        .ENDC   ;T$$GMC

        .IF DF  T$$SMC

10$:

        .IF NDF T$$GMC

        SEC                     ;ASSUME ILLEGAL SPEED

        .ENDC   ;NOT T$$GMC

        BIC     #177400,R0      ;CLEAR UPPER BYTE
        MOVB    SPDZ-1(R0),R0   ;GET SPEED BITS
        BMI     20$             ;ILLEGAL SPEED - JUMP
        BIC     R2,U.CW3-U.TSTA(R5) ;CLEAR OLD SPEED PARAMETER
        BISB    R0,U.CW3+1-U.TSTA(R5) ;SET NEW SPEED PARAMETER
        BIC     #40,U.CW3-U.TSTA(R5) ;ASSUME ONE STOP BIT FOR NEW SPEED         ; D0015
        CMPB    R0,#2           ;CHECK THAT ASSUMPTION                          ; D0015
        BGT     15$             ;IT WAS CORRECT - JUMP                          ; D0015
        BIS     #40,U.CW3-U.TSTA(R5) ;NOBODY'S PERFECT - SET 2 STOP BITS        ; D0015
15$:                                                                            ; D0015
        MOV     U.CW3-U.TSTA(R5),LPR(R3) ;SET NEW SPEED
        CLC                     ;INDICATE SUCCESS
20$:    RETURN                  ;RETURN

        .ENDC   ;T$$SMC

        .ENDC   ;T$$GMC!T$$SMC

;
;
;+
; YZPWUP - POWER UP.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.STS   SET UP FOR LOCAL LINE:
;               US.CRW  0
;               US.DSB  0
;-
;
;
                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YZCONL::                                                                        ; DD010
YZCPUP::                                                                        ; DD010
                                                                                ; DD010
        .IFF                                                                    ; DD010
                                                                                ; DD010
YZPWUP::TST     R2              ;IS THIS LINE ZERO?                             ;PW026
        BNE     40$             ;N - JUMP                                       ;**-1
                                                                                ; DD010
        .IFTF                                                                   ; DD010
                                                                                ; DD010
        MOV     #20,@R3         ;Y - CLEAR SILO, UARTS, CONTROLLER
30$:    BIT     #20,@R3         ;DONE?
        BNE     30$             ;N - LOOP
        BIS     #40140,@R3      ;Y - ENABLE INTERRUPTS
                                                                                ; DD010
        .IFT                                                                    ; DD010
                                                                                ; DD010
        RETURN                                                                  ; DD010
YZUONL::                                                                        ; DD010
YZUPUP::                                                                        ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
40$:    MOV     U.CW3-U.TSTA(R5),LPR(R3) ;SET INITIAL CHARACTERISTICS
                                         ;IN LINE PARAMETER REGISTER
;
;
;+
; YZMTIM - MODEM TIMER.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;-
;
;
;       LINE MAY HAVE BECOME NON-REMOTE WHILE TIMER WAS
;       RUNNING. IF SO, HANG UP.
;
YZMTIM::                                                                        ;PW026
                                                                                ;**-1
        .IF DF  D$$ZMD

        MOV     $BTMSK(R2),R2   ;GET BIT CORRESPONDING TO THIS LINE
        BIT     #U2.RMT,U.CW2-U.TSTA(R5) ;REMOTE LINE?
        BEQ     60$             ;N - GO AND HANG UP
        INCB    U.TMTI-U.TSTA(R5) ;SET NEW TIMER
        BITB    #US.DSB,U.STS-U.TSTA(R5) ;LINE ENABLED?
        BNE     70$             ;N - JUMP
;
; LINE IS ENABLED. IF CARRIER IS OFF, HANG UP LINE.
;
        BITB    R2,MSR+1(R3)    ;CARRIER ON?
        BNE     80$             ;Y - JUMP
60$:    BICB    R2,TCR+1(R3)    ;N - DROP DTR
        CALLR   MHUP            ;HANG UP
;
; LINE IS DISABLED. SET DTR. IF CARRIER IS ON, ANSWER LINE.
;
70$:    BISB    R2,TCR+1(R3)    ;SET DTR
        BITB    R2,MSR+1(R3)    ;CARRIER ON?
        BEQ     80$             ;N - JUMP
        MOV     #T$$ZAN,-(SP)   ;GET ANSWERING PARAMETERS
        BISB    U.UNIT-U.TSTA(R5),@SP ;MASK IN LINE NUMBER
        MOV     @SP,LPR(R3)     ;LOAD PARAMETERS
        CALL    MANS            ;ANSWER CALL
                                ;NOTE - CANNOT USE "CALLR"!!

        .ENDC   ;D$$ZMD

80$:    RETURN

        .DSABL  LSB

                                                                                ; DD010
        .IF DF  R$$CON                                                          ; DD010
                                                                                ; DD010
YZCOFF::                                                                        ; DD010
        MOV     #20,@R3         ;CLEAR SILO, UARTS, CONTROLLER                  ; DD010
10$:    BIT     #20,@R3         ;DONE?                                          ; DD010
        BNE     10$             ;N - LOOP                                       ; DD010
        RETURN                                                                  ; DD010
YZUOFF::                                                                        ; DD010
        MOV     U.CW3,-(SP)     ;GET LINE PARAMETERS                            ; DD010
        BIC     #10000,@SP      ;DISABLE THIS LINE                              ; DD010
        MOV     (SP)+,LPR(R3)   ;LOAD NEW LINE PARAMETERS                       ; DD010
                                                                                ; DD010
        .IF DF  D$$ZMD                                                          ; DD010
                                                                                ; DD010
        MOV     $BTMSK(R2),R2   ;GET BIT CORRESPONDING TO THIS LINE             ; DD010
        BICB    R2,TCR+1(R3)    ;DROP DTR                                       ; DD010
        RETURN                                                                  ; DD010
                                                                                ; DD010
        .ENDC   ;D$$ZMD                                                         ; DD010
                                                                                ; DD010
        .ENDC   ;R$$CON                                                         ; DD010
                                                                                ; DD010
;
;
;+
; INPUT INTERRUPT SERVICE ROUTINE.
;-
;
;
        .ENABL  LSB
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$YZINP::TTSET$  YZ              ;;;SAVE R2, R3 AND SET UP:
                                ;;; R3 = CSR ADDRESS
                                ;;; R4 = KRB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DZINP::TTSET$  DZ              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF UCB LIST                    ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
        CALL    MUXINP          ;;;DO COMMON MULTIPLEXER INPUT
                                ;;;CHARACTER PROCESSING
                                ;;;MUXINP DISMISSES INTERRUPT IF NO OUTPUT WORK
        BR      10$             ;;;XMIT READY - GO DO OUTPUT WORK
;
;
;+
; OUTPUT INTERRUPT SERVICE ROUTINE.
;-
;
;
                                                                                ; CS013
        .IF DF R$$MPL                                                           ; CS013
                                                                                ; CS013
$YZOUT::TTSET$  YZ              ;;;SAVE R2, R3 AND SET UP:
                                ;;; R3 = CSR ADDRESS
                                ;;; R4 = KRB ADDRESS
                                                                                ; CS013
        .IFF    ;R$$MPL                                                         ; CS013
                                                                                ; CS013
$DZOUT::TTSET$  DZ              ;;;SAVE R2,R3 AND SET UP                        ; CS013
                                ;;; R3 = CSR                                    ; CS013
                                ;;; R4 = ADDRESS OF UCB LIST                    ; CS013
                                                                                ; CS013
        .ENDC   ;R$$MPL                                                         ; CS013
                                                                                ; CS013
10$:    MOV     R3,-(SP)        ;;;
        INC     @SP             ;;;POINT TO BYTE CONTAINING
                                ;;;INTERRUPTING LINE NUMBER (CSR HIGH BYTE)
        CALL    JZOUT           ;;;DO OUTPUT INTERRUPT PROCESSING
                                ;;;(COMMON FOR DJ-11 AND DZ-11)
        TST     (SP)+           ;;;CLEAN STACK
;
;
;+
; YZABOX - ABORT OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       U.TOC           0
;       U.TTOC          0
;
; YZSTOX - STOP OUTPUT.
;
; INPUT:
;       REGISTERS R2-R5 STANDARD FOR CONTROLLER-DEPENDENT ROUTINE.
;       S1.CTS          1
;-
;
;
YZABOX::                                                                        ;PW026
YZSTOX::RETURN                  ;;;RETURN                                       ;PW026
;                                                                               ;**-2
        .DSABL  LSB

        .ENDC   ;D$$Z11

;
;
        .END
        .IIF  DF M$$MGE!U$$DCM .TITLE UDCOM
        .IIF NDF M$$MGE&U$$DCM .TITLE UDCDF
        .IDENT  /01/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; VERSION 01
;
; C. MONIA 17-JUL-74
;
; ALLOCATE UDC COMMON BLOCK AND DEFINE OFFSETS FOR MODULE TYPES
;
; LOCAL MACROS
;
; DEFINE STORAGE AND OFFSETS FOR UDC-11 MODULES
;
; DFUDC TYP
;
; WHERE:
;
;       TYP = GENERIC MODULE TYPE. ONE OF THE FOLLOWING
;             RECOGNIZED:
;
;       'ADM' - ADU01 A/D CONVERTER
;       'AOM' - ANALOG OUTPUT MODULE
;       'CIM' - CONTACT INTERRUPT MODULE
;       'CSM' - CONTACT SENSE MODULE
;       'LTM' - LATCHING MODULE
;       'SSM' - SINGLE SHOT DIGITAL OUTPUT
;       'TIM' - TIMER MODULE
;
; THE SYMBOL "U$$'TYP", IF DEFINED, ENCODES THE FOLLOWING
; INFORMATION:
;
;       BITS 15 - 8 = NUMBER OF MODULES
;       BITS 7 - 0  = RELATIVE MODULE NUMBER
;
; THIS MACRO GENERATES GLOBAL CONSTANTS OF THE FOLLWING FORMS
; FOR EACH GENERIC MODULE TYPE:
;
;       $.'TYP = STARTING ADDRESS OF MODULE TYPE
;       M$.'TYP = HIGHEST RELATIVE MODULE NUMBER
;       P$.'TYP = HIGHEST ALLOWABLE POINT NUMBER
;
 
        .MACRO  DFUDC   TYP
        .IF     DF      U$$'TYP
...PC=<U$$'TYP&377>*2
.=UDCBA
        .BLKB   ...PC
...SIZ=<U$$'TYP/256.>&377
$.'TYP::        .BLKW   ...SIZ
M$.'TYP==<...SIZ>-1
P$.'TYP==<...SIZ*16.>-1
        .ENDC
        .ENDM
 
;+
; **-UDCOM-MODULE TO ALLOCATE UDC-11 COMMON BLOCK STORAGE, DEFINE UDC
;          MODULE OFFSETS.
;
; THIS MODULE, WHEN ASSEMBLED WITH PREFIX FILE RSXMC.MAC, WILL:
;
;       (1) GENERATE SYMBOLIC ADDRESSES AND LENGTHS FOR GENERIC
;           UDC MODULE TYPES
;
;       (2) IF 'M$$MGE' OR 'U$$DCM' IS DEFINED ALLOCATE STORAGE FOR
;            THE UDC GLOBAL COMMON BLOCK
;
; THE GLOBAL COMMON AREA RESIDES IN  A RELOCATABLE PROGRAM SECTION
; NAMED 'UDCOM' HAVING  '.CSECT' ATTRIBUTES (IE. 'GBL', 'OVR', 'I'). IN
; THIS CASE THE SYMBOLIC OFFSETS ARE RELOCATABLE. THE NAMED
; SECTION MAY BE REFERENCED DIRECTLY BY THE FORTRAN PROGRAM.
;
; IF THE COMMON AREA IS NOT TO BE GENERATED . THEN
; THE OFFSETS ARE ABSOLUTE LOCATIONS ON THE EXTERNAL PAGE.  IN THIS CASE
; DIRECT FORTRAN ACCESS IS NOT POSSIBLE.
;
; THE VARIABLE 'M$$MGE' IS DEFINED IN 'RSXMC.MAC' IF MEMORY MANAGE-
; MENT IS PRESENT.
;
;
;-
 
        .IF     DF      M$$MGE!U$$DCM
 
        .PSECT  UDCOM,GBL,D,OVR
 
        .IFF
 
        .PSECT  $$UDAB,ABS
 
        .BLKB   171000
 
        .ENDC
 
UDCBA=.                         ; REF LABEL
 
        DFUDC   ADM             ; DEFINE ANALOG INPUT CONFIGURATION
        DFUDC   AOM             ; DEFINE ANALOG  OUTPUT CONFIGURATION
        DFUDC   CIM             ; DEFINE CONTACT INTERRUPT CONFIGURATION
        DFUDC   CSM             ; DEFINE CONTACT SENSE CONFIGURATION
        DFUDC   LTM             ; DEFINE LATCHING MODULE CONFIGURATION
        DFUDC   SSM             ; DEFINE SINGLE SHOT CONFIGURATION
        DFUDC   TIM             ; DEFINE TIMER MODULE CONFIGURATION
 
        .END
        .TITLE  UDDRV
        .IDENT  /07/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 07
;
; D. N. CUTLER 20-FEB-74
;
; PREVIOUSLY MODIFIED BY:
;
;       D. N. CUTLER
;       T. J. MILLER
;       C. A. MONIA
;
; MODIFIED BY:
;
;       C. A. MONIA 03-MAR-77
;
;               CM085 -- CLEAR OUT SCAN ERROR INDICATIONS CORRECTLY
;
; UDC11 UNIVERSAL DIGITAL INPUT/OUTPUT CONTROLLER
;
; NOTE: THIS IS A SINGLE CONTROLLER DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$,PKTDF$,TCBDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        TCBDF$                  ;DEFINE TASK CONTROL BLOCK OFFSETS
 
;
; EQUATED SYMBOLS
;
; UDC11 HARDWARE REGISTER DEFINITIONS
;
 
UDCR=171776                     ;ADDRESS OF UDC11 CSR
UDSR=171774                     ;ADDRESS OF UDC11 SCAN REGISTER
UDMD=171000                     ;ADDRESS OF FIRST FUNCTIONAL MODULE
 
;
; MODULE TABLE AND INTERUPT CONTROL BLOCK OFFSET DEFINITIONS
;
 
MDCNT=0                         ;NUMBER OF POINTS OR MODULES
MDBAS=2                         ;ADDRESS IN I/O PAGE OF FIRST MODULE
NMBYT=4                         ;NUMBER OF BYTES OF INTERRUPT DATA
STATS=5                         ;FORK STATUS BYTE (0=FORK IN PROGRESS)
STRBF=6                         ;STARTING BUFFER RELOCATION BIAS
CURBF=10                        ;CURRENT BUFFER RELOCATION BIAS
BUFAD=12                        ;ADDRESS OF START OF BUFFER
CURNX=20                        ;CURRENT FORTRAN BUFFER FILL INDEX
BFLGH=22                        ;LENGTH OF BUFFER IN WORDS
EFNMK=24                        ;EVENT FLAG MASK WORD
EFNAD=26                        ;EVENT FLAG MASK ADDRESS
LSCNT=30                        ;LOST DATA COUNT
CONTK=32                        ;TCB ADDRESS OF CONNECTED TASK
FRBLK=34                        ;INTERRUPT FORK BLOCK (3 WORDS)
 
;
; LOCAL DATA
;
; UDC11 UCB ADDRESS
;
 
UDUCB:  .BLKW   1               ;SAVED UCB ADDRESS
 
;
; A/D MODULE TABLE
;
 
 
        .IF DF  U$$ADM
 
ADTBL:  .WORD   <<U$$ADM/256.>&377>*U$$ACH ;NUMBER OF A/D CHANNELS
        .WORD   UDMD+<<U$$ADM&377>*2> ;ADDRESS OF BASE MODULE
ADMOD:  .BLKW   1               ;INTERRUPT MODULE ADDRESS
 
        .ENDC
 
 
;
; CONTACT INTERRUPT MODULE TABLE, INTERRUPT CONTROL BLOCK, AND PREVIOUS STATE TA
;
;
 
 
        .IF DF  U$$CIM
 
CITBL:  .WORD   <<U$$CIM/256.>&377>*16. ;NUMBER OF CONTACT INTERRUPT POINTS
        .WORD   UDMD+<<U$$CIM&377>*2> ;ADDRESS OF BASE MODULE
        .WORD   5*2             ;NUMBER OF BYTES OF INTERRUPT DATA
        .BLKB   FRBLK+4-NMBYT   ;INTERRUPT CONTROL BLOCK
CIPRV:  .BLKW   <U$$CIM/256.>&377 ;CONTACT POINT PREVIOUS STATE TABLE
 
        .ENDC
 
 
;
; LATCHING OUTPUT MODULE TABLE
;
 
 
        .IF DF  U$$LTM
 
LTTBL:  .WORD   <<U$$LTM/256.>&377>*16. ;NUMBER OF LATCHING OUTPUT POINTS
        .WORD   UDMD+<<U$$LTM&377>*2> ;ADDRESS OF BASE MODULE
LTPRV:  .BLKW   <U$$LTM/256.>&377 ;LATCHING OUTPUT PREVIOUS STATE TABLE
 
        .ENDC
 
 
;
; TIMER INTERRUPT MODULE TABLE, INTERRUPT CONTROL BLOCK, AND INITIAL VALUE TABLE
;
 
 
        .IF DF  U$$TIM
 
TMTBL:  .WORD   <<U$$TIM/256.>&377> ;NUMBER OF TIMER INTERRUPT MODULES
        .WORD   UDMD+<<U$$TIM&377>*2> ;ADDRESS OF BASE MODULE
        .WORD   4*2             ;NUMBER OF BYTES OF INTERRUPT DATA
        .BLKB   FRBLK+4-NMBYT   ;INTERRUPT CONTROL BLOCK
TMINI:  .BLKW   <<U$$TIM/256.>&377> ;INITIAL TIMER VALUE TABLE
 
        .ENDC
 
;
; DRIVER DISPATCH TABLE
;
 
$UDTBL::.WORD   UDCHK           ;DEVICE INITIATOR ENTRY POINT
        .WORD   UDCAN           ;CANCEL I/O OPERATION ENTRY POINT
        .WORD   UDOUT           ;DEVICE TIMEOUT ENTRY POINT
        .WORD   UDPWF           ;POWERFAIL ENTRY POINT
 
;+
; **-UDCHK-UDC11 UNIVERSAL DIGITAL INPUT/OUTPUT CONTROLLER PARAMETER CHECKING
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O
; REQUEST IS RECEIVED FOR THE UDC11 UNIVERSAL DIGIT INPUT/OUTPUT
; CONTROLLER. UDC11 I/O REQUESTS CONTAIN DEVICE DEPENDENT INFORMA-
; ATION THAT MUST BE CHECKED IN THE CONTEXT OF THE ISSUING TASK.
; THEREFORE THE I/O REQUEST IS NOT QUEUED BEFORE CALLING THE DRIVER.
;
; INPUTS:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       DEPENDENT UPON FUNCTION TO BE PERFORMED.
;
; UDC11 FUNCTION INDEPENDENT I/O PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE .
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;-
 
UDCHK:  MOV     R1,-(SP)        ;SAVE I/O PACKET ADDRESS
        MOV     I.TCB(R1),R0    ;GET TCB ADDRESS OF REQUESTER TASK
        MOVB    I.FCN+1(R1),R2  ;GET I/O FUNCTION CODE
        ADD     #I.PRM,R1       ;POINT TO FIRST I/O PARAMETER
 
 
        .IF DF  U$$CIM
 
        MOV     #CITBL,R3       ;ASSUME CONTACT INTERRUPT FUNCTION
        CMPB    #IO.CCI/256.,R2 ;CONNECT CONTACT INTERRUPTS?
        BEQ     UDCNT           ;IF EQ YES
        CMPB    #IO.DCI/256.,R2 ;DISCONNECT CONTACT INTERRUPTS?
        BEQ     UDDIS           ;IF EQ YES
 
        .ENDC
 
 
        .IF DF  U$$TIM
 
        MOV     #TMTBL,R3       ;ASSUME TIMER FUNCTION
        CMPB    #IO.CTI/256.,R2 ;CONNECT TIMER INTERRUPTS?
        BEQ     UDCNT           ;IF EQ YES
        CMPB    #IO.DTI/256.,R2 ;DISCONNECT TIMER INTERRUPTS?
        BEQ     UDDIS           ;IF EQ YES
        CMPB    #IO.ITI/256.,R2 ;INITIALIZE TIMER MODULE?
        BEQ     UDITM           ;IF EQ YES
 
        .ENDC
 
 
        .IF DF  U$$LTM
 
        CMPB    #IO.MLO/256.,R2 ;MULTILATCHING DIGITAL OUTPUT?
        BEQ     UDLTM           ;IF EQ YES
 
        .ENDC
 
 
        .IF DF  U$$ADM
 
        CMPB    #IO.RBC/256.,R2 ;READ BUFFERED A/D MODULES?
 
        .IFTF
 
        BNE     UDIFC           ;IF NE NO ILLEGAL FUNCTION
 
        .IFT
 
        JMP     UDRAD           ;
 
        .ENDC
 
 
;+
; **-UDCNT-CONNECT TASK TO INTERRUPTS
;
; FUNCTION DEPENDENT I/O REQUEST PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER.
;       WD. 13 -- DATA BUFFER ADDRESS.
;       WD. 14 -- NUMBER OF BYTES IN DATA BUFFER.
;       WD. 15 -- TRIGGER EVENT FLAG NUMBER.
;       WD. 16 -- INITIAL TIMER BUFFER (IO.CTI ONLY).
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;-
 
 
        .IF DF  U$$CIM!U$$TIM
 
UDCNT:  BIT     #T2.CHK!T2.FXD,T.ST2(R0) ;TASK FXD OR NOT CHKPOINTABLE?
        BEQ     UDPRI           ;IF EQ NO
        TST     CONTK(R3)       ;ANOTHER TASK ALREADY CONNECTED?
        BNE     UDCON           ;IF NE YES
        CMP     (R1)+,(R1)+     ;POINT TO DATA BUFFER SIZE
        MOVB    NMBYT(R3),R0    ;GET NUMBER OF BYTES OF INTERRUPT DATA
        CMP     (R0)+,(R0)+     ;ADJUST FOR BUFFER HEADER
        CMP     (R1)+,R0        ;BUFFER BIG ENOUGH?
        BLO     UDSPC           ;IF LO NO
        MOV     (R1)+,R0        ;GET EVENT FLAG NUMBER
        BEQ     UDIEF           ;IF EQ NO EVENT FLAG SPECIFIED
        CMP     R0,#64.         ;LEGAL EVENT FLAG NUMBER?
        BHI     UDIEF           ;IF HI NO
 
 
        .IF DF  U$$TIM
 
        CMP     #TMTBL,R3       ;TIMER CONNECT?
        BNE     20$             ;IF NE NO
        MOV     (R1),R0         ;GET ADDRESS OF INITIAL VALUE BUFFER
        MOV     (R3)+,R4        ;GET NUMBER OF TIMER MODULES
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     R4,R1           ;SET NUMBER OF TIMER MODULES
        ASL     R1              ;CONVERT TO BYTE COUNT
        CALL    $ACHCK          ;ADDRESS CHECK INITIAL VALUE BUFFER
        BCS     UDSPC           ;IF CS ILLEGAL BUFFER
 
        .ENDC
 
 
        .IF DF  M$$MGE
 
        CALL    $RELOM          ;RELOCATE AND MAP TO INITIAL VALUE BUFFER
 
        .ENDC
 
 
        BIC     #36,UDCR        ;DISABLE UDC INTERRUPTS
        MOV     (R3),R1         ;GET ADDRESS OF FIRST TIMER MODULE
        MOV     #TMINI,R2       ;GET ADDRESS OF INITIAL VALUE TABLE
10$:    MOV     (R0)+,(R2)      ;SET VALUE IN INITIAL VALUE TABLE
        BIS     #1,UDCR         ;SET RIF BIT
        MOV     (R2)+,(R1)+     ;SET COUNTER VALUE AND RESET MODULE
        BIC     #1,UDCR         ;CLEAR RIF BIT
        DEC     R4              ;ANY MORE INITIALIZE?
        BGT     10$             ;IF GT YES
        TST     -(R3)           ;POINT TO MODULE COUNT
 
        .IFTF
 
20$:    MOV     (SP),R4         ;RETRIEVE ADDRESS OF I/O PACKET
        MOV     R5,-(SP)        ;SAVE ADDRESS OF UCB
        MOV     I.TCB(R4),R5    ;GET REQUESTER TASK TCB ADDRESS
        ADD     #I.PRM,R4       ;POINT TO FIRST I/O PARAMETER
        ADD     #NMBYT,R3       ;POINT TO NUMBER OF BYTES OF INT DATA
        MOVB    (R3)+,(R3)+     ;SET FORK NOT IN PROGRESS
        MOV     (R4)+,(R3)      ;INSERT STARTING BUFFER RELOCATION BIAS
        MOV     (R3)+,(R3)+     ;COPY STARTING BUFFER RELOCATION BIAS
        MOV     (R4)+,(R3)      ;INSERT STARTING BUFFER ADDRESS
        MOV     (R3)+,(R3)      ;COPY STARTING BUFFER ADDRESS
        ADD     #4,(R3)         ;CALCULATE ADDRESS OF FIRST DATA WORD
        MOV     (R3)+,(R3)+     ;COPY ADDRESS OF FIRST DATA WORD
        MOV     #3,(R3)+        ;SET CURRENT FORTRAN INDEX
        MOV     (R4)+,(R3)      ;GET SIZE OF BUFFER IN BYTES
        ROR     (R3)+           ;CONVERT TO SIZE IN WORDS
        MOV     (R4),R0         ;GET EVENT FLAG NUMBER
        CALL    $CEFI           ;CONVERT TO MASK AND MASK ADDRESS
        MOV     R0,(R3)+        ;INSERT EVENT FLAG MASK
        MOV     R1,(R3)+        ;INSERT EVENT FLAG MASK ADDRESS
        BIC     R0,(R1)         ;CLEAR EVENT FLAG
        CLR     (R3)+           ;CLEAR LOST DATA COUNT
        MOV     R5,(R3)+        ;CONNECT TASK TO INTERRUPTS
        INCB    T.IOC(R5)       ;BIAS TASK'S OUTSTANDING I/O COUNT
 
        .IF DF  D$$SHF
 
        MOV     T.PCB(R5),R1    ;GET ADDRESS OF TASK PCB
        BIS     #PS.NSF,P.STAT(R1) ;DISABLE TASK SHUFFLING
 
        .ENDC
 
        MOV     (SP)+,R5        ;RETRIEVE ADDRESS OF UCB
        MOVB    NMBYT-FRBLK(R3),R1 ;GET NUMBER OF BYTES OF INTERRUPT DATA
        ASR     R1              ;CONVERT TO WORD COUNT
        DEC     R1              ;ADJUST FOR EXISTANCE INDICATOR
        BIS     #3*256.,R1      ;INSERT INITIAL FORTRAN INDEX
        
        .IFT
        
        BIS     #36,UDCR        ;ENABLE UDC INTERRUPTS
        
        .ENDC
        
        
        BR      UDSUC1          ;
 
        .ENDC
 
 
        .IF DF  U$$LTM
 
UDLTM:  BR      UDLAT           ;MULTILATCHING OUTPUT
 
        .ENDC
 
 
;+
; **-UDDIS-DISCONNECT TASK FROM INTERRUPTS
;
; FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- NOT USED.
;       WD. 13 -- NOT USED.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;-
 
 
        .IF DF  U$$CIM!U$$TIM
 
UDDIS:  CALL    UDCAN1          ;DISCONNECT TASK FROM INTERRUPTS
        BCC     UDSUC           ;IF CC OKAY
 
;
; ILLEGAL CONNECT/DISCONNECT TO/FROM INTERRUPTS
;
 
UDCON:  MOV     #IE.CON&377,R0  ;SET ILLEGAL CONNECT/DISCONNECT STATUS
        BR      UDCMN           ;
 
;
; ILLEGAL EVENT FLAG NUMBER
;
 
UDIEF:  MOV     #IE.IEF&377,R0  ;SET ILLEGAL EVENT FLAG STATUS
        BR      UDCMN           ;
 
;
; PRIVILEGE VIOLATION
;
 
UDPRI:  MOV     #IE.PRI&377,R0  ;SET PRIVILEGE VIOLATION STATUS
        BR      UDCMN           ;
 
        .ENDC
 
 
;
; ILLEGAL FUNCTION
;
 
UDIFC:  MOV     #IE.IFC&377,R0  ;SET ILLEGAL FUNCTION STATUS
        BR      UDCMN           ;
 
;
; ILLEGAL BUFFER SPECIFICATION
;
 
 
        .IF DF  U$$ADM!U$$CIM!U$$TIM
 
UDSPC:  MOV     #IE.SPC&377,R0  ;SET ILLEGAL BUFFER STATUS
        BR      UDCMN           ;
 
        .ENDC
 
 
;+
; **-UDITM-INITIALIZE TIMER VALUE
;
; FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- RELATIVE MODULE NUMBER.
;       WD. 13 -- NEW TIMER VALUE.
;       WD. 14 -- NOT USED.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;-
 
 
        .IF DF  U$$TIM
 
UDITM:  CMP     R0,CONTK(R3)    ;CURRENT TASK CONNECTED TO TIMER INTERRUPTS?
        BNE     UDIFC           ;IF NE NO
        MOV     (R1)+,R2        ;GET RELATIVE MODULE NUMBER
        CMP     R2,(R3)+        ;LEGAL TIMER MODULE?
        BHIS    UDMOD           ;IF HIS NO
        ASL     R2              ;CONVERT TO WORD INDEX
        MOV     (R1),TMINI(R2)  ;SET NEW TIMER PRESET VALUE
        ADD     (R3),R2         ;CALCULATE ADDRESS OF TIMER MODULE
        MOVB    #PR6,PS         ;;;LOCKOUT DEVICE INTERRUPTS
        BIS     #1,UDCR         ;;;SET RIF BIT
        MOV     (R1),(R2)       ;;;SET TIMER VALUE AND RESET MODULE
        BIC     #1,UDCR         ;;;RESET RIF BIT
        CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
        BR      UDSUC           ;
 
        .ENDC
 
 
;+
; **-UDLAT-MULTIPLE LATCHING OUTPUT
;
; FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- STARTING RELATIVE RELAY POINT NUMBER.
;       WD. 13 -- DATA MASK WORD.
;       WD. 14 -- DATA VALUE.
;       WD. 15 -- NOT USED.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;-
 
        .IF DF  U$$LTM
 
UDLAT:  MOV     (R1)+,R0        ;GET STARTING RELATIVE RELAY POINT NUMBER
        CMP     R0,LTTBL+MDCNT  ;LEGAL STARTING POINT NUMBER?
        BHIS    UDMOD           ;IF HIS NO
        BIT     #17,R0          ;ALL POINTS WITHIN ONE MODULE?
        BNE     UDMOD           ;IF NE NO
        ASR     R0              ;CONVERT STARTING POINT NUMBER TO
        ASR     R0              ;RELATIVE INDEX
        ASR     R0              ;
        MOV     LTPRV(R0),R4    ;GET LAST DATA WRITTEN
        BIC     (R1),R4         ;CLEAR BITS TO BE WRITTEN
        COM     (R1)            ;COMPLEMENT MASK WORD
        BIC     (R1)+,(R1)      ;CLEAR EXTRANEOUS BITS IN DATA WORD
        BIS     (R1),R4         ;MERGE NEW DATA WITH LAST WRITTEN
        MOV     R4,LTPRV(R0)    ;SAVE RESULT AS LAST DATA WRITTEN
        ADD     LTTBL+MDBAS,R0  ;CALCULATE ADDRESS OF OUTPUT MODULE
        MOV     R4,(R0)         ;OUTPUT NEW VALUE
 
        .ENDC
 
 
;
; SUCCESSFUL COMPLETION
;
 
UDSUC:  CLR     R1              ;CLEAR SECOND I/O STATUS WORD
UDSUC1: MOV     #IS.SUC&377,R0  ;SET SUCCESSFUL COMPLETION STATUS
        BR      UDCMN1          ;
 
;
; BAD MODULE NUMBER
;
 
 
        .IF DF  U$$LTM!U$$TIM
 
UDMOD:  MOV     #IE.MOD&377,R0  ;SET BAD MODULE NUMBER STATUS
 
        .ENDC
 
 
;
; COMMON FUNCTION EXIT
;
 
UDCMN:  CLR     R1              ;CLEAR SECOND I/O STATUS WORD
UDCMN1: MOV     (SP)+,R3        ;RETRIEVE I/O PACKET ADDRESS
        CALLR   $IOFIN          ;FINISH I/O OPERATION
 
;+
; **-UDRAD-READ A/D CHANNELS
;
; FUNCTION DEPENDENT I/O PACKET FORMAT:
;
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER.
;       WD. 13 -- DATA BUFFER ADDRESS.
;       WD. 14 -- NUMBER OF BYTES IN DATA BUFFER.
;       WD. 15 -- CONTROL BUFFER ADDRESS.
;       WD. 16 -- NOT USED.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;-
 
 
        .IF DF  U$$ADM
 
UDRAD:  MOV     6(R1),R0        ;GET VIRTUAL ADDRESS OF CONTROL BUFFER
 
 
        .IF DF  A$$CHK!M$$MGE
 
        MOV     4(R1),R1        ;SET LENGTH OF BUFFER TO CHECK
        CALL    $ACHCK          ;ADDRESS CHECK CONTROL BUFFER
        BCS     UDSPC           ;IF CS ADDRESS CHECK FAILURE
 
        .ENDC
 
 
        MOV     (SP)+,R3        ;RETRIEVE ADDRESS OF I/O PACKET
        CALL    $RELOC          ;RELOCATE CONTROL BUFFER ADDRESS
        MOV     R1,I.PRM+6(R3)  ;SET RELOCATION BIAS OF CONTROL BUFFER
        MOV     R2,I.PRM+10(R3) ;SET ADDRESS OF CONTROL BUFFER
        MOV     R3,R1           ;SET ADDRESS OF I/O PACKET
        MOV     R4,R0           ;SET ADDRESS OF I/O LISTHEAD
        CALL    $QINSP          ;INSERT I/O PACKET IN REQUEST QUEUE
 
;+
; **-UNINI-UDC11 ANALOG TO DIGITAL CONVERSION INITIATOR
;
; THIS ROUTINE IS ENTERED FROM THE QUEUE I/O DIRECTIVE WHEN AN I/O REQUEST
; IS QUEUED AND AT THE END OF A PREVIOUS I/O OPERATION TO PROPAGATE THE EXECU-
; TION OF THE DRIVER. IF THE SPECIFIED CONTROLLER IS NOT BUSY, THEN AN ATTEMPT
; IS MADE TO DEQUE THE NEXT I/O REQUEST. ELSE A RETURN TO THE CALLER IS EXE-
; CUTED. IF THE DEQUEUE ATTEMPT IS SUCCESSFUL, THEN THE NEXT I/O OPERATION
; IS INITIATED. A RETURN TO THE CALLER IS THEN EXECUTED.
;
; INPUTS:
;
;       R5=ADDRESS OF THE UNIT CONTROL BLOCK.
;
; OUTPUTS:
;
;       IF THE SPECIFIED CONTROLLER IS NOT BUSY AND AN I/O REQUET IS WAIT-
;       ING TO BE PROCESSED, THEN THE REQUEST IS DEQUEUED AND THE I/O OPER-
;       ATION IS INITIATED.
;-
 
        .ENABL  LSB
UDINI:  CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     20$             ;IF CS CONTROLLER BUSY OR NO REQUEST
 
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1=ADDRESS OF THE I/O REQUEST PACKET.
;       R2=PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3=CONTROLLER INDEX.
;       R4=ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5=ADDRESS OF THE UCB OF THE UDC11 CONTROLLER.
;
; UDC11 A/D CONVERSION I/O REQUEST PACKET FORMAT:
;
;       WD. 00 -- I/O QUEUE THREAD WORD.
;       WD. 01 -- REQUEST PRIORITY, EVENT FLAG NUMBER.
;       WD. 02 -- ADDRESS OF THE TCB OF THE REQUESTER TASK.
;       WD. 03 -- POINTER TO SECOND LUN WORD IN REQUESTER TASK HEADER.
;       WD. 04 -- CONTENTS OF THE FIRST LUN WORD IN REQUESTER TASK HEADER (UCB).
;       WD. 05 -- I/O FUNCTION CODE (IO.RBC).
;       WD. 06 -- VIRTUAL ADDRESS OF I/O STATUS BLOCK.
;       WD. 07 -- RELOCATION BIAS OF I/O STATUS BLOCK.
;       WD. 10 -- I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT + 140000).
;       WD. 11 -- VIRTUAL ADDRESS OF AST SERVICE ROUTINE.
;       WD. 12 -- RELOCATION BIAS OF DATA BUFFER.
;       WD. 13 -- DATA BUFFER ADDRESS.
;       WD. 14 -- NUMBER OF BYTES IN DATA BUFFER.
;       WD. 15 -- RELOCATION BIAS OF CONTROL BUFFER.
;       WD. 16 -- CONTROL BUFFER ADDRESS.
;       WD. 17 -- NOT USED.
;       WD. 20 -- NOT USED.
;
; THE DATA BUFFER RECEIVES CONVERTED VALUES AND THE CONTROL BUFFER CONTAINS
; CONTROL WORDS THAT CONTROL THE CONVERSION PROCESS. EACH WORD IN THE CONTROL
; BUFFER HAS THE FORMAT:
;
;       BITS 15-12 -- GAIN CODE.
;
;               LEGAL GAIN CODES ARE:
;
;               0000=GAIN OF 1.
;               0001=GAIN OF 2.
;               0100=GAIN OF 10.
;               0101=GAIN OF 20.
;               1000=GAIN OF 50.
;               1001=GAIN OF 100.
;               1100=GAIN OF 200.
;               1101=GAIN OF 1000.
;
;       BITS 11-0 -- CHANNEL NUMBER.
;
;               EACH UDC11 MAY HAVE 2016. CHANNELS. THE LEGALITY OF
;               A PARTICULAR CHANNEL NUMBER IS DETERMINED BY THE A/D
;               MODULE TABLE DISCRIPTOR.
;
; EACH CHANNEL IS CONVERTED ACCORDING TO THE CORRESPONDING WORD IN THE CONTROL
; BUFFER AND THE RESULTANT VALUE IS PLACED IN THE DATA BUFFER. IF AN ILLEGAL
; CONTROL WORD IS DETECTED THEN THE CONVERSION PROCESS IS TERMINATED. THE SECOND
; I/O STATUS WORD SPECIFIES THE NUMBER OF CHANNELS THAT WERE CONVERTED.
;-
 
        MOV     I.PRM+6(R1),U.CBF(R5) ;SET RELOCATION BIAS OF CONTROL BUFFER
        MOV     I.PRM+10(R1),U.CBF+2(R5) ;SET ADDRESS OF CONTROL BUFFER
 
;
; INITIATE I/O OPERATION
;
 
10$:    CALL    $GTCWD          ;GET NEXT WORD FROM CONTROL BUFFER
        MOV     #IE.BAD&377,R0  ;ASSUME ILLEGAL GAIN OR CHANNEL
        MOV     (SP)+,R1        ;RETRIEVE CONTROL WORD
        MOV     R1,R2           ;COPY CONTROL WORD
        BIC     #170000,R1      ;CLEAR GAIN CODE BITS
        CMP     R1,ADTBL+MDCNT  ;LEGAL CHANNEL NUMBER?
        BHIS    30$             ;IF HIS NO
        BIC     R1,R2           ;CLEAR CHANNEL NUMBER BITS
        ASL     R2              ;ISOLATE GAIN CODE BY DROPPING BIT 13
        ROL     R2              ;
        ROL     R2              ;
        BCS     30$             ;IF CS ILLEGAL GAIN CODE
        ASRB    R2              ;DROP BIT 13
        ROR     R2              ;SHIFT BITS 15 AND 14 BACK INTO PLACE
        ROR     R2              ;
        SEC                     ;SET CARRY
        ROR     R2              ;SHIFT CARRY INTO START CONVERSION
        MOV     R1,R0           ;COPY CHANNEL NUMBER
        
        
        .IF EQ  U$$ACH-8.
        
        ASR     R0              ;ISOLATE AND MERGE CHANNEL NUMBER
        RORB    R2              ;WITH GAIN CODE
        ASR     R0              ;
        RORB    R2              ;
        ASR     R0              ;
        RORB    R2              ;
        RORB    R2              ;SHIFT CHANNEL NUMBER INTO POSITION
        
        .IFF
        
        MOV     #U$$ACH,R1      ;GET NUMBER OF CHANNELS PER MODULE
        CALL    $DIV            ;CALCULATE MODULE AND CHANNEL NUMBER
        ADD     #8.,R1          ;BIAS CHANNEL NUMBER BY 8.
        ASL     R1              ;SHIFT CHANNEL NUMBER INTO POSITION
        ASL     R1              ;
        ASL     R1              ;
        ASL     R1              ;
        BIS     R1,R2           ;MERGE CHANNEL NUMBER WITH GAIN CODE
        ASL     R0              ;CONVERT TO IAD-IA MODULE INDEX
        ASL     R0              ;
        ASL     R0              ;
        
        .ENDC
        
        
        ASL     R0              ;CONVERT MODULE NUMBER TO WORD INDEX
        ADD     ADTBL+MDBAS,R0  ;CALCULATE ADDRESS OF A/D  MODULE
        MOVB    S.ITM(R4),S.CTM(R4) ;SET TIMEOUT COUNT
        MOV     R0,ADMOD        ;SAVE ADDRESS OF A/D MODULE
        MOV     R2,(R0)         ;START CONVERSION
20$:    RETURN                  ;
 
;+
; **-UDADI-UDC11 ANALOG TO DIGITAL CONVERSION INTERRUPT
;-
 
UDADI:  TST     (SP)+           ;;;REMOVE GENERIC CODE FROM STACK
        MOV     (SP)+,R2        ;;;RESTORE R2 AND R3
        MOV     (SP)+,R3        ;;;
        CMP     R5,ADMOD        ;;;CORRECT MODULE INTERRUPT?
        BNE     40$             ;;;IF NE NO
        CLR     ADMOD           ;;;CLEAR A/D MODULE ADDRESS
        MOV     UDUCB,R5        ;;;RETRIEVE ADDRESS OF UCB
        CALL    $FORK           ;;;CREATE A SYSTEM PROCESS
        MOV     R4,-(SP)        ;SET CONVERTED DIGITAL VALUE
        MOV     U.SCB(R5),R4    ;GET ADDRESS OF SCB
        CALL    $PTWRD          ;PUT CONVERTED VALUE IN DATA BUFFER
        SUB     #2,U.CNT(R5)    ;ANY MORE TO CONVERT?
        BGT     10$             ;IF GT YES
        MOV     #IS.SUC&377,R0  ;
 
;
; DEVICE TIMEOUT RESULTS IN THE CURRENT OPERATION BEING TERMINATED WITH A FINAL
; I/O STATUS OF DEVICE NOT READY, THE SECOND I/O STATUS WORD CONTAINS THE NUM-
; BER OF CHANNELS THAT WERE SAMPLED BEFORE THE TIMEOUT OCCURRED. TIMEOUTS ARE
; USUALLY CAUSED BY POWERFAILURE BUT MAY ALSO BE THE RESULT OF A HARDWARE
; FAILURE.
;
 
        .IFTF
 
UDOUT:                          ;;;REF LABEL
 
        .IFT
 
        CLR     ADMOD           ;;;CLEAR A/D MODULE ADDRESS
        CLRB    PS              ;;;ALLOW DEVICE INTERRUPTS
30$:    MOV     S.PKT(R4),R3    ;GET ADDRESS OF I/O PACKET
        MOV     I.PRM+4(R3),R1  ;GET SIZE OF ORIGINAL BUFFER
        SUB     U.CNT(R5),R1    ;CALCULATE NUMBER OF BYTES PROCESSED
        ROR     R1              ;CONVERT TO NUMBER OF SAMPLES PROCESSED
        CALL    $IODON          ;FINISH I/O OPERATION
        BR      UDINI           ;
40$:    JMP     $INTXT          ;;;EXIT FROM INTERRUPT
        .DSABL  LSB
 
        .ENDC
 
 
;
; CANCEL I/O OPERATION
;
; THIS ROUTINE IS CALLED TO CANCEL ALL I/O IN PROGRESS FOR THE CURRENT
; TASK. IF THE TASK IS CONNECTED TO EITHER CONTACT OR TIMER INTERRUPTS, THEN
; IT IS DISCONNECTED. ALL A/D INPUT IS ALLOWED TO COMPLETE SINCE IT WILL
; DO SO WITHIN A REASONABLE AMOUNT OF TIME.
;
 
UDCAN:                          ;;;REF LABEL
 
 
        .IF DF  U$$CIM!U$$TIM
 
        MOV     R1,R0           ;;;SET TCB ADDRESS OF CURRENT TASK
 
 
        .IF DF  U$$CIM
 
        MOV     #CITBL,R3       ;;;POINT TO CONTACT INTERRUPT TABLE
 
        .ENDC
 
 
        .IF DF  U$$CIM&U$$TIM
 
        CALL    UDCAN1          ;;;DISCONNECT CONTACT INTERRUPTS
 
        .ENDC
 
 
        .IF DF  U$$TIM
 
        MOV     #TMTBL,R3       ;;;POINT TO TIMER INTERRUPT TABLE
 
        .ENDC
 
 
UDCAN1: CMP     R0,CONTK(R3)    ;;;CURRENT TASK CONNECTED?
        SEC                     ;;;ASSUME NO
        BNE     10$             ;;;IF NE NO
        CLR     CONTK(R3)       ;;;DISCONNECT TASK
        CLR     EFNMK(R3)       ;;;CLEAR EVENT FLAG WORD IN CASE A
        CLR     EFNAD(R3)       ;;;FORK IS ALREADY QUEUED
        DECB    T.IOC(R0)       ;;;DECREMENT OUTSTANDING I/O COUNT
 
        .IF DF  D$$SHF
 
        MOV     T.PCB(R0),R1    ;;;GET ADDRESS OF TASK PCB
        BIC     #PS.NSF,P.STAT(R1) ;;;ENABLE TASK SHUFFLING
 
        .ENDC
 
 
        .ENDC
 
 
10$:    RETURN                  ;;;
 
;
; POWERFAILURE IS HANDLED VIA THE DEVICE TIMEOUT FACILITY AND THEREFORE
; CAUSES NO IMMEDIATE ACTION ON THE DEVICE. THE UDC11 UNIT CONTROL BLOCK
; ADDRESS IS STORED AND UDC11 INTERRUPTS ARE ENABLED.
;
 
UDPWF:  MOV     R5,UDUCB        ;SAVE ADDRESS OF UDC11 UCB
 
 
        .IF DF  U$$ADM!U$$CIM!U$$TIM
 
        MOV     #36,@S.CSR(R4)  ;INITIALIZE UDC11 INTERRUPTS
 
 
        .IF DF  U$$TIM
 
        MOV     #<U$$TIM/256.>&377,R0 ;GET NUMBER OF TIMER MODULES
        MOV     TMTBL+2,R1      ;GET ADDRESS OF FIRST TIMER MODULE
        MOV     #TMINI,R2       ;GET ADDRESS OF INITIAL VALUE TABLE
10$:    MOV     (R2)+,(R1)+     ;SET INITIAL TIMER VALUE
        DEC     R0              ;ANY MORE TIMERS TO SET?
        BGT     10$             ;IF GT YES
 
        .ENDC
 
 
        .ENDC
 
 
        .IF DF  U$$LTM
 
        MOV     #<U$$LTM/256.>&377,R0 ;GET NUMBER OF LATCHING MODULES
        MOV     LTTBL+2,R1      ;GET ADDRESS OF FIRST LATCHING MODULE
        MOV     #LTPRV,R2       ;GET ADDRESS OF PREVIOUS STATE TABLE
20$:    MOV     (R2)+,(R1)+     ;RELOAD LATCHING OUTPUT MODULES
        DEC     R0              ;ANY MORE TO LOAD?
        BGT     20$             ;IF GT YES
 
        .ENDC
 
 
30$:    RETURN                  ;
 
;+
; **-$UDINT-UDC11 UNIVERSAL DIGITAL INPUT/OUTPUT CONTROLLER INTERRUPTS
;-
 
$UDINT::CALL    $INTSV,PR6      ;;;SAVE REGISTERS AND SET PRIORITY
 
 
        .IF DF  U$$ADM!U$$CIM!U$$TIM
 
        MOV     R3,-(SP)        ;;;SAVE R3 AND R2
        MOV     R2,-(SP)        ;;;
        MOV     #UDCR,R3        ;;;GET ADDRESS OF CSR
        BIT     #140000,(R3)    ;;;ANY ERRORS?
        BNE     60$             ;;;IF NE YES
        TSTB    (R3)            ;;;IMMEDIATE SCAN DONE?
        BMI     10$             ;;;IF MI YES
        MOV     -(R3),R2        ;;;READ SCAN REGISTER
        BMI     50$             ;;;IF MI SCAN DISPLACED
        BR      20$             ;;;
10$:    MOV     -(R3),R2        ;;;READ SCAN REGISTER
20$:    TST     (R3)+           ;;;POINT BACK TO CSR
        CLR     R5              ;;;PICKUP INTERRUPTING MODULE NUMBER
        BISB    R2,R5           ;;;
        ASL     R5              ;;;CALCULATE ADDRESS OF INTERRUPTING
        ADD     #UDMD,R5        ;;;MODULE
        BIS     #1,(R3)         ;;;SET RIF BIT
        MOV     (R5),R4         ;;;READ MODULE DATA RESETTING INTERRUPT
        BIC     #1,(R3)         ;;;RESET RIF BIT
        MOV     R2,-(SP)        ;;;COPY CONTENTS OF SCAN REGISTER
        SWAB    (SP)            ;;;SWAP GENERIC CODE TO RIGHT BYTE
        BIC     #^C<7>,(SP)     ;;;CLEAR ALL BUT GENERIC CODE
 
 
        .IF DF  U$$ADM
 
        CMP     #7,(SP)         ;;;A/D MODULE?
        BEQ     UDADI           ;;;IF EQ YES
 
 
        .IF NDF U$$CIM&U$$TIM
 
        TST     (SP)+           ;;;REMOVE GENERIC CODE FROM STACK
 
        .ENDC
 
 
        .ENDC
 
 
        .IF DF  U$$CIM
 
        MOV     #CITBL+2,R3     ;;;GET ADDRESS OF CONTACT TABLE
 
        .ENDC
 
 
        .IF DF  U$$CIM&U$$TIM
 
        BIT     #4,(SP)         ;;;CONTACT INTERRUPT MODULE?
        BEQ     30$             ;;;IF EQ YES
 
        .ENDC
 
 
        .IF DF  U$$TIM
 
        MOV     #TMTBL+2,R3     ;;;GET ADDRESS OF TIMER TABLE
 
        .ENDC
 
 
30$:                            ;;;REF LABEL
 
 
        .IF DF  U$$CIM!U$$TIM
 
        SUB     (R3),R5         ;;;CALCULATE RELATIVE MODULE INDEX
        MOV     R5,-(SP)        ;;;CONVERT TO RELATIVE MODULE NUMBER
        ASR     (SP)            ;;;
        MOV     R4,-(SP)        ;;;SET CURRENT MODULE DATA
 
 
        .IF DF  U$$CIM&U$$TIM
 
        CMP     #TMTBL+2,R3     ;;;TIMER MODULE?
        BEQ     70$             ;;;IF EQ YES
 
        .ENDC
 
 
;
; CONTACT INTERRUPT MODULE
;
 
 
        .IF DF  U$$CIM
 
        ADD     #CIPRV,R5       ;;;POINT TO PREVIOUS MODULE STATE
        BIC     (R5),R4         ;;;.NOT.PREVIOUS.AND.CURRENT
        BIC     (SP),(R5)       ;;;.NOT.CURRENT.AND.PREVIOUS
        BIS     (R5),R4         ;;;PREVIOUS.OR.CURRENT
        MOV     (SP),(R5)       ;;;SET PREVIOUS VALUE TO CURRENT
        MOV     R4,-(SP)        ;;;SET CHANGE OF STATE BITS
        MOV     (R5),R4         ;;;RETRIEVE CURRENT VALUE
        COM     R2              ;;;COMPLEMENT SCAN REGISTER
        BIT     #60000,R2       ;;;BOTH PCL AND POP?
        BEQ     80$             ;;;IF EQ YES
        BIT     #40000,R2       ;;;PCL?
        BNE     40$             ;;;IF NE NO
        COM     R4              ;;;COMPLEMENT CURRENT STATE
40$:    BIC     R4,(SP)         ;;;CLEAR UNWANTED COS BITS
        BNE     80$             ;;;IF NE SOME CHANGED BITS
        ADD     #10,SP          ;;;REMOVE DATA FROM STACK
 
        .ENDC
 
 
        .ENDC
        
        
50$:    BR      140$            ;;;TAKE COMMON EXIT
60$:    MOV     #37,(R3)        ;;;RESET UDC CONTROLLER
        BIC     #1,(R3)         ;;;CLEAR RIF BIT
        BR      140$            ;;;TAKE COMMON EXIT
 
;
; TIMER MODULE
;
        
        
        .IF DF  U$$CIM!U$$TIM
 
 
        .IF DF  U$$TIM
 
70$:    MOV     R4,R2           ;;;COPY MODULE DATA
        ROL     R2              ;;;TEST FOR OVERFLOW TO ZERO
        BVS     80$             ;;;IF VS NO OVERFLOW
        TST     CONTK-2(R3)     ;;;TASK CONNECTED?
        BEQ     80$             ;;;IF EQ NO
        MOV     R5,R2           ;;;COPY RELATIVE INDEX
        ADD     (R3),R5         ;;;CALCULATE ADDRESS OF TIMER MODULE
        MOV     TMINI(R2),(R5)  ;;;RELOAD TIMER MODULE
 
        .ENDC
 
 
;
; COMMON EXIT FOR CONTACT AND TIMER MODULES
;
 
80$:    MOVB    NMBYT-2(R3),R2  ;;;GET NUMBER OF BYTES OF DATA
        MOV     #1,-(SP)        ;;;SET EXISTANCE INDICATOR
        TST     CONTK-2(R3)     ;;;TASK CONNECTED?
        BEQ     130$            ;;;IF EQ NO
 
 
        .IF DF  M$$MGE
 
        MOV     KISAR6,R5       ;;;SAVE CURRENT MAPPING
        MOV     CURBF-2(R3),KISAR6 ;;;MAP TO USER BUFFER
 
        .IFTF
 
        MOV     CURBF+6-2(R3),R4 ;;;GET CURRENT BUFFER ADDRESS
        TST     (R4)            ;;;BUFFER ENTRY FREE?
        BNE     120$            ;;;IF NE NO
        CLR     LSCNT-2(R3)     ;;;CLEAR LOST DATA COUNT
        ASR     R2              ;;;CONVERT BYTE COUNT TO WORD COUNT
90$:    MOV     (SP)+,(R4)+     ;;;PUT DATA IN USER BUFFER
 
        .IFT
 
        BIT     #20000,R4       ;;;OVERFLOW 4K BOUNDRY?
        BEQ     100$            ;;;IF EQ NO
        BIC     #20000,R4       ;;;RESET TO APR6 ADDRESS
        ADD     #200,CURBF-2(R3) ;;;ADVANCE TO NEXT 4K BLOCK
        ADD     #200,KISAR6     ;;;ADVANCE TO NEXT 4K BLOCK
 
        .IFTF
 
100$:   INC     CURNX-2(R3)     ;;;INCREMENT FORTRAN INDEX
        CMP     BFLGH-2(R3),CURNX-2(R3) ;;;END OF BUFFER?
        BHIS    110$            ;;;IF HIS NO
        MOV     #3,CURNX-2(R3)  ;;;RESET CURRENT FORTRAN INDEX
 
        .IFT
 
        MOV     STRBF-2(R3),CURBF-2(R3) ;;;RESET CURRENT RELOCATION BIAS
        MOV     CURBF-2(R3),KISAR6 ;;;RESET CURRENT APR6 BIAS
 
        .IFTF
 
        MOV     STRBF+6-2(R3),R4 ;;;RESET CURRENT BUFFER ADDRESS
110$:   DEC     R2              ;;;ANY MORE DATA?
        BGT     90$             ;;;IF GT YES
        MOV     R4,CURBF+6-2(R3) ;;;SAVE CURRENT BUFFER ADDRESS
 
        .IFT
 
        MOV     STRBF-2(R3),KISAR6 ;;;MAP TO START OF BUFFER
 
        .IFTF
 
        MOV     CURNX-2(R3),@BUFAD-2(R3) ;;;SET FORTRAN INDEX
 
        .IFT
 
        MOV     R5,KISAR6       ;;;RESTORE CURRENT MAPPING
 
        .IFTF
 
        TSTB    STATS-2(R3)     ;;;FORK ALREADY IN PROGRESS?
        BNE     150$            ;;;IF NE NO
        BR      140$            ;;;
120$:   ADD     #LSCNT-2,R3     ;;;POINT TO LOST DATA COUNT
        CMP     #100001,(R3)    ;;;MAXIMUM VALUE?
        BEQ     125$            ;;;IF EQ YES
        DEC     (R3)            ;;;DECREMENT LOST DATA COUNT
125$:   MOV     (R3),(R4)       ;;;SET LOST DATA COUNT
 
        .IFT
 
        MOV     R5,KISAR6       ;;;RESTORE CURRENT MAPPING
 
        .ENDC
 
 
130$:   ADD     R2,SP           ;;;REMOVE ENTRIES FROM STACK
 
        .ENDC
 
 
140$:   MOV     (SP)+,R2        ;;;RESTORE R2 AND R3
        MOV     (SP)+,R3        ;;;
 
        .ENDC
 
 
        JMP     $INTXT          ;;;EXIT FROM INTERRUPT
 
;
; CREATE FORK PROCESS AND WAKE UP TASK
;
 
 
        .IF DF  U$$CIM!U$$TIM
 
150$:   CLRB    STATS-2(R3)     ;;;SET FORK IN PROGRESS
        MOV     R3,R4           ;;;COPY DATA CONTROL BLOCK ADDRESS
        MOV     R3,R5           ;;;
        ADD     #FRBLK+6-2,R4   ;;;POINT TO FORK BLOCK
        MOV     (SP)+,R2        ;;;RESTORE R2 AND R3
        MOV     (SP)+,R3        ;;;
        CALL    $FORK1          ;;;CREATE A SYSTEM PROCESS
        INCB    STATS-2(R5)     ;CLEAR FORK IN PROGRESS FLAG
        MOV     CONTK-2(R5),R0  ;GET CONNECTED TASK TCB ADDRESS
        BIT     #T2.ABO,T.ST2(R0) ;TASK BEING ABORTED?
        BNE     160$            ;IF NE YES
        BIS     EFNMK-2(R5),@EFNAD-2(R5) ;SET SPECIFIED EVENT FLAG
160$:   CALLR   $SETCR          ;SET A CONDITIONAL SCHEDULE REQUEST
 
        .ENDC
 
 
        .END
        .TITLE  XBDRV
        .IDENT  /04.2/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 04
;
; EARL D. WALDIN 21-NOV-75
;
; PREVIOUSLY MODIFIED BY:
;
;       L. GILLESPIE
;       E. D. WALDIN
;
; MODIFIED BY:
;
; EB083 - MODIFIED 18-SEP-77 TO CORRECT BRANCH OUT OF RANGE FOR
;       MULTICONTROLLER DRIVER
;
; B. SCHREIBER  30-JUN-78
;
;       BLS056 -- CORRECT UMR ALLOCATION HANDLING
;
; B. SCHREIBER  15-OCT-78
;
;       BLS069 -- CORRECT ERROR WHEN TRANSMITTING OR RECEIVING
;               AND BUFFER FALLS EXACTLY ON BOUNDARY.
;
; DA11-B INTERPROCESSOR COMMUNICATIONS DRIVER
;
; *****************************************************************************
;
;                       KNOWN HACKS FOR THIS DEVICE
;
; 1)    CYCLE BIT IS READ/WRITE INSTEAD OF WRITE ONLY.  IT IS SET EVERY TIME
;       A WORD IS TRANSFERED FROM ONE SYSTEM TO ANOTHER, AND THEREFORE
;       ITS STATE AT ANY TIME IS INDETERMINATE.  THEREFORE ALL "BIS" AND
;       "BIC" INSTRUCTIONS ARE FORBIDDEN AS THEY CAN REWRITE THE CYCLE BIT
;       INITIATING AN UNWANTED NPR CYCLE OR CYCLES.
;
; 2)    BOTH SIDES CANNOT TRY TO TRANSMIT AT THE SAME TIME BECAUSE THIS
;       DEVICE IS HALF DUPLEX ONLY.  THEREFORE A DEVICE PROTOCOL MUST
;       BE WRITEN INTO THE DRIVER TO ARBITRATE THE LINK.
;
; 3)    THE DEVICE NPR LOGIC WILL NOT CROSS 32K WORD BOUNDRIES BECAUSE
;       THE BUFFER REGISTER IS ONLY A 16 BIT COUNTER.  WHEN A 32K WORD
;       BOUNDARY IS CROSSED, THE MEMORY EXTENSION BITS MUST BE INCREMENTED
;       FOR A RESTART.  ALSO, DUE TO THE CYCLE REQUEST LOGIC, THE
;       NEXT TRANSMIT WORD IS PLACED IN THE DATA BUFFER AND MUST BE
;       REMOVED (VIA SOFTWARE) AND STORED IN THE RECEIVE DATA BUFFER
;       BEFORE RESUMING THE TRANSFER.
;
;
; 4)    ACCESSING THE CSR AFTER SETTING THE GO BIT MAY CAUSE THE
;       DEVICE TO LOSE A CYCLE REQUEST AND THEREBY HALT NPR TRANSFERS
;       WITHOUT SETTING DONE OR ERROR. RECOVERY IN THIS CASE IS
;       BY TIMEOUT ALONE.
;
; *****************************************************************************
;



;
; MACRO LIBRARY CALLS
;

        .MCALL  PKTDF$,HWDDF$
        PKTDF$                          ;DEFINE I/O PACKET OFFSETS
        HWDDF$                          ;DEFINE HARDWARE REGISTERS
        .MCALL  UCBDF$,CUCDF$
        UCBDF$                          ; DEFINE UCB OFFSETS
        CUCDF$                          ;COMMUNICATIONS UCB LABELS


        .IF DF  M$$NET

        .MCALL F11DF$,CVCDF$
        F11DF$                          ;DEFINE FILES 11
        CVCDF$                          ;COMMUNICATIONS VCB LABELS

        .ENDC


;
; EQUATED SYMBOLS
;


;
; LOCAL DEFINITIONS
;

DBGO=   1                               ;SET TO START TRANSFERS (RCV)
MDOUT=  2                               ;OUTPUT MODE,1= WORD
DROUT=  4                               ;OUTPUT DIRECT,1= RCV
INTENB= 100                             ;INTERRUPT ENABLE
IREQO=  10                              ;SET TO REQ INTR IN COMPANION
RDY=    200                             ;INDICATES DEVICE READY
CYCLE=  400                             ;SET W/GO TO START XMIT XFER
MDINP=  1000                            ;INP MODE, 1= WORD
DRINP=  2000                            ;INP DIRECT 1= COMPANION IS RCV
IREQN=  4000                            ;INTR REQ FROM COMPANION
NEX=    40000                           ;NON EXISTENT MEMORY
ERROR=  100000                          ;=1 WHEN DEVICE ERROR
DIS0=   DROUT!MDOUT!IREQO!CYCLE         ;RESTORE DB TO IDLE STATE
ATTN=   20000
MBIT=60                                 ;MEMORY EXTENSION BIT POSITIONS
BUMP=20                                 ;MEMORY EXTEN BIT INCREMENT


;
; UNIT IMPURE DATA TABLE
;

CNTBL:                                  ;REF LABEL
UNITBL: .REPT   D$$B11

        .WORD   0

        .ENDM


        .IF GT  D$$B11-1

TEMP:                                   ;REF LABEL
UNIT:   .BLKW   1

        .ENDC


;
; DEVICE DISPATCH TABLE
;

$XBTBL::.WORD   DBINIT                  ;DEVICE INITIATION ENTRY
        .WORD   DBCANC                  ;I/O CANCELLATION ENTRY
        .WORD   DBTMO                   ;DEVICE TIMEOUT ENTRY
        .WORD   DBPWRF                  ;POWERFAIL ENTRY

        .IF DF  M$$NET

        XBRCV                           ;UNSOLICITED RECEIVE INITIALIZATION
        RESYNC                          ;RESYNC ENTRY POINT

        .IFF

        XBRET
        XBRET

        .ENDC

;+
;**- DBINIT - DA11-B PARALLEL COMMUNICATIONS LINK CONTROLLER I/O INITIATOR
;
; DBINIT IS ENTERED WHEN AN I/O REQUEST IS QUEUED ON THE DEVICE
; AND AT THE END OF EACH QIO REQUEST WHICH OBEYS THE NORMAL
; RSX-11M INPUT/OUTPUT LOGIC FLOW.  IF THE DEVICE IS
; AVAILABLE AND A REQUEST IS IN THE QUEUE FOR THAT UNIT, THE
; REQUEST IS INITIATED.
; IF NO REQUEST EXISTS FOR THAT UNIT OR IF IT IS BUSY,
; AN EXIT IS TAKEN TO THE CALLER.  NOTE THAT BECAUSE OF THE
; NATURE OF THE DA11-B, EACH UNIT IS A CONTROLLER ITSELF, HAS
; ITS OWN SCB, AND THEREFORE ITS OWN QUEUE.
; EACH TIME DBINIT IS CALLED, IT IS CALLED TO SERVICE ONLY
; THE UNIT SPECIFIED IN THE CALL.
;
; INPUTS:
;       R4 = STATUS CONTROL BLOCK ADDRESS
;       R5 = ADDRESS OF THE UCB TO BE INITIATED
;
; OUTPUTS:
;       IF A REQUEST IS SUCCESSFULLY DEQUEUED, THE
;       DEVICE IS INITIATED APPROPRIATELY.
;
;-

        .ENABL  LSB

DBINIT:                                 ;REFERENCE LABEL

        .IF DF  M$$NET

        TSTB    U.CW2(R5)               ;UNSOL RCV (HDPX) EXPECTED?
        BMI     XBRET                   ;DON'T INITIATE IF YES
        MTPS    S.PRI(R4)               ;;;LOCK OUT UNSOLICITED REQUESTS
        TSTB    U.CW3(R5)               ;DEVICE BUSY?
        BNE     XBRET                   ;DON'T INITIATE IF YES
        CLR     @S.CSR(R4)              ;;;CLEAR INTERRUPT ENABLE
        MTPS    #0                      ;LOWER PRIORITY

        .IFTF

        CALL    $GTPKT                  ;ANY WORK TO DO?
        BCC     20$                     ;BR IF WORK TO DO

        .IFT

        BIT     #U3.RPD!U3.SND,U.CW3(R5);RECEIVE PENDING OR SENDING?
        BEQ     XBRET                   ;DON'T ENABLE IF NOT
        MOV     #INTENB,@S.CSR(R4)      ;RE-ENABLE INTERRUPTS FOR DEVICE


        .IFTF

XBRET:                                  ;REFERENCE LABEL

        .IFT

        MTPS    #0                      ;LOWER PRIORITY

        .ENDC

        RETURN                          ;RETURN TO CALLER


; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT
;
;       R1= ADDRESS OF I/O REQUEST PACKET
;       R2= PHYSICAL UNIT NUMBER OF THE REQUEST UCB
;       R3= CONTROLLER INDEX
;       R4= ADDRESS OF THE STATUS CONTROL BLOCK
;       R5= ADDRESS OF THE UCB SPECIFIED IN THE DBINIT CALL
;
; DA11-B I/O REQUEST PACKET FORMAT
;
;       WORD            CONTENT
;
;       0       I/O QUEUE THREAD WORD
;       1       REQUEST PRIORITY, EVENT FLAG NUMBER
;       2       ADDRESS OF THE TCB OF THE REQUESTER TASK
;       3       POINTER TO SECOND LUN WORD IN TASK HEADER
;       4       CONTENTS OF FIRST LUN WORD (UCB)
;       5       I/O FUNCTION CODE
;       6       VIRTUAL ADDRESS OF I/O STATUS BLOCK
;       7       RELOCATION BIAS OF I/O STATUS BLOCK
;      10       I/O STATUS BLOCK ADDR (REAL OF DISPLACEMENT + 140000)
;      11       VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;      12       MEMORY EXTENSION BITS FOR I/O BUFFER
;      13       BUFFER ADDRESS FOR TRANSFER
;      14       TOTAL BYTE COUNT TO TRANSFER
;      15       NOT USED
;      16       NOT USED
;      17       NOT USED
;      20       NOT USED
;

20$:    MOV     S.CSR(R4),R2            ;PUT CSR INTO R2
        ADD     #I.FCN+1,R1             ;R1 POINTS TO I/O FUNCTION CODE
        CMPB    #IO.INL/256.,(R1)       ;CONTROL FUNCTION?
        BLOS    40$                     ;BR IF CONTROL FUNCTION
        BIT     #U2.ONL,U.CW2(R5)       ;DEVICE ONLINE?
        BEQ     50$                     ;RETURN IE.DNR IF NOT ONLINE

        .IF DF  M$$MGE&M$$EXT

        CMP     #4096.,U.CNT(R5)        ;BUFFER BIGGER THAN 4K?
        BHIS    25$                     ;CONTINUE IF SMALLER
        MOV     #IE.SPC&377,R0          ;SAY BUFFER TOO BIG
        BR      UNSUCC                  ;FINISH I/O UNSUCCESSFUL

25$:    CALL    $STMAP                  ;SET DEVICE'S UNIBUS ADDRESS            ;BLS056
        MOV     R1,-(SP)                ;SAVE R1                                ;BLS056
        MOV     R2,-(SP)                ;AND R2                                 ;BLS056
        CALL    $MPUBM                  ;SET UP 11/70 UNIBUS MAPPING            ;**-3
        MOV     (SP)+,R2                ;RESTORE R2 AND R1
        MOV     (SP)+,R1

        .ENDC

        CMPB    #IO.RLB/256.,(R1)       ;RECEIVE FUNCTION?
        BEQ     30$                     ;BR IF RECEIVE FUNCTION

; FALL THROUGH ON TRANSMIT REQUEST

        .IF DF  M$$NET

        CALL    @U.PHDR(R5)             ;CALL COROUTINE FOR INITIATE

        .IFTF

        CMP     -(R2),-(R2)             ;POINT TO WORD CNT REG
        CLR     -(SP)                   ;INITIALIZE CSR, CLEAR C BIT
        MOV     U.CNT(R5),-(SP)         ;GET DATA COUNT IN BYTES
        ROR     (SP)                    ;CONVERT TO WORD COUNT
        ADC     (SP)                    ;ADJUST FOR ODD BYTE COUNT
        MOV     (SP),6(R2)              ;PASS COUNT IN DATA BUFFER
        NEG     (SP)                    ;COUNT IN 2'S COMPLEMENT
        MOV     (SP)+,(R2)+             ;LOAD COUNT
        MOV     U.BUF+2(R5),(R2)+       ;LOAD ADDRESS
        MOVB    S.ITM(R4),S.CTM(R4)     ;SET TIMEOUT COUNT
        INCB    U.CW3(R5)               ;SET SENDER STATUS IN UCB

        .IF DF  M$$MGE

        BIS     U.BUF(R5),(SP)          ;OR IN MEMORY EXTENSION BITS

        .ENDC

        BIS     #IREQO!INTENB!DBGO,(SP) ;SETUP TO GO
        MOV     (SP)+,(R2)              ;START DEVICE
        RETURN                          ;INTERRUPTS PROPAGATE TRANSMIT

; RECEIVE FUNCTION INITIATION

30$:                                    ;REFERENCE LABEL

        .IFF

        MOV     R5,R0                   ;R0 POINTS TO UCB
        ADD     #U.RBUF,R0              ;R0 POINTS TO RCV BUF ADDR AREA
        MOV     U.BUF(R5),(R0)+         ;TRANSFER BUFFER ADDR TO U.RBUF
        MOV     U.BUF+2(R5),(R0)+       ;
        MOV     U.CNT(R5),(R0)          ;TRANSFER COUNT
        ROR     (R0)                    ;CHANGE BYTE CONT TO WORD COUNT
        ADC     (R0)                    ;ADJUST FOR ODD BYTE COUNT
        MOV     #U3.RPD,U.CW3(R5)       ;SET RECEIVE PENDING
        MOV     #INTENB,(R2)            ;ENABLE INTERRUPTS (CAUSING ONE)
        RETURN                          ;RETURN, INTERRUPT PROPAGATES RX

        .IFT

        MOV     #IE.IFC,R0              ;SIGNAL ILLEGAL FUNCTION
        BR      UNSUCC                  ;COMPLETE UNSUCCESSFULLY

        .IFTF

; REQUEST WAS CONTROL FUNCTION

40$:    BNE     SUCC                    ;CHANGE MODE IS NO-OP
        TSTB    -(R1)
        BNE     60$                     ;BR IF FUNCTION WAS TERMINATE

; INITIALIZE  DEVICE FUNCTION

        MOV     R5,UNITBL(R3)           ;PUT UCB ADDR INTO TABLE
        CLR     (R2)                    ;CLEAR CSR REGISTER
        CLR     -2(R2)                  ;CLEAR BUFFER ADDR REGISTER
        TST     (R2)                    ;ERROR BIT SET?
        BMI     50$                     ;BR IF MODULE NOT IN PLACE

        .IFF

        BIS     #U2.ONL,U.CW2(R5)       ;MARK DEVICE ONLINE

        .IFT

        BIS     #U2.ONL!U2.RFK!U2.HRC,U.CW2(R5) ;NETWORK INITIAL BITS

        .ENDC

        BR      70$                     ;COMPLETE SUCCESSFUL I/O

; SIGNAL DEVICE NOT READY

50$:    MOV     #IE.DNR&377,R0          ;SIGNAL DEVICE NOT READY
        BR      UNSUCC                  ;COMPLETE UNSUCCESSFUL I/O

; FUNCTION WAS TERMINATE

60$:    CLR     UNITBL(R3)              ;REMOVE UCB ADDR FROM TABLE
        BIC     #U2.ONL,U.CW2(R5)       ;MARK DEVICE OFFLINE
        CLR     (R2)                    ;CLEAR CSR REGISTER
70$:    CLR     U.CW3(R5)               ;CLEAR DEVICE STATUS IN UCB
        CLR     2(R2)                   ;CLEAR DATA BUFFER REGISTER
        CLR     -(R2)                   ;CLEAR ADDRESS REGISTER
        CLR     -(R2)                   ;CLEAR WORD COUNT REGISTER
SUCC:   MOV     #IS.SUC&377,R0          ;SUCCESSFUL COMPLETION ENTRY
UNSUCC: CLRB    S.STS(R4)               ;IDLE CONTROLLER
        BICB    #US.BSY,U.STS(R5)       ;MARK UNIT IDLE
        MOV     R0,-(SP)                ;SAVE STATUS WORD ONE
        MOV     S.PKT(R4),-(SP)         ;SAVE OLD PACKET ADDR
        CALL    DBINIT                  ;TRY TO ACTIVATE NEXT REQUEST
        MOV     (SP)+,R3                ;GET OLD I/O PACKET
        MOV     I.PRM+4(R3),R1          ;RETURN REQUESTED ITEM COUNT
        MOV     (SP)+,R0                ;GET STATUS WORD 1
        CALLR   $IOFIN                  ;TERMINATE OLD PACKET

        .DSABL  LSB

;
; DEVICE TIMEOUT ENTRY
;
; THIS CODE IS ENTERED WHEN THE TRANSMIT TIMEOUT COUNT GOES TO ZERO.
;

DBTMO:                                  ;;;REFERENCE LABEL

        .IF DF  M$$NET

        CLRB    U.CW3(R5)               ;;;CLEAR DEVICE STATUS
        CLR     @S.CSR(R4)              ;;;CLEAR DEVICE REGISTER
        CLRB    PS                      ;;;ALLOW INTERRUPTS
        JMP     TXDN            ;FINISH TRANSMIT PACKET

        .IFF

        CLR     U.CW3(R5)               ;;;CLEAR DEVICE STATUS
        CLR     @S.CSR(R4)              ;;;DISABLE DEVICE
        CLRB    PS                      ;;;ENABLE INTERRUPTS
        BR      UNSUCC                  ;FINISH UNSUCCESSFUL

; DEVICE CANCELLATION AND POWERFAIL ENTRYS
;
; FOR NETWORKS CANCELLATION AND POWERFAIL ARE NO-OPED AND THE
; TRANSMIT EITHER COMPLETES OR TIMES OUT. IT IS THEN FINISHED
; IN THE NORMAL MANNER.
; FOR NON-NETWORKS, THE DEVICE IS DISABLED AND A TIMEOUT FORCED SO
; THAT THE PACKET IS FINISHED BY DBTMO, AVOIDING ANY RACE CONDITIONS
; ARISING FROM I/O TERMINATION.
;

        .IFT

DBCANC:                                 ;;;REFERENCE LABEL
DBPWRF: RETURN                          ;;;LET TX FINISH OR TIMEOUT

        .IFF

        .ENABL  LSB

DBCANC: CMP     I.TCB(R0),R1            ;;;I/O FOR THIS TASK?
        BNE     5$                      ;;;RETURN IF NOT
        TSTB    U.CW3(R5)               ;;;TRANSFER IN PROGRESS?
        BNE     5$                      ;;;LET FINISH IF YES
        MOV     #IE.ABO&377,R0          ;;;RETURN ABORT STATUS
        BR      DBTMO                   ;;;FINISH AS TIMEOUT

DBPWRF: MOVB    #2,S.CTM(R4)            ;;;FORCE TIMEOUT
5$:     RETURN                          ;;;RETURN TO CALLER

        .DSABL  LSB

        .ENDC

;
; DA11-B INTERRUPT ROUTINE
;

        .ENABL  LSB

$XBINT::                                ;;;REFERENCE LABEL
        INTSV$  XB,PR5,D$$B11           ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DBSET                   ;;;PUT CSR ADDRESS IN R4
        TSTB    (R4)                    ;;;DEVICE READY?
        BMI     5$                      ;;;CONTINUE IF YES
        RETURN                          ;;;EXIT INTERRUPT IF NOT

5$:     TSTB    U.CW3(R5)               ;;;TX OR RCV ACTIVE
        BEQ     NOTHNG                  ;;;BR IF NOTHING ACTIVE
        BMI     10$                     ;;;BR IF RECEIVE ACTIVE

; AM CURRENTLY TRYING TO TRANSMIT, CHECK FOR SUCCESSFUL COMPLETION

        BIT     #IREQN,(R4)             ;;;HE INTERRUPTING ME?
        BEQ     10$                     ;;;CHECK ON IF NOT
        BIT     #MDINP,(R4)             ;;;DOES HE WANT ME TO FLUSH TX?
        BNE     IEVER                   ;;;RETURN ERROR IF YES

; AM CURRENTLY RECEIVING, CHECK FOR SUCESSFUL COMLETION

10$:    TST     (R4)                    ;;;ERROR BIT SET?
        BPL     20$                     ;;;CHECK ON IF NOT
        JMP     ERR                     ;;;CHECK ON ERROR

20$:    TST     -4(R4)                  ;;;ALL DATA TRANSFERRED?
        BEQ     SUCDN                   ;;;RETURN GOOD STAUTS IF YES
IEVER:  MOV     #IE.VER&377,-(SP)       ;;;UNRECOVERABLE ERROR FINISH
        BR      INTDN                   ;;;FINISH I/O

SUCDN:                                  ;;;SUCCESSFUL COMPLETION

        .IF DF  M$$NET

        CLR     -(SP)                   ;;;RETURN SUCCESSFUL STATUS

        .IFF

        MOV     #IS.SUC&377,-(SP)       ;;;RETURN SUCESSFUL STATUS

        .IFTF

INTDN:                                  ;;;REFERENCE LABEL

        .IFF

        CLR     (R4)                    ;;;DISABLE DEVICE
        MOV     (SP)+,R4                ;;;SAVE STATUS IN R4
        CALL    $FORK                   ;;;GO TO FORK LEVEL
        CLR     U.CW3(R5)               ;SAY DEVICE NOT ACTIVE
        MOV     R4,R0                   ;RETURN STATUS IN R0
        MOV     U.SCB(R5),R4            ;GET SCB ADDR FOR I/O DONE
        CALLR   UNSUCC                  ;FINISH I/O

        .IFT

        CLR     (R4)                    ;;;DISABLE DEVICE
        TSTB    U.CW3(R5)               ;;;WHAT WAS I DOING?
        BPL     110$                    ;;;BR IF WAS TRANSMITTING

; RECEIVE IS FINISHED

        MOV     (SP)+,R4                ;;;PUT COMPLETION STATUS IN R4
        CALL    $FORK                   ;;;GO TO FORK LEVEL
        CLR     U.CW3(R5)               ;;;RE-ENABLE INTERRUPTS
        BIT     #U2.ONL,U.CW2(R5)       ;DEVICE STILL ONLINE?
        BEQ     EXIT                    ;EXIT IF NOT
        MOV     R4,R0                   ;RETURN STATUS IN R0
        CLR     R1                      ;RETURN GOOD CRC
        MOV     U.SCB(R5),R2            ;GET SCB ADDRESS
        MOV     S.CSR(R2),R2            ;GET DEVICE CSR ADDRESS IN R2
        MOV     U.VCB(R5),R4            ;GET VCB ADDRESS
        SUB     U.RCNT(R5),U.RCAC(R5)   ;SUB MY COUNT FROM HIS COUNT
        BHI     30$                     ;DON'T CLR CSR IF HE'S NOT DONE
        CLR     (R2)                    ;CLR INTERRUPT ENABLE
30$:    ADD     #V.CIAD,R4              ;POINT TO FIRST BUFFER ADDRESS
        MOV     (R4)+,U.RBUF+2(R5)      ;PUT ADDRESS INTO UCB
        BNE     40$                     ;BR IF ADDRESS OK
        ADD     #V.CSAD-<V.CIAD+2>,R4   ;POINT TO SECOND BUFFER ADDRESS
        MOV     (R4)+,U.RBUF+2(R5)      ;PUT ADDRESS INTO UCB
        BNE     40$                     ;BR IF GOOD ADDRESS
        MOV     R5,R0                   ;RETURN BAD STATUS, NO BUFFER
        BR      50$                     ;GO TO CO-ROUTINE

40$:    CLC                             ;CLEAR CARRY
        ROR     (R4)                    ;CONVERT BYTE COUNT TO WORD COUNT
        ADC     (R4)                    ;ADJUST FOR ODD BYTE COUUNT
        MOV     (R4),U.RCNT(R5)         ;PUT COUNT IN UCB
        CLR     -(R4)                   ;CLEAR BUFFER ADDRESS
50$:    CALL    @U.SVC(R5)              ;GO TO CO-ROUTINE
        BCS     100$                    ;DO NOTHING IF C SET
        BPL     60$                     ;CONTINUE IF NO ERROR
        CALL    MYSYNC                  ;RESYNCH DEVICE
        BR      100$                    ;JUST RETURN

60$:    TST     U.RCAC(R5)              ;DID HIS BUFFER FINISH?
        BLOS    80$                     ;NORMAL STARTUP IF YES
70$:    MOV     R5,R4                   ;COPY UCB ADDRESS
        ADD     #U.RBUF+2,R4            ;POINT TO RCV BUFFER ADDR
        MOV     2(R2),@(R4)             ;STORE LAST TX CHAR
        ADD     #2,(R4)+                ;INCREMENT ADDRESS BY 2
        DEC     (R4)                    ;DEC RECEIVE COUNT
        DEC     U.RCAC(R5)              ;DEC HIS TX COUNT
        CMP     -(R2),-(R2)             ;POINT TO WORD COUNT REG
        MOV     (R4),(R2)               ;COUNT INTO DB
        NEG     (R2)+                   ;COUNT IN 2'S COMPLEMENT
        MOV     -(R4),(R2)+             ;ADDRESS INTO DB
        BIS     #U3.RAC!U3.RPD,U.CW3(R5) ;SAY RCV PENDING AND ACTIVE
        MOV     #DBGO!DROUT!INTENB,(R2) ;RESTART RECEIVE
        BR      100$                    ;RETURN TO COROUTINE

80$:    BIS     #U3.RPD,U.CW3(R5)       ;SAY RECEIVE IS PENDING
        MOV     #INTENB,(R2)            ;ENABLE INTERRUPTS
100$:   RETURN                          ;RETURN TO CO-ROUTINE


; TRANSMIT IS FINISHED

110$:                                   ;REFERENCE LABEL
        MOV     (SP)+,R4                ;;;SAVE I/O STATUS
        CALL    $FORK                   ;;;GO TO FORK LEVEL
        CLRB    U.CW3(R5)               ;IDLE STATUS IN UCB
        MOV     R4,R0                   ;RETURN STATUS IN R0
        MOV     U.SCB(R5),R4            ;GET SCB ADDRESS FOR FINISH
TXDN:   TSTB    U.CW2(R5)               ;RECEIVE TO BECOME ACTIVE?
        BPL     120$                    ;BR IF NOT
        MOV     #INTENB,@S.CSR(R4)      ;ENABLE INTERRUPTS (CAUSING ONE)
120$:   MOV     S.PKT(R4),R1            ;GET I/O PACKET FOR COROUTINE
        CALL    @U.PHDR(R5)             ;GO TO TRANSMIT CO-ROUTINE
        CALLR   DBINIT                  ;TRY TO INITIATE NEW TRANSMIT

        .IFTF

NOTHNG: BIT     #IREQN,(R4)             ;;;DID HE INTERRUPT ME?
        BEQ     EXIT                    ;;;EXIT IF NOT
        BIT     #MDINP!ERROR,(R4)       ;;;ERROR OR FLUSH TX SET?
        BNE     EXIT                    ;;;EXIT IF YES
        TSTB    U.CW3+1(R5)             ;;;IS A RECEIVE PENDING?
        BEQ     EXIT                    ;;;EXIT IF NOT

        .IFF

        CMP     2(R4),U.RCNT(R5)        ;;;TX COUNT = RECV COUNT/
        BNE     VER                     ;;;RETURN ERR IF NOT

        .IFT

        MOV     2(R4),U.RCAC(R5)        ;;;SAVE HIS TX COUNT
        BEQ     EXIT                    ;;;EXIT IF COUNT =0

        .ENDC

        CMP     -(R4),-(R4)             ;;;XFER REQUEST, SET UP TO GO
        MOV     U.RCNT(R5),(R4)         ;;;GET RECEIVE COUNT
        NEG     (R4)+                   ;;;COUNT IN 2'S COMPLEMENT
        MOV     U.RBUF+2(R5),(R4)+      ;;;ADDR INTO BUFFER ADDR REG
        BIS     #U3.RAC,U.CW3(R5)       ;;;SET RECEIVE ACTIVE IN UCB
        MOV     #DROUT!DBGO!INTENB,-(SP) ;;;SETUP TO GO

        .IF DF  M$$MGE

        BIS     U.RBUF(R5),(SP)         ;;;OR IN MEMORY EXENSION BITS

        .ENDC

        MOV     (SP)+,(R4)              ;;;ENABLE DEVICE
EXIT:   RETURN                          ;;;WAIT FOR XFER TO FINISH


        .DSABL  LSB

        .ENABL LSB

ERR:    BIT     #NEX,(R4)               ;;;NON EXISTENT MEMORY ERROR?
        BNE     20$                     ;;;BR IF YES
        BIT     #ATTN,(R4)              ;;;POSSIBLE INIT ON OTHER SYSTEM?
        BNE     30$                     ;;;BR IF YES
        CLR     -2(R4)                  ;;;REMOVE POSSIBLE OVERFLOW
        TST     (R4)                    ;;;ERROR STILL SET?
        BMI     30$                     ;;;BR IF YES

        .IF DF  M$$MGE

        MOV     #DBGO!INTENB!CYCLE,-(SP) ;;;SETUP FOR TRANSMIT CONTINUE
        MOV     (R4),-(SP)              ;;;COPY CURRENT CSR BITS
        BIC     #^CMBIT,(SP)            ;;;CLEAR ALL BUT EXTENSION BITS
        ADD     #BUMP,(SP)              ;;;INCREMENT MEMORY EXTENSION BITS
        BIS     (SP),2(SP)              ;;;OR IN EXTENSION BITS
        TSTB    U.CW3(R5)               ;;;WAS I TRANSMITTING?
        BPL     10$                     ;;;BR IF YES                            ;BLS069
                                                                                ;**-1
        .IF DF  M$$NET

; NOTE- ALL NETWORK RECEIVES ARE UNSOLICITED AND THE RECEIVE DATA
; BUFFERS ARE IN SYSTEM DYNAMIC MEMORY.  FALLING THROUGH TO THIS POINT
; WOULD INDICATE A FAULT WITH THE DEVICE SINCE RECEIVE BUFFERS
; CANNOT CROSS A 32K WORD BOUNDARY!!!!!

        CMP     (SP)+,(SP)+             ;;;CLEAN STACK OF TWO WORDS
        BR      VER                     ;;;RETURN UNRECOVERABLE ERROR
10$:                                    ;;;REF LABEL                            ;BLS069

        .IFF

        SWAB    (SP)                    ;;;PUT MEMORY EXTENSION BITS
        ASR     (SP)                    ;;;IN POSITIONS 10 & 11
        ASR     (SP)
        MOV     KISAR6,-(SP)            ;;;SAVE CURRENT MAPPING
        MOV     2(SP),KISAR6            ;;;SET NEW MAPPING
        MOV     2(R4),@#140000          ;;;PUT CHAR INTO USER'S BUFFER
        MOV     (SP)+,KISAR6            ;;;RESTORE MAPPING
        CMP     -(R4),-(R4)             ;;;POINT TO WORD CNT REG
        INC     (R4)+                   ;;;INCR COUNT
        ADD     #2,(R4)+                ;;;INCR BUFFER ADDRESS REG              ;BLS069
        BIC     #CYCLE,2(SP)            ;;;CLR CYCLE FOR RECEIVE                ;**-5
        BIS     #DROUT,2(SP)            ;;;SET RECEIVE DIRECTION
10$:    TST     -4(R4)                  ;;;I/O FINISHED?                        ;BLS069
        BNE     15$                     ;;;BRANCH IF NOT                        ;BLS069
        CMP     (SP)+,(SP)+             ;;;YES--CLEAN STACK                     ;BLS069
        JMP     SUCDN                   ;;;FINISH SUCCESSFULLY                  ;BLS069

        .ENDC

15$:    TST     (SP)+                   ;;;CLEAN STACK
        MOV     (SP)+,(R4)              ;;;START UP DEVICE

        .ENDC

        BR      DBEXIT                  ;;;EXIT FROM INTERRUPT

VER:                                    ;;;REFERENCE LABEL
20$:    JMP     IEVER                   ;;;RETURN UNRECOVERABLE ERROR

30$:    MOV     #IE.DNR&377,-(SP)       ;;;SIGNAL DEVICE NOT READY
40$:    JMP     INTDN                   ;;;FINISH I/O

        .DSABL  LSB

DBSET:                                  ;;;REFERENCE LABEL
        TST     R5                      ;;;CHECK FOR VALID UCB ADDRESS
        BEQ     10$                     ;;;BR IF NO UCB IN TABLE
        BIT     #U2.ONL,U.CW2(R5)       ;;;DEVICE ONLINE?
        BEQ     10$                     ;;;IGNORE INTERRUPT IF OFFLINE
        MOV     U.SCB(R5),R4            ;;;GET SCB ADDR IN R4
        MOV     S.CSR(R4),R4            ;;;PUT CSR ADDR INTO R4
        RETURN                          ;;;RETURN TO CALLER

10$:    TST     (SP)+                   ;;;CLEAR STACK OF RETURN ADDR
DBEXIT: JMP     $INTXT                  ;;;EXIT FROM INTERRUPT

        .IF DF  M$$NET

;+
; **-XBRCV- XBRCV IS CALLED TO INITIATE THE DEVICE FOR AN
; UNSOLICITED RECEIVE.  THE ADDRESS AND THE COUNT FOR THE
; RECEIVE BUFFER IS IN LOCATIONS V.CIAD AND V.CICT IN THE VCB
;
;       INPUTS:
;               R5 = DEVICE UCB ADDRESS
;               R4 = ADRESS OF VCB
;       OUTPUTS:
;               DEVICE IS INITIATED FOR RECEIVE
;               R5,R4,R0,R1 PRESERVED
;-

XBRCV:  CLR     U.RBUF(R5)              ;ZERO MEM  EXTENSION BITS
        MOV     R4,R3                   ;COPY VCB ADDR
        ADD     #V.CIAD,R3              ;POINT TO BUFFER ADDRESS
        MOV     (R3),U.RBUF+2(R5)       ;MOVE BUFFER ADDR
        CLR     (R3)+                   ;CLR ADDR IN VCB
        ROR     (R3)                    ;CHANGE TO WORD COUNT
        ADC     (R3)                    ;ADJUST FOR ODD BYTE COUNT
        MOV     (R3),U.RCNT(R5)         ;MOVE BUFFER COUNT
        BIS     #U3.RPD,U.CW3(R5)       ;SIGNAL RECEIVE PENDING
        TSTB    U.CW3(R5)               ;DEVICE BUSY?
        BNE     10$                     ;DON'T TOUCH CSR IF YES
        MOV     U.SCB(R5),R3            ;GET SCB ADDR
        MOV     #INTENB,@S.CSR(R3)      ;ENABLE INTERRUPTS (CAUSING ONE)
10$:    RETURN                          ;RETURN TO CALLER

;+
; **-MYSYNC- IS CALLED WHEN A RECEIVE ERROR IS DETECTED AND THE
; DEVICE NEEDS TO BE RESYNCED.  THIS IS ACCOMPLISHED BY SETTING THE
; MDOUT BIT INS THE CSR AND INTERRUPTING THE OTHER SYSTEM.  THE MDOUT
; BIT TELLS THE OTHER SYSTEM TO FLUSH THE TRANSMIT ON HIS SIDE.
;
;       INPUTS:
;               R5 = UCB ADDRESS
;               R4 = VCB ADDRESS
;       OUTPUTS:
;               R5,R4,R0,R1 PRESERVED
;-


        .ENABL  LSB

RESYNC: BIT     #U3.RAC,U.CW3(R5)       ;IS RECEIVER ACTIVE?
        BEQ     10$                     ;DON'T TOUCH CSR IF NOT
MYSYNC: MOV     U.SCB(R5),R2            ;GET SCB ADDR
        MOV     #IREQO!MDOUT!INTENB,@S.CSR(R2) ;TELL HIM TO FLUSH XMT
10$:    BIC     #U3.RAC!U3.RPD,U.CW3(R5);CLR RECEIVE ACTIVE AND PENDING
        RETURN                          ;RETURN

        .DSABL  LSB


        .ENDC


        .END

        .TITLE XLDRV
        .IDENT  /12/
;
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 12
;
; J. M. GILBERT, 31-MAR-74
;
; PREVIOUSLY MODIFIED BY:
;
;       S. G. DAVIS
;       J. M. GILBERT
;       L. GILLESPIE
;       E. D. WALDIN
;
; MODIFIED BY:
;
; DL11 ASYNCHRONOUS COMMUNICATIONS DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  HWDDF$,PKTDF$
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        .MCALL  UCBDF$,CUCDF$
        UCBDF$                  ; DEFINE UCB OFFSETS
        CUCDF$                  ;COMMUNICATIONS UCB LABELS
 
 
        .IF DF  M$$NET
 
        .MCALL  F11DF$,CVCDF$
        F11DF$                  ;DEFINE FILES-11 LABELS
        CVCDF$                  ;DEFINE COMMUNICATIONS VCB LABELS
 
        .ENDC
 
 

 
;
; CONFIGURATION DEPENDENT PARAMETERS
;
 
        .IIF NDF M$$NET, SOLRCV= 0 ;GENERATE SOLICITED RECEIVE
MDMCTL= 0                       ;SET IF DL-11E (MODEM CONTROL)
 
;
; EQUATED SYMBOLS
;
 
;
; RXCSR BIT ASSIGNMENTS
;
 
DTSTCH= 100000                  ;DATA SET CHANGE
RING=    40000                  ;RING LINE ASSERTED
CTS=     20000                  ;CLEAR TO SEND
CRRIER=  10000                  ;CARRIER STATE
RECACT=   4000                  ;RECEIVER ACTIVE
RXDONE=    200                  ;RECEIVER DONE
RCVENB=    100                  ;RECEIVER INTERRUPT ENABLE
DSINTE=     40                  ;DATA SET CHANGE INTERRUPT ENABLE
RTS=         4                  ;REQUEST TO SEND
TRMRDY=      2                  ;DATA TERMINAL READY
 
;
; RXDBUF BIT ASSIGNMENTS
;
 
RXERR=  100000                  ;RECEIVER ERROR "OR" BIT
OVRNER=  40000                  ;RECEIVER OVERRUN ERROR IF SET
FRMERR=  20000                  ;RECEIVER FRAMING ERROR
 
;
; TXCSR BIT ASSIGNMENTS
;
 
TXRDY=     200                  ;TRANSMITTER DONE BIT
TXINTE=    100                  ;TRANSMITTER INTERRUPT ENABLE BIT
BREAK=       1                  ;CLAMP OUTPUT TO SPACE
 
;
; LOCAL DATA
;
;
; UNIT IMPURE DATA TABLE (INDEXED BY UNIT, POINTS TO UCB)
;
 
CNTBL:                          ;REF LABEL
UNITBL:                         ;UCB ADDRESSES
        .REPT   D$$E11
        .WORD   0               ;ENSURE SET TO ZERO
        .ENDM
 
        .IF GT  D$$E11-1
 
TEMP:                           ;REF LABEL
UNIT:   .BLKW   1               ;TEMPORARY STORAGE FOR UNIT NUMBER
 
        .ENDC
 
        
        .ENABL  LSB
 
;
; DRIVER DISPATCH TABLE
;
 
$XLTBL::.WORD   DLINIT          ;DEVICE INITIALIZATION
        .WORD   DLCANC          ;DEVICE I/O CANCELLATION
        .WORD   DLTMO           ;TIMEOUT ENTRY POINT
        .WORD   DLPWRF          ;POWER FAIL ROUTINE
 
 
        .IF DF  M$$NET
 
        .WORD   DLRCV           ;UNSOLICITED RECEIVE ENTRY
        .WORD   DLRXER          ;RECEIVER ERROR SERVICE
 
        .IFF
 
        .WORD   140$            ; NOT SUPPORTED UNLESS NETWORK
        .WORD   140$            ; NOT SUPPORTED UNLESS NETWORK
 
        .ENDC
 
 
 

;+
;**-  DLINIT - DL-11 SYNCHRONOUS COMMUNICATION CONTROLLER I/O INITIATOR
;
; DLINIT IS ENTERED WHEN AN I/O REQUEST IS QUEUED ON THE DEVICE,
; AND AT THE END OF EACH QIO REQUEST WHICH OBEYS THE
; NORMAL RSX-11M INPUT/OUTPUT LOGIC FLOW.  IF THE DEVICE IS
; AVAILABLE AND A REQUEST IS IN THE QUEUE FOR THAT UNIT,
; THE REQUEST IS INITIATED.
; IF NO REQUEST EXISTS FOR THAT UNIT OR IF IT IS
; BUSY, AN EXIT IS TAKEN TO THE CALLER.  NOTE  THAT BECAUSE OF
; THE NATURE OF THE DL-11, EACH UNIT IS A CONTROLLER ITSELF,
; HAS ITS OWN SCB, AND THEREFORE ITS OWN QUEUE.
; EACH TIME DLINIT IS CALLED, IT IS CALLED TO SERVICE ONLY
; THE UNIT SPECIFIED IN THE CALL. NOTE ALSO THAT ONLY
; 8-BIT, NO PARITY DATA IS SUPPORTED.
; MESSAGE SYNCHRONIZATION IS PROVIDED BY PRECEDING KEY
; MESSAGES WITH A SYNC TRAIN, MUCH AS WITH A SYNCHRONOUS
; DEVICE.  THE DIFFERENCE, OF COURSE, IS THAT THIS SYNC
; TRAIN IS SOLELY FOR MESSAGE SYNCHRONIZATION.  THE LEADING
; SYNC TRAIN IS UNDER PROGRAM CONTROL, AS IT IS WITH THE
; RSX-11M SYNCHRONOUS LINE CONTROLLERS.
;
; INPUTS:
;
;       R4 = STATUS CONTROL BLOCK ADDRESS
;       R5 = ADDRESS OF THE UCB TO BE INITIATED.
;
; OUTPUTS:
;
;       IF A REQUEST IS SUCCESSFULLY DEQUEUED, THE
;       DEVICE IS INITIATED APPROPRIATELY.
;-
 
DLINIT: TSTB    U.CW2(R5)       ;UNSOLICITED (HDPX) RECEIVE ACTIVE?
        BMI     15$             ;IF SET, NOTHING TO DO - EXIT
        CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCS     15$             ;NO REQUEST OR UNIT BUSY
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1 = ADDRESS OF THE I/O REQUEST PACKET.
;       R2 = PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3 = CONTROLLER INDEX
;       R4 = ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5 = ADDRESS OF THE UCB SPECIFIED IN THE
;            DLINIT CALL.

;
; DL11 I/O REQUEST PACKET FORMAT
;
;       WORD         CONTENT
;
;         0     I/O QUEUE THREAD WORD
;         1     REQUEST PRIORITY, EVENT FLAG NUMBER
;         2     ADDRESS OF THE TCB OF THE REQUESTER TASK
;         3     POINTER TO SECOND LUN WORD IN TASK HEADER
;         4     CONTENTS OF FIRST LUN WORD (UCB)
;         5     I/O FUNCTION CODE
;         6     VIRTUAL ADDRESS OF I/O STATUS BLOCK
;         7     RELOCATION BIAS OF I/O STATUS BLOCK
;        10     I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000)
;        11     VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;        12     RELOCATION BIAS OF I/O BUFFER
;        13     BUFFER ADDRESS FOR TRANSFER
;        14     TOTAL BYTE COUNT TO TRANSFER
;        15     BYTE COUNT FOR SECOND PART OF TRANSMISSION OR 0
;        16     NOT USED
;        17     NOT USED
;        20     NOT USED
;
 
        MOV     S.CSR(R4),R2    ;GET RECEIVER CSR ADDRESS
        ADD     #I.FCN+1,R1     ;POINT TO I/O FUNCTION CODE
        CMPB    #IO.INL/256.,(R1) ;CHECK IF TRANSFER FUNCTION
        BLOS    40$             ;BRANCH ON CONTROL FUNCTION
        BIT     #U2.ONL,U.CW2(R5) ;IS DEVICE ON LINE (INITIALIZED?)
        BEQ     50$             ;CAN'T TRANSFER IF NOT
        CMPB    #IO.RLB/256.,(R1) ;READ LOGICAL?
        BEQ     20$             ;YES, SERVICE READ REQUEST
;
; FALL THROUGH ON TRANSMIT (WRITE LOGICAL)
;
 
        .IF DF  M$$NET
 
        CALL    @U.PHDR(R5)     ;CALL COROUTINE FOR TX INITIATE
 
        .ENDC
 
 
        MOVB    S.ITM(R4),S.CTM(R4) ;INITIALIZE TIMEOUT COUNT
        MOVB    U.NSYN(R5),R3   ;NO. OF SYNCS IN LEADER
        BITB    #IO.WNS,-(R1)   ;TRANSPARENT WRITE?
        BEQ     5$              ;IF EQ NO
        CLR     R3              ;SHOW NO SYNCS
5$:     MOVB    R3,U.NSYC(R5)   ;SET NO. OF SYNCS NEEDED
 
 
        .IF DF  MDMCTL
 
        BIT     #CTS,(R2)       ;CLEAR TO SEND SET YET?
        BNE     10$             ;IF SO, START TRANSMITTING
        BIS     #U2.CTS,U.CW2(R5) ;SAY CLEAR TO SEND EXPECTED
        BIS     #RTS!DSINTE,(R2) ;ASSERT REQUEST TO SEND
        BR      140$            ;RETURN - INTERRUPT PROPAGATES TRANSFER
 
        .ENDC
 
 
10$:    BIS     #TXINTE,4(R2)   ;ENABLE TRANSMITTER
15$:    BR      140$            ;RETURN, INTERRUPT PROPAGATES TX
 
;
; RECEIVE FUNCTION INITIATION
;
 
20$:                            ;REFERENCE LABEL
 
 
        .IF DF  SOLRCV
 
        BIC     #U2.FTM!U2.SYC,U.CW2(R5) ; ASSUME TRANSPARENT OP
        BITB    #IO.RNS,-(R1)   ;TRANSPARENT READ?
        BNE     30$             ;IF NE YES
        BIS     #U2.FTM!U2.SYC,U.CW2(R5) ;NON-TRANSPARENT READ
30$:                            ;REF LABEL
        MOV     R5,R0           ;SET UP TRANSFER VECTOR
        ADD     #U.RBUF,R0      ;RECEIVE TRANSFER INFORMATION HERE
        MOV     U.BUF(R5),(R0)+ ;TRANSFER BIAS
        MOV     U.BUF+2(R5),(R0)+ ;AND VIRTUAL ADDRESS
        MOV     U.CNT(R5),(R0)  ;AND COUNT
        TSTB    2(R2)           ; CLEAR RECEIVE BUFFER STATUS
        BIS     #RCVENB,(R2)    ; ENABLE RECEIVER
        BR      140$            ;RETURN - INTERRUPT CODE PROPAGATES RECEIVE
 
        .IFF
 
        BR      90$             ;MARK AS INVALID FUNCTION
 
        .ENDC
 
 
;
; CONTROL FUNCTION INITIATION (INITIATE OR TERMINATE CONTROLLER,
; OR CHANGE OPERATING MODE)
;
 
40$:    BNE     70$             ;IF NOT EQUAL, MODE CHANGE REQUEST
        CLR     (R2)            ;CLEAR RXCSR
        TSTB    -(R1)           ;START FUNCTION?
        BNE     60$             ;IF NON-ZERO, TERMINATE
;
; DO START FUNCTION INITIATION
;
 
 
        .IF DF  MDMCTL
 
        BIS     #TRMRDY,(R2)    ;INITIALIZE CONTROLLER
 
        .ENDC
 
 
        MOV     R5,UNITBL(R3)   ;INITIALIZE UCB ADDRESS IN UNIT TABLE
        BIS     #U2.ONL,U.CW2(R5) ;MARK UNIT ON LINE
        BIC     #U2.SYC,U.CW2(R5) ;CLEAR RECEIVER SYNC COUNT
        BR      120$            ;RETURN SUCCESSFUL
 
;
; CAN'T ESTABLISH COMMUNICATIONS
;
 
50$:    MOV     #IE.DNR&377,R0  ;SAY CAN'T INITIALIZE DEVICE (NOT READY)
        BR      130$            ;DO I/O DONE
 
;
; FUNCTION WAS TERMINATE LINE
;
 
60$:    BIC     #^C<U2.LIN!U2.SWC!U2.ACU>,U.CW2(R5) ;CLEAR OPERATING STATUS
        CLR     UNITBL(R3)      ;UNIT TABLE CLEARED OF UCB
        BR      120$            ;RETURN SUCCESSFUL STATUS
 
;
; SERVICE DEVICE MODE CHANGE REQUEST
;
 
70$:    BITB    #IO.HDX,-(R1)   ; SUBFUNCTION SAY HALF DUPLEX?
        BEQ     80$             ;IF ZERO, NO
        BIS     #U2.HDX,U.CW2(R5) ;SAY HALF DUPLEX CHARACTERISTIC
80$:    BITB    #IO.FDX,(R1)    ;SET MODE TO FULL DUPLEX?
        BEQ     110$            ;DON'T SET FULL DUPLEX
        BIT     #U2.LIN,U.CW2(R5) ;IS LINK FULL DUPLEX?
        BEQ     100$            ;IF SO, RUN FULL DUPLEX
90$:    MOV     #IE.IFC&377,R0 ;MARK AS ILLEGAL FUNCTION
        BR      130$            ;AND TERMINATE
 
100$:   BIC     #U2.HDX,U.CW2(R5) ;PUT IN FULL DUPLEX IN UCB
 
110$:   BITB    #IO.SYN,(R1)    ;SYNC CHARACTER SPECIFIED?
        BEQ     120$            ;NO, IF NOT SET
        MOVB    I.PRM-I.FCN(R1),U.SYNC(R5) ;RESET SYNC CHARACTER
DLSUCC:                         ;REFERENCE LABEL
120$:   MOV     #IS.SUC&377,R0  ;RETURN SUCCESSFUL STATUS
DLFIN:                          ;REFERENCE LABEL
130$:   CLRB    S.STS(R4)       ;CLEAR CONTROLLER STATUS
        BICB    #US.BSY,U.STS(R5) ;CLEAR UNIT STATUS
        MOV     R0,-(SP)        ;SAVE STATUS WORD 1
        MOV     S.PKT(R4),-(SP) ;SAVE PACKET ADDRESS
        CALL    DLINIT          ;ATTEMPT TO INITIATE SOMETHING
        MOV     (SP)+,R3        ;RESTORE PACKET ADDRESS
        MOV     I.PRM+4(R3),R1  ;RETURN REQUESTED COUNT
        MOV     (SP)+,R0        ;RESTORE STATUS WORD 1
        CALLR   $IOFIN          ;TERMINATE LAST PACKET
 
140$:   RETURN
 
;
; POWER FAIL SERVICE
;
 
DLPWRF:                         ;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        CALLR   DLRXER          ;RESYNC RECEIVER, WAIT FOR
                                ;TRANSMIT TO TIMEOUT
 
        .IFF
 
        CLRB    S.CTM(R4)       ;DISABLE TIMEOUTS
        BR      50$             ;FINISH I/O
        
        .IFTF
 
;
; I/O CANCELLATION
;
 
DLCANC:                         ;;;REFERENCE LABEL
 
        .IFT
 
        RETURN                  ;;;JUST WAIT FOR TRANSMIT TO FINISH
 
        .IFF
 
        CMP     R1,I.TCB(R0)    ;;;CANCEL FOR THIS TASK?
        BNE     140$            ;;;JUST RETURN IF NOT
        CMPB    #IO.WLB/256.,I.FCN+1(R0) ;;;WAS FUNCTION TRANSMIT?
        BEQ     140$            ;;;JUST LET FINISH IF YES
        TST     U.RCNT(R5)      ;;;RECEIVE FINISHED?
        BLE     140$            ;;;BR IF YES
        BIC     #RCVENB,@S.CSR(R4) ;;;DISABLE RECEIVER
        MOV     #IE.ABO&377,R0  ;;;PUT ERROR CODE IN R0
        CLR     U.RCNT(R5)      ;;;MARK COUNT SATISFIED
        BR      150$            ;;;FINISH OFF I/O
        
        .ENDC
 
 
;
; TIMEOUT SERVICE ROUTINE
;
;       INPUTS:
;
;               R0 = DEVICE TIMEOUT STATUS 'IE.DNR'
;               R3 = CONTROLLER INDEX
;               R4 = ADDRESS OF SCB
;               R5 = ADDRESS OF UCB
;
 
DLTMO:                          ;;;TIMEOUT ENTRY POINT
        MOV     S.CSR(R4),R3    ;;;GET RECEIVER CSR
        BIC     #TXINTE,4(R3)   ;;;DISABLE TRANSMITTER
 
        .IF DF  MDMCTL
 
        BIC     #RTS!DSINTE,(R3);;;CLEAR RTS AND DATA SET ENABLE
        BIC     #U2.CTS,U.CW2(R5);;;CLEAR WAITING FOR CTS
        
        .ENDC
 
150$:                           ;;;REFERENCE LABEL
        MTPS    #0              ;;;ALLOW INTERRUPTS
        JMP     DLTXND          ;;;WAIT FOR SOFTWARE TIMEOUT TO FINISH
        .DSABL  LSB

 
;
; **- $XLINP - DL-11 INPUT INTERRUPT SERVICE
;
 
$XLINP::                        ;;;REFERENCE LABEL
        INTSV$  XL,PR5,D$$E11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DLSET           ;;;SET CSR IN R4, UCB IN R5
 
        .IF DF  M$$NET
 
        MOV     R3,-(SP)        ;;;SAVE R3 THROUGH R0
        MOV     R2,-(SP)
        MOV     R1,-(SP)
        MOV     R0,-(SP)
        MOV     R4,R2           ;;;COPY RX CSR ADDRESS
        
        .ENDC
 
        MOV     (R4),-(SP)      ;;;SAVE CSR, TEST DATA SET CHANGE
 
 
        .IF DF  MDMCTL
 
        BPL     10$             ;;;NO DATA SET CHANGE, IF NOT SET
        BIT     #U2.CTS,U.CW2(R5) ;;;CTS EXPECTED?
        BEQ     5$              ;;;NO, IF NOT SET
        BIT     #CTS,(R4)       ;;;CLEAR TO SEND?
        BEQ     10$             ;;;NO, CHECK ON ERROR
        BIS     #TXINTE,4(R4)   ;;;ENABLE TRANSMITTER INTERRUPT
        BIC     #U2.CTS,U.CW2(R5) ;;;HAVE CTS
5$:     BIC     #DSINTE,(R4)    ;;;DISABLE DATA SET INTERRUPTS
 
        .IFTF
 
10$:    MOV     2(R4),R4        ;;;CAPTURE BUFFER REGISTER IN R4
 
 
        .IF DF  M$$NET
 
        MOV     U.VCB(R5),R3    ;;;GET VCB ADDRESS
        BIT     #OVRNER,R4      ;;;CHECK OVERRUN ERROR
        BEQ     20$             ;;;NOT OVERRUN - DON'T COUNT ERROR
        INC     V.COVR(R3)      ;;;MARK THAT OVERRUN OCCURRED
 
        .ENDC
        .ENDC
 
 
20$:    TSTB    (SP)+           ;;;RECEIVER DONE?
        BPL     70$             ;;;IF NOT, DISMISS INTERRUPT
        TST     U.RCNT(R5)      ;;;COUNT ALREADY SATISFIED?
        BLE     70$             ;;;IF SO, DISMISS INTERRUPT
        BIT     #U2.FTM,U.CW2(R5) ;;;IN MESSAGE SYNCH?
        BEQ     60$             ;;;IF NOT SET, YES
 
        .IF DF  M$$NET
 
; MESSAGE SYNC IS ACHIEVED BY LOOKING FOR THE START OF A
; MESSAGE. ALL CHARACTERS ARE DISCARDED UNTIL A START
; OF MESSAGE CHARACTER (ENQ,DLE, OR SOH) IS FOUND.
; THIS APPLIES FOR NETWORKS ONLY.
 
        CMPB    #5,R4           ;;;IS IT AN ENQ?
        BEQ     50$             ;;;START OF MESSAGE IF YES
        CMPB    #201,R4         ;;;IS IT AN SOH?
        BEQ     50$             ;;;START OF MESSAGE IF YES
        CMPB    #220,R4         ;;;IS IT A DLE?
        BNE     70$             ;;;IGNORE CHARACTER IF NOT
 
        .IFF
 
        CMPB    U.SYNC(R5),R4   ;;;IS CHARACTER A SYNC?
        BNE     30$             ;;;IF NOT, MAY BE DATA
        BIT     #U2.SYC,U.CW2(R5) ;;;WERE WE SYNCHING?
        BEQ     70$             ;;;ALREADY SYNCHED - JUST DISCARD
        DECB    U.CW2(R5)       ;;;DECREMENT RECEIVER SYNC COUNT
        RETURN                  ;;;DISMISS INTERRUPT
        
30$:    BIT     #U2.SYC,U.CW2(R5) ;;;COUNT SATISFIED?
        BEQ     50$             ;;;YES, IF EQUAL
        BISB    #2,U.CW2(R5)    ;;;TRY TO SYNC AGAIN
        RETURN                  ;;;DISMISS INTERRUPT
        
        .ENDC
 
50$:    BIC     #U2.FTM,U.CW2(R5) ;;;NOW PAST LEADING SYNCS
60$:                            ;;;REFERENCE LABEL
 
 
        
        .IF DF  SOLRCV&M$$MGE
 
        MOV     KISAR6,-(SP)    ;;;SAVE CURRENT MAPPING
        MOV     U.RBUF(R5),KISAR6 ;;;MAP TO USER BUFFER
        MOVB    R4,@U.RBUF+2(R5) ;;;STORE BYTE IN USER BUFFER
        MOV     (SP)+,KISAR6    ;;;RESTORE CURRENT MAPPING
 
 
        .IFF
 
        MOVB    R4,@U.RBUF+2(R5) ;;;STORE BYTE IN USER BUFFER
 
        .IFTF
 
        DEC     U.RCNT(R5)      ;;;SEE IF COUNT SATISFIED
        BEQ     80$             ;;;YES, IF EQUAL
        INC     U.RBUF+2(R5)    ;;;BUMP BYTE ADDRESS
 
        .IFT
 
        BIT     #20000,U.RBUF+2(R5) ;;;OVERFLOWED 4K BOUNDARY?
        BEQ     70$             ;;;NO, IF ZERO
        BIC     #20000,U.RBUF+2(R5) ;;;CLEAR OVERFLOW BIT
        ADD     #200,U.RBUF(R5) ;;;BUMP BIAS
 
        .ENDC
 
 
70$:                            ;;;REFERENCE LABEL
        .IF DF  M$$NET
 
        MOV     (SP)+,R0        ;;;RESTORE R0 THRU R3
        MOV     (SP)+,R1
        MOV     (SP)+,R2
        MOV     (SP)+,R3
 
        .ENDC
 
        RETURN                  ;;;EXIT INTERRUPT
        
;
; REQUEST SATISFIED
;
 
80$:                            ;;;REFERENCE LABEL
 
        .IF NDF M$$NET
 
        MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS
        BIC     #RCVENB,@S.CSR(R4) ;;;DISABLE RECEIVER
        CALL    $FORK           ;;;GO TO FORK LEVEL
        JMP     DLSUCC          ;FINISH I/O SUCESSFUL
 
        .IFF
 
        CLR     R1              ;;;RETURN CRC=0
        ADD     #V.CIAD,R3      ;;;POINT TO 1ST BUFFER ADDR
        MOV     (R3),U.RBUF+2(R5) ;;;PUT BUFFER ADDR IN UCB
        BNE     100$            ;;;USE IT IF THERE
        
90$:    ADD     #V.CSAD-V.CIAD,R3 ;;;POINT TO SEC BUFFER ADDR
        MOV     (R3),U.RBUF+2(R5) ;;;PUT BUFFER ADDR IN UCB
        BNE     100$            ;;;CONTINUE IF BUFFER HERE
        BIC     #RCVENB,(R2)    ;;; ERROR, DISABLE INTERRUPTS
        MOV     R2,R0           ;;;RETURN BAD STATUS
        BR      110$            ;;;CALL CO-ROUTINE
 
100$:   CLR     (R3)+           ;;;CLR BUFFER ADDR IN VCB
        MOV     (R3),U.RCNT(R5) ;;;PUT RCV COUNT IN UCB
        CLR     R0              ;;;RETURN GOOD STATUS
110$:   CALL    @U.SVC(R5)      ;;;GO TO CO-ROUTINE
        BCS     120$            ;;;IF C SET, DO NOTHING
        BPL     120$            ;;;DON'T CLEAR RECV IF OK
        BIC     #RCVENB,(R2)    ;;; ERROR, DISABLE RECEIVER
120$:   RETURN                  ;;;RETURN TO CO-ROUTINE
 
        .ENDC
 

;
; **- $XLOUT - TRANSMITTER INTERRUPT SERVICE
;
 
$XLOUT::                        ;;;REFERENCE LABEL
        INTSV$  XL,PR5,D$$E11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DLSET           ;;;SET RECEIVE CSR IN R4, UCB IN R5
        ADD     #6,R4           ;;; POINT TO TRANSMITTER BUFFER
;
; SET UP AND TRANSMIT A BYTE
;
        DECB    U.NSYC(R5)      ;;;DECREMENT LEADING SYNC COUNT
        BLT     10$             ;;;IF LT GO TO DATA
        MOVB    U.SYNC(R5),(R4) ;;;SEND ANOTHER SYNC CHARACTER
        BR      30$             ;;;RESET TIMEOUT, EXIT
 
10$:    INCB    U.NSYC(R5)      ;;; OFFSET DECREMENT ABOVE
        DEC     U.CNT(R5)       ;;; CHECK COUNT
        BGE     20$             ;;;IF GE,  CONTINUE
 
        .IF DF  SOLRCV
 
        TST     U.CW2(R5)       ;;;IN HALF DUPLEX?
        BPL     50$             ;;;IF NOT, NO LINE TURNAROUND
 
        .ENDC
 
        .IF DF  M$$NET
 
        TSTB    U.CW2(R5)       ;;;RECEIVER TO BECOME ACTIVE?
        BPL     50$             ;;; IF NOT, DON'T TURN LINE AROUND
 
        .IFTF
 
        CMP     #-3,U.CNT(R5)   ;;;SENT 2 MARKS?
        BGE     40$             ;;;IF SO, TURN LINE AROUND
        MOVB    #-1,(R4)        ;;;SEND A MARK
        BR      30$             ;;;DISMISS INTERRUPT
 
20$:    CALL    $GTBYT          ;;;GET NEXT BYTE FROM BUFFER
        MOVB    (SP)+,(R4)      ;;;OUTPUT CHARACTER
30$:    MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS BACK
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET TIMEOUT COUNT
        RETURN                  ;;;EXIT INTERRUPT
        
40$:                            ;;;REFERENCE LABEL
 
 
        .IF DF  MDMCTL
 
        BIC     #RTS,-6(R4)     ;;;CLR REQUEST TO SEND
 
        .ENDC
 
        .IFT
 
;       TST     U.CW2(R5)       ;;;IN HALF DUPLEX?
;       BPL     50$             ;;;NO TOUCH RCVER IF FULL DUPLEX
;       TST     -4(R4)          ;;;CLEAR RCVER DONE
;       BIS     #RCVENB,-6(R4)  ;;;RE-ENABLE RECEIVER
        
        .IFTF
 
50$:    BIC     #TXINTE,-(R4)   ;;;DISABLE TRANSMITTER
        CALL    $FORK           ;;;CREATE SYSTEM PROCESS
 
        .IFF
 
        MOV     #IS.SUC&377,R0  ;RETURN SUCCESSFUL STATUS
 
        .IFTF
 
DLTXND:                         ;REFERENCE LABEL
 
        .IFT
 
        MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS IN R4
        MOV     S.PKT(R4),R1    ;;;GET PACKET ADDR TO FINISH
        CALL    @U.PHDR(R5)     ;;;CALL COROUTINE TO FINISH TRANSMIT
60$:    JMP     DLINIT          ;SEE IF MORE TO DO
 
        .IFF
 
        MOV     U.SCB(R5),R4    ;RESTORE SCB TO R4
        JMP     DLFIN           ;MARK COMPLETION
        
        .ENDC
 
 

 
 
        .IF DF  M$$NET
 
;
; RECEIVER ERROR DETECTED WHICH REQUIRES RESYNCHING OF CONTROLLER
; IN THE CASE OF AN ASYNCHROUNOUS DEVICE, THE SYNCHING
; IS TO PROVIDE MESSAGE SYNCH, RATHER THAN CHARACTER SYNCH.
;
;       INPUTS:
;               R5 = UCB ADDRESS
;
;       OUTPUTS:
;               SYNCH COUNT RESET, R5 PRESERVED
;
 
DLRXER: BIS     #U2.FTM,U.CW2(R5);SET SEARCH FOR MESSAGE SYNC
        RETURN                  ;EXIT
;
;
; UNSOLICITED RECEIVE INITIALIZATION
; ACTIVATES CONTROLLER TO BE READY TO ACCEPT DATA,
; AND TO SATISFY COUNT INTO BUFFER ADDRESS ALREADY SET
; UP IN UNIT CONTROL BLOCK.  CODE AT 10$ ENTERED EACH
; TIME A REQUEST IS SATISFIED.
;
; INPUTS:
;
;       R5 = UCB ADDRESS
;
; OUTPUTS:
;
;       R0,R1 PRESERVED
;       R5 = UCB ADDRESS
;
 
DLRCV:  BIS     #U2.FTM,U.CW2(R5);ENTER SYNCHING MODE
        CLR     U.RCAC(R5)      ;INITIALIZE REDUNDANCY CHECK REGISTER
        MOV     V.CIAD(R4),U.RBUF+2(R5) ;PUT 1ST RCV BUFFER IN UCB
        MOV     V.CICT(R4),U.RCNT(R5) ;PUT RCV COUNT IN UCB
        CLR     V.CIAD(R4)      ;CLR 1ST BUFFER ADDR IN VCB
20$:    MOV     U.SCB(R5),R2    ;GET SCB ADDRESS
        BIS     #RCVENB,@S.CSR(R2) ;ENABLE RECEIVER
        RETURN                  ;GO BACK TO CALLER
 
        .ENDC
 
 

;
; DLSET - SET UP REGISTER R4 WITH CSR ADDRESS, R5 WITH
;       UCB ADDRESS.  UNIT NUMBER IN LOW ORDER 4 BITS OF UNIT.
;
 
DLSET:                          ;;;REFERENCE LABEL
        TST     R5              ;;;CHECK FOR UCB ADDRESS
        BEQ     10$             ;;;IF NO UCB, TROUBLE
        BIT     #U2.ONL,U.CW2(R5) ;;;UNIT ON LINE?
        BEQ     10$             ;;;IF NOT ON LINE, NONSENSE
        MOV     U.SCB(R5),R4    ;;;FIRST GET SCB ADDRESS
        MOV     S.CSR(R4),R4    ;;;NOW DEVICE CSR ADDRESS
        RETURN                  ;;;AND NOW RETURN
 
10$:    TST     (SP)+           ;;;CLEAR STACK OF RETURN ADDRESS
DLSXT:  JMP     $INTXT          ;;;DISMISS INTERRUPT
 
        .END
        .TITLE  XMDRV
        .IDENT  /03.13/
;
; COPYRIGHT (C) 1976, 1977, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS. 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
; AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS
; SOFTWARE OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED
; OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON. NO TITLE TO
; AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY
; DIGITAL EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
; OF ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;
; VERSION 03.13
;
;
; PROGRAM:
;       DMC-11 DRIVER
;
; IDENT HISTORY:
;       03.11   10-DEC-77       LUKE GILLESPIE
;
;
;
;
;       MODIFIED BY:
;
;               J. F. REED      7-NOV-78
;
;               JFR001          --      MODIFIED FOR M+
;       
;               JFR002          --      CHANGE TO QIO DRIVER ONLY
;
;               JFR003          --      CORRECTION OF MODE CHANGE ERROR
;
;
;
;               JFR004          --      DISABLE INTERRUPTS DURING POWERFAIL
;                                       MASTER CLEAR
;
        .SBTTL  LIBRARY MACROS                                          ;JFR002
                                                                        ;JFR002
        .MCALL  CUCDF$,INTSV$,PKTDF$,SCBDF$,UCBDF$                      ;JFR002
        CUCDF$          ;COMMUNICATIONS UCB DEFINITIONS                 ;JFR002
        PKTDF$          ;I/O PACKET DEFINITIONS
        SCBDF$          ;SCB DEFINITIONS
        UCBDF$          ;UCB DEFINITIONS

        .SBTTL  CONDITIONAL ASSEMBLY PARAMETERS

; 22 BIT ADDRESSING
.IIF DF M$$MGE & M$$EXT, X$$22=0

; 18 BIT ADDRESSING
.IF DF M$$MGE
.IIF NDF M$$EXT, X$$18=0
.ENDC

                                                                        ;JFR002
; QIO DRIVER PLUS 22 BIT ADDRESSING                                     ;JFR002
.IIF DF X$$22 Q$$22=0                                                   ;JFR002
        X$$M11=X$$M11           ; DON'T LAUGH                           ;JFR002
                                                                        ;**-5
; LOADABLE DRIVER MAPPING NEEDED
.IIF DF M$$MGE & LD$XM, X$$LDM=0

; DYNAMIC UMR ALLOCATION COUNT FOR RSX-11M VERSION 3.1
        .IF     DF      R$$MPL!V$$RSN&Q$$22                             ;JFR001
.IIF NDF XM$UMR, XM$UMR=5                                               ;**-1
.IIF NE XM$UMR-3, XM$UMR=5
.ENDC

        .SBTTL  EQUATED SYMBOLS

; BIT ASSIGNMENTS
BIT0=1
BIT1=2
BIT2=4
BIT3=10
BIT4=20
BIT5=40
BIT6=100
BIT7=200
BIT8=400
BIT9=1000
BIT10=2000
BIT11=4000
BIT12=10000
BIT13=20000
BIT14=40000
BIT15=100000

; CSR INDEX VALUES
SEL0=0
SEL2=2

; SEL0 ASSIGNMENTS
RUN=BIT15               ;RUN
MC=BIT14                ;MASTER CLEAR
RDYI=BIT7               ;MICROPROCESSOR READY FOR INPUT
IEI=BIT6                ;INPUT INTERRUPT ENABLE
RQI=BIT5                ;REQUEST IN
TYPE=BIT2!BIT1!BIT0     ;REQUEST TYPE
RELEAS=RQI!IEI          ;PORT RELEASE

; SEL0 INPUT TRANSACTION TYPES
BACCI=RQI               ;BUFFER ADDRESS/CHARACTER COUNT IN
CNTLI=RQI!BIT0          ;CONTROL IN
BASEI=RQI!BIT1!BIT0     ;BASE IN
XMT=BACCI               ;TRANSMIT BUFFER
RCV=BACCI!BIT2          ;RECEIVE BUFFER
PERR=BASEI              ;CAUSE PROCEDURE ERROR BY DOING BASE IN TWICE

; SEL2 ASSIGNMENTS
RDYO=BIT7               ;MICROPROCESSOR READY FOR OUTPUT
IEO=BIT6                ;OUTPUT INTERRUPT ENABLE

; SEL6 ASSIGNMENTS (CNTLI)
HDX=BIT10               ;HALF DUPLEX
SCNDRY=BIT11            ;HALF DUPLEX SECONDARY STATION
MOP=BIT8                ;MAINTENANCE MODE

; SEL6 ASSIGNMENTS (BASEI)
RESUME=BIT12            ;RESUME AFTER POWERFAIL (PERIPHERALS HANDBOOK IS WRONG!)

; SEL6 ASSIGNMENTS (CNTLO)
DATACK=BIT0             ;RETRANSMISSION THRESHOLD EXCEEDED
TIMOUT=BIT1             ;NO REMOTE RESPONSE FOR 21 SECONDS
ORUN=BIT2               ;MESSAGE RECEIVED BUT NO BUFFER AVAILABLE
MAINT=BIT3              ;DDCMP MAINTENANCE RECEIVED
LOST=BIT4               ;MESSAGE RECEIVED > BUFFER SIZE
DISCON=BIT6             ;MODEM DATA SET READY LEAD WENT FROM ON TO OFF
START=BIT7              ;DDCMP START RECEIVED
MEMORY=BIT8             ;UNIBUS TIME-OUT ON MEMORY REFERENCE
BUG=BIT9                ;PROGRAM BUG!
FATAL=TIMOUT!MAINT!LOST!START!MEMORY!BUG

; U.CW3 ASSIGNMENTS
U3.ERR=BIT15            ;HAS FATAL ERROR OCCURRED? (1=YES)
U3.KIL=BIT14            ;HAS I/O KILL BEEN DONE? (1=YES)
U3.PWF=BIT13            ;HAS POWER FAILED? (1=YES)
U3.MOD=HDX!SCNDRY!MOP   ;CURRENT OPERATING MODE
U3.FRK=BIT0             ;IS FORK PROCESS RUNNING? (1=YES)

; UCB DISPLACEMENTS USED
        .ASECT
        .=U.VCB+2
U.XQ:   .BLKW   1       ;TRANSMIT LISTHEAD ADDRESS
U.RQ:   .BLKW   1       ;RECEIVE LISTHEAD ADDRESS
U.ERR:  .BLKW   1       ;ERROR STATUS
U.LEN=.                                                                 ;**-4
        .PSECT

; MAXIMUM NUMBER OF BUFFERS WHICH DMC CAN HANDLE
.IF DF Q$$22
        .IF     DF      V$$RSN!R$$MPL                                   ;JFR001
.IIF EQ XM$UMR-3, MAXBUF=1                                              ;**-1
.ENDC
.IIF NDF MAXBUF, MAXBUF=2
.ENDC
.IIF NDF MAXBUF, MAXBUF=7

; LISTHEAD DISPLACEMENTS
        .ASECT
        .=0
        .BLKW   2       ;SENT QUEUE
        .BLKW   2       ;WAIT QUEUE
IOTYPE: .BLKB   1       ;SEL0 REQUEST TYPE
COUNT:  .BLKB   1       ;SENT COUNT
        .IF DF  Q$$22
UMR:    .BLKW   1       ;NEXT UMR TO USE
UMRSUM: .BLKW   1       ;SUM OF BOTH UMR ADDRESSES
        .ENDC
        .PSECT

; FIRST UMR ADDRESS
FIRSTUMR=170200

; WHERE BUFFER ADDRESS AND COUNT ARE TO BE FOUND
X.PRM=I.PRM                                                             ;JFR002
                                                                        ;**-2
; DEVICE INITIALIZATION WAIT TIMES
S.WAIT=200.     ;LOOP COUNTDOWN VALUE WAITING FOR RDYI TO BE SET
C.WAIT=100.     ;DITTO WAITING FOR RDYI TO BE CLEARED

        .SBTTL  LOCAL DATA

; MICROPROCESSOR BASE TABLE(S)
; *** WARNING *** THIS MUST BE THE FIRST ASSEMBLY LOCATION
BASE:   .REPT   X$$M11
        .BLKW   128.
        .ENDR

; DRIVER DISPATCH TABLE
        .IF     DF      R$$MPL                                          ;JFR001
        DDT$    XM,X$$M11,<INP,OUT>,INIT,CNTBL,NEW                      ;JFR001
        .IFF                                                            ;JFR001
        DDT$    XM,X$$M11,<INP,OUT>,INIT,CNTBL                          ;JFR001
        .ENDC                                                           ;JFR001
                                                                        ;**-15
; TEMPORARY UNIT SAVE
        .IF GT  X$$M11-1
TEMP:   .BLKW   1
        .ENDC

; LISTHEADS
LIST:   .REPT   X$$M11
        .WORD   0,.-2   ;COMPLETED BUFFERS
        .WORD   0,.-2   ;TRANSMITS SENT (U.XQ)
        .WORD   0,.-2   ;TRANSMITS WAITING
        .BYTE   XMT,0
        .IF DF  Q$$22
        .BLKW   2
        .IFTF
        .WORD   0,.-2   ;RECEIVES SENT (U.RQ)
        .WORD   0,.-2   ;RECEIVES WAITING
        .BYTE   RCV,0
        .IFT
        .BLKW   2
        .ENDC
        .ENDR

; MULTIPLE UNIT BASE TABLE ADDRESSES
        .IF NDF X$$LDM
        .IF GT  X$$M11-1
BTAB:
BADDR=BASE
        .REPT   X$$M11
        .WORD   BADDR
BADDR=BADDR+256.
        .ENDR
        .ENDC
        .ENDC

; MULTIPLE UNIT LISTHEAD ADDRESSES
        .IF GT  X$$M11-1
XLTAB:
XLADDR=LIST+4
        .REPT   X$$M11
        .WORD   XLADDR
        .IF DF  Q$$22
XLADDR=XLADDR+32.
        .IFF
XLADDR=XLADDR+24.
        .ENDC
        .ENDR
        .ENDC

; ADDRESS EXTENSION BITS
        .IF DF  M$$MGE
AXTAB:  .WORD   0,40000,100000,140000
        .ENDC

        .SBTTL  INITIATE I/O

;+
; **-XMINIT-INITIATE DMC I/O
;
; INPUTS:
;       R5=UCB ADDRESS
;
; OUTPUTS:
;       ALL I/O PACKETS PROCESSED
;
; NOTE:
;       IF TIMER IS ACTIVE, DISCONNECT ERROR RECOVERY IS IN PROGRESS
;-
XMRET:  RETURN
XMINIT: MOV     U.SCB(R5),R4    ;SCB ADDRESS

        TSTB    S.CTM(R4)       ;IS TIMER ACTIVE?                       ;JFR002
        BNE     XMRET           ;IF NE, YES - MUST WAIT                 ;JFR002
        MOVB    S.STS(R4),-(SP) ;SAVE ACTIVITY COUNT                    ;JFR002
                                                                        ;**-5
        CLRB    S.STS(R4)       ;DECLARE CONTROLLER NOT BUSY
        GTPKT$  XM,X$$M11,,CNTBL                                        ;JFR001
                                                                        ;JFR002
        MOVB    (SP)+,S.STS(R4) ;RESTORE ACTIVITY COUNT                 ;JFR002
                                                                        ;JFR002
        BCS     XMRET           ;IF CS, NO MORE PACKETS                 ;JFR002
                                                                        ;JFR002
;                                                                       ;**-12
; $GTPKT RETURNS THE FOLLOWING:
;       R1=I/O PACKET ADDRESS
;       R2=PHYSICAL UNIT NUMBER (U.UNIT)
;       R3=CONTROLLER INDEX (S.CON)
;       R4=SCB ADDRESS
;       R5=UCB ADDRESS
;
        MOV     R5,R2           ;UCB ADDRESS
        ADD     #U.CW2,R2       ;U.CW2 ADDRESS
        CMPB    #IO.INL/256.,I.FCN+1(R1);IS IT A TRANSFER FUNCTION?

        BLOS    2$              ;IF LOS, NO                             ;**-3
        JMP     TRAN            ;ELSE IT IS A TRANSFER REQUEST
;
; CONTROL FUNCTION
;
2$:     BNE     20$             ;IF NE, MODE CHANGE REQUEST
                                                                        ;**-1
        TSTB    I.FCN(R1)       ;IS IT TERMINATE FUNCTION?
        BNE     10$             ;IF NE, YES
;
; INITIALIZE (IO.INL)
;
        BIT     #U2.ONL,(R2)    ;IS DEVICE ALREADY ON-LINE?
        BNE     PKTOK           ;IF NE, YES
        MOV     R5,CNTBL(R3)    ;SAVE UCB ADDRESS

        .IF GT  X$$M11-1
        MOV     XLTAB(R3),R0    ;TRANSMIT LISTHEAD ADDRESS
        .IFF
        MOV     #LIST+4,R0      ;TRANSMIT LISTHEAD ADDRESS
        .ENDC

        MOV     R0,U.XQ(R5)     ;SAVE TRANSMIT LISTHEAD ADDRESS
        ADD     #COUNT,R0       ;POINT TO SENT COUNT
        CLRB    (R0)+           ;ZERO IT OUT

        .IF DF  Q$$22

        .IF DF V$$RSN!R$$MPL                                            ;JFR001
        .IF     NDF     R$$MPL                                          ;JFR001
        TST     S.MPR+2(R4)     ;DOES UMR BLOCK ALREADY EXIST?          ;**-1
        .IFF                                                            ;JFR001
        MOV     S.KRB(R4),R2    ; MOV KRB ADDRESS INTO R2               ;JFR001
        ADD     K.OFF(R2),R2    ; ADD IN THE OFFSET TO TH UMR AREA      ;JFR001
        ADD     #14,R2          ; POINT TO THE START OF THE UMR         ;JFR001
        TST     (R2)    ; IS IT ALREADY SET UP?                         ;JFR001
        .ENDC                                                           ;JFR001
        BNE     6$              ;IF NE, YES (!!!)
        MOV     R0,-(SP)        ;SAVE R0
        MOV     R1,-(SP)        ;AND THE PACKET ADDRESS
        MOV     #M.LGTH,R1      ;SET SIZE OF BLOCK TO BE REQUESTED
        CALL    $ALOCB          ;TRY TO ALLOCATE THE DATA BLOCK
        BCS     4$              ;IF C-SET WE FAILED
        MOV     #<XM$UMR*4>,M.UMRN(R0)  ;SETUP UMR COUNT * 4
        CALL    $ASUMR          ;TRY TO GET THE UMRS
        BCC     5$              ;IF C-CLEAR WE GOT THEM
        CALL    $DEACB          ;ELSE GIVE BACK THE DATA BLOCK
4$:     MOV     (SP)+,R1        ;RESTORE THE PACKET ADDRESS
        TST     (SP)+           ;POP THE STACK
        BR      XMRSU           ;AND REPORT THE RESOURCE ALLOCATION FAILURE
        .IF NDF R$$MPL                                                  ;JFR001
5$:     MOV     M.UMRA(R0),S.MPR(R4)    ;SAVE THE FIRST UMR ADDRESS
        MOV     R0,S.MPR+2(R4)  ;AND THE UMR BLOCK ADDRESS
        .IFF                                                            ;JFR001
5$:     MOV     M.UMRA(R0),(R2) ; SAVE THE FIRST UMR ADDRESS            ;JFR001
        MOV     R0,2(R2)        ; AND THE UMR BLOCK ADDRESS             ;JFR001
        .ENDC                                                           ;JFR001
        MOV     R5,M.UMVL(R0)   ;MARK THE UMR BLOCK (FOR SYSTEM DEBUGGING)
        MOV     (SP)+,R1        ;RESTORE THE PACKET ADDRESS
        MOV     (SP)+,R0        ;AND THE LISTHEAD POINTER
                                                                        ;**-1
        .ENDC                                                           ;JFR001
        .IF NDF R$$MPL                                                  ;JFR001
6$:     MOV     S.MPR(R4),R2    ;FIRST UMR IS FOR BASE TABLE
        .IFF                                                            ;JFR001
6$:     MOV     S.KRB(R4),R2    ; MOV KRB ADDRESS INTO R2               ;JFR001
        ADD     K.OFF(R2),R2    ; ADD IN THE OFFSET TO TH UMR AREA      ;JFR001
        ADD     #14,R2          ; POINT TO THE START OF THE UMR         ;JFR001
        .ENDC                                                           ;JFR001
        CMP     (R2)+,(R2)+     ;SECOND AND THIRD UMRS ARE FOR TRANSMITS
        MOV     R2,(R0)+        ;SECOND UMR ADDRESS
        MOV     R2,(R0)

                .IF EQ  MAXBUF-2
        CMP     (R2)+,(R2)+     ;GET TO THE THIRD UMR
                .ENDC

        ADD     R2,(R0)+        ;SUM OF SECOND AND THIRD UMR ADDRESSES

        .IFTF

        MOV     R0,U.RQ(R5)     ;SAVE RECEIVE LISTHEAD ADDRESS

        .IFT

        ADD     #COUNT,R0       ;POINT TO SENT COUNT
        CLRB    (R0)+           ;ZERO IT OUT
        CMP     (R2)+,(R2)+     ;FOURTH AND FIFTH UMRS ARE FOR RECEIVES
        MOV     R2,(R0)+        ;FOURTH UMR ADDRESS
        MOV     R2,(R0)

                .IF EQ  MAXBUF-2
        CMP     (R2)+,(R2)+     ;GET TO THE FIFTH UMR
                .ENDC

        ADD     R2,(R0)         ;SUM OF FOURTH AND FIFTH UMR ADDRESSES

        .IFF

        CLRB    COUNT(R0)       ;ZERO OUT RECEIVE SENT COUNT

        .ENDC

        CALL    SETDMC          ;INITIALIZE DMC HARDWARE
        BCS     XMINF           ;IF CS, HARDWARE TROUBLE

                                                                        ;**-3
        BIS     #U2.ONL,U.CW2(R5) ;SET ON-LINE BIT
        BIC     #^C<U3.MOD>,U.CW3(R5) ;CLEAR EVERYTHING EXCEPT MODE
        BR      PKTOK           ;RETURN SUCCESSFUL STATUS
;
; TERMINATE (IO.TRM)
;
10$:    MOV     R1,-(SP)        ;SAVE PACKET ADDRESS

                                                                        ;**-8
        CLR     R0              ;NO SPECIAL ERROR CODE
        CALL    KILL            ;KILL THE DEVICE

                                                                        ;**-9
16$:    MOV     (SP)+,R1        ;RESTORE THE PACKET ADDRESS
        BR      PKTOK           ;RETURN SUCCESSFUL STATUS
;
; MODE CHANGE FUNCTION
;

                                                                        ;JFR003
20$:    BIT     #U2.ONL,(R2)    ;IS DEVICE ON-LINE?                     ;JFR003
        BEQ     XMDNR           ;IF NE, YES                             ;JFR003
        BITB    #IO.HDX,I.FCN(R1);IS SUB-FUNCTION HALF-DUPLEX?          ;**-4
        BNE     30$             ;IF NE, YES
        BITB    #IO.FDX,I.FCN(R1);IS SUB-FUNCTION FULL DUPLEX?
        BEQ     XMIFC           ;IF EQ, NO
;
; FULL DUPLEX (IO.FDX)
;
        BIT     #U2.LIN,(R2)    ;WAS DEVICE SYSGENED AS HALF-DUPLEX?
        BNE     XMIFC           ;IF NE, YES
        BIC     #U2.HDX,(R2)+   ;SET FULL DUPLEX IN U.CW2
        CLR     (R2)            ;HALF-DUPLEX MODE BIT OFF
        BR      50$
;
; HALF-DUPLEX (IO.HDX)
;
30$:    BIS     #U2.HDX,(R2)+   ;SET HALF-DUPLEX IN U.CW2
        MOV     #HDX,(R2)       ;HALF-DUPLEX MODE BIT
        TST     I.PRM(R1)       ;LOOK AT QIO PARAMETER P1
        BEQ     40$             ;IF EQ, PRIMARY STATION
        BIS     #SCNDRY,(R2)    ;IF NE, SECONDARY STATION
40$:    TST     I.PRM+2(R1)     ;LOOK AT QIO PARAMETER P2
        BEQ     50$             ;IF EQ, NORMAL MODE
        BIS     #MOP,(R2)       ;IF NE, MAINTENANCE MODE
50$:                            ;FALL THRU TO PKTOK


        .SBTTL  FINISH I/O PACKET

;+
; **-PKTOK-FINISH PACKET WITH STATUS OF "IS.SUC"
; **-FINPKT-ALTERNATE ENTRY
;
; INPUTS:
;       R1=I/O PACKET ADDRESS
;       R5=UCB ADDRESS
;
; CALLING SEQUENCE:
;       JMP     PKTOK
;
; OUTPUTS:
;       PACKET FINISHED
;       XMINIT CALLED TO START ANY NEW PACKETS
;-
PKTOK:  MOV     #IS.SUC&377,-(SP);SUCCESSFUL STATUS
FINPKT: MOV     R1,-(SP)        ;SAVE PACKET ADDRESS
        CALL    XMINIT          ;TRY ANOTHER PACKET
        MOV     (SP)+,R3        ;RESTORE PACKET ADDRESS
        MOV     (SP)+,R0        ;STATUS WORD 1
        CLR     R1              ;STATUS WORD 2 = 0
        CALLR   $IOFIN          ;FINISH I/O PACKET
;
; DEVICE NOT READY
;
XMINF:  .IF     DF      R$$MPL!V$$RSN&Q$$22                             ;JFR001
        CALL    DEUMR           ;DE-ALLOCATE UMR'S                      ;**-1
        .ENDC
XMDNR:  MOV     #IE.DNR&377,-(SP)
        BR      FINPKT
;
; ILLEGAL BUFFER
;
XMSPC:  MOV     #IE.SPC&377,-(SP)
        BR      FINPKT
;
; ILLEGAL FUNCTION CODE
;
XMIFC:  MOV     #IE.IFC&377,-(SP)
        BR      FINPKT
;
; RESOURCE ALLOCATION FAILURE
;
        .IF     DF      R$$MPL!V$$RSN&Q$$22                             ;JFR001
XMRSU:  MOV     #IE.RSU&377,-(SP)                                       ;**-1
        BR      FINPKT
        .ENDC

        .SBTTL  PROCESS QIO TRANSFER FUNCTION

;
; TRANSFER FUNCTION
;

                                                                        ;**-1
TRAN:   BIT     #U2.ONL,(R2)    ;IS DEVICE ON-LINE?
        BEQ     XMDNR           ;IF EQ, NO

                .IF DF  X$$22
        BIT     #160000,I.PRM+4(R1) ;IS BUFFER SIZE >= 4K WORDS?
                                ;BUFFER MUST BE MAPPED BY 1 UMR
                .IFF
        BIT     #140000,I.PRM+4(R1) ;IS BUFFER SIZE >= 8K WORDS?
                .ENDC

        BNE     XMSPC           ;IF NE, YES - BUFFER IS TOO BIG
        INCB    S.STS(R4)       ;INCR ACTIVITY COUNT

                .IF DF  X$$18
        MOV     I.PRM(R1),R0    ;GET NPR EXTENSION BITS
        SWAB    R0              ;AND SHIFT FROM BIT POSITIONS 5-4
        ASL     R0              ;TO BIT POSITIONS 15-14
        ASL     R0
        BIS     R0,I.PRM+4(R1)  ;THEN AND WITH BYTE COUNT
                .ENDC

        CMPB    #IO.WLB/256.,I.FCN+1(R1) ;IS IT A WRITE FUNCTION?
        BEQ     10$             ;IF EQ, YES
;
; RECEIVE DATA (IO.RLB OR IO.RNS)
;
        MOV     U.RQ(R5),R0     ;RECEIVE LISTHEAD ADDRESS
        BR      20$
;
; TRANSMIT DATA (IO.WLB OR IO.WNS)
;
10$:    MOV     U.XQ(R5),R0     ;TRANSMIT LISTHEAD ADDRESS
20$:    MOV     #XMINIT,-(SP)   ;SET TO RETURN TO XMINIT
                                ;FALL THRU TO TRY

        .SBTTL  TRY TO GIVE TRANSFER REQUEST TO DMC

;+
; **-TRY-TRY TO GIVE TRANSFER REQUEST TO DMC
;
; INPUTS:
;       R0=SENT Q LISTHEAD ADDRESS (U.XQ OR U.RQ)
;       R1=I/O PACKET ADDRESS
;       R4=SCB ADDRESS
;       R5=UCB ADDRESS
;
; OUTPUTS IF PORT WAS NOT AVAILABLE:
;       R0=WAIT Q LISTHEAD ADDRESS
;       R2,R3=DESTROYED
;       R4=CSR ADDRESS
;       PACKET QUEUED ON WAIT Q
;
; OUTPUTS IF PORT WAS AVAILABLE BUT NOT READY:
;       R0=WAIT Q LISTHEAD ADDRESS
;       R2,R3=DESTROYED
;       R4=CSR ADDRESS
;       REQUEST TYPE!IEI LEFT IN SEL0
;       PACKET QUEUED ON WAIT Q
;
; OUTPUTS IF PORT WAS AVAILABLE AND READY:
;       R2,R3=DESTROYED
;       R4=CSR ADDRESS
;       DMC GIVEN BUFFER ADDRESS AND COUNT
;       DMC PORT RELEASED
;       SENT COUNT INCREMENTED
;       PACKET QUEUED ON SENT Q
;-
TRY:    MTPS    S.PRI(R4)       ;DISABLE INTERRUPTS
        MOV     S.CSR(R4),R4    ;;;CSR ADDRESS
        TST     4(R0)           ;;;IS WAIT Q EMPTY?
        BNE     30$             ;;;IF NE, NO - NO ACTION POSSIBLE
        CALL    PORT            ;;;IS PORT AVAILABLE?
        BCS     30$             ;;;IF CS, NO
        BIT     #RDYO,2(R4)     ;;;IS OUTPUT TRANSFER READY?
        BNE     20$             ;;;IF NE, YES - USE INTERRUPTS
        MOV     #4,R2           ;;;LOOP COUNT
10$:    BIT     #RDYI,(R4)      ;;;IS DMC READY FOR INPUT?
        BNE     40$             ;;;IF NE, YES
        SOB     R2,10$          ;;;
20$:    BIS     #IEI,(R4)       ;;;ENABLE INPUT INTERRUPT
        BIS     #IEI,(R4)       ;;;TWICE
30$:    CMP     (R0)+,(R0)+     ;;;WAIT Q LISTHEAD ADDRESS
        CALL    $QINSF          ;;;INSERT PACKET ON WAIT Q
                                ;;;NOTE-$QINSF DESTROYS R2
        BR      50$             ;;;
40$:    CALL    GIVE            ;;;GIVE PACKET INFO TO DMC
50$:    MTPS    #0              ;;;RE-ENABLE INTERRUPTS
        RETURN

        .SBTTL  LOAD DATA PORT WITH BUFFER ADDRESS AND COUNT

;+
; **-GIVE-GIVE BUFFER ADDRESS AND COUNT TO DMC
;
; INPUTS:
;       R0=SENT Q LISTHEAD ADDRESS
;       R1=I/O PACKET ADDRESS
;       R4=CSR ADDRESS
;       DMC READY FOR INPUT
;
; OUTPUTS:
;       R2,R3=DESTROYED
;       DMC GIVEN BUFFER ADDRESS AND COUNT
;       DMC PORT RELEASED
;       SENT COUNT INCREMENTED
;       PACKET INSERTED ON SENT Q
;-
GIVE:   INCB    COUNT(R0)       ;;;INCREMENT SENT COUNT

        .IF DF  Q$$22
        MOV     R0,R2           ;;;COPY LISTHEAD ADDRESS
        MOV     UMR(R2),R0      ;;;NEXT UMR TO USE
        MOV     UMRSUM(R2),UMR(R2) ;;;RESET NEXT UMR ADDRESS
        SUB     R0,UMR(R2)      ;;;
        MOV     R2,-(SP)        ;;;SAVE LISTHEAD ADDRESS
        MOV     X.PRM(R1),R2    ;;;PUT 18 BIT ADDRESS IN R2,R3
        SWAB    R2              ;;;
        MOV     X.PRM+2(R1),R3  ;;;
        CALL    MAP22           ;;;DO 22 BIT MAPPING AND LOAD DATA PORT
        BIS     X.PRM+4(R1),6(R4) ;;;INCLUDE BYTE COUNT
        MOV     (SP)+,R0        ;;;RESTORE LISTHEAD ADDRESS
        .IFF
        MOV     X.PRM+2(R1),4(R4) ;;;GIVE DMC BUFFER ADDRESS
        MOV     X.PRM+4(R1),6(R4) ;;;AND COUNT
        .ENDC

        BIC     #RELEAS,(R4)    ;;;RELEASE THE PORT
        CALLR   $QINSF          ;;;INSERT PACKET ON SENT Q
                                ;;;NOTE-$QINSF DESTROYS R2

        .SBTTL  INITIALIZE DMC HARDWARE

;+
; **-SETDMC-INITIALIZE DMC HARDWARE
;
; INPUTS:
;       R3=CONTROLLER INDEX (S.CON)
;       R4=SCB ADDRESS
;       R5=UCB ADDRESS
;       U3.MOD=DMC MODE
;
; OUTPUTS:
;       R0,R2,R3=DESTROYED
;       R4=CSR ADDRESS
;       CARRY CLEAR=OK
;       CARRY SET=HARDWARE NOT WORKING PROPERLY
;-

        .ENABL  LSB

SETDMC: CLR     U.ERR(R5)       ;CLEAR ERROR STATUS AND C-BIT
        .IF DF V$$RSN&Q$$22                                             ;JFR001
        MOV     S.MPR(R4),R0    ;GET THE BASE TABLE UMR                 ;**-2
        .ENDC                                                           ;JFR001
        .IF DF R$$MPL&Q$$22                                             ;JFR001
        MOV     S.KRB(R4),R0    ; MOV KRB ADDRESS INTO R0               ;JFR001
        ADD     K.OFF(R0),R0    ; ADD IN THE OFFSET TO TH UMR AREA      ;JFR001
        ADD     #14,R0          ; POINT TO THE FRONT                    ;JFR001
        .ENDC                                                           ;**-4

        MOV     S.CSR(R4),R4    ;CSR ADDRESS
        BIS     #MC,(R4)        ;MASTER CLEAR THE DMC
; THE FOLLOWING INSTRUCTION NEEDED WITH COMIOP BOARD AND OK WITHOUT
        MOV     #RUN,(R4)       ;START THE MICROPROCESSOR
        BIS     #IEO,2(R4)      ;ENABLE COMPLETION INTERRUPTS
        MOVB    #BASEI,(R4)     ;BASE IN REQUEST TYPE
        CALL    WRDYIS          ;WAIT FOR RDYI SET
        BCS     40$             ;IF CS, TROUBLE
;
; THE BASE TABLE ADDRESS IS CALCULATED AS FOLLOWS:
;       IF UNMAPPED, USE EITHER "#BASE" OR "BTAB(R3)".
;       IF MAPPED AND DMC DRIVER IS NOT LOADABLE, SAME AS UNMAPPED.
;       IF MAPPED AND DMC DRIVER IS LOADABLE, USE KISAR5 CONTENTS
;               SHIFTED LEFT 6 PLACES.
;
; FURTHERMORE, FOR DECNET THE FOURTH UMR IS USED TO MAP ALL BASE
;       TABLES. THUS, THE UMR IS ALWAYS SET TO THE ADDRESS OF THE FIRST
;       BASE TABLE AND THE 18 BIT ADDRESS IS ADJUSTED ACCORDINGLY.
;
        .IF DF  X$$LDM

        CLR     R2              ;NO EXTENSION BITS YET

                .IF DF  X$$22

        ASR     R3              ;CALCULATE UNIT # * 400
        SWAB    R3
        MOV     R3,-(SP)        ;SAVE IT ON STACK
        MOV     KISAR5,R3       ;UMR ALWAYS POINTS TO FIRST BASE TABLE

                .IFF

        ASL     R3              ;BASE TABLE DISPLACEMENT/100
        ADD     KISAR5,R3       ;PLUS DRIVER ADDRESS/100

                .IFTF

        MOV     #6,-(SP)        ;NOW MULTIPLY BY 100
5$:     ASL     R3              ;BY SHIFTING R2,R3 LEFT
        ROL     R2              ;6 PLACES
        DEC     (SP)            ;DONE?
        BNE     5$              ;IF NE, NO
        TST     (SP)+           ;PURGE LOOP COUNT

                .IFT

        CALL    MAP22           ;DO 22 BIT MAPPING AND LOAD DATA PORT
        ADD     (SP)+,4(R4)     ;ADJUST BY MULTIPLE BASE TABLE INDEX

                .IFF

        MOV     R3,4(R4)        ;LOW 16 BITS OF ADDRESS
        ASL     R2              ;MAKE A WORD INDEX
        MOV     AXTAB(R2),6(R4) ;ADDRESS EXTENSION BITS

                .ENDC

        .IFF

                .IF GT  X$$M11-1
        MOV     BTAB(R3),4(R4)  ;LOW 16 BITS OF ADDRESS
                .IFF
        MOV     #BASE,4(R4)     ;LOW 16 BITS OF ADDRESS
                .ENDC

        CLR     6(R4)           ;NO EXTENSION BITS

        .ENDC

        CALL    WRDYIC          ;RELEASE PORT AND WAIT FOR RDYI CLEAR
        BCS     40$             ;IF CS, TROUBLE
        MOVB    #CNTLI,(R4)     ;CONTROL IN REQUEST TYPE
        CALL    WRDYIS          ;WAIT FOR RDYI SET
        BCS     40$             ;IF CS, TROUBLE
        MOV     U.CW3(R5),-(SP) ;STRIP MODE BITS FROM U.CW3
        BIC     #^C<U3.MOD>,(SP)
        MOV     (SP)+,6(R4)     ;SET DMC MODE
                                ;FALL THRU TO WRDYIC
;
; RELEASE PORT AND WAIT FOR RDYI CLEAR
;
WRDYIC: BIC     #RELEAS,(R4)    ;RELEASE THE PORT
        MOV     #C.WAIT,R2      ;LOOP COUNT
10$:    BIT     #RDYI,(R4)      ;IS RDYI STILL SET?
        BEQ     40$             ;IF EQ, NO
        SOB     R2,10$
        BR      30$             ;RDYI NOT CLEARED PROPERLY
;
; WAIT FOR RDYI SET
;
WRDYIS: MOV     #S.WAIT,R2      ;LOOP COUNT
20$:    BIT     #RDYI,(R4)      ;IS RDYI SET?
        BNE     40$             ;IF NE, YES
        SOB     R2,20$
30$:    SEC                     ;RDYI NOT SET PROPERLY
40$:    RETURN

        .DSABL  LSB

        .SBTTL  DO 22 BIT MAPPING

;+
; **-MAP22-DO 22 BIT MAPPING AND LOAD DATA PORT
;
; INPUTS:
;       R0=UMR ADDRESS
;       R2,R3=22 BIT PHYSICAL ADDRESS
;       R4=CSR ADDRESS
;
; OUTPUTS:
;       R0,R2,R3=DESTROYED
;       UMR LOADED WITH PHYSICAL ADDRESS
;       DATA PORT LOADED WITH 18 BIT UMR ADDRESS
;-

        .IF DF  X$$22

MAP22:  MOV     R3,(R0)         ;COPY R2,R3 TO UMR
        BIC     #1,(R0)+        ;FIRST WORD OF UMR MUST BE EVEN
        MOV     R2,(R0)+
        SUB     #FIRSTU+4,R0    ;UMR# IS NOW IN BITS 6-2
        SWAB    R0
        ASL     R0
        CLR     R2              ;FORM AN 18 BIT NUMBER IN R2,R0
        ASL     R0              ;WITH BITS 17-13 CONTAINING THE UMR#
        ROL     R2
        ASL     R0
        ROL     R2
        ROR     R3              ;ODD/EVEN BIT TO CARRY
        ADC     R0              ;AND THEN TO BIT 0 OF ADDRESS
        MOV     R0,4(R4)        ;LOW 16 BITS OF ADDRESS TO DATA PORT
        ASL     R2              ;MAKE A WORD INDEX
        MOV     AXTAB(R2),6(R4) ;ADDRESS EXTENSION BITS TO DATA PORT
        RETURN

        .ENDC

        .SBTTL  PROCESS RDYI INTERRUPT

;
; PROCESS RDYI INTERRUPT
;
$XMINP::INTSV$  XM,PR5,X$$M11   ;;;GENERATE INTERRUPT SAVE CODE
        JSR     R0,XMSET        ;;;DO INTERRUPT SETUP AND TRANSFER
        .WORD   SEL0            ;;;CSR INDEX
        .WORD   XMTRDY          ;;;TRANSFER ADDRESSES
        .WORD   BAD
        .WORD   BAD
        .WORD   FPERR
        .WORD   RCVRDY
        .WORD   BAD
        .WORD   BAD
        .WORD   BAD
;
; DMC READY FOR TRANSMIT BUFFER
;
XMTRDY: MOV     U.XQ(R5),R0     ;;;TRANSMIT LISTHEAD ADDRESS
        JSR     R1,RDYINT       ;;;GIVE BUFFER TO DMC
;
; DMC READY FOR RECEIVE BUFFER
;
RCVRDY: MOV     U.RQ(R5),R0     ;;;RECEIVE LISTHEAD ADDRESS
        JSR     R1,RDYINT       ;;;GIVE BUFFER TO DMC
;
; FORCE PROCEDURE ERROR
;
FPERR:  BIC     #RELEAS,(R4)    ;;;CLEAR RQI WHICH WILL CAUSE
        BR      XMINTX          ;;;CNTLO INTERRUPT

        .SBTTL  PROCESS COMPLETION OR CONTROL OUT INTERRUPT

;
; PROCESS COMPLETION INTERRUPT
;
$XMOUT::INTSV$  XM,PR5,X$$M11   ;;;GENERATE INTERRUPT SAVE CODE
        JSR     R0,XMSET        ;;;DO INTERRUPT SETUP AND TRANSFER
        .WORD   SEL2            ;;;CSR INDEX
        .WORD   XMTCOM          ;;;TRANSFER ADDRESSES
        .WORD   CNTLO
        .WORD   BAD
        .WORD   BAD
        .WORD   RCVCOM
        .WORD   CNTLO
        .WORD   BAD
        .WORD   BAD
;
; TRANSMIT BUFFER COMPLETE
;
XMTCOM: MOV     U.XQ(R5),R0     ;;;TRANSMIT LISTHEAD ADDRESS
        JSR     R1,BUFCOM       ;;;PROCESS BUFFER COMPLETE
;
; RECEIVE BUFFER COMPLETE
;
RCVCOM: MOV     U.RQ(R5),R0     ;;;RECEIVE LISTHEAD ADDRESS
        JSR     R1,BUFCOM       ;;;PROCESS BUFFER COMPLETE
;
; CONTROL OUT
;
CNTLO:  MOV     4(R4),R0        ;;;COPY SEL6 CONTENTS
        BIC     #RDYO,(R4)      ;;;RELEASE THE PORT
        BIS     R0,U.ERR(R5)    ;;;UPDATE ERROR STATUS
        BIT     #FATAL,R0       ;;;IS IT A FATAL ERROR?
        BEQ     20$             ;;;IF EQ, NO
        BIT     #BUG,R0         ;;;IS IT DISCONNECT ERROR PART 2?

                                                                        ;**-5
        BEQ     10$             ;;;IF EQ, NO
        MOV     U.SCB(R5),R4    ;;;SCB ADDRESS
        MOVB    #2,S.CTM(R4)    ;;;SET TIMER FOR BETWEEN 1 AND 2 SECONDS
                                ;;;NOTE-ONLY 1 SECOND DELAY IS NEEDED
        BR      XMFRK           ;;;CAN'T MASTER CLEAR UNTIL THEN

                                                                        ;**-1
10$:    BIS     #MC,-(R4)       ;;;MASTER CLEAR THE DMC
        BR      XMFRK           ;;;START FORK PROCESS

                                                                        ;JFR002
20$:    BIT     #DISCON,R0      ;;;IS IT DISCONNECT ERROR?              ;JFR002
                                                                        ;JFR002
                                                                        ;**-16
        BEQ     XMINTX          ;;;IF EQ, NO
        MOVB    #PERR!IEI,-2(R4);;;CAUSE PROCEDURE ERROR
                                ;;;FALL THRU TO XMINTX
;
; EXIT FROM INTERRUPT
;
BAD:
XMINTX: MOV     (SP)+,R0        ;;;RESTORE R0
        JMP     $INTXT          ;;;EXIT FROM INTERRUPT

        .SBTTL  SETUP FOR INTERRUPT ROUTINES AND TRANSFER

;+
; **-XMSET-SETUP FOR INTERRUPT ROUTINES AND TRANSFER
;
; INPUTS:
;       R0=CALLING REGISTER
;       INTSV$ HAS BEEN DONE
;
; CALLING SEQUENCE:
;       JSR     R0,XMSET
;       .WORD                   ;;;CSR INDEX (EITHER 0 OR 2)
;       .BLKW   8.              ;;;TRANSFER ADDRESSES BY TYPE
;
; OUTPUTS: (IF VALID INTERRUPT)
;       R4=CSR ADDRESS
;       R5=UCB ADDRESS
;       (SP)=SAVED R0
;
; ALTERNATE RETURN: (IF INVALID INTERRUPT)
;       RETURN TO $INTXT
;-
XMSET:  TST     R5              ;;;HAS UCB BEEN ENTERED IN TABLE?
        BEQ     XMINTX          ;;;IF EQ, NO
        BIT     #U2.ONL,U.CW2(R5);;;IS DMC ON-LINE?
        BEQ     XMINTX          ;;;IF EQ, NO
        MOV     U.SCB(R5),R4    ;;;SCB ADDRESS
        MOV     S.CSR(R4),R4    ;;;CSR ADDRESS
        ADD     (R0)+,R4        ;;;PLUS CSR INDEX
        MOV     (R4),-(SP)      ;;;STRIP EVERYTHING BUT TYPE BITS
        BIC     #^C<TYPE>,(SP)
        ASL     (SP)            ;;;MAKE A WORD INDEX
        ADD     (SP)+,R0        ;;;ADD TO TRANSFER TABLE ADDRESS
        JMP     @(R0)+          ;;;AND GO!

        .SBTTL  RDYI INTERRUPT ROUTINES

;+
; **-RDYINT-GIVE BUFFER TO DMC
;
; INPUTS:
;       R0=SENT Q LISTHEAD ADDRESS (U.XQ OR U.RQ)
;       R1=CALLING REGISTER
;       R4=CSR ADDRESS
;       R5=UCB ADDRESS
;       2(SP)=INTERRUPT SAVED R0
;
; CALLING SEQUENCE:
;       JSR     R1,RDYINT
;
; OUTPUTS:
;       DMC GIVEN BUFFER ADDRESS AND COUNT
;       DMC PORT RELEASED
;       ATTEMPT MADE TO SETUP ANOTHER BUFFER OF EITHER TYPE
;       INTERRUPT EXITED
;-
RDYINT: MOV     R2,-(SP)        ;;;SAVE R2,R3
        MOV     R3,-(SP)        ;;;
        CMP     (R0)+,(R0)+     ;;;ADVANCE TO WAIT Q ADDRESS
        CALL    $QRMVF          ;;;REMOVE FIRST PACKET FROM WAIT Q
                                ;;;NOTE-$QRMVF DESTROYS R2,R3
        CMP     -(R0),-(R0)     ;;;RESET TO SENT Q ADDRESS
        CALL    GIVE            ;;;GIVE BUFFER TO DMC
        CALL    ITRY            ;;;TRY TO SETUP ANOTHER BUFFER
        MOV     (SP)+,R3        ;;;RESTORE R1,R2,R3
        MOV     (SP)+,R2        ;;;
        MOV     (SP)+,R1        ;;;
        BR      XMINTX          ;;;EXIT FROM INTERRUPT

        .SBTTL  COMPLETION INTERRUPT ROUTINES

;+
; **-BUFCOM-PROCESS BUFFER COMPLETE
;
; INPUTS:
;       R0=SENT Q LISTHEAD ADDRESS (U.XQ OR U.RQ)
;       R1=CALLING REGISTER
;       R4=CSR ADDRESS+2
;       R5=UCB ADDRESS
;       2(SP)=INTERRUPT SAVED R0
;
; CALLING SEQUENCE:
;       JSR     R1,BUFCOM
;
; OUTPUTS:
;       CHARACTER COUNT STORED IN X.PRM+4 OF I/O PACKET
;       PACKET MOVED FROM SENT Q TO COMPLETION Q
;       DMC PORT RELEASED
;       ATTEMPT MADE TO SETUP ANOTHER BUFFER OF EITHER TYPE
;       FORK PROCESS STARTED IF IT'S NOT RUNNING
;       INTERRUPT EXITED
;-
BUFCOM: MOV     R2,-(SP)        ;;;SAVE R2,R3
        MOV     R3,-(SP)        ;;;
        DECB    COUNT(R0)       ;;;DECREMENT SENT COUNT
        CALL    $QRMVF          ;;;REMOVE PACKET FROM SENT Q
                                ;;;NOTE-$QRMVF DESTROYS R2,R3
        MOV     4(R4),X.PRM+4(R1);;;PUT COUNT IN I/O PACKET

        .IF DF  M$$MGE
        BIC     #140000,X.PRM+4(R1) ;;;CLEAR ADDRESS EXTENSION BITS
        .ENDC

        BIC     #RDYO,(R4)      ;;;RELEASE THE PORT
        MOV     U.XQ(R5),R0     ;;;TRANSMIT SENT Q LISTHEAD ADDRESS
        CMP     -(R0),-(R0)     ;;;COMPLETION Q LISTHEAD ADDRESS
        CALL    $QINSF          ;;;INSERT PACKET ON COMPLETION Q
                                ;;;NOTE-$QINSF DESTROYS R2
        TST     -(R4)           ;;;SEL0 ADDRESS
        CALL    ITRY            ;;;TRY TO SETUP ANOTHER BUFFER
        MOV     (SP)+,R3        ;;;RESTORE R1,R2,R3
        MOV     (SP)+,R2        ;;;
        MOV     (SP)+,R1        ;;;
                                ;;;FALL THRU TO XMFRK

        .SBTTL  FORK PROCESSING

;
; START FORK PROCESS IF IT'S NOT RUNNING
;
XMFRK:  BIT     #U3.FRK,U.CW3(R5);;;IS FORK PROCESS RUNNING?
        BNE     XMINTX          ;;;IF NE, YES
        MOV     (SP)+,R0        ;;;RESTORE R0
        BIS     #U3.FRK,U.CW3(R5);;;INDICATE FORK PROCESS RUNNING
        CALL    $FORK           ;;;CREATE SYSTEM PROCESS
;
; FORK LEVEL PROCESSING
;
        MOV     U.XQ(R5),R0     ;TRANSMIT SENT Q LISTHEAD ADDRESS
        CMP     -(R0),-(R0)     ;COMPLETION Q LISTHEAD ADDRESS
10$:    MOV     U.SCB(R5),R4    ;SCB ADDRESS
        MTPS    S.PRI(R4)       ;DISABLE INTERRUPTS
        CALL    $QRMVF          ;;;REMOVE FIRST PACKET FROM COMPLETION Q
        BCS     20$             ;;;IF CS, Q WAS EMPTY
        MTPS    #0              ;;;RE-ENABLE INTERRUPTS
        MOV     #IS.SUC&377,R2  ;STATUS WORD 1
        MOV     X.PRM+4(R1),R4  ;STATUS WORD 2 = BYTE COUNT
        CALL    RAP             ;RETURN THE I/O PACKET
        BR      10$             ;AND TRY AGAIN
20$:    BIC     #U3.FRK,U.CW3(R5);;;NO MORE FORK PROCESSING
        MTPS    #0              ;;;RE-ENABLE INTERRUPTS
        BIT     #FATAL,U.ERR(R5) ;HAS FATAL ERROR OCCURRED?
        BEQ     EXIT            ;IF EQ, NO

        BIT     #LOST,U.ERR(R5) ;WAS IT LOST DATA?                      ;**-4
        BEQ     30$             ;IF EQ, NO
        MOV     U.RQ(R5),R0     ;RECEIVE SENT Q LISTHEAD ADDRESS
        MOV     #IE.DAO&377,R2  ;RETURN FIRST PACKET ON SENT Q
        CALL    DQRAP0          ;WITH A STATUS OF "IE.DAO"
30$:    MOV     #U3.ERR,R0      ;FATAL ERROR BIT
        MOV     #IE.CNR&377,R2  ;ASSUME DDCMP START RECEIVED
        BIT     #START,U.ERR(R5) ;WAS IT DDCMP START RECEIVED?
        BNE     RQP             ;IF NE, YES
        BIT     #TIMOUT,U.ERR(R5);WAS IT TIME-OUT?
        BEQ     RQPABO          ;IF EQ, NO
        MOV     #IE.TMO&377,R2  ;TIMEOUT ERROR CODE
        BR      RQP             ;RETURN ALL PACKETS

        .SBTTL  TIMEOUT

;+
; **-XMTMO-TIMEOUT ENTRY POINT
;
; INPUTS:
;       R3=CONTROLLER INDEX (S.CON)
;       R4=SCB ADDRESS
;       R5=UCB ADDRESS
;
; OUTPUTS:
;       DISCONNECT ERROR RECOVERY IS COMPLETED (QIO)
;       POWERFAIL ENTERED IF ANY UNABORTED REQUESTS (DECNET)
;-
XMOUT:                                                                  ;JFR001
                                                                        ;**-1
        BIS     #MC,@S.CSR(R4)  ;MASTER CLEAR THE DEVICE                ;JFR002
        CALLR   XMINIT          ;TIMER BLOCKED PACKETS                  ;JFR002

        .SBTTL  CANCEL I/O AND POWERFAIL

;+
; **-XMCANC-CANCEL I/O ENTRY POINT
; **-XMPWRF-POWERFAIL RECOVERY ENTRY POINT
;
; INPUTS:
;       R1=TCB ADDRESS (CANCEL ONLY)
;       R3=CONTROLLER INDEX (S.CON)
;       R4=SCB ADDRESS
;       R5=UCB ADDRESS
;
; OUTPUTS:
;       DEVICE IS KILLED
;-
XMPWF:                                                                  ;JFR001
                                                                        ;JFR001
        MTPS    #PR7            ;;; DISABLE INTERUPTS FROM THE WORLD    ;JFR001
        MOV     #U3.PWF,R0      ;;;INDICATE POWERFAIL OCCURRED          ;JFR001
        BR      KILL            ;;;                                     ;JFR001
                                                                        ;JFR001
XMCAN:                                                                  ;JFR001
        MOV     #U3.KIL,R0      ;INDICATE I/O KILL WAS DONE             ;JFR001
                                ; NOTE THAT INTERRUPTS ARE NOT DISABLED ;JFR001
                                ; THE NEXT FOUR INSTRUCTIONS            ;JFR001
                                                                        ;JFR001
                                ;FALL THRU TO KILL                      ;**-8

        .SBTTL  KILL THE DMC

;+
; **-KILL-KILL THE DEVICE
; **-RQP,RQPABO-ALTERNATE ENTRIES
;
; INPUTS:
;       R0=KILL REASON
;       R4=SCB ADDRESS
;       R5=UCB ADDRESS
;
; OUTPUTS:
;       R0,R1,R2,R3,R4=DESTROYED
;       DMC MASTER CLEARED IF ON-LINE
;       U2.ONL BIT CLEARED
;       ALL PACKETS DEQUEUED AND RETURNED WITH STATUS OF "IE.ABO"
;-
KILL:   BIT     #U2.ONL,U.CW2(R5) ;;;IS THE DEVICE ON-LINE?             ;JFR004
        BNE     1$              ;;; IF NE THEN YES                      ;JFR004
        MTPS    #0              ; ALLOW INTERRUPTS AGAIN                ;JFR004
        BR      EXIT            ;IF EQ, NO                              ;JFR004
1$:     BIS     #MC,@S.CSR(R4)  ;;;MASTER CLEAR THE DEVICE              ;JFR004
        MTPS    #0              ; ALL INTERRUPTS AGAIN                  ;JFR004
RQPABO: MOV     #IE.ABO&377,R2  ;STATUS WORD 2 FOR LATER                ;**-3
RQP:    BIS     R0,U.CW3(R5)    ;SAVE KILL REASON
        BIC     #U2.ONL,U.CW2(R5) ;IT'S NOT ON-LINE NOW

                                                                        ;**-6
        .IF     DF      R$$MPL!V$$RSN&Q$$22                             ;JFR001
        CALL    DEUMR           ;DE-ASSIGN UMR'S                        ;**-1
                .ENDC

        MOV     U.XQ(R5),R0     ;TRANSMIT SENT Q LISTHEAD ADDRESS
        CALL    10$             ;RETURN ALL TRANSMIT PACKETS
        MOV     U.RQ(R5),R0     ;RECEIVE SENT Q LISTHEAD ADDRESS
10$:    CALL    (PC)            ;DO THE FOLLOWING FOR SENT Q AND WAIT Q
20$:    CALL    DQRAP0          ;DEQUEUE AND RETURN ONE PACKET
        BCC     20$             ;IF CC, Q WAS NOT EMPTY
        CMP     (R0)+,(R0)+     ;ADVANCE TO NEXT LISTHEAD
EXIT:   RETURN
;
; QUEUE AN AST TO THE CCP
;

        .SBTTL  DEQUEUE AND RETURN ONE I/O PACKET

;+
; **-DQRAP/DQRAP0-DEQUEUE AND RETURN ONE I/O PACKET
; **-RAP-RETURN AN ALREADY DE-QUEUED I/O PACKET
;
; INPUTS:
;       R0=LISTHEAD ADDRESS
;       R2=I/O STATUS WORD 1
;       R4=I/O STATUS WORD 2
;
; OUTPUTS:
;       R1,R3,R4=DESTROYED
;       CARRY CLEAR=PACKET DEQUEUED AND RETURNED OK
;       CARRY SET=QUEUE WAS EMPTY
;-

        .ENABL  LSB

DQRAP0: CLR     R4              ;ENTRY FOR STATUS WORD 2 = 0
DQRAP:  MOV     R2,-(SP)        ;SAVE STATUS WORD 1
        CALL    $QRMVF          ;DEQUEUE AN I/O PACKET
                                ;NOTE-$QRMVF DESTROYS R2,R3
        BCC     5$              ;IF CC, Q WAS NOT EMPTY
        BR      10$             ;RETURN WITH CARRY SET
RAP:    MOV     R2,-(SP)        ;SAVE STATUS WORD 1
5$:
                                                                        ;**-16
        MOV     R0,-(SP)        ;SAVE LISTHEAD ADDRESS
        MOV     R1,R3           ;PACKET ADDRESS
        MOV     2(SP),R0        ;STATUS WORD 1
        MOV     R4,R1           ;STATUS WORD 2
        MOV     U.SCB(R5),R4    ;GET SCB ADDRESS
        DECB    S.STS(R4)       ;DECR ACTIVITY COUNT
        CALL    $IOFIN          ;FINISH THE I/O PACKET
                                ;NOTE-$IOFIN SAVES ONLY R5
                                                                        ;**-1
        CLC                     ;INDICATE SUCCESS
        MOV     (SP)+,R0        ;RESTORE LISTHEAD ADDRESS
10$:    MOV     (SP)+,R2        ;RESTORE STATUS WORD 1
        RETURN

        .DSABL  LSB

        .SBTTL  DE-ASSIGN UMR'S

;+
; **-DEUMR-DEASSIGN UMR'S (FOR QIO DRIVER ONLY)
;
; INPUTS:
;       R5=UCB ADDRESS
;
; OUTPUTS:
;       R0,R3=DESTROYED
;       R4=SCB ADDRESS
;       S.MPR+2(R4)=CLEARED
;-

        .IF     DF      R$$MPL!V$$RSN&Q$$22                             ;JFR001
                                                                        ;**-1
DEUMR:  MOV     R2,-(SP)        ;SAVE R2
        MOV     R1,-(SP)        ;AND R1
        MOV     U.SCB(R5),R4    ;GET SCB ADDRESS
        .IF NDF R$$MPL                                                  ;JFR001
        MOV     S.MPR+2(R4),R2  ;GET UMR BLOCK ADDRESS
        .IFF                                                            ;JFR001
        MOV     S.KRB(R4),R2    ; MOV KRB ADDRESS INTO R2               ;JFR001
        ADD     K.OFF(R2),R2    ; ADD IN THE OFFSET TO TH UMR AREA      ;JFR001
        ADD     #14,R2          ; POINT TO THE FRONT                    ;JFR001
        .ENDC                                                           ;JFR001
        BEQ     10$             ;IF EQ, NO UMR BLOCK (!!!)
        .IF NDF R$$MPL                                                  ;JFR001
        CLR     S.MPR+2(R4)     ;ZERO THE POINTER
        CLR     (R2)            ; ZERO THE POINTER                      ;JFR001
        .ENDC                                                           ;JFR001
        MOV     R2,R0           ;COPY UMR BLOCK ADDRESS
        CALL    $DEUMR          ;DE-ASSIGN UMR'S
        MOV     #M.LGTH,R1      ;SETUP UMR BLOCK LENGTH
        CALL    $DEACB          ;DE-ALLOCATE UMR BLOCK
10$:    MOV     (SP)+,R1        ;RESTORE R1
        MOV     (SP)+,R2        ;AND R2
        RETURN

        .ENDC

        .SBTTL  TRY TO SETUP ANOTHER BUFFER FROM INTERRUPT LEVEL

;+
; **-ITRY-TRY TO SETUP ANOTHER BUFFER FROM INTERRUPT LEVEL
;
; INPUTS:
;       R4=CSR ADDRESS
;       R5=UCB ADDRESS
;
; OUTPUTS:
;       R0=DESTROYED
;       REQUEST TYPE!IEI LEFT IN SEL0 IF EITHER WAIT Q WAS NOT EMPTY
;       RECEIVE REQUESTS ARE ATTEMPTED FIRST
;-
ITRY:   MOV     U.RQ(R5),R0     ;;;TRY RECEIVES FIRST
        CALL    IPORT           ;;;IS THE PORT AVAILABLE?
        BCC     10$             ;;;IF CC, YES (PORT IS LOADED)
        MOV     U.XQ(R5),R0     ;;;THEN TRY TRANSMITS
        CALL    IPORT           ;;;IS THE PORT AVAILABLE?
        BCS     20$             ;;;IF CS, NO
10$:    BIS     #IEI,(R4)       ;;;SET INTERRUPT BIT
        BIS     #IEI,(R4)       ;;;TWICE
20$:    RETURN                  ;;;

;+
; **-PORT-REQUEST THE DATA PORT
; **-IPORT-REQUEST THE DATA PORT FROM INTERRUPT LEVEL
;
; INPUTS:
;       R0=SENT Q LISTHEAD ADDRESS (U.XQ OR U.RQ)
;       R4=CSR ADDRESS
;
; OUTPUTS IF PORT WAS AVAILABLE:
;       CARRY CLEAR
;       REQUEST TYPE LEFT IN SEL0
;
; OUTPUTS IF PORT WAS NOT AVAILABLE:
;       CARRY SET
;-

        .ENABL  LSB

IPORT:  TST     4(R0)           ;;;IS WAIT Q EMPTY?
        BEQ     10$             ;;;IF EQ, YES - NOTHING TO DO
PORT:   CMPB    #MAXBUF,COUNT(R0) ;;;CAN DMC ACCEPT MORE?
        BEQ     10$             ;;;IF EQ, NO - NO ACTION POSSIBLE
                                ;;;NOTE-CARRY IS NOW CLEAR
        BIT     #RDYI!RQI,(R4)  ;;;IS PORT ALREADY IN USE?
        BNE     10$             ;;;IF NE, YES - NO ACTION POSSIBLE
        MOVB    IOTYPE(R0),(R4) ;;;SET REQUEST TYPE AND RQI
        BR      20$             ;;;
10$:    SEC                     ;;;INDICATE UNAVAILABILITY
20$:    RETURN                  ;;;

        .DSABL  LSB

        .IF DF R$$MPL                                                   ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       CONTORLER ONLINE ENTRY POINT:                                   ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       THE OLRSR ROUTINE WILL ENTER THIS DRIVER AT THE XMKRB LABLE     ;JFR001
;       TO BRING THE DEVICE ONLINE OR OFFLINE.  IF THE DEVICE IS        ;JFR001
;       COMMING ONLINE, THE UNIT IS MASTER CLEARED AND THE RUN BIT      ;JFR001
;       IS CLEARED.  THE RUN BIT IS THEN TESTED.  IF IT IS STILL SET,   ;JFR001
;       THE BS1 SWITCH IS TURNED ON WHICH MAKES IT IMPOSSIBLE TO DIABLE ;JFR001
;       THE UNIT.  THIS CONDITION IS NOT ALLOWED IN M+ AND THE ONLINE   ;JFR001
;       COMMAND WILL FAIL.  IF THE DEVICE IS COMMING OFFLINE, A MASTER  ;JFR001
;       CLEAR IS ISSUED AND THE RUN BIT IS CLEARED.  NO TEST IS         ;JFR001
;       NECESSARY.                                                      ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       INPUTS:                                                         ;JFR001
;                                                                       ;JFR001
;               R2 = KRB ADDRESS                                        ;JFR001
;               R3 = DCB ADDRESS                                        ;JFR001
;               CARRY BIT CLEARED IF DEVICE IS TO COME ONLINE           ;JFR001
;               CARRY BIT SET IF DEVICE IS TO COME OFFLINE              ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
XMKRB:                                                                  ;JFR001
        MOV     #MC,@K.CSR(R2)  ; MASTER CLEAR THE UNIT                 ;JFR001
        BIC     #RUN,@K.CSR(R2) ; CLEAR THE RUN BIT                     ;JFR001
        BCS     1$              ; IF DEVICE IS COMMING OFFLINE THE RETUR;JFR001
        BIT     #RUN,@K.CSR(R2) ; ELSE TEST IF RUN BIT IS REALLY CLEARED;JFR001
        BEQ     1$              ; IF YES THE ALL IS WELL                ;JFR001
        MOV     #-1,$SCERR      ; ELSE THE RUN BIT BEING LOCKED ON MEANS;JFR001
                                ; THAT THE BS1 SWITCH IS ON WHICH MEANS ;JFR001
                                ; THE THAT A DOWNLINE LOAD CAN NOT BE   ;JFR001
                                ; AVOIDED.  WE DO NOT WANT THIS IN THIS ;JFR001
                                ; THIS IN THE SYSTEM.                   ;JFR001
1$:     RETURN                  ; GO BACK                               ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       UNIT ONLINE - OFFLINE ENTRY POINT                               ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       WHEN THE UNIT IS BROUGHT ONLINE THE OLRSR ROUTINE CALLS THE     ;JFR001
;       DRIVER AT THIS POINT WITH THE CARRY BIT CLEAR AND FOR OFFLINE   ;JFR001
;       WITH THE CARRY BIT SET.  WHEN COMMING ONLINE THE UNIT IS        ;JFR001
;       SET UP USING THE DRIVER ROUTINE "SETDMC".  WHEN THE UNIT IS     ;JFR001
;       OFFLINE A MASTER CLEAR IS ISSUED AND THE RUN BIT IS TURNED OFF. ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       INPUTS:                                                         ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       R3 = CONTROLLER INDEX                                           ;JFR001
;       R4 = SCB ADDRESS                                                ;JFR001
;       R5 = UCB ADDRESS                                                ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       OUTPUTS:                                                        ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
;       $SCERR = 1   IF SUCCESSFUL                                      ;JFR001
;       $SCERR = -1  IF FAILED                                          ;JFR001
;                                                                       ;JFR001
;                                                                       ;JFR001
XMUCB:                                                                  ;JFR001
        BCC     2$      ; IF CARRY CLEAR THEN THIS IS AN ONLINE         ;JFR001
1$:     MOV     #MC,@S.CSR(R4)  ; MASTER CLEAR THE UNIT                 ;JFR001
        BIC     #RUN,@S.CSR(R4) ; CLEAR THE RUN BIT                     ;JFR001
        BR      3$              ; AND GO HOME                           ;JFR001
2$:                                                                     ;JFR001
        CALL SETDMC             ; SET UP THE HARDWARE TABLES            ;JFR001
        BCC     3$              ; IF CARRY CLEAR THEN GOOD              ;JFR001
        MOV     #-1,$SCERR      ; ELSE FAILURE AND WE SO INDICATE       ;JFR001
        BR      1$              ; DISABEL THE HARDWARE                  ;JFR001
3$:     RETURN                  ; GO BACK                               ;JFR001
        .ENDC                                                           ;JFR001
        .END                                                            ;JFR001
        .TITLE XPDRV
        .IDENT  /13/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 13
;
; J. M. GILBERT, 31-JAN-74
;
; PREVIOUSLY MODIFIED BY:
;
;       J. M. GILBERT
;       L. GILLESPIE
;       E. D. WALDIN
;
; MODIFIED BY:
;
; DP11 SYNCHRONOUS COMMUNICATIONS DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  PKTDF$,HWDDF$
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        .MCALL  UCBDF$,CUCDF$
        UCBDF$                  ; DEFINE UCB OFFSETS
        CUCDF$                  ;COMMUNICATIONS UCB LABELS
 
 
        .IF DF  M$$NET
 
        .MCALL  F11DF$,CVCDF$
        F11DF$                  ;DEFINE FILES-11 OFFSETS
        CVCDF$                  ;DEFINE COMMUNICATIONS VCB OFFSETS
 
        .ENDC
 
 

 
;
; CONFIGURATION DEPENDENT PARAMETERS
;
 
        .IIF NDF M$$NET, SOLRCV= 0 ;GENERATE SOLICITED RECEIVE
 
;
; EQUATED SYMBOLS
;
 
;
; RXCSR BIT ASSIGNMENTS
;
 
RECACT=   4000                  ;RECEIVER ACTIVE (IN SYNCH)
RCVENB=    100                  ;RECEIVER INTERRUPT ENABLE
HDPX=        2                  ;HALF DUPLEX IF SET
STRSYN=      1                  ;STRIP SYNC CHARACTERS
 
;
; TXCSR BIT ASSIGNMENTS
;
 
CRRTRN= 100000                  ;CARRIER TRANSITION FLAG
OVRNER=  40000                  ;RECEIVER OVERRUN IF SET
RING=    20000                  ;RING ASSERTED
DSRDY=   10000                  ;DATA SET (MODEM) READY
CRRIER=   4000                  ;CARRIER STATE FLAG
CTS=      2000                  ;CLEAR TO SEND
RTS=      1000                  ;REQUEST TO SEND
TXDONE=    200                  ;TRANSMITTER DONE BIT
TXINTE=    100                  ;TRANSMITTER INTERRUPT ENABLE
STINTE=     40                  ;STATUS INTERRUPT ENABLE
IDLSYN=      2                  ;IDLE SYNC CHARACTERS
TRMRDY=      1                  ;DATA TERMINAL READY
 
;
; LOCAL DATA
;
;
; UNIT IMPURE DATA TABLE (INDEXED BY UNIT, POINTS TO UCB)
;
 
CNTBL:                          ;REF LABEL
UNITBL:                         ;UCB ADDRESSES
        .REPT   D$$P11          ;NUMBER OF UNITS ASSIGNED
        .WORD   0               ;INITIALIZE TO 0
        .ENDM
 
        .IF GT  D$$P11-1
 
TEMP:                           ;REF LABEL
UNIT:   .BLKW   1               ;TEMPORARY STORAGE FOR UNIT NUMBER
 
        .ENDC
 
        
        .ENABL  LSB
 
;
; DRIVER DISPATCH TABLE
;
 
$XPTBL::.WORD   DPINIT          ;DEVICE INITIALIZATION
        .WORD   DPCANC          ;DEVICE I/O CANCELLATION
        .WORD   DPTMO           ;TIMEOUT ENTRY POINT
        .WORD   DPPWRF          ;POWER FAIL ROUTINE
 
 
        .IF DF  M$$NET
 
        .WORD   DPRCV           ;UNSOLICITED RECEIVE ENTRY
        .WORD   DPRXER          ;RECEIVER ERROR SERVICE
 
        .IFF
 
        .WORD   180$            ;NOT GENERATED IF NOT NETWORK
        .WORD   180$            ;NO CODE IF NOT NETWORK
 
        .ENDC
 
 
 

;+
;**-  DPINIT - DP-11 SYNCHRONOUS COMMUNICATION CONTROLLER I/O INITIATOR
;
; DPINIT IS ENTERED WHEN AN I/O REQUEST IS QUEUED ON THE DEVICE,
; AND AT THE END OF EACH QIO REQUEST WHICH OBEYS THE
; NORMAL RSX-11M INPUT/OUTPUT LOGIC FLOW.  IF THE DEVICE IS
; AVAILABLE AND A REQUEST IS IN THE QUEUE FOR THAT UNIT,
; THE REQUEST IS INITIATED.
; IF NO REQUEST EXISTS FOR THAT UNIT OR IF IT IS
; BUSY, AN EXIT IS TAKEN TO THE CALLER.  NOTE  THAT BECAUSE OF
; THE NATURE OF THE DP-11, EACH UNIT IS A CONTROLLER ITSELF,
; HAS ITS OWN SCB, AND THEREFORE ITS OWN QUEUE.
; EACH TIME DPINIT IS CALLED, IT IS CALLED TO SERVICE ONLY
; THE UNIT SPECIFIED IN THE CALL.
;
; INPUTS:
;
;       R4 = STATUS CONTROL BLOCK ADDRESS
;       R5 = ADDRESS OF THE UCB TO BE INITIATED.
;
; OUTPUTS:
;
;       IF A REQUEST IS SUCCESSFULLY DEQUEUED, THE
;       DEVICE IS INITIATED APPROPRIATELY.
;-
 
DPINIT: TSTB    U.CW2(R5)        ;UNSOLICITED (HDPX) RECEIVE ACTIVE?
        BPL     10$             ;IF NOT, PROCEED
        JMP     180$            ;ACTIVATE NO NEW OPERATION
 
10$:    CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCC     20$             ;CC MEANS HAVE REQUEST
        JMP     180$            ;NONE TO DO - EXIT
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1 = ADDRESS OF THE I/O REQUEST PACKET.
;       R2 = PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3 = CONTROLLER INDEX
;       R4 = ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5 = ADDRESS OF THE UCB SPECIFIED IN THE
;            DPINIT CALL.

;
; DP11 I/O REQUEST PACKET FORMAT
;
;       WORD         CONTENT
;
;         0     I/O QUEUE THREAD WORD
;         1     REQUEST PRIORITY, EVENT FLAG NUMBER
;         2     ADDRESS OF THE TCB OF THE REQUESTER TASK
;         3     POINTER TO SECOND LUN WORD IN TASK HEADER
;         4     CONTENTS OF FIRST LUN WORD (UCB)
;         5     I/O FUNCTION CODE
;         6     VIRTUAL ADDRESS OF I/O STATUS BLOCK
;         7     RELOCATION BIAS OF I/O STATUS BLOCK
;        10     I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000)
;        11     VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;        12     RELOCATION BIAS OF I/O BUFFER
;        13     BUFFER ADDRESS FOR TRANSFER
;        14     TOTAL BYTE COUNT TO TRANSFER
;        15     BYTE COUNT FOR SECOND PART OF TRANSMISSION OR 0
;        16     NOT USED
;        17     NOT USED
;        20     NOT USED
;
 
20$:    MOV     S.CSR(R4),R2    ;GET RECEIVER CSR ADDRESS
        ADD     #I.FCN+1,R1     ;POINT TO I/O FUNCTION CODE
        CMPB    #IO.INL/256.,(R1) ;CHECK IF TRANSFER FUNCTION
        BLOS    70$             ;BRANCH ON CONTROL FUNCTION
        BIT     #U2.ONL,U.CW2(R5) ;IS DEVICE ON LINE (INITIALIZED?)
        BEQ     90$             ;CAN'T TRANSFER IF NOT
 
        .IF NDF M$$NET
 
        BIT     #DSRDY,4(R2)    ;DATA SET READY?
        BEQ     90$             ;NO, IF BIT NOT SET
 
        .ENDC
 
        CMPB    #IO.RLB/256.,(R1) ;READ LOGICAL?
        BEQ     40$             ;YES, SERVICE READ REQUEST
;
; FALL THROUGH HERE ON TRANSMIT (WRITE LOGICAL)
;
 
        .IF DF  M$$NET
 
        CALL    @U.PHDR(R5)     ;GO TO COROUTINE FOR INITIATE
        BIT     #DSRDY,4(R2)    ;IS DATA SET READY?
        BEQ     210$            ;CAN'T TRANSMIT IF NOT
 
        .ENDC
 
        ADD     #6,R2           ;POINT TO TX BUFFER
        MOVB    U.SYNC(R5),R0   ;LOAD FIRST SYNC
        MOVB    S.ITM(R4),S.CTM(R4) ;INITIALIZE TIMEOUT COUNT
        MOVB    U.NSYN(R5),R3   ;SYNC COUNT
 
 
        .IF DF  M$$NET
 
        BITB    #IO.WNS,-(R1)   ;IS FUNCTION WRITE WITH SYNC?
        BEQ     30$             ;IF NOT SET, PRECEDE WITH SYNCS
        CALL    $GTBYT          ;GET BYTE FROM USER'S BUFFER
        CLR     R3              ;CLEAR SYNC COUNT
        MOVB    (SP)+,R0        ;CHARACTER TO LOAD TO TRANSMITTER
 
        .ENDC
 
 
30$:    MOVB    R3,U.NSYC(R5)   ;SET COUNT OF SYNCS TO ISSUE
        MOVB    R0,(R2)         ;ISSUE A CHARACTER
        BIS     #IDLSYN!TXINTE,-(R2)    ;ENABLE INTERRUPTS ON DEVICE
        BR      180$            ;RETURN - INTERRUPT CODE PROPAGATES TRANSMISSION
 
;
; RECEIVE FUNCTION INITIATION
;
 
40$:                            ;REFERENCE LABEL
 
 
        .IF DF  SOLRCV
 
        MOV     R5,R0           ;SET UP TRANSFER VECTOR
        ADD     #U.RBUF,R0      ;RECEIVE TRANSFER INFORMATION HERE
        MOV     U.BUF(R5),(R0)+ ;TRANSFER BIAS
        MOV     U.BUF+2(R5),(R0)+ ;AND OFFSET
        MOV     U.CNT(R5),(R0)  ;AND COUNT
        BIC     #RECACT,(R2)    ;FORCE RESYNCHING
        BIS     #STRSYN!RCVENB,(R2) ; ENABLE RECEIVER
        BR      180$            ;RETURN - INTERRUPT CODE PROPAGATES RECEIVE
 
        .IFF
 
        BR      130$            ;MARK AS INVALID FUNCTION
 
        .ENDC
 
 
;
; CONTROL FUNCTION INITIATION (INITIATE OR TERMINATE CONTROLLER,
; OR CHANGE OPERATING MODE)
;
 
70$:    BNE     110$            ;IF NOT EQUAL, MODE CHANGE REQUEST
        TSTB    -(R1)           ;START FUNCTION?
        BNE     100$            ;IF NON-ZERO, TERMINATE
;
; DO START FUNCTION INITIATION
;
        MOV     #STRSYN,(R2)    ;NOW INITIALIZE CONTROLLER
        TST     U.CW2(R5)       ;HALF DUPLEX MODE SELECTED?
        BPL     80$             ;NO, IF PLUS
        BIS     #HDPX,(R2)      ;PUT DEVICE IN HALF DUPLEX
80$:    MOV     #TRMRDY,4(R2)   ;PUT TRANSMITTER ON LINE
        MOVB    U.SYNC(R5),3(R2) ;INITIALIZE SYNC CHARACTER
        MOV     R5,UNITBL(R3)   ;INITIALIZE UCB ADDRESS IN UNIT TABLE
        BIS     #U2.ONL,U.CW2(R5) ;MARK UNIT ON LINE
        BR      160$            ;RETURN SUCCESSFUL
 
;
; CAN'T ESTABLISH COMMUNICATIONS
;
 
90$:    MOV     #IE.DNR&377,R0  ;SAY CAN'T INITIALIZE DEVICE (NOT READY)
        BR      170$            ;DO I/O DONE
 
;
; FUNCTION WAS TERMINATE LINE
;
 
100$:   CLR     (R2)            ;CLEAR UNIT READY
        CLR     4(R2)           ;CLEAR TRANSMIT CSR
        BIC     #^C<U2.LIN!U2.SWC!U2.ACU>,U.CW2(R5) ;CLEAR OPERATING STATUS
        CLR     UNITBL(R3)      ;UNIT TABLE CLEARED OF UCB
        BR      160$            ;RETURN SUCCESSFUL STATUS
 
;
; SERVICE DEVICE MODE CHANGE REQUEST
;
 
110$:   BITB    #IO.HDX,-(R1)   ;SUBFUNCTION SAY HALF DUPLEX?
        BEQ     120$            ;IF ZERO, NO
        BIS     #U2.HDX,U.CW2(R5) ;SAY HALF DUPLEX CHARACTERISTIC
120$:   BITB    #IO.FDX,(R1)    ;SET MODE TO FULL DUPLEX?
        BEQ     150$            ;DON'T SET FULL DUPLEX
        BIT     #U2.LIN,U.CW2(R5) ;IS LINE CAPABLE OF FULL DUPLEX?
        BEQ     140$            ;YES, IF BIT NOT SET
130$:   MOV     #IE.IFC&377,R0  ;SET ILLEGAL FUNCTION CODE
        BR      170$            ;AND RETURN ERROR STATUS
 
140$:   BIC     #U2.HDX,U.CW2(R5) ;PUT IN FULL DUPLEX IN UCB
150$:   BITB    #IO.SYN,(R1)    ;SYNC CHARACTER SPECIFIED?
        BEQ     160$            ;NO, IF NOT SET
        MOVB    I.PRM-I.FCN(R1),U.SYNC(R5) ;MARK NEW SYNC CHARACTER
DPSUCC:                         ;REFERENCE LABEL
160$:   MOV     #IS.SUC&377,R0  ;RETURN SUCCESSFUL STATUS
DPFIN:                          ;REFERENCE LABEL
170$:   CLRB    S.STS(R4)       ;IDLE CONTROLLER
        BICB    #US.BSY,U.STS(R5) ;AND MARK UNIT IDLE
        MOV     R0,-(SP)        ;SAVE STATUS WORD 1
        MOV     S.PKT(R4),-(SP) ;SAVE OLD PACKET ADDRESS
        CALL    DPINIT          ;TRY TO ACTIVATE ANOTHER REQUEST
        MOV     (SP)+,R3        ;GET OLD I/O PACKET
        MOV     I.PRM+4(R3),R1  ;RETURN REQUESTED ITEM COUNT
        MOV     (SP)+,R0        ;GET STATUS WORD 1
        CALLR   $IOFIN          ;TERMINATE OLD PACKET
 
180$:   RETURN
 

 
;
; POWER FAIL SERVICE
;
 
DPPWRF:                         ;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        CALLR   DPRXER          ;CLEAR RECEIVER,WAIT FOR
                                ;DEVICE TIMEOUT FOR TRANSMIT
 
        .IFF
 
        CLRB    S.CTM(R4)       ;CLEAR DEVICE TIMEOUT COUNT
        MOV     #IE.DNR&377,R0  ;PUT ERROR CODE IN R0 FOR DPTMO
        BR      DPTMO           ;FINISH I/O ABORT
 
        .ENDC
 
 
;
; I/O CANCELLATION ENTRY
;
 
;       INPUTS:
;               R0=I/O PACKET ADDRESS
;               R1=TCB ADDRESS OF TASK TO CANCEL
;               R4=SCB ADDRESS
;               R5=UCB ADDRESS
 
DPCANC:                         ;;;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        RETURN                  ;;;JUST LET TRANSMITS FINISH
 
        .IFF
 
        CMP     R1,I.TCB(R0)    ;;;CANCEL FOR THIS TASK?
        BNE     180$            ;;;DON'T CANCEL IF NOT
        CMPB    #IO.WLB/256.,I.FCN+1(R0) ;;;IS FUNCTION TRANSMIT?
        BEQ     180$            ;;;JUST LET TRANSMIT FINISH
        TST     U.RCNT(R5)      ;;;RECEIVE FINISHEED?
        BLE     180$            ;;;DON'T CANCEL IF YES
        BIC     #RCVENB,@S.CSR(R4) ;;;DISABLE RECEIVER
        MOV     #IE.ABO&377,R0  ;;;PUT ERROR CODE IN R0 FOR DPTMO
        BR      DPTMO           ;;;FINISH OFF RECEIVE PACKET
 
        .ENDC
 
 
;
; TIMEOUT SERVICE ROUTINE
;
;       INPUTS:
;
;               R0 = DEVICE TIMEOUT STATUS 'IE.DNR'
;               R3 = CONTROLLER INDEX
;               R4 = ADDRESS OF SCB
;               R5 = ADDRESS OF UCB
;
 
DPTMO:  MOV     S.CSR(R4),R4    ;;;GET DEVICE CSR
        BIC     #TXINTE!IDLSYN,4(R4) ;;;DISABLE TRANSMITTER
        MTPS    #0              ;;;ALLOW INTERRUPTS
210$:   JMP     DPTXND          ;WAIT FOR SOFTWARE TIMEOUT
 
        .DSABL LSB

 
;
; **- $XPINP - DP-11 INPUT INTERRUPT SERVICE
;
 
        .ENABL  LSB
 
$XPINP::                        ;;;REFERENCE LABEL
        INTSV$  XP,PR5,D$$P11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DPSET           ;;;SET CSR IN R4, UCB IN R5
 
        .IF DF  M$$NET
 
        MOV     R3,-(SP)        ;;;SAVE R3 THROUGH R0
        MOV     R2,-(SP)
        MOV     R1,-(SP)
        MOV     R0,-(SP)
        MOV     R4,R2           ;;;COPY CSR ADDRESS
        
        .IFTF
 
        BIC     #STRSYN,(R4)+   ;;;CLEAR STRIP SYNC MODE
        MOV     (R4),R4         ;;;GET RECEIVED CHARACTER
 
        .ENDC
 
 
        .IF DF  SOLRCV&M$$MGE
 
        MOV     KISAR6,-(SP)    ;;;SAVE CURRENT MAPPING
        MOV     U.RBUF(R5),KISAR6 ;;;MAP TO USER BUFFER
        MOVB    R4,@U.RBUF+2(R5) ;;;STORE BYTE IN USER BUFFER
        MOV     (SP)+,KISAR6    ;;;RESTORE CURRENT MAPPING
 
 
        .IFF
 
        MOVB    R4,@U.RBUF+2(R5) ;;;STORE BYTE IN USER BUFFER
 
        .IFTF
 
        DEC     U.RCNT(R5)      ;;;SEE IF COUNT SATISFIED
        BEQ     20$             ;;;YES, IF EQ
        INC     U.RBUF+2(R5)    ;;;BUMP BYTE ADDRESS
 
        .IFT
 
        BIT     #20000,U.RBUF+2(R5) ;;;OVERFLOWED 4K BOUNDARY?
        BEQ     10$             ;;;NO, IF ZERO
        BIC     #20000,U.RBUF+2(R5) ;;;CLEAR OVERFLOW BIT
        ADD     #200,U.RBUF(R5) ;;;BUMP BIAS
 
        .ENDC
 
        .IF DF  M$$NET
 
        MOV     (SP)+,R0        ;;;RESTORE R0 - R3
        MOV     (SP)+,R1
        MOV     (SP)+,R2
        MOV     (SP)+,R3
 
        .ENDC
 
10$:    RETURN                  ;;;EXIT FROM INTERRUPTS
        
;
; REQUEST SATISFIED
;
 
20$:                            ;;;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        MOV     U.VCB(R5),R4    ;;;GET VCB ADDR
        CLR     R1              ;;;RETURN CRC=0
        ADD     #V.CIAD,R4      ;;;POINT TO FIRST BUFFER ADDR IN VCB
        MOV     (R4),U.RBUF+2(R5) ;;;PUT BUFER ADDR IN UCB
        BEQ     30$             ;;;BR IF ADDRESS IS NOT THERE
        BIS     #STRSYN,(R2)    ;;;START IN STRIP SYNC
        BR      40$             ;;;CONTINUE SETUP
 
30$:    ADD     #V.CSAD-V.CIAD,R4 ;;;POINT TO SECOND BUFFER ADDR IN VCB
        MOV     (R4),U.RBUF+2(R5) ;;;PUT BUFFER ADDR IN UCB
        BNE     40$             ;BR IF LEGAL ADDRESS
        MOV     R2,R0           ;;;RETURN BAD STATUS
        BR      50$
 
40$:    CLR     (R4)+           ;;;CLEAR OUT BUFFER ADDR IN VCB
        MOV     (R4),U.RCNT(R5) ;;;TRANSFER COUNT INTO UCB
        CLR     R0              ;;;RETURN GOOD STATUS
50$:    BIC     #RCVENB,(R2)    ;;;DISABLE RECEIVE INTERRUPTS
        MTPS    #PR4            ;;;LOWER PRIORITY
        CALL    @U.SVC(R5)      ;;;GO TO RECEIVE COROUTINE
        BCS     60$             ;;;IF C SET, DON'T DO ANYTHING
        BMI     60$             ;;;DON'T ENABLE RECV IF ERROR
        MTPS    #PR5            ;;;RETURN TO PRIORITY 5
        BIS     #RCVENB,(R2)    ;;;RE-ENABLE RECEIVE INTERRUPTS
60$:    RETURN                  ;;;RETURN TO CO-ROUTINE
 
        .ENDC
 
        .IF DF  SOLRCV
 
        MOV     U.SCB(R5),R4 ;;;GET DEVICE SCB ADDRESS
        BIC     #RCVENB,@S.CSR(R4) ;;;DISABLE RECEIVE INTERRUPTS
        CALL    $FORK           ;;;CREATE A FORK PROCESS
        JMP     DPSUCC          ;END I/O SUCCESSFUL
 
 
        .ENDC
 
        .DSABL  LSB

 
 
;
; **- $XPOUT - TRANSMITTER INTERRUPT SERVICE
;
 
$XPOUT::                        ;;;REFERENCE LABEL
        INTSV$  XP,PR5,D$$P11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DPSET           ;;;SET RECEIVE CSR IN R4, UCB IN R5
        ADD     #4,R4           ;;;POINT TO TX CSR
        BIT     #CRRTRN!OVRNER!RING,(R4)+ ;;;ANY TRANSITIONS MADE?
        BEQ     20$             ;;;IF NOT, CHECK TRANSMIT INTERRUPT
 
 
        .IF DF  M$$NET
 
        BIT     #OVRNER,-2(R4)  ;;;OVERRUN ERROR?
        BEQ     10$             ;;;NO, IGNORE STATUS BIT(S)
        MOV     R4,-(SP)        ;;;SAVE CSR ADDRESS
        MOV     U.VCB(R5),R4    ;;;GET VCB ADDRESS
        INC     V.COVR(R4)      ;;;BUMP RECEIVER OVERRUN COUNT
        MOV     (SP)+,R4        ;;;RESTORE CSR
 
        .ENDC
 
 
10$:    BIC     #OVRNER!CRRTRN!RING,-(R4) ;;;CLEAR STATUS TRANSITION BIT
        TSTB    (R4)+           ;;;TRANSMITTER FLAG SET?
        BPL     60$             ;;;IF NOT, DISMISS INTERRUPT
        INC     R4              ;;;POINT TO TRANSMITTER BUFFER
20$:    TSTB    U.NSYC(R5)      ;;;SYNC COUNT 0?
        BEQ     30$             ;;;IF SO, TRANSMIT
        DECB    U.NSYC(R5)      ;;;DECREMENT LEADING SYNC COUNT
        BLE     40$             ;;;IF LE, BEGIN TRANSMITTING
        MOVB    U.SYNC(R5),(R4) ;;;SEND ANOTHER SYNC
        BR      50$             ;;;AND EXIT
 
;
; SET UP AND TRANSMIT A BYTE
;
 
30$:    DEC     U.CNT(R5)       ;;;CHECK COUNT (0 NOT VALID)
        BLE     70$             ;;;IF LE, COUNT SATISFIED
40$:    CALL    $GTBYT          ;;;GET NEXT BYTE FROM BUFFER
        MOVB    (SP)+,(R4)      ;;;OUTPUT CHARACTER
50$:    MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS BACK
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET TIMEOUT COUNT
60$:    BR      DPSXT           ;;;EXIT FROM INTERRUPT
 
;
; COUNT SATISFIED - TERMINATE TRANSMISSION
;
 
70$:    BIC     #TXDONE!TXINTE,-(R4) ;;;DISABLE TRANSMITTER
 
 
        .IF NDF M$$NET
 
        TST     U.CW2(R5)        ;;;IN HALF DUPLEX?
        BPL     80$             ;;;IF PLUS NO
        BIC     #IDLSYN,(R4)    ;;;DON'T GO TO IDLE SYNC
        CMP     -(R4),-(R4)     ;;;POINT TO RECEIVER CSR
        BIC     #RECACT,(R4)    ;;;FORCE RE-SYNCHING
 
        .IFF
 
        TSTB    U.CW2(R5)       ;;;RECEIVER TO BECOME ACTIVE?
        BPL     80$             ;;;NO TURNAROUND IF FULL DUPLEX
        BIC     #IDLSYN,(R4)    ;;;DON'T IDLE SYNC
        TST     -(R4)           ;;;CLEAR RECEIVER DONE BIT              ;EW003
        BIC     #RECACT,-(R4)   ;;;FORCE RESYNCHING
 
        .IFTF
 
80$:    CALL    $FORK           ;;;CREATE SYSTEM PROCESS
 
        .IFT
 
        MOV     #IS.SUC&377,R0  ;RETURN SUCCESSFUL STATUS
 
        .IFTF
 
DPTXND:                         ;REFERENCE LABEL
 
        .IFF
 
        MOV     U.SCB(R5),R4    ;GET SCB ADDRESS                        ;EW003
        MOV     S.PKT(R4),R1    ;GET I/O PACKET TO FINISH
        CALL    @U.PHDR(R5)     ;CALL COROUTINE TO FINISH PACKET
90$:    JMP     DPINIT          ;SEE IF MORE TO DO
 
        .IFT
 
        MOV     U.SCB(R5),R4    ;RESTORE SCB TO R4
        JMP     DPFIN           ;MARK COMPLETION
        
        .ENDC
 
 

 
 
        .IF DF  M$$NET
 
;
; RECEIVER ERROR DETECTED WHICH REQUIRES RESYNCHING OF CONTROLLER
;
; INPUT:
;
;       R5 = UCB ADDRESS
;
; OUTPUT:
;       INITIATES ATTEMPTED RESYNCHING OF DEVICE
;       R2 = DEVICE RECEIVER CSR
;
 
DPRXER: MOV     U.SCB(R5),R2    ;GET SCB ADDRESS
        MOV     S.CSR(R2),R2    ;GET CSR ADDRESS IN R2
        BIC     #RECACT!RCVENB,(R2) ;CLEAR RECEIVER
        BIS     #STRSYN,(R2) ;ATTEMPT TO RE-SYNCH
        RETURN
 
;
;
; UNSOLICITED RECEIVE INITIALIZATION
; ACTIVATES CONTROLLER TO BE READY TO ACCEPT DATA,
; STARTING BUFFER ADDRESS IS IN V.CIAD IN THE VCB
; AND COUNT IS IN V.CICT
;
; INPUTS:
;
;       R4 = VCB ADDRESS
;       R5 = UCB ADDRESS
;
; OUTPUTS:
;
;       R0,R1 PRESERVED
;       R4 = VCB ADDRESS
;       R5 = UCB ADDRESS
;
 
DPRCV:  CALL    DPRXER          ;RESYNCH RX, GET CSR IN R2
        CLR     U.RCAC(R5)      ;START NEW CRC ACUMULATION
        MOV     R4,R3           ;COPY VCB ADDR
        ADD     #V.CIAD,R3      ;POINT TO FIRST RECEIVE BUFFER
        MOV     (R3),U.RBUF+2(R5) ;PUT ADDRESS OF BUFFER IN UCB
        CLR     (R3)+           ;CLEAR ADDRESS IN VCB
        MOV     (R3),U.RCNT(R5) ;PUT RECEIVE COUNT IN UCB
        CLR     (R3)            ;CLEAR COUNT IN VCB
        BIS     #STRSYN!RCVENB,(R2) ;START IN STRIP SYNC, ENABLE INTERRU
        RETURN                  ;GO BACK TO CALLER
 
        .ENDC
 
 

;
; DPSET - SET UP REGISTER R4 WITH CSR ADDRESS, R5 WITH
; UCB ADDRESS.  UNIT NUMBER IN LOW ORDER 4 BITS OF UNIT.
;
 
 
 
DPSET:                          ;;;REFERENCE LABEL
        TST     R5              ;;;CHECK FOR UCB ADDRESS
        BEQ     10$             ;;;IF NO UCB, TROUBLE
        BIT     #U2.ONL,U.CW2(R5) ;;;UNIT ON LINE?
        BEQ     10$             ;;;IF NOT ON LINE, NONSENSE
        MOV     U.SCB(R5),R4    ;;;FIRST GET SCB ADDRESS
        MOV     S.CSR(R4),R4    ;;;NOW DEVICE CSR ADDRESS
        RETURN                  ;;;AND NOW RETURN
 
10$:    TST     (SP)+           ;;;CLEAR STACK OF RETURN ADDRESS
DPSXT:  JMP     $INTXT          ;;;DISMISS INTERRUPT
 
        .END
        .TITLE  XQDRV
        .IDENT  /03.2/
 
;
; COPYRIGHT (C) 1974, 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 03
;
; EARL D. WALDIN 10-MAR-75
;
; PREVIOUSLY MODIFIED BY:
;
;       L. GILLESPIE
;       E. D. WALDIN
;
; MODIFIED BY:
;
; B. SCHREIBER  30-JUN-78
;
;       BLS056 -- CORRECT UMR ALLOCATION HANDLING
;
; C. SPITZ      9-AUG-78
;
;       CS015 -- CORRECT HANDLING OF I/O KILLS
;
;
; DQ11 SYNCHRONOUS COMMUNICATIONS DRIVER
;
 
 
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  PKTDF$,CLKDF$,HWDDF$
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        CLKDF$                  ;DEFINE CLOCK QUEUE PACKET OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        .MCALL  UCBDF$,CUCDF$
        UCBDF$                  ; DEFINE UCB OFFSETS
        CUCDF$                  ;COMMUNICATIONS UCB LABELS
 
 
        .IF DF  M$$NET
 
        .MCALL  F11DF$,CVCDF$
        F11DF$                  ;DEFINE FILES-11 OFFSETS
        CVCDF$                  ;DEFINE COMMUNICATIONS VCB OFFSETS
 
        .IFTF
 
 
 

;
; EQUATED SYMBOLS
;
 
;
; RXCSR BIT ASSIGNMENTS
;
 
RXGO=   1                               ;RECEIVE GO, SET TO START RECEIVER
STRSYN= 2                               ;STRIP SYNC CHARACTERS WHEN SET
RXPS=   4                               ;RX PRIMARY OF SECONDARY REG ACTIVE(0=PR)
HDPX=   10                              ;HALF DUPLEX IF SET
RXDNIE= 40                              ;RECEIVER DONE INTERRUPT ENABLE
RXDNP=  200                             ;RECEIVE PRIMARY REGISTER DONE
RXDNS=  100                             ;RECEIVE SECONDARY REGISTER DONE
RXACT=  10000                           ;RECEIVER ACTIVE FLAG
RXDIS=  RXDNIE!RXDNP!RXDNS              ;DISABLE RECIEVER MASK
 
;
; TXCSR BIT ASSIGN
;
 
TXGO=   1                               ;TRANSMIT GO
IDLSYN= 2                               ;IDLE SYNC MODE BIT
TXPS=   4                               ;TX PRI OF SEC REG ACTIVE (0=PRI)
ERRIE=  10                              ;ERROR INTERRUPT ENABLE
DTSIE=  20                              ;DATA SET INTR ENABLE
TXDNIE= 40                              ;TX DONE INTR ENABLE
TXDNP=  200                             ;TX DONE PRIMARY REG
TXDNS=  100                             ;TX DONE SECONDARY REG
RTS=    400                             ;REQUEST TO SEND
DTR=    1000                            ;DATA TERMINAL READY
DSR=    2000                            ;DATA SET READY
CTS=    20000                           ;CLEAR TO SEND WHEN SET
DSFLG=  100000                          ;DATA SET FLG (RI!CTS!SQDT)
TXDISF= ^C<RTS!IDLSYN!DTR>              ;TX DISABLE FOR FULL DUPLEX
TXDISH= ^C<DTR>                         ;TX DISABLE FOR HALF DUPLEX
TXNDIS= TXDISF&<^CERRIE>                ;TX NETWORK DISABLE
 
;
;REG/ERR REGISTER BIT ASSIGNMENTS
;
 
ERRINT= 100000                          ;ERROR INTERRUPT
WRTEN=  20                              ;WRITE ENABLE BIT FOR EXTENSION BITS
TEXIT=  60                              ;EXIT TRANSPARENCY BITS
TENTR=  120                             ;ENTER TRANSPARENCY BITS
CCRG=   1!WRTEN                         ;CCRG!<BUF ADDR PTR>= COUNT REG
TXCLK=  1                               ;TX CLOCK LOSS ERROR
TXLAT   =4                              ;TX BUSS LATENCY ERROR
TXNEX=  20                              ;TX NON EXISTENT MEMORY ERROR
RXCLK=  2                               ;RX CLOCK LOSS ERROR
RXLAT=  10                              ;RX BUS LATENCY ERROR
RXNEX=  40                              ;RX NON EXISTENT MEMORY ERROR
BCCERR=100                              ;BCC (RX) ERROR BIT
TXERR=TXCLK!TXLAT!TXNEX                 ;OR OF TRANSMIT ERROR BITS
RXERR=RXCLK!RXLAT!RXNEX!BCCERR          ;OR OF RECEIVE ERROR BITS
 
 
;
;MISC SECONDARY REGISTER BIT ASSIGNMENTS
;
 
TXACT=  40000                           ;=1 WHEN TX IS ACTIVE
MSCLR=40                                ;MASTER CLEAR
 
 
;
; SECONDARY REGISTER ADDRESS ASSIGNMENTS
;
 
RXBAP=  0                               ;RX BUS ADDR PRIMARY REG
RXCCP=  1                               ;RX CHAR COUNT PRIMARY
TXBAP=  2                               ;TX BUS ADDR PRIMARY
TXCCP=  3                               ;TX CHAR COUNT PRIMARY
RXBAS=  4                               ;RX BUS ADDR SECONDARY
RXCCS=  5                               ;RX CHAR COUNT SECONDARY
TXBAS=  6                               ;TX BUS ADDR SECONDARY
TXCCS=  7                               ;TX CHAR COUNT SECONDARY
SYNREG= 4400                            ;SYNC CHAR REGISTER
MISCRG= 5000                            ;MISC REGISTER
MISCRB= 12                              ;MISC REGISTER ADDR, HIGH BYTE
POLY= 7400                              ;POLYNOMIAL REGISTER FOR CRC
SEQREG= 6000                            ;SEQUENCE REGISTER FOR PROTOCOL OPTION
 
;
; MISC ASSIGNMENTS
;
 
TERM=   U2.CTS!U2.HDX!U2.ONL!U2.SNC!U2.RCV      ;U.CW2 BITS WHICH
                                        ;ARE CLEARED ON TERMINATE
CLNGTH=4000                             ;SETS CHAR LENGTH TO 8 BITS
CRC16=120001                            ;POLYNOMIAL REG BITS FOR CRC 16
IE.BCC=-64.                             ;RX BCC ERROR CODE
 
        MXSYNC=10.
 

;
; LOCAL DATA
;
 
;
; UNIT IMPURE DATA TABLE
;
 
CNTBL:                                  ;REF LABEL
UNITBL: .REPT  D$$Q11                   ;UCB ADDRESS TABLE
                                        ;INDEXED BY CONTROLLER NUMBER
        .WORD   0
 
        .ENDM
 
        .IF GT  D$$Q11-1
 
TEMP:                                   ;REF LABEL
UNIT:   .BLKW   1
 
        .ENDC
 
        .IFTF
 
;
; DEVICE DISPATCH TABLE
;
 
$XQTBL:: .WORD DQINIT                   ;DEVICE INITILIZATION
         .WORD DQCANC                   ;DEVICE I/O CANCEL ENTRY
         .WORD DQTMO                    ;TIMEOUT ENTRY
         .WORD DQPWRF                   ;POWER FAIL ROUTINE
 
        .IFT
 
        .WORD   DQRCV                   ;UNSOLICITED RECIEVE INITIATION
        .WORD   RESYNC                  ;RESYNC ON RECEIVE ERROR
 
        .IFF
 
        .WORD   DQRET
        .WORD   DQRET

;+
;**- DQINIT - DQ-11 SYNCHRONOUS COMMUNICATION CONTROLLER I/O INITIATOR
;
; DQINIT IS ENTERED WHEN AN I/O REQUEST IS QUEUED ON THE DEVICE
; AND AT THE END OF EACH QIO REQUEST WHICH OBEYS THE
; NORMAL RSX-11M INPUT/OUTPUT LOGIC FLOW.  IF THE DEVICE IS
; AVAILABLE AND A REQUEST IS IN THE QUEUE FOR THAT UNIT,
; THE REQUEST IS INITIATED.
; IF NO REQUEST EXISTS FOR THAT UNIT OR IF IT IS BUSY,
; AN EXIT IS TAKEN TO THE CALLER.  NOTE THAT BECAUSE OF THE
; NATURE OF THE DQ-11, EACH UNIT IS A CONTROLLER ITSELF, HAS
; ITS OWN SCB, AND THEREFORE ITS OWN QUEUE.
; EACH TIME DQINIT IS CALLED, IT IS CALLED TO SERVICE ONLY
; THE UNIT SPECIFIED IN THE CALL.
;
; INPUTS:
;       R4 = STATUS CONTROL BLOCK ADDRESS
;       R5 = ADDRESS OF THE UCB TO BE INITIATED.
;
; OUTPUTS;
;       IF A REQUEST IS SUCCESSFULLY DEQUEUED, THE
;       DEVICE IS INITIATED APPROPRIATELY.
;
;-
 
 
 
        .IFTF
 
        .ENABL  LSB
 
DQINIT:                                 ;REFERENCE LABEL
 
        .IFT
 
        TSTB    U.CW2(R5)               ;HALF DUPLX RCV EXPECTED?
        BMI     DQRET                   ;INITIATE NO NEW ACTION
 
        .IFTF
 
 
        CALL    $GTPKT                  ;GET I/O PACKET TO PROCESS
        BCC     10$                     ;CC MEANS WORK TO DO
DQRET:  RETURN
 
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1= ADDRESS OF I/O REQUEST PACKET
;       R2= PHYSICAL UNIT NUMBER OF REQUEST UCB
;       R3= CONTROLLER INDEX
;       R4= ADDRESS OF STATUS CONTROL BLOCK
;       R5= ADDRESS OF THE UCB SPECIFIED IN THE DQINIT CALL

;
; DQ11 I/O REQUEST PACKET FORMAT
;
;       WORD         CONTENT
;
;         0     I/O QUEUE THREAD WORD
;         1     REQUEST PRIORITY, EVENT FLAG NUMBER
;         2     ADDRESS OF THE TCB OF THE REQUESTER TASK
;         3     POINTER TO SECOND LUN WORD IN TASK HEADER
;         4     CONTENTS OF FIRST LUN WORD (UCB)
;         5     I/O FUNCTION CODE
;         6     VIRTUAL ADDRESS OF I/O STATUS BLOCK
;         7     RELOCATION BIAS OF I/O STATUS BLOCK
;        10     I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000)
;        11     VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;        12     RELOCATION BIAS OF I/O BUFFER
;        13     BUFFER ADDRESS FOR TRANSFER
;        14     TOTAL BYTE COUNT TO TRANSFER
;        15     NOT USED
;        16     NOT USED
;        17     NOT USED
;        20     NOT USED
;
 
 
10$:    MOV     S.CSR(R4),R2            ;GET RX CSR ADDR
        ADD     #I.FCN+1,R1             ;POINT TO I/O FUNC CODE
        CMPB    #IO.INL/256.,(R1)       ;CHECK IF TRANSFER FUNC
        BLOS    110$                    ;BR IF CONTROL FUNCTION
        BIT     #U2.ONL,U.CW2(R5)       ;IS DEVICE ONLINE
        BNE     30$                     ;CONTINUE
20$:    JMP     210$                    ;DEVICE NOT READY
 
30$:                                    ;REFERENCE LABEL
 
        .IFF
 
        BIT     #DSR,2(R2)              ;DATA SET READY?
        BEQ     20$                     ;BRANCH IF NOT READY
 
        .IFTF
 
        .IF DF  M$$MGE
 
        .IF DF  M$$EXT
 
        CMP     #4096.,U.CNT(R5)        ;BUFFER TOO BIG?
        BHIS    33$                     ;CONTINUE IF NOT
        MOV     #IE.SPC&377,R0          ;SIGNAL BUFFER TOO BIG
        JMP     UNSUCC                  ;FINISH I/O
 
33$:    CALL    $STMAP                  ;GET DEVICE'S BUS ADDRESS
        MOV     R1,-(SP)                ;SAVE R1
        MOV     R2,-(SP)                ;AND R2
        CALL    $MPUBM                  ;MAP 11/70 UNIBUS FOR DEVICE
        MOV     (SP)+,R2                ;RESTORE R2 AND R1
        MOV     (SP)+,R1
 
        .ENDC
 
        MOV     U.BUF(R5),R0            ;GET MEMORY EXTENSION BITS
        ASL     R0                      ;PUT THEM IN BITS 5 & 6
        BIS     #WRTEN,R0               ;OR IN WRITE ENABLE BIT
 
        .IFF
 
        MOV     #WRTEN,R0               ;ZERO MEMORY EXTENSION BITS
 
        .ENDC
 
        CMPB    #IO.RLB/256.,(R1)       ;IS FUNC READ LOGICAL?
        BEQ     100$                    ;YES, GO TO READ REQ
 
; FALL THROUGH ON TRANSMIT REQUEST
 
        .IFT
 
        MOV     R0,-(SP)                ;SAVE R0
        CALL    @U.PHDR(R5)             ;CALL COROUTINE FOR INITIATE
        MOV     (SP)+,R0                ;RESTORE R0
        BIT     #DSR,2(R2)              ;DATA SET READY?
        BNE     35$                     ;CONTINUE IF YES
        JMP     DQTXDN                  ;FINISH TRANSMIT
35$:                                    ;REFERENCE LABEL
 
        .IFTF
 
        TST     (R2)+                   ;POINT TO TXCSR
        BIS     #RTS,(R2)+              ;SET REQUEST TO SEND
        INC     R2                      ;POINT TO ERR/REG HIGH BYTE
        CALL    TNEXT                   ;GET NEXT BUFFER REGISTER ADDR
        BIS     #WRTEN,R3               ;CLEAR MEM EXT BITS
        MOVB    R3,(R2)+                ;SET UP SECONDARY REGISTER PTR
        MOV     U.QSYN(R5),(R2)         ;LOAD ADDRESS OF SYNC BUFFER
        BIS     #CCRG,R3                ;SELECT CHAR COUNT REG
        MOVB    R3,-(R2)                ;SET UP SECONDARY REG PTR
        MOVB    U.NSYN(R5),R1           ;GET NO.OF SYNCS TO SEND
        CMPB    #MXSYNC,R1              ;COUNT EXCEED SPACE?
        BHIS    40$                     ;BR IF NOT
        MOV     #MXSYNC,R1              ;SET COUNT TO MAX OF 8 SYNCS
40$:    NEG     R1                      ;COUNT IN 2'S COMPLEMENT
        MOV     R1,1(R2)                ;COUNT INTO DQ
        BIS     #U2.SNC,U.CW2(R5)       ;SAY SENDING SYNCS
        CALL    TOAN                    ;SETUP SECOND BUFFER
50$:    BIS     R0,R3                   ;OR IN MEM  EXT BITS
        MOVB    R3,(R2)+                ;SET UP SECONDARY REG PTR
 
        .IF DF  Q$$CRC&M$$NET
        
        SUB     #2,U.CNT(R5)            ;REMOVE CRC BIAS
 
        .ENDC
        
        MOV     U.BUF+2(R5),(R2)        ;USER BUFFER ADDR INTO DQ
        BIC     R0,R3                   ;CLR OUT MEM EXT BITS
 
        .IF DF  Q$$CRC
 
        BIS     #CCRG!TENTR,R3          ;SELECT COUNT REG, START CRC
 
        .IFF
 
        BIS     #CCRG,R3                ;JUST SELECT COUNT REG
 
        .ENDC
 
55$:    MOVB    R3,-1(R2)               ;SET UP SECONDARY REG PTR
        NEG     U.CNT(R5)               ;COUNT IN 2'S COMPLEMENT
        MOV     U.CNT(R5),(R2)          ;LOAD COUNT INTO DQ
        MOVB    S.ITM(R4),S.CTM(R4)     ;SET TIMEOUT
        TST     -(R2)                   ;POINT TO ERR/REG REG
        BIT     #CTS,-(R2)              ;CTS SET YET?
        BEQ     70$                     ;BR IF NOT SET YET
        BIS     #TXGO!TXDNIE!ERRIE,(R2)  ;START XMIT, ENABLE INTERRUPTS
        BR      80$                     ;RETURN
 
70$:    BIS     #U2.CTS,U.CW2(R5)       ;SAY CTS EXPECTED IN UCB
        BIS     #DTSIE,(R2)             ;ENABLE DATA SET INTERRUPTS
80$:    RETURN                          ;RETURN, INTR PROPAGATES XMIT

 
;
; RECEIVE FUNCTION INITIATION
;
 
 
100$:                                   ;REFERENCE LABEL
 
        .IFF
 
 
        ADD     #5,R2                   ;POINT TO ERR/REG HIGH BYTE
        CALL    RNEXT                   ;SETUP FIRST BUFFER
        BIS     R0,R3                   ;OR IN MEMORY EXTENSION BITS
        MOVB    R3,(R2)+                ;SET UP SECONDARY REG PTR
        MOV     U.BUF+2(R5),(R2)        ;USER BUFFER ADDR INTO DQ
        BIC     R0,R3                   ;CLR OUT MEM EXT BITS
        BIS     #TENTR!CCRG,R3          ;SELECT CC REG AND ENTER TRANS
        MOVB    R3,-1(R2)               ;SET UP SECONDARY REG PTR
        MOV     U.CNT(R5),(R2)          ;DATA COUNT INTO DQ
        NEG     (R2)                    ;COUNT IN 2'S COMPLEMENT
        DEC     R2                      ;POINT TO ERR/REG HIGH BYTE
 
 
        .IF DF  Q$$CRC
 
        CALL    ROAN                    ;SETUP SECOND BUFFER
        BIS     #TEXIT!CCRG,R3          ;SELECT CC AND EXIT TRANS
        MOVB    R3,(R2)                 ;SET UP SECONDARY REG PTR
        CLR     1(R2)
        
        .ENDC
 
 
        DEC     R2                      ;POINT TO ERR/REG REGISTER
        BIS     #ERRIE,-(R2)            ;ENABLE ERROR INTERRUPTS
        BIS     #RXGO!RXDNIE,-(R2)      ;START RECEIVER
        RETURN                          ;RETURN, INTERRUPTS PROPAGATE RECEIVE
 
        .IFT
 
        BR      180$                    ;SIGNAL ILLEGAL FUNCTION
 
        .IFTF
 
 
; FUNCTION WAS CONTROL FUNCTION
 
110$:   BNE     160$                    ;BR IF CHANGE MODE FUNCTION
        TSTB    -(R1)                   ;TEST SUBCODE
        BNE     220$                    ;FUNCTION WAS TERMINATE
 
; START FUNCTION INITIATION
 
 
        CMP     (R2)+,(R2)+             ;POINT TO ER/REG
        MOV     #MISCRG,(R2)            ;SELECT MISCELL REG
        MOV     #MSCLR,2(R2)            ;AND DO A MASTER CLEAR
        MOVB    #20,R0                  ;SET UP TO CLEAR SEC REGS
120$:   MOVB    R0,1(R2)                ;SELECT SECONDARY REGISTER
        CLR     2(R2)                   ;CLEAR SECONDARY REGISTER
        INC     R0                      ;NEXT SEC REG ADDR
        CMPB    #30,R0                  ;LAST REG TO CLEAR
        BHI     120$                    ;BR IF MORE TO CLEAR
 
 
        .IF DF  Q$$HPT
 
        BIT     #U2.HPT,U.CW2(R5)       ;DOES DEVICE HAVE PROTOCOL OPTION?
        BEQ     125$                    ;BR IF NO
        MOV     #17,R0                  ;SET UP TO CLR SEQUENCE SCRATCHPAD
        MOV     #SEQREG,(R2)            ;SELECT SEQUENCE REG
122$:   MOVB    R0,-3(R2)               ;INDEX INTO SEQUENCE SCRATCHPAD
        CLR     2(R2)                   ;CLEAR ENTRY
        DEC     R0
        BGE     122$                    ;BR IF MORE TO GO
 
        .ENDC
 
 
125$:   MOV     #MISCRG,(R2)+           ;SELECT MISC REGISTER
        MOV     #CLNGTH,(R2)            ;SET CHARACTER LENGTH
        MOV     #SYNREG,-(R2)           ;SELECT SYNC REGISTER
        MOVB    U.SYNC(R5),-(SP)        ;GET SYNC CHAR FROM UCB
        MOVB    (SP),1(SP)              ;COPY LOW BYTE INTO HIGH BYTE
        MOV     (SP)+,2(R2)             ;LOAD DQ SYNC REG
 
        .IF DF  Q$$CRC
 
        MOV     #POLY,(R2)              ;SELECT POLYNOMIAL REG
        MOV     #CRC16,2(R2)            ;LOAD POLYNOMIAL FOR CRC16
 
        .ENDC
 
 
        BIS     #DTR,-(R2)              ;SET DATA TERMINAL READY
        TST     U.CW2(R5)               ;IN HALF DUPLEX?
        BPL     130$                    ;BR IF FULL DUPLEX
        BIS     #HDPX,-(R2)             ;SET HALF DUPLEX IN RXCSR
130$:   MOV     R5,UNITBL(R3)           ;PUT UCB INTO TABLE
        MOV     U.QSYN(R5),R0           ;SYNC BUFFER ALREADY ALLOCATED?
        BNE     135$                    ;DON'T RE-ALLOCATE BUFFER
        MOV     #MXSYNC,R1              ;GET SIZE OF SYNC BUFFER
        CALL    $ALOCB                  ;TRY TO ALLOCATE BUFFER
        BCS     210$                    ;BR IF COULDN'T
        MOV     R0,U.QSYN(R5)           ;SAVE POINTER TO AREA
135$:   BIS     #U2.ONL,U.CW2(R5)       ;MARK DEVICE ONLINE
        .IF DF  M$$NET
 
        BISB    #US.SYN,U.STS(R5)       ;SAY TO ALWAYS SEND SYNCS
 
        .IF NDF Q$$CRC
 
        BIC     #U2.HRC,U.CW2(R5)       ;NETWORK DOESN'T USE CRC OPTION
 
        .ENDC
 
        .ENDC
 
        MOV     #MXSYNC,R2              ;SET UP TO LOAD SYNC BUFFER
150$:   MOVB    U.SYNC(R5),(R0)+        ;MOV SYNC CHAR INTO BUFFER
        DEC     R2                      ;MORE TO PUT IN?
        BGT     150$                    ;BR IF MORE TO GO
        BR      SUCC                    ;COMPLETE I/O DONE
 
 
; SERVICE DEVICE MODE CHANGE REQUEST
 
160$:   BITB    #IO.HDX,-(R1)           ;HALF DUPLEX SUBFUNCTION?
        BEQ     170$                    ;BR IF NOT
        BIS     #U2.HDX,U.CW2(R5)       ;SET HALF DUPLEX
170$:   BITB    #IO.FDX,(R1)            ;FULL DUPLEX SUBFUNCTION?
        BEQ     200$                    ;BR IF NOT
        BIT     #U2.LIN,U.CW2(R5)       ;DEVICE CAPABLE OF FULL DUPLEX?
        BEQ     190$                    ;BR IF YES
180$:   MOV     #IE.IFC&377,R0          ;SIGNAL ILLEGAL FUNCTION CODE
        BR      UNSUCC                  ;FINISH I/O UNSUCCESSFUL
 
190$:   BIC     #U2.HDX,U.CW2(R5)       ;SET FULL DUPLEX CHARACTERISTIC
200$:   BITB    #IO.SYN,(R1)            ;SYNC CHARACTER SPECIFIED?
        BEQ     SUCC                    ;DO I/O DONE IF NOT
        MOVB    I.PRM-I.FCN(R1),U.SYNC(R5) ;MARK NEW SYNC CHAR
        BR      SUCC                    ;COMPLETE I/O DONE
 
 
; CAN'T ESTABLISH COMMUNICATIONS
 
210$:   MOV     #IE.DNR&377,R0          ;SAY DEVICE NOT READY
        BR      UNSUCC                  ;DO I/O DONE
 
;FUNCTION WAS TERMINATE LINE
 
220$:   CMP     (R2)+,(R2)+             ;POINT TO ER/REG
        MOV     #MISCRG,(R2)+           ;SELECT MISC REG
        MOV     #MSCLR,(R2)             ;AND DO A MASTER CLEAR
        BIC     #TERM,U.CW2(R5)         ;CLR STATUS BITS IN UCB
        CLR     UNITBL(R3)              ;REMOVE UCB FROM UNITBL
        MOV     U.QSYN(R5),R0           ;GET FORK BLOCK AREA
        BEQ     SUCC                    ;DON'T RELEASE IF NOT ALLOCATED
        MOV     #MXSYNC,R1              ;SET SIZE OF FORK AREA
        CALL    $DEACB                  ;RELEASE BLOCK AREA
        CLR     U.QSYN(R5)              ;SIGNAL NOTHING THERE
SUCC:   MOV     #IS.SUC&377,R0          ;SUCC COMP ENTRY
UNSUCC: CLRB    S.STS(R4)               ;IDLE CONTROLLER
        BICB    #US.BSY,U.STS(R5)       ;MARK UNIT IDLE
        MOV     R0,-(SP)                ;SAVE STATUS WORD 1
        MOV     S.PKT(R4),-(SP)         ;SAVE OLD PACKET ADDR
        CALL    DQINIT                  ;TRY TO ACT NEXT REQ
        MOV     (SP)+,R3                ;GET OLD I/O PACKET
        MOV     I.PRM+4(R3),R1          ;RETURN REQ ITEM CNT
        MOV     (SP)+,R0                ;GET STATUS WORD 1
        CALLR   $IOFIN                  ;TERMINATE OLD PACKET
 

 
; I/O CANCELLATION ENTRY
;
;       INPUTS:
;               R5 = ADDRESS OF UNIT CONTROL BLOCK
;               R4 = ADDRESS OF STATUS CONTROL BLOCK
;               R1 = TCB ADDRESS OF TASK FOR CANCELL
;               R0 = ADDRESS OF CURRENT PACKET
;
 
DQCANC:                                 ;;;REFERENCE LABEL
 
        .IFT
 
        RETURN                          ;;;LET TRANSMIT FINISH OR TIMEOUT
 
        .IFF
 
        CMP     R1,I.TCB(R0)            ;;;CURRENT PACKET FOR THIS TASK?
        BNE     225$                    ;;;RETURN IF NOT
        CMPB    #IO.WLB/256.,I.FCN+1(R0);;;TRANSMIT?
        BEQ     225$                    ;;;JUST LET FINISH IF YES
        MOV     #IE.ABO&377,R0          ;;;ASSUME WE WILL ABORT
        BIT     #RXACT,@S.CSR(R4)       ;;;IS RECEIVER ACTIVE?
        BNE     217$                    ;RECEIVER IS ACTIVE
        BIT     #RXDNP!RXDNS,@S.CSR(R4) ;HAS RECEIVE FINISHED?
        BNE     225$                    ;IF NE, YES, LET IT BE SUCCESSFUL
217$:   BIC     #RXDIS!RXGO,@S.CSR(R4)  ;DISABLE RECEIVER
        BR      UNSUCC                  ;FINISH UNSUCCESSFUL I/O
225$:   RETURN                          ;;;RETURN TO CALLER
        
; POWERFAIL ENTRY FOR NON NETWORKS
 
DQPWRF: MOV     S.CSR(R4),R2            ;;;GET DEVICE CSR ADDRESS
        BIC     #RXDIS!RXGO,(R2)+       ;;;DISABLE RECEIVER
        BIC     #TXDISH,(R2)+           ;;;DISABLE TRANSMITTER
        CLRB    (R2)                    ;;;CLEAR ALL ERROR BITS
        MOVB    #2,S.CTM(R4)            ;;;FORCE TIMEOUT
230$:   RETURN                          ;;;RETURN TO CALLER
 
        .IFT
 
; POWERFAIL ENTRY FOR NETWORKS
 
DQPWRF: CALLR   RESYNC                  ;;;RESYNC RECEIVER, WAIT FOR
                                        ;;;TIMEOUT ON TRANSMIT
 
        .IFTF
 
; TIMEOUT ENTRY
; THIS CODE IS ENTERED WHEN THE TRANSMIT TIMEOUT COUNT GOES TO ZERO.
 
DQTMO:  MOV     S.CSR(R4),R2            ;;;GET CSR IN R2
        BIC     #TXDISH,2(R2)           ;;;DISABLE TRANSMITTER
        BIC     #U2.CTS,U.CW2(R5)       ;;;CLR WAITING FOR CTS FLAG
        MTPS    #0                      ;;;DROP PRIORITY LEVEL
 
        .IFF
 
        BR      UNSUCC                  ;FINISH I/O UNSUCCESSFUL
 
        .IFT
 
240$:   JMP     DQTXDN          ;WAIT FOR SOFTWARE TIMEOUT TO FINISH
 
        .ENDC
 
        .DSABL  LSB

;+
; TNEXT,TOAN,RNEXT AND ROAN ARE SUBROUTINES WHICH SELECT THE
; APPROPRIATE BUFFER ADDRESS REGISTER TO USE.  TNEXT (TRANSMIT)
; AND RNEXT (RECEIVE) SELECT THE NEXT BUFFER AS INDICATED BY THE
; TXPS AND TXPS STATUS BITS RESPECTIVELY.  TOAN AND ROAN SELECT THE
; BUFFER WHICH IS THE ONE AFTER THE NEXT BUFFER TO BE USED. (IE.
; FOR DOUBLE BUFFERING AHEAD)
;
;       INPUTS:
;               R2 = ADDR OF DQ ERR/REG REGISTER, HIGH BYTE
;
;       OUTPUTS:
;               R3 = APPROPRIATE SECONDARY REGISTER ADDRESS
;-
 
        .ENABL  LSB
 
TNEXT:  BIT     #TXGO,-3(R2)            ;CURRENT BUFFER ACTIVE?
        BNE     TOAN                    ;USE OTHER IF YES
        BIT     #TXPS,-3(R2)            ;PRIMARY OR SEC REG ACTIVE?
        BNE     20$                     ;BR IF SECONDARY
        BR      10$                     ;BR IF PRIMARY
 
TOAN:   BIT     #TXPS,-3(R2)            ;PRIMARY OR SECONDARY ACTIVE?
        BEQ     20$                     ;BR IF SECONDARY NOT ACTIVE
10$:    MOV     #TXBAP,R3               ;SELECT PRIMARY TX REG
        RETURN                          ;RETURN
20$:    MOV     #TXBAS,R3               ;SELECT SECONDARY TX REG
        RETURN                          ;RETURN
 
        .IF DF  Q$$CRC!M$$NET
        
ROAN:   BIT     #RXPS,-5(R2)            ;PRIMARY OR SECONDARY ACTIVE?
        BEQ     40$                     ;BR IF SEC NOT ACTIVE
        BR      30$                     ;BR IF PRI NOT ACTIVE
 
        .IFTF
 
RNEXT:                                  ;REFERENCE LABEL
 
        .IFT
 
        BIT     #RXACT,-5(R2)           ;RECEIVER ACTIVE?
        BNE     ROAN                    ;USE ROAN IF ACTIVE
 
        .ENDC
 
        BIT     #RXPS,-5(R2)            ;PRIMARY OR SECONDARY ACTIVE?
        BNE     40$                     ;BR IF SEC ACTIVE
30$:    CLR     R3                      ;SELECT PRIMARY RECEIVE REG
        RETURN                          ;RETURN
 
40$:    MOV     #RXBAS,R3               ;SELECT SECONDARY RECEIVE REG
        RETURN
 
        .DSABL  LSB

 
;
; TRANSMIT INTERRUPT ROUTINE
;
 
        .ENABL  LSB
 
$XQOUT::                                ;;;REFERENCE LABLE
        INTSV$  XQ,PR5,D$$Q11           ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DQSET                   ;;;RXCSR->R4, UCB->R5
        TST     (R4)+                   ;;;POINT TO TXSCR
        BIT     #U2.CTS,U.CW2(R5)       ;;;CTS EXPECTED?
        BEQ     20$                     ;;;BR IF NOT EXPECTED
        BIT     #CTS,(R4)               ;;;IS CTS SET?
        BEQ     10$                     ;;;BR IF NOT SET YET
        BIC     #DTSIE,(R4)             ;;;DISABL DATASET INTERRUPTS
        BIS     #TXGO!TXDNIE!ERRIE,(R4) ;;;START TRANSMIT
        BIC     #U2.CTS,U.CW2(R5)       ;;;CLR CTS EXPECTED IN UCB
10$:    BIC     #DSFLG,(R4)             ;;;RESET DATA SET FLAG
20$:    TST     2(R4)                   ;;;ANY ERRORS?
        BPL     22$                     ;;;BR IF NO ERRORS
        JMP     ERROR                   ;;;GO TO ERROR ROUTINE
 
22$:                                    ;;;REFERENCE LABEL
 
        BIT     #TXDNP,(R4)             ;;;PRIMARY BUFFER FINISH?
        BNE     70$                     ;;;BR IF YES
        BIT     #TXDNS,(R4)             ;;;SECONDARY BUFFER FINISH?
        BNE     25$                     ;;;BR IF YES
        JMP     DQEXIT                  ;;;EXIT FROM INTERRUPT
 
25$:    BIC     #TXDNS,(R4)             ;;;CLR SECONDARY DONE
        BR      80$                     ;;;CONTINUE
70$:    BIC     #TXDNP,(R4)             ;;;CLR PRIMARY DONE
80$:    BIT     #U2.SNC,U.CW2(R5)       ;;;SENDING SYNCS?
        BEQ     180$                    ;;;BR IF SENDING DATA
        BIC     #U2.SNC,U.CW2(R5)       ;;;CLR SENDING SYNCS IN UCB
        MOV     R2,-(SP)                ;;;SAVE R2
 
        .IF DF  Q$$CRC
 
        MOV     R3,-(SP)                ;;;SAVE R3
        MOV     R4,R2                   ;;;COPY CSR ADDR
        ADD     #3,R2                   ;;;POINT TO ERR/REG HIGH BYTE
        CALL    TNEXT                   ;;;GET NEXT REGISTER POINTER
        BISB    #CCRG!TEXIT,R3          ;;;FORCE EXIT TRANSPARENCY
        MOVB    (R2),-(SP)              ;;;SAVE OLD SECONDARY POINTER
        MOVB    R3,(R2)+                ;;;SETUP SECONDARY ADDR
        CLR     (R2)                    ;;;SET COUNT OF ZERO
        MOVB    (SP)+,-(R2)             ;;;RESTORE OLD SECONDARY POINTER
 
        .IFTF
 
        MOV     U.SCB(R5),R2            ;;;GET SCB ADDR
        MOVB    S.ITM(R2),S.CTM(R2)     ;;;RESET TIMEOUT
 
        .IFT
 
        MOV     (SP)+,R3                ;;;RESTORE R3
 
        .ENDC
 
        MOV     (SP)+,R2                ;;;RESTORE R2
        BR      20$                     ;;;CHECK FOR NEW FLAGS
 
180$:   BIC     #TXDISF,(R4)            ;;;DISABLE TRANSMITTER
        CALL    $FORK                   ;GO TO FORK LEVEL
TXTRN:  MOV     U.SCB(R5),R4            ;GET SCB ADDRESS INTO R4
        MOV     S.CSR(R4),R2            ;GET DEVICE RXCSR
        TST     (R2)+                   ;POINT TO TXCSR
 
        .IF DF  M$$NET
 
        TSTB    U.CW2(R5)               ;RECEIVER TO BECOME ACTIVE?
 
        .IFF
 
        TST     U.CW2(R5)               ;IN HALF DUPLEX?
 
        .IFTF
 
        BPL     220$                    ;BR IF FULL DUPLEX
        MOVB    #MISCRB,3(R2)           ;SELECT MISCELLANEOUS REG
        BIT     #TXACT,4(R2)            ;TX STILL ACTIVE?
        BEQ     210$                    ;BR IF FINISHED
        MOV     R4,R0                   ;SCB ADDR INTO R0
        ADD     #S.XQCK,R0              ;POINT TO CLOCK QUEUE BLOCK
        CLR     R1                      ;CLR HIGH TIME
        MOV     #1,R2                   ;SET TIMEOUT OF ONE TICK
        MOV     #C.SYST,R4              ;SIGNAL INTERNAL REQUEST
        MOV     #200$,C.SUB(R0)         ;SET TIMEOUT ADDRESS
        CALLR   $CLINS                  ;QUEUE A CLOCK PACKET
 
200$:   MOV     C.TCB(R4),R5            ;RECOVER UCB ADDR
        BR      TXTRN                   ;CHECK ACTIVE AGAIN
 
210$:   BIC     #RTS,(R2)               ;CLEAR REQUEST TO SEND
 
220$:                                   ;REFERENCE LABEL
 
        .IFF
 
        JMP     SUCC                    ;FINISH I/O
 
        .IFT
 
        BIS     #ERRIE,(R2)             ;ENABLE ERROR INTERRUPTS FOR RECVR
DQTXDN: MOV     S.PKT(R4),R1            ;GET ADDRESS OF PACKET TO FINISH
        CALL    @U.PHDR(R5)             ;CALL CO-ROUTINE FOR FINISH
        CALLR   DQINIT                  ;TRY TO START NEW I/O
 
        .ENDC
 
        .DSABL  LSB

ERROR:                                  ;;;REFERENCE LABEL
 
        .IF NDF M$$NET
 
        TST     -(R4)                   ;;;POINT TO RXCSR
        BIC     #RXDIS,(R4)+            ;;;DISABLE RECEIVER
        BIC     #TXDISH,(R4)+           ;;;DISABLE TRANSMITTER
        CALL    $FORK                   ;;;GO TO FORK LEVEL
RBCERR: MOV     (R4),R0                 ;;;GET ERROR BITS IN R0
        CLRB    (R4)                    ;;;CLR ERROR BITS IN DEVICE
        BIT     #TXCLK!TXLAT!RXCLK!RXLAT,R0  ;;;CLOCK OR LATENCY ERROR?
        BEQ     10$                     ;;;BR IF NOT
        MOV     #IE.DAO&377,R0          ;;;SIGNAL DATA OVERRUN ERROR
        BR      30$                     ;;;CONTINUE
 
10$:    BIT     #RXNEX!TXNEX,R0         ;;;NON EXISTENT MEMORY ERROR?
        BEQ     20$                     ;;;BR IF NOT
        MOV     #IE.SPC&377,R0          ;;;SIGNAL SPACE ERROR
        BR      30$                     ;;;CONTINUE
 
20$:    MOV     #IE.BCC&377,R0          ;;;MUST BE BCC ERROR
30$:    MOV     U.SCB(R5),R4            ;;;GET SCB ADDR FOR I/O DONE
        CALLR   UNSUCC                  ;;;FINISH I/O
 
        .IFF
 
        BIC     #ERRIE,(R4)+            ;;;DISABLE ERROR INTERRUPTS
        BIT     #TXERR,(R4)             ;;;WAS IT TRANSMIT ERROR?
        BEQ     40$                     ;;;BR IF RECEIVE ERROR
        BIC     #TXERR,(R4)             ;;;CLR TX ERROR BITS
        BIC     #TXDISF,-(R4)           ;;;DISABLE TRANSMITTER
        CALL    $FORK                   ;;;GO TO FORK LEVEL
        BR      TXTRN                   ;FINISH OF TRANSMIT
 
40$:    CMP     -(R4),-(R4)             ;;;POINT TO RX CSR
        BR      RXENT                   ;;;FINISH OFF RECEIVE
 
        .ENDC

;
;DQSET - SET UP REGISTER R4 WITH RXCSR ADDR, R5 WITH
;       UCB ADDR. UNIT NUMBER IN LOW ORDER 4 BITS OF UNIT
 
DQSET:
        TST     R5                      ;;;CHECK FOR UCB ADDRESS
        BEQ     10$                     ;;;NO UNIT, EXIT INTR
        BIT     #U2.ONL,U.CW2(R5)       ;;;UNIT ONLINE?
        BEQ     10$                     ;;;DISMIS IF NOT
        MOV     U.SCB(R5),R4            ;;;GET SCB ADDR
        MOV     S.CSR(R4),R4            ;;;NOW GET RXCSR ADDR
        RETURN                          ;;;RETURN
 
10$:    TST     (SP)+                   ;;;CLEAR STACK
DQEXIT: JMP     $INTXT                  ;;;DISMISS INTERRUPT

;
; RECEIVE INTERRUPT ROUTINE
;
 
        .ENABL  LSB
 
$XQINP::
        INTSV$  XQ,PR5,D$$Q11           ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DQSET                   ;;;R4=RXCSR, R5=UCB ADDR
        BIT     #RXDNP!RXDNS,(R4)       ;;;DID BUFFER COMPLETE?
        BEQ     DQEXIT                  ;;;BR IF NOT
 
 
        .IF NDF M$$NET
 
        BIC     #RXDIS,(R4)+            ;;;DISABLE RECEIVER
        BIC     #ERRIE,(R4)+            ;DISABLE ERROR INTERRUPTS
        CALL    $FORK                   ;;;GO TO FORK LEVEL
        BIC     #RXCLK,(R4)             ;CLR RECEIVE CLOCK ERROR
        BIT     #BCCERR,(R4)            ;WAS THERE A BCC ERROR?
        BNE     RBCERR                  ;BR IF YES
        MOV     U.SCB(R5),R4            ;GET SCB ADDR FOR I/O DONE
        JMP     SUCC                    ;FINISH SUCCESSFUL I/O
 
        .IFF
 
        BIC     #RXCLK,4(R4)            ;;;CLR SPURIOUS CLK ERROR
RXENT:  MOV     R3,-(SP)                ;;;SAVE R3 THROUGH R0
        MOV     R2,-(SP)
        MOV     R1,-(SP)
        MOV     R0,-(SP)
        MOV     R4,R2                   ;;;PUT RXCSR IN R2
        CLR     R0                      ;;;ASSUME NO DEVICE PROBLEMS
        CLR     R1                      ;;;RETURN GOOD CRC
        BIC     #RXDIS,(R2)             ;;;CLR DONE AND ENABLE BITS
        BIT     #RXACT,(R2)             ;;;DID BOTH BUFFERS FINISH?
        BEQ     2$                      ;;;RETURN DEVICE ERROR IF YES
        BIT     #RXERR,4(R2)            ;;;ANY ERRORS?
        BEQ     10$                     ;;;COMPLETE SUCCESSFUL IF NOT
 
        .IF DF  Q$$CRC
 
        BIT     #BCCERR,4(R2)           ;;;WAS IT A CRC ERROR?
        BEQ     2$                      ;;;RETURN DEVICE ERROR IF NOT
        MOV     R5,R1                   ;;;RETURN BAD CRC (NOT = 0)
        BR      5$                      ;;;FINISH OFF ERROR PATH
 
        .ENDC
 
2$:     MOV     R5,R0                   ;;;RETURN DEVICE ERROR
5$:     BIC     #RXGO!RXDIS,(R2)        ;;;SHUT DOWN DEVICE
        BIC     #RXERR,4(R2)            ;;;CLEAR ERROR BITS
10$:    CALL    @U.SVC(R5)              ;;;CALL RECEIVE CO-ROUTINE
        BCS     25$                     ;;;BR IF NOTHING TO DO
        BMI     33$                     ;;;BR IF ERROR DETECED BY CO-OP
        ADD     #5,R2                   ;;;POINT TO ERR/REG HIGH BYTE
        MOV     R3,-(SP)                ;;;SAVE R3
        CALL    RNEXT                   ;;;NEXT RX REGISTER IN R3
        CALL    SETUP                   ;;;SETUP NEXT BUFFER
        BCS     20$                     ;;;DON'T ENABLE IF FAILED
        BIS     #RXDNIE,-5(R2)          ;;;RE-ENABLE INTERRUPTS
20$:    MOV     (SP)+,R3                ;;;RESTORE R3
25$:    RETURN                          ;;;RETURN
 
;+
;***- DQRCV - IS ENTERED TO INITIALIZE DQ FOR UNSOLICITED RECEIVE
;-
 
DQRCV:  CALL    RESYNC                  ;RESYNCH RECEIVER
        ADD     #5,R2                   ;POINT TO ERR/REG HIGH BYTE
        CALL    RNEXT                   ;GET NEXT HARDWARE REGISTER
        CALL    SETUP                   ;SET UP BUFFER
        BCS     30$                     ;BR IF FAILED
        CALL    ROAN                    ;GET ONE AFTER NEXT REGISTER
        CALL    SETUP                   ;SET UP BUFFER
        BCS     30$                     ;BR IF FAILED
        DEC     R2                      ;POINT TO ERR/REG
        BIS     #ERRIE,-(R2)            ;ENABLE ERRROR INTERRUPTS
        BIS     #RXGO!RXDNIE,-(R2)      ;START RECEIVER
30$:    RETURN                          ;RETURN
 
;+
; ***- RESYNC - IS ENTERED WHEN THE RECEIVER NEEDS TO BE RESYNCED
; OR INITIALIZED FOR A RECEIVE FROM A DEAD START.  THE HARDWARE IS
; INITIALIZED, AND ANY PENDING RECEIVE FORK PROCESSES ARE NO-OPED.
;
;       INPUTS:
;               R5=UCB ADDRESS
;
;       OUTPUTS:
;               R2=POINTER TO DQ RXCSR
;               R0,R1,R4,R5 ARE PRESERVED
;-
 
RESYNC: MOV     U.SCB(R5),R2            ;PUT SCB ADDR IN R2
        MOV     S.CSR(R2),R2            ;PUT CSR ADDR INTO R2
33$:    BIC     #RXGO!RXDIS!RXACT,(R2)  ;STOP RECEIVER
        BIC     #RXERR,4(R2)            ;DONT ALLOW ANY RX ERROR INTERRUPTS
        RETURN
 
;+
; ***- SETUP - IS CALLED TO SET UP THE DEVICE WITH THE NEXT RECEIVE
; BUFFER WHICH IS IN EITHER V.CIAD OR V.CSAD IN THE VCB.  IF THE
; BUFFER ADDRESS IS IN V.CIAD, THEN THE CRC ACCUMULATOR IS STARTED
; WITH THIS BUFFER. IF THE BUFFER IS IN V.CSAD, THE COUNT IS REDUCED
; BY TWO SINCE THE CRC WILL BE RECEVED AT THE END OF THE DATA FOR
; THIS BUFFER.
;
;       INPUTS:
;               R2 = POINTER TO ERR/REG HIGH BYTE
;               R3 = HARDWARE ADDRESS OF NEXT BUFFER IN DQ
;               R4 = VCB ADDRESS
;       OUTPUTS:
;               C BIT CLEAR IF DQ LOADED SUCCESSFULLY
;               C BIT SET IF NO BUFFER WAS FOUND
;               R1,R3 DESTROYED
;-
 
SETUP:  MOVB    (R2),-(SP)              ;;;SAVE OLD REGISTER POINTER
        MOV     R4,R1                   ;;;COPY VCB ADDRESS
        ADD     #V.CIAD,R1              ;;;POINT TO 1ST BUFFER ADDR
 
        .IF DF  Q$$CRC
 
        MOV     #CCRG!TENTR!TEXIT,-(SP) ;;;ASSUME START CRC
 
        .IFTF
 
        TST     (R1)                    ;;;USE 1ST BUFFER?
        BNE     40$                     ;;;BR IF THERE
        ADD     #V.CSAD-V.CIAD,R1       ;;;POINT TO 2ND BUFFER
 
        .IFT
 
        MOV     #CCRG!WRTEN,(SP)        ;;;CONTINUE CRC
 
        .IFTF
 
        TST     (R1)                    ;;;BUFFER HERE?
        BNE     40$                     ;;;USE IT IF YES
35$:    BIC     #RXGO!RXDIS,-5(R2)      ;;;ERROR, DISABLE RECEIVER
        BICB    #RXERR,-(R2)            ;;;CLR RX ERROR BITS
 
        .IFT
 
        TST     (SP)+                   ;;;CLEAN STACK
 
        .IFTF
 
        SEC                             ;;;SET C BIT
        BR      60$                     ;;;RESTORE POINTER AND RETURN
 
40$:    BIS     #WRTEN,R3               ;;;CLR MEMORY EXTENSION BITS
        MOVB    R3,(R2)+                ;;;SETUP SECONDARY REGISTER
        MOV     (R1),(R2)               ;;;BUFFER ADDRES INTO DQ
        CLR     (R1)+                   ;;;CLEAR OUT ADDRESS
 
        .IFT
 
        BIS     (SP)+,R3                ;;;OR IN COUNT REG AND CONTROL
 
        .IFF
 
        BIS     #CCRG,R3                ;;;SELECT COUNT REGISTER
 
        .ENDC
 
        MOVB    R3,-(R2)                ;;;SETUP SECONDARY REGISTER
        NEG     (R1)                    ;;;COUNT IN 2'S COMPLEMENT
        MOV     (R1),1(R2)              ;;;COUNT INTO DQ
        CLC                             ;;;CLEAR C BIT
60$:    MOVB    (SP)+,(R2)              ;;;RESTORE OLD REGISTER POINTER
        RETURN                          ;;;RETURN
 
        .ENDC
 
        .DSABL  LSB
 
        .END
        .TITLE XUDRV
        .IDENT  /14/
 
;
; COPYRIGHT (C) 1974, 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 13
;
; J. M. GILBERT, 31-JAN-74
;
; PREVIOUSLY MODIFIED BY:
;
;       J. M. GILBERT
;       L. GILLESPIE
;       E. D. WALDIN
;
; MODIFIED BY:
;
;       J. H. MATTHEWS 19-OCT-77
;
;               JM001 -- MODIFIED TRANSMIT LINE TO IDLE WITH MARK
;                        INSTEAD OF SYNC.
;
; DU11 SYNCHRONOUS COMMUNICATIONS DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  PKTDF$,HWDDF$
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        .MCALL  UCBDF$,CUCDF$
        UCBDF$                  ; DEFINE UCB OFFSETS
        CUCDF$                  ;COMMUNICATIONS UCB LABELS
 
 
        .IF DF  M$$NET
 
        .MCALL  F11DF$,CVCDF$
        F11DF$                  ;DEFINE FILES OFFSETS
        CVCDF$                  ;COMMUNICATIONS VCB LABELS
 
        .ENDC
 
 

 
;
; CONFIGURATION DEPENDENT PARAMETERS
;
 
        .IIF NDF M$$NET, SOLRCV= 0 ;GENERATE SOLICITED RECEIVE
 
 
;
; EQUATED SYMBOLS
;
 
;
; RXCSR BIT ASSIGNMENTS
;
 
DTSTCH= 100000                  ;DATA SET CHANGE
RING=    40000                  ;RING LINE ASSERTED
CTS=     20000                  ;CLEAR TO SEND
CRRIER=  10000                  ;CARRIER STATE
RECACT=   4000                  ;RECEIVER ACTIVE
DSRDY=    1000                  ;DATA SET READY
STRSYN=    400                  ;STRIP SYNC
RXDONE=    200                  ;RECEIVER DONE
RCVENB=    100                  ;RECEIVER INTERRUPT ENABLE
DSINTE=     40                  ;DATA SET CHANGE INTERRUPT ENABLE
SCHSYN=     20                  ;SEARCH SYNC MODE BIT
RTS=         4                  ;REQUEST TO SEND
TRMRDY=      2                  ;DATA TERMINAL READY
 
;
; RXDBUF BIT ASSIGNMENTS
;
 
RXERR=  100000                  ;RECEIVER ERROR "OR" BIT
OVRNER=  40000                  ;RECEIVER OVERRUN ERROR IF SET
 
;
; PARCSR INITIALIZATION VALUES
;
 
INTSYN=  30000                  ;INTERNAL SYNC MODE PATTERN
WRDLEN=   6000                  ;WORD LENGTH (8 BITS STANDARD)
PARENB=      0                  ;NO PARITY CHECKING
PARSEN=      0                  ;PARITY SENSE (DEPENDS ON PARENB)
INITMD= INTSYN!WRDLEN!PARENB!PARSEN ;ALL INITIALIZATION PARAMETERS
 
;
; TXCSR BIT ASSIGNMENTS
;
 
DNAINT= 100000                  ;SET ON DATA NOT AVAILABLE INTERRUPT
MSTRST=    400                  ;MASTER DEVICE RESET
TXDONE=    200                  ;TRANSMITTER DONE BIT
TXINTE=    100                  ;TRANSMITTER INTERRUPT ENABLE BIT
DNAEN=      40                  ;ENABLE DATA NOT AVAILABLE INTERRUPT
SEND=       20                  ;TRANSMITTER ENABLE (GO) BIT
HDPX=       10                  ;HALF DUPLEX IF SET
 
;
; LOCAL DATA
;
;
; UNIT IMPURE DATA TABLE (INDEXED BY UNIT, POINTS TO UCB)
;
 
CNTBL:                          ;REF LABEL
UNITBL:                         ;UCB ADDRESS TABLE
        .REPT   D$$U11          ;ONE ENTRY PER UNIT
        .WORD   0
        .ENDM
 
        .IF GT  D$$U11-1
 
TEMP:                           ;REF LABEL
UNIT:   .BLKW   1               ;TEMPORARY STORAGE FOR UNIT NUMBER
 
        .ENDC
 
        
        .ENABL  LSB
 
;
; DRIVER DISPATCH TABLE
;
 
$XUTBL::.WORD   DUINIT          ;DEVICE INITIALIZATION
        .WORD   DUCANC          ;DEVICE I/O CANCELLATION
        .WORD   DUTMO           ;TIMEOUT ENTRY POINT
        .WORD   DUPWRF          ;POWER FAIL ROUTINE
 
 
        .IF DF  M$$NET
 
        .WORD   DURCV           ;UNSOLICITED RECEIVE ENTRY
        .WORD   DURXER          ;RECEIVER ERROR SERVICE
 
        .IFF
 
        .WORD   180$            ;CODE NOT GENERATED IF NOT NETWORK
        .WORD   180$            ;JUST RETURN
 
        .ENDC
 
 
 

;+
;**-  DUINIT - DU-11 SYNCHRONOUS COMMUNICATION CONTROLLER I/O INITIATOR
;
; DUINIT IS ENTERED WHEN AN I/O REQUEST IS QUEUED ON THE DEVICE,
; AND AT THE END OF EACH QIO REQUEST WHICH OBEYS THE
; NORMAL RSX-11M INPUT/OUTPUT LOGIC FLOW.  IF THE DEVICE IS
; AVAILABLE AND A REQUEST IS IN THE QUEUE FOR THAT UNIT,
; THE REQUEST IS INITIATED.
; IF NO REQUEST EXISTS FOR THAT UNIT OR IF IT IS
; BUSY, AN EXIT IS TAKEN TO THE CALLER.  NOTE  THAT BECAUSE OF
; THE NATURE OF THE DU-11, EACH UNIT IS A CONTROLLER ITSELF,
; HAS ITS OWN SCB, AND THEREFORE ITS OWN QUEUE.
; EACH TIME DUINIT IS CALLED, IT IS CALLED TO SERVICE ONLY
; THE UNIT SPECIFIED IN THE CALL.
;
; INPUTS:
;
;       R4 = STATUS CONTROL BLOCK ADDRESS
;       R5 = ADDRESS OF THE UCB TO BE INITIATED.
;
; OUTPUTS:
;
;       IF A REQUEST IS SUCCESSFULLY DEQUEUED, THE
;       DEVICE IS INITIATED APPROPRIATELY.
;-
 
DUINIT: TSTB    U.CW2(R5)       ;UNSOLICITED (HDPX) RECEIVE ACTIVE?
        BPL     10$             ;IF NOT, PROCEED
        JMP     180$            ;ACTIVATE NO NEW OPERATION
 
10$:    CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCC     20$             ;IF CC, SOMETHING TO DO
        JMP     180$            ;NO REQUEST OR UNIT BUSY
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1 = ADDRESS OF THE I/O REQUEST PACKET.
;       R2 = PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3 = CONTROLLER INDEX
;       R4 = ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5 = ADDRESS OF THE UCB SPECIFIED IN THE
;            DUINIT CALL.

;
; DU11 I/O REQUEST PACKET FORMAT
;
;       WORD         CONTENT
;
;         0     I/O QUEUE THREAD WORD
;         1     REQUEST PRIORITY, EVENT FLAG NUMBER
;         2     ADDRESS OF THE TCB OF THE REQUESTER TASK
;         3     POINTER TO SECOND LUN WORD IN TASK HEADER
;         4     CONTENTS OF FIRST LUN WORD (UCB)
;         5     I/O FUNCTION CODE
;         6     VIRTUAL ADDRESS OF I/O STATUS BLOCK
;         7     RELOCATION BIAS OF I/O STATUS BLOCK
;        10     I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000)
;        11     VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;        12     RELOCATION BIAS OF I/O BUFFER
;        13     BUFFER ADDRESS FOR TRANSFER
;        14     TOTAL BYTE COUNT TO TRANSFER
;        15     BYTE COUNT FOR SECOND PART OF TRANSMISSION OR 0
;        16     NOT USED
;        17     NOT USED
;        20     NOT USED
;
 
20$:    MOV     S.CSR(R4),R2    ;GET RECEIVER CSR ADDRESS
        ADD     #I.FCN+1,R1     ;POINT TO I/O FUNCTION CODE
        CMPB    #IO.INL/256.,(R1) ;CHECK IF TRANSFER FUNCTION
        BLOS    70$             ;BRANCH ON CONTROL FUNCTION
        BIT     #U2.ONL,U.CW2(R5) ;IS DEVICE ON LINE (INITIALIZED?)
        BEQ     90$             ;CAN'T TRANSFER IF NOT
 
        .IF NDF M$$NET
 
        BIT     #DSRDY,(R2)     ;IS DATA SET READY?
        BEQ     90$             ;IF NOT, CAN'T TRANSFER
 
        .ENDC
 
        CMPB    #IO.RLB/256.,(R1) ;READ LOGICAL?
        BEQ     40$             ;YES, SERVICE READ REQUEST
;
; FALL THROUGH HERE ON TRANSMIT (WRITE LOGICAL)
;
        .IF DF  M$$NET
 
        CALL    @U.PHDR(R5)     ;CALL TX COROUTINE FOR INITIATE
        BIT     #DSRDY,(R2)     ;DATA SET READY SET?
        BEQ     210$            ;CAN'T TX IF NOT
 
        .ENDC
 
        BIS     #RTS,(R2)       ;ASSERT REQUEST TO SEND
        MOVB    U.SYNC(R5),R0   ;LOAD SYNC CHARACTER
        MOVB    S.ITM(R4),S.CTM(R4) ;INITIALIZE TIMEOUT COUNT
        MOVB    U.NSYN(R5),R3   ;NUMBER OF SYNCS IN LEADER
 
 
        .IF DF  M$$NET
 
        BITB    #IO.WNS,-(R1)   ;IS FUNCTION WRITE WITH NO SYNCS?
        BEQ     30$             ;IF NOT, SEND THEM
        BIT     #CTS,(R2)       ;IS CLEAR TO SEND SET?
        BEQ     30$             ;IF EQUAL, SEND SYNCS
        CALL    $GTBYT          ;GET DATA
        MOVB    (SP)+,R0        ;SEND BYTE
        CLR     R3              ;CLEAR SYNC COUNT FOR LEADER
 
        .ENDC
 
 
30$:    MOVB    R3,U.NSYC(R5)   ;LOAD SYNC LEADER COUNT
        ADD     #4,R2           ;POINT TO TRANSMIT CSR
        BIS     #SEND,(R2)+     ;ENABLE TRANSMISSION
        MOVB    R0,(R2)         ;SEND FIRST CHARACTER
        TST     -(R2)           ;CLEAR DATA LATE ERRORS
        BIS     #DNAEN!TXINTE,(R2) ;ENABLE INTERRUPTS
        BR      180$            ;RETURN - INTERRUPT CODE PROPAGATES TRAN
 
;
; RECEIVE FUNCTION INITIATION
;
 
40$:                            ;REFERENCE LABEL
 
 
        .IF DF  SOLRCV
 
        MOV     R5,R0           ;SET UP TRANSFER VECTOR
        ADD     #U.RBUF,R0      ;RECEIVE TRANSFER INFORMATION HERE
        MOV     U.BUF(R5),(R0)+ ;TRANSFER BIAS
        MOV     U.BUF+2(R5),(R0)+ ;AND OFFSET
        MOV     U.CNT(R5),(R0)  ;AND COUNT
        BIC     #SCHSYN,(R2)    ;FORCE RE-SYNCHING
        TSTB    2(R2)           ; ENSURE RECEIVE BUFFER CLEAR
        BIS     #STRSYN!RCVENB!SCHSYN,(R2) ; ENABLE RECEIVER
        BR      180$            ;RETURN - INTERRUPT CODE PROPAGATES RECEIVE
 
        .IFF
 
        BR      130$            ;MARK AS INVALID FUNCTION
 
        .ENDC
 
 
;
; CONTROL FUNCTION INITIATION (INITIATE OR TERMINATE CONTROLLER,
; OR CHANGE OPERATING MODE)
;
 
70$:    BNE     110$            ;IF NOT EQUAL, MODE CHANGE REQUEST
        CMP     (R2)+,(R2)+     ;POINT TO TXCSR
        BIS     #MSTRST,(R2)    ;RESET DEVICE
        TSTB    -(R1)           ;START FUNCTION?
        BNE     100$            ;IF NON-ZERO, TERMINATE
;
; DO START FUNCTION INITIATION
;
        TST     U.CW2(R5)       ;DEVICE TO BE IN HALF DUPLEX?
        BPL     80$             ;NO, IF PLUS
        BIS     #HDPX,(R2)      ;PUT IN HALF DUPLEX MODE
80$:    MOV     #INITMD,R0      ;GET WORD SIZE, SYNC MODE
        BISB    U.SYNC(R5),R0   ;OR IN SYNC CHARACTER
        MOV     R0,-(R2)        ;INITIALIZE DEVICE PARAMETERS
        BIS     #STRSYN!TRMRDY!SCHSYN,-(R2) ;NOW INITIALIZE CONTROLLER
        MOV     R5,UNITBL(R3)   ;INITIALIZE UCB ADDRESS IN UNIT TABLE
        BIS     #U2.ONL,U.CW2(R5) ;MARK UNIT ON LINE
        BR      160$            ;RETURN SUCCESSFUL
 
;
; CAN'T ESTABLISH COMMUNICATIONS
;
 
90$:    MOV     #IE.DNR&377,R0  ;SAY CAN'T INITIALIZE DEVICE (NOT READY)
        BR      170$            ;DO I/O DONE
 
;
; FUNCTION WAS TERMINATE LINE
;
 
100$:   BIC     #^C<U2.LIN!U2.SWC!U2.ACU>,U.CW2(R5) ;CLEAR OPERATING STATUS
        CLR     UNITBL(R3)      ;UNIT TABLE CLEARED OF UCB
        BR      160$            ;RETURN SUCCESSFUL STATUS
 
;
; SERVICE DEVICE MODE CHANGE REQUEST
;
 
110$:   BITB    #IO.HDX,-(R1)   ;SUBFUNCTION SAY HALF DUPLEX?
        BEQ     120$            ;IF ZERO, NO
        BIS     #U2.HDX,U.CW2(R5) ;SAY HALF DUPLEX CHARACTERISTIC
120$:   BITB    #IO.FDX,(R1)    ;SET MODE TO FULL DUPLEX?
        BEQ     150$            ;DON'T SET FULL DUPLEX
        BIT     #U2.LIN,U.CW2(R5) ;IS LINK FULL DUPLEX?
        BEQ     140$            ;IF SO, RUN FULL DUPLEX
130$:   MOV     #IE.IFC&377,R0  ;MARK AS ILLEGAL FUNCTION
        BR      170$            ;AND TERMINATE
 
140$:   BIC     #U2.HDX,U.CW2(R5) ;PUT IN FULL DUPLEX IN UCB
150$:   BITB    #IO.SYN,(R1)    ;SYNC CHARACTER SPECIFIED?
        BEQ     160$            ;NO, IF NOT SET
        MOVB    I.PRM-I.FCN(R1),U.SYNC(R5) ;MARK NEW SYNC CHARACTER
DUSUCC:                         ;REFERENCE LABEL
160$:   MOV     #IS.SUC&377,R0  ;RETURN SUCCESSFUL STATUS
DUFIN:                          ;REFERENCE LABEL
170$:   CLRB    S.STS(R4)       ;CLEAR CONTROLLER STATUS
        BICB    #US.BSY,U.STS(R5) ;MARK UNIT IDLE, ALSO
        MOV     R0,-(SP)        ;SAVE STATUS WORD 1
        MOV     S.PKT(R4),-(SP) ;SAVE OLD PACKET ADDRESS
        CALL    DUINIT          ;INITIATE NEXT PACKET
        MOV     (SP)+,R3        ;GET OLD PACKET ADDRESS
        MOV     I.PRM+4(R3),R1  ;RETURN REQUESTED ITEM COUNT
        MOV     (SP)+,R0        ;RESTORE STATUS WORD 1
        CALLR   $IOFIN          ;TERMINATE OLD PACKET
 
180$:   RETURN                  ;
 
;
; POWER FAIL SERVICE
;
 
DUPWRF:                         ;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        CALLR   DURXER          ;CLEAR RECEIVER,WAIT FOR
                                ;DEVICE TIMEOUT ON TRANSMIT
 
        .IFF
 
        CLRB    S.CTM(R4)       ;DISABLE DEVICE TIMEOUTS
        MOV     #IE.DNR&377,R0  ;PUT ERROR CODE IN R0 FOR DUTMO
        BR      DUTMO           ;FINISH I/O ABORT
 
        .ENDC
 
;
; I/O CANCELLATION SERVICE
;
 
;       INPUTS:
;               R0=I/O PACKET ADDRESS
;               R1=TCB ADDRESS OF TASK TO CANCEL
;               R4=SCB ADDRESS
;               R5=UCB ADDRESS
 
DUCANC:                         ;;;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        RETURN                  ;;;JUST LET TRANSMIT FINISH
 
        .IFF
 
        CMP     R1,I.TCB(R0)    ;;;CANCEL FOR THIS TASK?
        BNE     180$            ;;;JUST RETURN IF NOT
        CMPB    #IO.WLB/256.,I.FCN+1(R0) ;;;TRANSMIT FUNCTION?
        BEQ     180$            ;;;LET TRANSMIT FINISH
        TST     U.RCNT(R5)      ;;;RECEIVER FINISHED?
        BLE     180$            ;;;RETURN IF YES
        BIC     #RCVENB!SCHSYN,@S.CSR(R4) ;DISABLE RECEIVER
        MOV     #IE.ABO&377,R0  ;;;PUT ERROR CODE IN R0 FOR DUTMO
        BR      DUTMO           ;;;FINISH OFF RECEIVE PACKET
 
        .ENDC
 
 
;
; TIMEOUT SERVICE ROUTINE
;
;       INPUTS:
;
;               R0 = DEVICE TIMEOUT STATUS 'IE.DNR'
;               R3 = CONTROLLER INDEX
;               R4 = ADDRESS OF SCB
;               R5 = ADDRESS OF UCB
;
 
DUTMO:                          ;;;REFERENCE LABEL
        MOV     S.CSR(R4),R4    ;GET RECEIVER CSR
        BIC     #TXINTE!SEND!DNAEN,4(R4) ;;;DISABLE TRANSMITTER
        BIC     #RTS,(R4)       ;;;TURN OFF CARRIER
        MTPS    #0              ;;;ALLOW INTERRUPTS
210$:   JMP     DUTXND          ;WAIT FOR SOFTWARE TIMEOUT
 
        .DSABL LSB

 
;
; **- $XUINP - DU-11 INPUT INTERRUPT SERVICE
;
 
$XUINP::                        ;;;REFERENCE LABEL
        INTSV$  XU,PR5,D$$U11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DUSET           ;;;SET CSR IN R4, UCB IN R5
 
        .IF DF  M$$NET
 
        MOV     R3,-(SP)        ;;;SAVE R3 THROUGH R0
        MOV     R2,-(SP)
        MOV     R1,-(SP)
        MOV     R0,-(SP)
        MOV     R4,R2           ;;;COPY RX CSR ADDRESS
        
        .IFTF
 
        BIC     #STRSYN,(R4)+   ;;; EXIT STRIP SYNC MODE
        MOV     (R4),R4         ;;;CONTENTS OF RCV BUFFER IN R4
 
        .IFT
 
        MOV     U.VCB(R5),R3    ;;;GET VCB ADDRESS
        TST     R4              ;;;OVERRUN OCCUR?
        BPL     10$             ;;;BR IF NOT
        INC     V.COVR(R3)      ;;;YES, INCR OVERRUN COUNT
10$:                            ;;;REFERENCE LABEL
 
        .ENDC
 
 
        .IF DF  SOLRCV&M$$MGE
 
        MOV     KISAR6,-(SP)    ;;;SAVE CURRENT MAPPING
        MOV     U.RBUF(R5),KISAR6 ;;;MAP TO USER BUFFER
        MOVB    R4,@U.RBUF+2(R5) ;;;STORE BYTE IN USER BUFFER
        MOV     (SP)+,KISAR6    ;;;RESTORE CURRENT MAPPING
 
 
        .IFF
 
        MOVB    R4,@U.RBUF+2(R5) ;;;STORE BYTE IN USER BUFFER
 
        .IFTF
 
        DEC     U.RCNT(R5)      ;;;SEE IF COUNT SATISFIED
        BEQ     30$             ;;;YES, IF EQUAL
        INC     U.RBUF+2(R5)    ;;;BUMP BYTE ADDRESS
 
        .IFT
 
        BIT     #20000,U.RBUF+2(R5) ;;;OVERFLOWED 4K BOUNDARY?
        BEQ     20$             ;;;NO, IF ZERO
        BIC     #20000,U.RBUF+2(R5) ;;;CLEAR OVERFLOW BIT
        ADD     #200,U.RBUF(R5) ;;;BUMP BIAS
 
        .ENDC
 
        .IF DF  M$$NET
 
        MOV     (SP)+,R0        ;RESTORE R0 THROUGH R3
        MOV     (SP)+,R1
        MOV     (SP)+,R2
        MOV     (SP)+,R3
 
        .ENDC
 
 
20$:    RETURN                  ;;;EXIT FROM INTERRUPT
        
;
; REQUEST SATISFIED
;
 
30$:                            ;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        CLR     R1              ;;;RETURN CRC=0
        ADD     #V.CIAD,R3      ;;;POINT TO 1ST BUF ADDRESS
        MOV     (R3),U.RBUF+2(R5) ;;;TRANS NEXT RCV BUFFER ADDR
        BEQ     40$             ;;;BR IF ADDR NOT THERE
        BIS     #STRSYN,(R2)    ;;;START IN STRIP SYNC MODE
        CLR     U.RCAC(R5)      ;;;START NEW CRC ACCUMULATION
        BR      50$             ;;;CONTINUE
 
40$:    ADD     #V.CSAD-V.CIAD,R3 ;;;POINT TO SECOND BUF ADDR
        MOV     (R3),U.RBUF+2(R5) ;;;TRANS NEXT RCV BUFFER ADDR
        BNE     50$             ;;;BR IF ADDR HERE
        MOV     R2,R0           ;;;REURN BAD ATSTUS
        BR      60$             ;;;CONTINUE
 
50$:    CLR     (R3)+           ;CLR BUFFER ADDR IN VCB
        MOV     (R3),U.RCNT(R5) ;;;TRANSFER COUNT
        CLR     R0              ;;;RETURN GOOD STATUS
60$:    BIC     #RCVENB,(R2)    ;;;DISABLE RECEIVE INTERRUPTS
        MTPS    #PR4            ;;;CREATE WINDOW FOR INTERRUPTS
        CALL    @U.SVC(R5)      ;;;CALL RECEIVE COROUTINE
        BCS     70$             ;;;IF C SET, DON'T DO ANTHING
        BMI     70$             ;;;DON'T ENABLE IF ERROR
        MTPS    #PR5            ;;;RETURN TO PRIORITY OF DEVICE
        BIS     #RCVENB,(R2)    ;;;RE-ENABLE RECEIVER
70$:    RETURN                  ;;;RETURN TO CO-ROUTINE
 
        .IFF
 
        MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS
        BIC     #RCVENB,@S.CSR(R4) ;;;DISABLE RECEIVER
        CALL    $FORK           ;;;GO TO FORK LEVEL
        JMP     DUSUCC          ;COMPLETE SUCCESSFUL I/O
 
        .ENDC

 
;
; **- $XUOUT - TRANSMITTER INTERRUPT SERVICE
;
 
$XUOUT::                        ;;;REFERENCE LABEL
        INTSV$  XU,PR5,D$$U11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DUSET           ;;;SET RECEIVE CSR IN R4, UCB IN R5
        ADD     #4,R4           ;;;POINT TO TX CSR
        TST     (R4)+           ;;;DATA NOT AVAILABLE?
        BPL     10$             ;;;NO, IF NOT SET
 
;
; CHECK DATA LATE
;
 
 
        .IF DF  M$$NET
 
        MOV     R4,-(SP)        ;;;SAVE CSR A MOMENT
        MOV     U.VCB(R5),R4    ;;;GET VCB ADDRESS
 
 
        .IF DF  C$$MPT
 
        MOV     V.CMPL(R4),R4   ;;;IF MULTIPOINT, GET PROPER VCB
 
        .ENDC
 
 
        INC     V.CDLE(R4)      ;;;BUMP DATA LATE ERROR
        MOV     (SP)+,R4        ;;;RESTORE CSR TO R4
 
        .ENDC
 
 
        TSTB    -2(R4)          ;;;TRANSMITTER DONE SET?
        BPL     60$             ;;;IF NOT, DISMISS INTERRUPT
10$:    BIT     #CTS,-6(R4)     ;;;CLEAR TO SEND SET?
        BEQ     20$             ;;;IF NOT, SEND A SYNC
        TSTB    U.NSYC(R5)      ;;;SYNC COUNT ZERO?
        BEQ     30$             ;;;IF YES, TRANSMIT DATA
        DECB    U.NSYC(R5)      ;;;DECREMENT SYNC LEADER COUNT
        BLE     30$             ;;;IF LE, TRANSMIT DATA
20$:    MOVB    U.SYNC(R5),(R4) ;;;SEND A SYNC CHARACTER
        BR      50$             ;;;EXIT
 
 
;
; SET UP AND TRANSMIT A BYTE
;
30$:    DEC     U.CNT(R5)       ;;;CHECK COUNT (0 NOT VALID)
        BGE     40$             ;;;IF NOT, CONTINUE
        TST     U.CW2(R5)       ;;;IN HALF DUPLEX?
        BPL     80$             ;;;IF NOT, NO TURNAROUND
 
        .IF DF  M$$NET
 
        TSTB    U.CW2(R5)       ;;;RECEIVER TO BECOME ACTIVE?
        BPL     80$             ;;;DON'T TURN LINE AROUND IF NOT
 
        .IFTF
 
        CMP     #-3,U.CNT(R5)   ;;;SENT TWO MARKS?
        BGE     70$             ;;;IF SO, TURN LINE AROUND
        MOVB    #-1,(R4)        ;;;OUTPUT A MARK
        BR      50$             ;;;DISMISS INTERRUPT
 
40$:    CALL    $GTBYT          ;;;GET NEXT BYTE FROM BUFFER
        MOVB    (SP)+,(R4)      ;;;OUTPUT CHARACTER
50$:    MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS BACK
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET TIMEOUT COUNT
60$:    BR      DUSXT           ;;;EXIT FROM INTERRUPT
 
70$:    BIC     #SEND,-(R4)     ;;;DON'T IDLE SYNC
        TST     -(R4)           ;;;CLEAR RECEIVE DONE AND ERROR
        BIC     #SCHSYN!RTS,-(R4) ;;;TURN OFF CARRIER
 
        .IFT
 
        BIS     #RCVENB!SCHSYN,(R4) ;;;RE-ENABLE RECEIVER INTERRUPTS
 
        .IFF
 
        BIS     #SCHSYN,(R4)    ;;;FORCE RESYNCHIBNG
 
        .IFTF
 
        ADD     #6,R4           ;;;POINT TO TRANSMIT BUFFER
80$:    BIC     #TXINTE!DNAEN!SEND,-(R4) ;;;DISABLE TRANSMITTER
        CALL    $FORK           ;;;CREATE SYSTEM PROCESS
 
        .IFF
 
        MOV     #IS.SUC&377,R0  ;RETURN SUCCESSFUL STATUS
 
        .IFTF
 
DUTXND:                         ;REFERENCE LABEL
 
        .IFT
 
        MOV     U.SCB(R5),R4    ;GET DEVICE SCB
        MOV     S.PKT(R4),R1    ;PACKET ADDRESS IN R1 FOR CO-ROUTINE
        CALL    @U.PHDR(R5)     ;CALL CO-ROUTINE TO FINISH PACKET
90$:    JMP     DUINIT          ;SEE IF MORE TO DO
 
        .IFF
 
        MOV     U.SCB(R5),R4    ;RESTORE SCB TO R4
        JMP     DUFIN           ;MARK COMPLETION
        
        .ENDC
 

 
 
        .IF DF  M$$NET
 
;
; RECEIVER ERROR DETECTED WHICH REQUIRES RESYNCHING OF CONTROLLER
;
; INPUT:
;
;       R5 = UCB ADDRESS
;
; OUTPUT:
;       INITIATES ATTEMPTED RESYNCHING OF DEVICE
;       DESTROYS R2
;
 
DURXER: MOV     U.SCB(R5),R2    ; GET SCB ADDRESS
        MOV     S.CSR(R2),R2    ;GET RX CSR IN R2
        BIC     #SCHSYN!RCVENB,(R2) ; CLEAR RECEIVER
        BIS     #STRSYN!SCHSYN,(R2) ; ATTEMPT TO RE-SYNCH RECEIVER
        RETURN                  ;AND EXIT
 
;
;
; UNSOLICITED RECEIVE INITIALIZATION
; ACTIVATES CONTROLLER TO BE READY TO ACCEPT DATA,
; AND TO SATISFY COUNT INTO BUFFER ADDRESS ALREADY SET
; UP IN UNIT CONTROL BLOCK.  CODE AT 10$ ENTERED EACH
; TIME A REQUEST IS SATISFIED.
;
; INPUTS:
;
;       R5 = UCB ADDRESS
;
; OUTPUTS:
;
;       R0,R1 PRESERVED
;       R5 = UCB ADDRESS
;
 
DURCV:  CALL    DURXER          ;RESYNC DEVICE
        CLR     U.RCAC(R5)      ;START NEW CRC ACCUMLATION
        MOV     R4,R3           ;COPY VCB ADDR
        ADD     #V.CIAD,R3      ;POINT TO 1ST RECV BUFFER
        MOV     (R3),U.RBUF+2(R5) ;TRANSFER RCV BUFFER ADDR
        CLR     (R3)+           ;CLR BUFFER ADDR IN VCB
        MOV     (R3),U.RCNT(R5) ;TRANSFER RECEIVE COUNT
        BIS     #STRSYN!RCVENB,(R2) ;START IN STRIP SYNC
        RETURN                  ;RETURN TO CALLER
 
        .ENDC
 
 
 

;
; DUSET - SET UP REGISTER R4 WITH CSR ADDRESS, R5 WITH
;       UCB ADDRESS.  UNIT NUMBER IN LOW ORDER 4 BITS OF UNIT.
;
 
 
 
DUSET:                          ;;;REFERENCE LABEL
        TST     R5              ;;;TEST FOR VALID UCB ADDRESS
        BEQ     10$             ;;;IF NO UCB, TROUBLE
        BIT     #U2.ONL,U.CW2(R5) ;;;UNIT ON LINE?
        BEQ     10$             ;;;IF NOT ON LINE, CAN'T TRANSFER
        MOV     U.SCB(R5),R4    ;;;FIRST GET SCB ADDRESS
        MOV     S.CSR(R4),R4    ;;;NOW DEVICE CSR ADDRESS
        RETURN                  ;;;AND NOW RETURN
 
10$:    TST     (SP)+           ;;;CLEAR STACK OF RETURN ADDRESS
DUSXT:  JMP     $INTXT          ;;;DISMISS INTERRUPT
 
        .END
        .TITLE XWDRV
        .IDENT  /01/
 
;
; COPYRIGHT (C) 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
; OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 01
;
; SCOTT G. DAVIS        21-JUL-76
;
; DUE ALMOST ENTIRELY TO XUDRV
;
;
; DUP11 SYNCHRONOUS COMMUNICATIONS DRIVER
;
; MACRO LIBRARY CALLS
;
 
        .MCALL  PKTDF$,HWDDF$
        PKTDF$                  ;DEFINE I/O PACKET OFFSETS
        HWDDF$                  ;DEFINE HARDWARE REGISTERS
        .MCALL  UCBDF$,CUCDF$
        UCBDF$                  ; DEFINE UCB OFFSETS
        CUCDF$                  ;COMMUNICATIONS UCB LABELS
 
 
        .IF DF  M$$NET
 
        .MCALL  F11DF$,CVCDF$
        F11DF$                  ;DEFINE FILES OFFSETS
        CVCDF$                  ;COMMUNICATIONS VCB LABELS
 
        .ENDC
 
 

 
;
; CONFIGURATION DEPENDENT PARAMETERS
;
 
        .IIF NDF M$$NET, SOLRCV= 0 ;GENERATE SOLICITED RECEIVE
 
 
;
; EQUATED SYMBOLS
;
 
;
; RXCSR BIT ASSIGNMENTS
;
 
DTSTCH= 100000                  ;DATA SET CHANGE
RING=    40000                  ;RING LINE ASSERTED
CTS=     20000                  ;CLEAR TO SEND
CRRIER=  10000                  ;CARRIER STATE
RECACT=   4000                  ;RECEIVER ACTIVE
DSRDY=    1000                  ;DATA SET READY
STRSYN=    400                  ;STRIP SYNC
RXDONE=    200                  ;RECEIVER DONE
RCVENB=    100                  ;RECEIVER INTERRUPT ENABLE
DSINTE=     40                  ;DATA SET CHANGE INTERRUPT ENABLE
SCHSYN=     20                  ;SEARCH SYNC MODE BIT
RTS=         4                  ;REQUEST TO SEND
TRMRDY=      2                  ;DATA TERMINAL READY
 
;
; RXDBUF BIT ASSIGNMENTS
;
 
RXERR=  100000                  ;RECEIVER ERROR "OR" BIT
OVRNER=  40000                  ;RECEIVER OVERRUN ERROR IF SET
 
;
; PARCSR INITIALIZATION VALUES
;
 
DECMOD= 100000                  ;SET DDCMP/BISYNCH MODE
CRCINH=1000                     ;INHIBIT CRC CALCULATION
INITMD=DECMOD!CRCINH            ;PARAMETER INITIALIZATION BITS
 
;
 
TSOM=400                        ;TRANSFER - START OF MESSAGE
 
;
;
; TXCSR BIT ASSIGNMENTS
;
 
DNAINT= 100000                  ;SET ON DATA NOT AVAILABLE INTERRUPT
MSTRST=    400                  ;MASTER DEVICE RESET
TXDONE=    200                  ;TRANSMITTER DONE BIT
TXINTE=    100                  ;TRANSMITTER INTERRUPT ENABLE BIT
DNAEN=      40                  ;ENABLE DATA NOT AVAILABLE INTERRUPT
SEND=       20                  ;TRANSMITTER ENABLE (GO) BIT
HDPX=       10                  ;HALF DUPLEX IF SET
 
;
; LOCAL DATA
;
;
; UNIT IMPURE DATA TABLE (INDEXED BY UNIT, POINTS TO UCB)
;
 
CNTBL:                          ;REF LABEL
UNITBL:                         ;UCB ADDRESS TABLE
        .REPT   D$$W11          ;ONE ENTRY PER UNIT
        .WORD   0
        .ENDM
 
        .IF GT  D$$W11-1
 
TEMP:                           ;REF LABEL
UNIT:   .BLKW   1               ;TEMPORARY STORAGE FOR UNIT NUMBER
 
        .ENDC
 
        .ENABL  LSB
 
;
; DRIVER DISPATCH TABLE
;
 
$XWTBL::.WORD   DWINIT          ;DEVICE INITIALIZATION
        .WORD   DWCANC          ;DEVICE I/O CANCELLATION
        .WORD   DWTMO           ;TIMEOUT ENTRY POINT
        .WORD   DUPWRF          ;POWER FAIL ROUTINE
 
 
        .IF DF  M$$NET
 
        .WORD   DWRCV           ;UNSOLICITED RECEIVE ENTRY
        .WORD   DWRXER          ;RECEIVER ERROR SERVICE
 
        .IFF
 
        .WORD   180$            ;CODE NOT GENERATED IF NOT NETWORK
        .WORD   180$            ;JUST RETURN
 
        .ENDC
 
 
 

;+
;**-  DWINIT - DUP-11 SYNCHRONOUS COMMUNICATION CONTROLLER I/O INITIATOR
;
; DWINIT IS ENTERED WHEN AN I/O REQUEST IS QUEUED ON THE DEVICE,
; AND AT THE END OF EACH QIO REQUEST WHICH OBEYS THE
; NORMAL RSX-11M INPUT/OUTPUT LOGIC FLOW.  IF THE DEVICE IS
; AVAILABLE AND A REQUEST IS IN THE QUEUE FOR THAT UNIT,
; THE REQUEST IS INITIATED.
; IF NO REQUEST EXISTS FOR THAT UNIT OR IF IT IS
; BUSY, AN EXIT IS TAKEN TO THE CALLER.  NOTE  THAT BECAUSE OF
; THE NATURE OF THE DUP-11, EACH UNIT IS A CONTROLLER ITSELF,
; HAS ITS OWN SCB, AND THEREFORE ITS OWN QUEUE.
; EACH TIME DWINIT IS CALLED, IT IS CALLED TO SERVICE ONLY
; THE UNIT SPECIFIED IN THE CALL.
;
; INPUTS:
;
;       R4 = STATUS CONTROL BLOCK ADDRESS
;       R5 = ADDRESS OF THE UCB TO BE INITIATED.
;
; OUTPUTS:
;
;       IF A REQUEST IS SUCCESSFULLY DEQUEUED, THE
;       DEVICE IS INITIATED APPROPRIATELY.
;-
 
DWINIT: TSTB    U.CW2(R5)       ;UNSOLICITED (HDPX) RECEIVE ACTIVE?
        BPL     10$             ;IF NOT, PROCEED
        JMP     180$            ;ACTIVATE NO NEW OPERATION
 
10$:    CALL    $GTPKT          ;GET AN I/O PACKET TO PROCESS
        BCC     20$             ;IF CC, SOMETHING TO DO
        JMP     180$            ;NO REQUEST OR UNIT BUSY
;
; THE FOLLOWING ARGUMENTS ARE RETURNED BY $GTPKT:
;
;       R1 = ADDRESS OF THE I/O REQUEST PACKET.
;       R2 = PHYSICAL UNIT NUMBER OF THE REQUEST UCB.
;       R3 = CONTROLLER INDEX
;       R4 = ADDRESS OF THE STATUS CONTROL BLOCK.
;       R5 = ADDRESS OF THE UCB SPECIFIED IN THE
;            DWINIT CALL.

;
; DUP11 I/O REQUEST PACKET FORMAT
;
;       WORD         CONTENT
;
;         0     I/O QUEUE THREAD WORD
;         1     REQUEST PRIORITY, EVENT FLAG NUMBER
;         2     ADDRESS OF THE TCB OF THE REQUESTER TASK
;         3     POINTER TO SECOND LUN WORD IN TASK HEADER
;         4     CONTENTS OF FIRST LUN WORD (UCB)
;         5     I/O FUNCTION CODE
;         6     VIRTUAL ADDRESS OF I/O STATUS BLOCK
;         7     RELOCATION BIAS OF I/O STATUS BLOCK
;        10     I/O STATUS BLOCK ADDRESS (REAL OR DISPLACEMENT +140000)
;        11     VIRTUAL ADDRESS OF AST SERVICE ROUTINE
;        12     RELOCATION BIAS OF I/O BUFFER
;        13     BUFFER ADDRESS FOR TRANSFER
;        14     TOTAL BYTE COUNT TO TRANSFER
;        15     BYTE COUNT FOR SECOND PART OF TRANSMISSION OR 0
;        16     NOT USED
;        17     NOT USED
;        20     NOT USED
;
 
20$:    MOV     S.CSR(R4),R2    ;GET RECEIVER CSR ADDRESS
        ADD     #I.FCN+1,R1     ;POINT TO I/O FUNCTION CODE
        CMPB    #IO.INL/256.,(R1) ;CHECK IF TRANSFER FUNCTION
        BLOS    70$             ;BRANCH ON CONTROL FUNCTION
        BIT     #U2.ONL,U.CW2(R5) ;IS DEVICE ON LINE (INITIALIZED?)
        BEQ     90$             ;CAN'T TRANSFER IF NOT
 
        .IF NDF M$$NET
 
        BIT     #DSRDY,(R2)     ;IS DATA SET READY?
        BEQ     90$             ;IF NOT, CAN'T TRANSFER
 
        .ENDC
 
        CMPB    #IO.RLB/256.,(R1) ;READ LOGICAL?
        BEQ     40$             ;YES, SERVICE READ REQUEST
;
; FALL THROUGH HERE ON TRANSMIT (WRITE LOGICAL)
;
        .IF DF  M$$NET
 
        CALL    @U.PHDR(R5)     ;CALL TX COROUTINE FOR INITIATE
        BIT     #DSRDY,(R2)     ;DATA SET READY SET?
        BEQ     210$            ;CAN'T TX IF NOT
 
        .ENDC
 
        BIS     #RTS,(R2)       ;ASSERT REQUEST TO SEND
        MOVB    U.SYNC(R5),R0   ;LOAD SYNC CHARACTER
        MOVB    S.ITM(R4),S.CTM(R4) ;INITIALIZE TIMEOUT COUNT
        MOVB    U.NSYN(R5),R3   ;NUMBER OF SYNCS IN LEADER
 
 
        .IF DF  M$$NET
 
        BITB    #IO.WNS,-(R1)   ;IS FUNCTION WRITE WITH NO SYNCS?
        BEQ     30$             ;IF NOT, SEND THEM
        BIT     #CTS,(R2)       ;IS CLEAR TO SEND SET?
        BEQ     30$             ;IF EQUAL, SEND SYNCS
        CALL    $GTBYT          ;GET DATA
        MOVB    (SP)+,R0        ;SEND BYTE
        CLR     R3              ;CLEAR SYNC COUNT FOR LEADER
 
        .ENDC
 
 
30$:    MOVB    R3,U.NSYC(R5)   ;LOAD SYNC LEADER COUNT
        ADD     #4,R2           ;POINT TO TRANSMIT CSR
        BIS     #SEND,(R2)+     ;ENABLE TRANSMISSION
;
;       *****   NOTE    *****
;
; SINCE TSOM IS SET THROUGHOUT THE TRANSMISSION, DATA LATE
; ERRORS WILL NEVER BE DETECTED.
;
;       *****           *****
;
        BIC     #177400,R0      ;CLEAR HIGH BYTE
        BIS     #TSOM,R0        ;SET TSOM
        MOV     R0,(R2)         ;SEND CHAR+TSOM
        TST     -(R2)           ;CLEAR DATA LATE ERRORS
        BIS     #DNAEN!TXINTE,(R2) ;ENABLE INTERRUPTS
        BR      180$            ;RETURN - INTERRUPT CODE PROPAGATES TRANSMISSION
 
;
; RECEIVE FUNCTION INITIATION
;
 
40$:                            ;REFERENCE LABEL
 
 
        .IF DF  SOLRCV
 
        MOV     R5,R0           ;SET UP TRANSFER VECTOR
        ADD     #U.RBUF,R0      ;RECEIVE TRANSFER INFORMATION HERE
        MOV     U.BUF(R5),(R0)+ ;TRANSFER BIAS
        MOV     U.BUF+2(R5),(R0)+ ;AND OFFSET
        MOV     U.CNT(R5),(R0)  ;AND COUNT
        BIC     #SCHSYN,(R2)    ;FORCE RE-SYNCHING
        TSTB    2(R2)           ; ENSURE RECEIVE BUFFER CLEAR
        BIS     #STRSYN!RCVENB!SCHSYN,(R2) ; ENABLE RECEIVER
        BR      180$            ;RETURN - INTERRUPT CODE PROPAGATES RECEIVE
 
        .IFF
 
        BR      130$            ;MARK AS INVALID FUNCTION
 
        .ENDC
 
 
;
; CONTROL FUNCTION INITIATION (INITIATE OR TERMINATE CONTROLLER,
; OR CHANGE OPERATING MODE)
;
 
70$:    BNE     110$            ;IF NOT EQUAL, MODE CHANGE REQUEST
        CMP     (R2)+,(R2)+     ;POINT TO TXCSR
        BIS     #MSTRST,(R2)    ;RESET DEVICE
        TSTB    -(R1)           ;START FUNCTION?
        BNE     100$            ;IF NON-ZERO, TERMINATE
;
; DO START FUNCTION INITIATION
;
        TST     U.CW2(R5)       ;DEVICE TO BE IN HALF DUPLEX?
        BPL     80$             ;NO, IF PLUS
        BIS     #HDPX,(R2)      ;PUT IN HALF DUPLEX MODE
80$:    MOV     #INITMD,R0      ;GET WORD SIZE, SYNC MODE
        BISB    U.SYNC(R5),R0   ;OR IN SYNC CHARACTER
        MOV     R0,-(R2)        ;INITIALIZE DEVICE PARAMETERS
        BIS     #STRSYN!TRMRDY!SCHSYN,-(R2) ;NOW INITIALIZE CONTROLLER
        MOV     R5,UNITBL(R3)   ;INITIALIZE UCB ADDRESS IN UNIT TABLE
        BIS     #U2.ONL,U.CW2(R5) ;MARK UNIT ON LINE
        BR      160$            ;RETURN SUCCESSFUL
 
;
; CAN'T ESTABLISH COMMUNICATIONS
;
 
90$:    MOV     #IE.DNR&377,R0  ;SAY CAN'T INITIALIZE DEVICE (NOT READY)
        BR      170$            ;DO I/O DONE
 
;
; FUNCTION WAS TERMINATE LINE
;
 
100$:   BIC     #^C<U2.LIN!U2.SWC!U2.ACU>,U.CW2(R5) ;CLEAR OPERATING STATUS
        CLR     UNITBL(R3)      ;UNIT TABLE CLEARED OF UCB
        BR      160$            ;RETURN SUCCESSFUL STATUS
 
;
; SERVICE DEVICE MODE CHANGE REQUEST
;
 
110$:   BITB    #IO.HDX,-(R1)   ;SUBFUNCTION SAY HALF DUPLEX?
        BEQ     120$            ;IF ZERO, NO
        BIS     #U2.HDX,U.CW2(R5) ;SAY HALF DUPLEX CHARACTERISTIC
120$:   BITB    #IO.FDX,(R1)    ;SET MODE TO FULL DUPLEX?
        BEQ     150$            ;DON'T SET FULL DUPLEX
        BIT     #U2.LIN,U.CW2(R5) ;IS LINK FULL DUPLEX?
        BEQ     140$            ;IF SO, RUN FULL DUPLEX
130$:   MOV     #IE.IFC&377,R0  ;MARK AS ILLEGAL FUNCTION
        BR      170$            ;AND TERMINATE
 
140$:   BIC     #U2.HDX,U.CW2(R5) ;PUT IN FULL DUPLEX IN UCB
150$:   BITB    #IO.SYN,(R1)    ;SYNC CHARACTER SPECIFIED?
        BEQ     160$            ;NO, IF NOT SET
        MOVB    I.PRM-I.FCN(R1),U.SYNC(R5) ;MARK NEW SYNC CHARACTER
DWSUCC:                         ;REFERENCE LABEL
160$:   MOV     #IS.SUC&377,R0  ;RETURN SUCCESSFUL STATUS
DWFIN:                          ;REFERENCE LABEL
170$:   CLRB    S.STS(R4)       ;CLEAR CONTROLLER STATUS
        BICB    #US.BSY,U.STS(R5) ;MARK UNIT IDLE, ALSO
        MOV     R0,-(SP)        ;SAVE STATUS WORD 1
        MOV     S.PKT(R4),-(SP) ;SAVE OLD PACKET ADDRESS
        CALL    DWINIT          ;INITIATE NEXT PACKET
        MOV     (SP)+,R3        ;GET OLD PACKET ADDRESS
        MOV     I.PRM+4(R3),R1  ;RETURN REQUESTED ITEM COUNT
        MOV     (SP)+,R0        ;RESTORE STATUS WORD 1
        CALLR   $IOFIN          ;TERMINATE OLD PACKET
 
180$:   RETURN                  ;
 
;
; POWER FAIL SERVICE
;
 
DUPWRF:                         ;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        CALLR   DWRXER          ;CLEAR RECEIVER, WAIT FOR
                                ;DEVICE TIMEOUT ON TRANSMIT
 
        .IFF
 
        CLRB    S.CTM(R4)       ;DISABLE DEVICE TIMEOUTS
        MOV     #IE.DNR&377,R0  ;PUT ERROR CODE IN R0 FOR DWTMO
        BR      DWTMO           ;FINISH I/O ABORT
 
        .ENDC
 
;
; I/O CANCELLATION SERVICE
;
 
;       INPUTS:
;               R0=I/O PACKET ADDRESS
;               R1=TCB ADDRESS OF TASK TO CANCEL
;               R4=SCB ADDRESS
;               R5=UCB ADDRESS
 
DWCANC:                         ;;;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        RETURN                  ;;;JUST LET TRANSMIT FINISH
 
        .IFF
 
        CMP     R1,I.TCB(R0)    ;;;CANCEL FOR THIS TASK?
        BNE     180$            ;;;JUST RETURN IF NOT
        CMPB    #IO.WLB/256.,I.FCN+1(R0) ;;;TRANSMIT FUNCTION?
        BEQ     180$            ;;;LET TRANSMIT FINISH
        TST     U.RCNT(R5)      ;;;RECEIVER FINISHED?
        BLE     180$            ;;;RETURN IF YES
        BIC     #RCVENB!SCHSYN,@S.CSR(R4) ;DISABLE RECEIVER
        MOV     #IE.ABO&377,R0  ;;;PUT ERROR CODE IN R0 FOR DWTMO
        BR      DWTMO           ;;;FINISH OFF RECEIVE PACKET
 
        .ENDC
 
 
;
; TIMEOUT SERVICE ROUTINE
;
;       INPUTS:
;
;               R0 = DEVICE TIMEOUT STATUS 'IE.DNR'
;               R3 = CONTROLLER INDEX
;               R4 = ADDRESS OF SCB
;               R5 = ADDRESS OF UCB
;
 
DWTMO:                          ;;;REFERENCE LABEL
        MOV     S.CSR(R4),R4    ;GET RECEIVER CSR
        BIC     #TXINTE!SEND!DNAEN,4(R4) ;;;DISABLE TRANSMITTER
        BIC     #RTS,(R4)       ;;;TURN OFF CARRIER
        MTPS    #0              ;;;ALLOW INTERRUPTS
210$:   JMP     DWTXND          ;WAIT FOR SOFTWARE TIMEOUT
 
        .DSABL LSB

 
;
; **- $XWINP - DUP-11 INPUT INTERRUPT SERVICE
;
 
$XWINP::                        ;;;REFERENCE LABEL
        INTSV$  XW,PR5,D$$W11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DWSET           ;;;SET CSR IN R4, UCB IN R5
 
        .IF DF  M$$NET
 
        MOV     R3,-(SP)        ;;;SAVE R3 THROUGH R0
        MOV     R2,-(SP)
        MOV     R1,-(SP)
        MOV     R0,-(SP)
        MOV     R4,R2           ;;;COPY RX CSR ADDRESS
 
        .IFTF
 
        BIC     #STRSYN,(R4)+   ;;; EXIT STRIP SYNC MODE
        MOV     (R4),R4         ;;;CONTENTS OF RCV BUFFER IN R4
 
        .IFT
 
        MOV     U.VCB(R5),R3    ;;;GET VCB ADDRESS
        TST     R4              ;;;OVERRUN OCCUR?
        BPL     10$             ;;;BR IF NOT
        INC     V.COVR(R3)      ;;;YES, INCR OVERRUN COUNT
10$:                            ;;;REFERENCE LABEL
 
        .ENDC
 
 
        .IF DF  SOLRCV&M$$MGE
 
        MOV     KISAR6,-(SP)    ;;;SAVE CURRENT MAPPING
        MOV     U.RBUF(R5),KISAR6 ;;;MAP TO USER BUFFER
        MOVB    R4,@U.RBUF+2(R5) ;;;STORE BYTE IN USER BUFFER
        MOV     (SP)+,KISAR6    ;;;RESTORE CURRENT MAPPING
 
 
        .IFF
 
        MOVB    R4,@U.RBUF+2(R5) ;;;STORE BYTE IN USER BUFFER
 
        .IFTF
 
        DEC     U.RCNT(R5)      ;;;SEE IF COUNT SATISFIED
        BEQ     30$             ;;;YES, IF EQUAL
        INC     U.RBUF+2(R5)    ;;;BUMP BYTE ADDRESS
 
        .IFT
 
        BIT     #20000,U.RBUF+2(R5) ;;;OVERFLOWED 4K BOUNDARY?
        BEQ     20$             ;;;NO, IF ZERO
        BIC     #20000,U.RBUF+2(R5) ;;;CLEAR OVERFLOW BIT
        ADD     #200,U.RBUF(R5) ;;;BUMP BIAS
 
        .ENDC
 
        .IF DF  M$$NET
 
        MOV     (SP)+,R0        ;RESTORE R0 THROUGH R3
        MOV     (SP)+,R1
        MOV     (SP)+,R2
        MOV     (SP)+,R3
 
        .ENDC
 
 
20$:    RETURN                  ;;;EXIT FROM INTERRUPT
;
; REQUEST SATISFIED
;
 
30$:                            ;REFERENCE LABEL
 
        .IF DF  M$$NET
 
        CLR     R1              ;;;RETURN CRC=0
        ADD     #V.CIAD,R3      ;;;POINT TO 1ST BUF ADDRESS
        MOV     (R3),U.RBUF+2(R5) ;;;TRANS NEXT RCV BUFFER ADDR
        BEQ     40$             ;;;BR IF ADDR NOT THERE
        BIS     #STRSYN,(R2)    ;;;START IN STRIP SYNC MODE
        CLR     U.RCAC(R5)      ;;;START NEW CRC ACCUMULATION
        BR      50$             ;;;CONTINUE
 
40$:    ADD     #V.CSAD-V.CIAD,R3 ;;;POINT TO SECOND BUF ADDR
        MOV     (R3),U.RBUF+2(R5) ;;;TRANS NEXT RCV BUFFER ADDR
        BNE     50$             ;;;BR IF ADDR HERE
        MOV     R2,R0           ;;;RETURN BAD STATUS
        BR      60$             ;;;CONTINUE
 
50$:    CLR     (R3)+           ;CLR BUFFER ADDR IN VCB
        MOV     (R3),U.RCNT(R5) ;;;TRANSFER COUNT
        CLR     R0              ;;;RETURN GOOD STATUS
60$:    BIC     #RCVENB,(R2)    ;;;DISABLE RECEIVE INTERRUPTS
        MTPS    #PR4            ;;;CREATE WINDOW FOR INTERRUPTS
        CALL    @U.SVC(R5)      ;;;CALL RECEIVE COROUTINE
        BCS     70$             ;;;IF C SET, DON'T DO ANYTHING
        BMI     70$             ;;;DON'T ENABLE IF ERROR
        MTPS    #PR5            ;;;RETURN TO PRIORITY OF DEVICE
        BIS     #RCVENB,(R2)    ;;;RE-ENABLE RECEIVER
70$:    RETURN                  ;;;RETURN TO CO-ROUTINE
 
        .IFF
 
        MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS
        BIC     #RCVENB,@S.CSR(R4) ;;;DISABLE RECEIVER
        CALL    $FORK           ;;;GO TO FORK LEVEL
        JMP     DWSUCC          ;COMPLETE SUCCESSFUL I/O
 
        .ENDC

 
;
; **- $XWOUT - TRANSMITTER INTERRUPT SERVICE
;
 
$XWOUT::                        ;;;REFERENCE LABEL
        INTSV$  XW,PR5,D$$W11   ;;;GENERATE INTERRUPT SAVE CODE
        CALL    DWSET           ;;;SET RECEIVE CSR IN R4, UCB IN R5
        ADD     #4,R4           ;;;POINT TO TX CSR
        TST     (R4)+           ;;;DATA NOT AVAILABLE?
        BPL     10$             ;;;NO, IF NOT SET
 
;
; CHECK DATA LATE
;
 
 
        .IF DF  M$$NET
 
        MOV     R4,-(SP)        ;;;SAVE CSR A MOMENT
        MOV     U.VCB(R5),R4    ;;;GET VCB ADDRESS
 
 
        .IF DF  C$$MPT
 
        MOV     V.CMPL(R4),R4   ;;;IF MULTIPOINT, GET PROPER VCB
 
        .ENDC
 
 
        INC     V.CDLE(R4)      ;;;BUMP DATA LATE ERROR
        MOV     (SP)+,R4        ;;;RESTORE CSR TO R4
 
        .ENDC
 
 
        TSTB    -2(R4)          ;;;TRANSMITTER DONE SET?
        BPL     60$             ;;;IF NOT, DISMISS INTERRUPT
10$:    BIT     #CTS,-6(R4)     ;;;CLEAR TO SEND SET?
        BEQ     20$             ;;;IF NOT, SEND A SYNC
        TSTB    U.NSYC(R5)      ;;;SYNC COUNT ZERO?
        BEQ     30$             ;;;IF YES, TRANSMIT DATA
        DECB    U.NSYC(R5)      ;;;DECREMENT SYNC LEADER COUNT
        BLE     30$             ;;;IF LE, TRANSMIT DATA
20$:    MOVB    U.SYNC(R5),(R4) ;;;SEND A SYNC CHARACTER
        BR      50$             ;;;EXIT
 
 
;
; SET UP AND TRANSMIT A BYTE
;
30$:    DEC     U.CNT(R5)       ;;;CHECK COUNT (0 NOT VALID)
        BGE     40$             ;;;IF NOT, CONTINUE
        TST     U.CW2(R5)       ;;;IN HALF DUPLEX?
        BPL     80$             ;;;IF NOT, NO TURNAROUND
 
        .IF DF  M$$NET
 
        TSTB    U.CW2(R5)       ;;;RECEIVER TO BECOME ACTIVE?
        BPL     80$             ;;;DON'T TURN LINE AROUND IF NOT
 
        .IFTF
 
        CMP     #-3,U.CNT(R5)   ;;;SENT TWO MARKS?
        BGE     70$             ;;;IF SO, TURN LINE AROUND
        MOVB    #-1,(R4)        ;;;OUTPUT A MARK
        BR      50$             ;;;DISMISS INTERRUPT
 
40$:    CALL    $GTBYT          ;;;GET NEXT BYTE FROM BUFFER
        MOVB    (SP)+,(R4)      ;;;OUTPUT CHARACTER
50$:    MOV     U.SCB(R5),R4    ;;;GET SCB ADDRESS BACK
        MOVB    S.ITM(R4),S.CTM(R4) ;;;RESET TIMEOUT COUNT
60$:    BR      DWSXT           ;;;EXIT FROM INTERRUPT
 
70$:    BIC     #SEND,-(R4)     ;;;DON'T IDLE SYNC
        TST     -(R4)           ;;;CLEAR RECEIVE DONE AND ERROR
        BIC     #SCHSYN!RTS,-(R4) ;;;TURN OFF CARRIER
 
        .IFT
 
        BIS     #RCVENB!SCHSYN,(R4) ;;;RE-ENABLE RECEIVER INTERRUPTS
 
        .IFF
 
        BIS     #SCHSYN,(R4)    ;;;FORCE RESYNCHING
 
        .IFTF
 
        ADD     #6,R4           ;;;POINT TO TRANSMIT BUFFER
80$:    BIC     #TXINTE!DNAEN!SEND,-(R4) ;;;DISABLE TRANSMITTER
        CALL    $FORK           ;;;CREATE SYSTEM PROCESS
 
        .IFF
 
        MOV     #IS.SUC&377,R0  ;RETURN SUCCESSFUL STATUS
 
        .IFTF
 
DWTXND:                         ;REFERENCE LABEL
 
        .IFT
 
        MOV     U.SCB(R5),R4    ;GET DEVICE SCB
        MOV     S.PKT(R4),R1    ;PACKET ADDRESS IN R1 FOR CO-ROUTINE
        CALL    @U.PHDR(R5)     ;CALL CO-ROUTINE TO FINISH PACKET
90$:    JMP     DWINIT          ;SEE IF MORE TO DO
 
        .IFF
 
        MOV     U.SCB(R5),R4    ;RESTORE SCB TO R4
        JMP     DWFIN           ;MARK COMPLETION
 
        .ENDC
 

 
 
        .IF DF  M$$NET
 
;
; RECEIVER ERROR DETECTED WHICH REQUIRES RESYNCHING OF CONTROLLER
;
; INPUT:
;
;       R5 = UCB ADDRESS
;
; OUTPUT:
;       INITIATES ATTEMPTED RESYNCHING OF DEVICE
;       DESTROYS R2
;
 
DWRXER: MOV     U.SCB(R5),R2    ; GET SCB ADDRESS
        MOV     S.CSR(R2),R2    ;GET RX CSR IN R2
        BIC     #SCHSYN!RCVENB,(R2) ; CLEAR RECEIVER
        BIS     #STRSYN!SCHSYN,(R2) ; ATTEMPT TO RE-SYNCH RECEIVER
        RETURN                  ;AND EXIT
 
;
;
; UNSOLICITED RECEIVE INITIALIZATION
; ACTIVATES CONTROLLER TO BE READY TO ACCEPT DATA,
; AND TO SATISFY COUNT INTO BUFFER ADDRESS ALREADY SET
; UP IN UNIT CONTROL BLOCK.  CODE AT 10$ ENTERED EACH
; TIME A REQUEST IS SATISFIED.
;
; INPUTS:
;
;       R5 = UCB ADDRESS
;
; OUTPUTS:
;
;       R0,R1 PRESERVED
;       R5 = UCB ADDRESS
;
 
DWRCV:  CALL    DWRXER          ;RESYNC DEVICE
        CLR     U.RCAC(R5)      ;START NEW CRC ACCUMULATION
        MOV     R4,R3           ;COPY VCB ADDR
        ADD     #V.CIAD,R3      ;POINT TO 1ST RECV BUFFER
        MOV     (R3),U.RBUF+2(R5) ;TRANSFER RCV BUFFER ADDR
        CLR     (R3)+           ;CLR BUFFER ADDR IN VCB
        MOV     (R3),U.RCNT(R5) ;TRANSFER RECEIVE COUNT
        BIS     #STRSYN!RCVENB,(R2) ;START IN STRIP SYNC
        RETURN                  ;RETURN TO CALLER
 
        .ENDC
 
 
 

;
; DWSET - SET UP REGISTER R4 WITH CSR ADDRESS, R5 WITH
;       UCB ADDRESS.  UNIT NUMBER IN LOW ORDER 4 BITS OF UNIT.
;
 
 
 
DWSET:                          ;;;REFERENCE LABEL
        TST     R5              ;;;TEST FOR VALID UCB ADDRESS
        BEQ     10$             ;;;IF NO UCB, TROUBLE
        BIT     #U2.ONL,U.CW2(R5) ;;;UNIT ON LINE?
        BEQ     10$             ;;;IF NOT ON LINE, CAN'T TRANSFER
        MOV     U.SCB(R5),R4    ;;;FIRST GET SCB ADDRESS
        MOV     S.CSR(R4),R4    ;;;NOW DEVICE CSR ADDRESS
        RETURN                  ;;;AND NOW RETURN
 
10$:    TST     (SP)+           ;;;CLEAR STACK OF RETURN ADDRESS
DWSXT:  JMP     $INTXT          ;;;DISMISS INTERRUPT
 
        .END
        .TITLE  FCSRES - FCS RESIDENT LIBRARY FILE
        .IDENT  /M0101/
;
; COPYRIGHT   1974,  DIGITAL  EQUIPMENT  CORP.,  MAYNARD,   MASS.
;
; THIS SOFTWARE IS FURNISHED TO PURCHASER UNDER A LICENSE FOR USE
; ON A  SINGLE COMPUTER SYSTEM AND CAN BE  COPIED (WITH INCLUSION
; OF DEC'S COPYRIGHT  NOTICE) ONLY FOR USE IN SUCH SYSTEM, EXCEPT
; AS MAY OTHERWISE BE PROVIDED IN WRITING BY DEC.
;
; THE  INFORMATION  IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE  AND  SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC  ASSUMES NO  RESPONSIBILITY  FOR  THE  USE  OR  RELIABILITY
; OF  ITS  SOFTWARE ON  EQUIPMENT WHICH  IS  NOT SUPPLIED BY DEC.
;
; PETER H. LIPMAN       22-OCT-74
;
;
; THIS FILE DOCUMENTS HOW TO BUILD AN FCS RESIDENT LIBRARY,
; AND IT DEFINES ALL OF THE POSSIBLE MODULES THAT MIGHT GO INTO
; SUCH A LIBRARY.
;
; IT SHOULD BE UNDERSTOOD THAT PRECISELY HOW MUCH GOES INTO FCSRES
; IS ACTUALLY DEPENDENT ON WHICH PROGRAMS ARE GOING TO USE IT AND WHAT
; THOSE PROGRAMS REQUIRE.  THE IMPORTANT POINT TO BEAR IN MIND
; IS THAT A PROGRAM LINKING TO FCSRES MAY NOT GET MISSING FCS MODULES
; FROM THE SYSLIB.OLB OBJECT LIBRARY FILE AS WELL. A PROGRAM NEEDING
; FCS MODULES WHICH WERE NOT PLACED IN FCSRES WOULD HAVE NO CHOICE
; BUT TO LINK WITHOUT FCSRES AND USE ALL THE MODULES OUT OF SYSLIB.
;
; FOR THE OBVIOUS REASONS OF SIZE, THE MINIMUM AMOUNT SHOULD BE PUT IN
; FCSRES CONSISTENT WITH THE NEEDS OF THE PROGRAMS USING IT.
;
; THOSE ENTRY POINTS THAT ARE INVOKED BY MACROS ARE DOCUMENTED BELOW
; SO THAT IT IS POSSIBLE TO PICK WHAT SHOULD GO INTO FCSRES.
;
; IT IS INTENDED THAT THIS FILE BE EDITED TO ELIMINATE UNDESIRED 
; MODULES FROM FCSRES.
;
;       THE ACTUAL BUILDING OF FCSRES INVOLVES THE FOLLOWING:
;       1) ASSEMBLE THIS MODULE
;
;       MAC> FCSRES,FCSRES=FCSRES
;
;       2) BUILD THE LIBRARY
;
;       SET /UIC=[1,1]
;
; TO BUILD FCSRES FOR A MAPPED SYSTEM:
;
;       TKB>[1,1]FCSRES/-HD/MM/PI,LP:,SY:[1,1]FCSRES=[200,200]FCSRES
;       TKB>/
;       TKB>STACK=0
;       TKB>PAR=FCSRES:0:20000
;       TKB//
;
; TO BUILD AN FCSRES ON AN UNMAPPED SYSTEM:
;
;       TKB>SY:[1,1]FCSRES/-HD/-MM/PI,LP:,SY:[1,1]FCSRES=[200,200]FCSRES
;       TKB>/
;       TKB>STACK=0
;       TKB>PAR=FCSRES:140000:20000
;       TKB>//
;

        .MCALL  CALLR
        .PSECT  $$RESL
;
; OPENING FILES
;
        .GLOBL  .OPEN           ;OPEN$X, OPNS$X, OPNT$X
.OPFID::CALLR   .OPEN           ;OFID$X CAN USE THE OPEN$X CODE
        .GLOBL  .OPFNB          ;OFNB$X - USED FOR FORTAN RUN TIME
;
; CLOSING FILES
;
        .GLOBL  .CLOSE          ;CLOSE$
;
