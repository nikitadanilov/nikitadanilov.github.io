<!DOCTYPE html>
<html>
 <head>
   <meta name="viewport"
         content="width=device-width,
         initial-scale=1">
   <meta charset="UTF-8">
   <title>a very occasional diary @ Nikita Danilov | 3-lisp: an infinite tower of meta-circular interpreters.</title>
   <link rel="stylesheet" href="style.css">
   <style></style>
   <script async src="https://www.googletagmanager.com/gtag/js?id=G-WEM34DWDR2"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WEM34DWDR2');
</script>
   
 </head>
 <body>
   <a name="3-lisp"></a><div class="column"><header>3-lisp: an infinite tower of meta-circular interpreters.</header>
<a name="3-lisp-00000"></a><p><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/3-lisp/epigraph.png" border="0" width="75%"></center></p>
<a name="3-lisp-00001"></a><p><a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.lisp#L259">Source</a></p>
<a name="3-lisp-00002"></a><h2>Précis</h2>
<a name="3-lisp-00003"></a><p>3-LISP is a dialect of LISP designed and implemented by <a href="https://en.wikipedia.org/wiki/Brian_Cantwell_Smith">Brian C. Smith</a> as part of his PhD. thesis <a href="https://dspace.mit.edu/handle/1721.1/15961">Procedural Reflection in Programming Languages</a> (what this thesis refers to as &quot;<a href="https://en.wikipedia.org/wiki/Reflective_programming">reflection</a>&quot; is nowadays more usually called &quot;<a href="https://en.wikipedia.org/wiki/Reification_(computer_science)">reification</a>&quot;). A 3-LISP program is conceptually executed by an interpreter written in 3-LISP that is itself executed by an interpreter written in 3-LISP and so on <i>ad infinitum</i>. This forms a (countably) infinite tower of meta-circular (<i>v.i.</i>) interpreters. <i>reflective lambda</i> is a function that is executed one tower level above its caller. Reflective lambdas provide a very general language extension mechanism.</p>
<a name="3-lisp-00004"></a><p>The code is <a href="https://github.com/nikitadanilov/3-lisp">here</a>.</p>
<a name="3-lisp-00005"></a><h2>Meta-circular interpreters</h2>
<a name="3-lisp-00006"></a><p>An <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> is a program that executes programs written in some programming language.</p>
<a name="3-lisp-00007"></a><p>A <a href="https://en.wikipedia.org/wiki/Meta-circular_evaluator">meta-circular interpreter</a> is an interpreter for a programming language written in that language. Meta-circular interpreters can be used to clarify or define the semantics of the language by reducing the full language to a sub-language in which the interpreter is expressed.  Historically, such <i>definitional interpreters</i> become popular within the functional programming community, see the classical <a href="https://surface.syr.edu/cgi/viewcontent.cgi?article=1012&amp;context=lcsmith_other">Definitional interpreters for higher-order programming languages</a>. Certain important techniques were classified and studied in the framework of meta-circular interpretation, for example, <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a> can be understood as a mechanism that makes meta-circular interpretation independent of the <a href="https://en.wikipedia.org/wiki/Evaluation_strategy">evaluation strategy</a>: it allows an eager meta-language to interpret a lazy object language and <i>vice versa</i>. As a by-product, a <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a> interpreter is essentially a state machine and so can be implemented in hardware, see <a href="https://dspace.mit.edu/handle/1721.1/6334">The Scheme-79 chip</a>. Similarly, <a href="https://www.brics.dk/RS/08/4/BRICS-RS-08-4.pdf"><i>de-functionalisation</i></a> of languages with higher-order functions obtains for them first-order interpreters. But meta-circular interpreters occur in imperative contexts too, for example, the usual proof of the <a href="https://en.wikipedia.org/wiki/Structured_program_theorem">Böhm–Jacopini theorem</a> (interestingly, it was <a href="https://en.wikipedia.org/wiki/Corrado_B%C3%B6hm">Corrado Böhm</a> who first introduced meta-circular interpreters in his 1954 PhD. thesis) constructs for an Algol-like language a meta-circular interpreter expressed in some goto-less subset of the language and then <a href="https://en.wikipedia.org/wiki/Partial_evaluation">specialises</a> this interpreter for a particular program in the source language.</p>
<a name="3-lisp-00008"></a><p>Given a language with a meta-circular interpreter, suppose that the language is extended with a mechanism to <i>trap</i> to the meta-level. For example, in a LISP-like language, that trap can be a new special form <code class="inline">(reflect FORM)</code> that directly executes (rather than interprets) <code class="inline">FORM</code> within the interpreter. Smith is mostly interested in reflective (<i>i.e.</i>, reification) powers obtained this way, and it is clear that the meta-level trap provides a very general language extension method: one can add new primitives, data types, flow and sequencing control operators, <i>etc</i>. But if you try to add <code class="inline">reflect</code> to an existing LISP meta-circular interpreter (for example, see p. 13 of <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">LISP 1.5 Programmers Manual</a>) you&#x27;d hit a problem: <code class="inline">FORM</code> cannot be executed at the meta-level, because at this level it is not a form, but an <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a>.</p>
<a name="3-lisp-00009"></a><h2>Meta-interpreting machine code</h2>
<a name="3-lisp-00010"></a><p>To understand the nature of the problem, consider a very simple case: the object language is the machine language (or equivalently the assembly language) of some processor. Suppose that the interpreter for the machine code is written in (or, more realistically, compiled to) the same machine language. The interpreter maintains the state of the simulated processor that is, among other things registers and memory. Say, the object (interpreted) code can access a register, <code class="inline">R0</code>, then the interpreter has to keep the contents of this register somewhere, but typically not in <i>its</i> (interpreter&#x27;s) <code class="inline">R0</code>. Similarly, a memory word visible to the interpreted code at an address <code class="inline">ADDR</code> is stored by the interpreter at some, generally different, address <code class="inline">ADDR&#x27;</code> (although, by applying the <a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">contractive mapping theorem</a> and a <i>lot</i> of hand-waving one might argue that there will be at least one word stored at the same address at the object- and meta-levels). Suppose that the interpreted machine language has the usual sub-routine call-return instructions <code class="inline">call ADDR</code> and <code class="inline">return</code> and is extended with a new instruction <code class="inline">reflect ADDR</code> that forces the interpreter to call the sub-routine <code class="inline">ADDR</code>. At the very least the interpreter needs to convert <code class="inline">ADDR</code> to the matching <code class="inline">ADDR&#x27;</code>. This might not be enough because, for example, the object-level sub-routine <code class="inline">ADDR</code> might not be contiguous at the meta-level, <i>i.e.</i>, it is not guaranteed that if <code class="inline">ADDR</code> maps to <code class="inline">ADDR&#x27;</code> then <code class="inline">(ADDR + 1)</code> maps <code class="inline">(ADDR&#x27; + 1)</code>. This example demonstrates that a reflective interpreter needs a systematic and efficient way of converting or translating between object- and meta-level representations. If such a method is somehow provided, <code class="inline">reflect</code> is a very powerful mechanism: by modifying interpreter state and code it can add new instructions, addressing modes, condition bits, branch predictors, <i>etc</i>.</p>
<a name="3-lisp-00011"></a><h2>N-LISP for a suitable value of N</h2>
<a name="3-lisp-00012"></a><p>In his thesis Prof. Smith analyses what would it take to construct a dialect of LISP for which a faithful reflective meta-circular interpreter is possible. He starts by defining a formal model of computation with an (extremely) rigorous distinction between meta- and object- levels (and, hence, between <a href="https://en.wikipedia.org/wiki/Use%E2%80%93mention_distinction">use and mention</a>). It is then determined that this model can not be satisfactorily applied to the <i>traditional</i> LISP (which is called 1-LISP in the thesis and is mostly based on <a href="https://en.wikipedia.org/wiki/Maclisp">Maclisp</a>). The reason is that LISP&#x27;s notion of <a href="https://en.wikipedia.org/wiki/Eval#Lisp">evaluation</a> conflates two operations: <a href="https://en.wikipedia.org/wiki/Normal_form_(abstract_rewriting)">normalisation</a> that operates within the level and <a href="https://en.wikipedia.org/wiki/Referent">reference</a> that moves one level down. A dialect of LISP that consistently separates normalisation and reference is called 2-LISP (the then new <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> is called 1.75-LISP). Definition of 2-LISP occupies the bulk of the thesis, which the curious reader should consult for (exciting, believe me) details.</p>
<a name="3-lisp-00013"></a><p>Once 2-LISP is constructed, adding the reflective capability to it is relatively straightforward. Meta-level trap takes the form of a special <a href="https://en.wikipedia.org/wiki/Anonymous_function#Lisp">lambda expression</a>:</p>
<a name="3-lisp-00014"></a><pre><code>(lambda reflect [ARGS ENV CONT] BODY)</code></pre>
<a name="3-lisp-00015"></a><p>When this lambda function is applied (at the object level), the body is directly executed (not interpreted) at the meta-level with <code class="inline">ARGS</code> bound to the meta-level representation of the actual parameters, <code class="inline">ENV</code> bound to the <i>environment</i> (basically, the list of identifiers and the values they are bound to) and <code class="inline">CONT</code> bound to the <a href="https://en.wikipedia.org/wiki/Continuation">continuation</a>. Environment and continuation together represent the 3-LISP interpreter state (much like registers and memory represent the machine language interpreter state), this representation goes all the way back to <a href="https://en.wikipedia.org/wiki/SECD_machine">SECD machine</a>, see <a href="https://doi.org/10.1093%2Fcomjnl%2F6.4.308">The Mechanical Evaluation of Expressions</a>.</p>
<a name="3-lisp-00016"></a><p>Here is the <a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.lisp#L1570">fragment</a> of 3-LISP meta-circular interpreter code that handles <code class="inline">lambda reflect</code> (together with &quot;ordinary&quot; lambda-s, denoted by <code class="inline">lambda simple</code>):</p>
<a name="3-lisp-00017"></a><p><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/3-lisp/reduce.png" border="0" width="75%"></center></p>
<a name="3-lisp-00018"></a><h2>Implementation</h2>
<a name="3-lisp-00019"></a><p>It is of course not possible to run an infinite tower of interpreters directly.</p>
<a name="3-lisp-00020"></a><p><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/3-lisp/infinity.png" border="0" width="75%"></center></p>
<a name="3-lisp-00021"></a><p>3-LISP implementation creates a meta-level on demand, when a reflective lambda is invoked. At that moment the state of the meta-level interpreter is synthesised (<i>e.g.</i>, see <a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.lisp#L1586"><code class="inline">make-c1</code></a> in the listing above). The implementation takes pain to detect when it can drop down to a lower level, which is not entirely simple because a reflective lambda can, instead of returning (that is, invoking the supplied continuation), run a potentially modified version of the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">read-eval-loop</a> (called <a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.lisp#L1563"><code class="inline">READ-NORMALISE-PRINT</code></a> in 3-LISP) which does not return. There is a lot of non-trivial machinery operating behind the scenes and though the implementation modestly proclaims itself <a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.lisp#L33"><i>extremely inefficient</i></a> it is, in fact, remarkably fast.</p>
<a name="3-lisp-00022"></a><h2>Porting</h2>
<a name="3-lisp-00023"></a><p>I was unable to find a digital copy of the 3-LISP sources and so manually retyped the sources from the appendix of the thesis. The transcription in <a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.lisp">3-lisp.lisp</a> (2003 lines, 200K characters) preserves the original pagination and character set, see the comments at the top of the file. Transcription was mostly straightforward except for a few places where the PDF is illegible (for example, <a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.lisp#L396">see here</a>) all of which fortunately are within comment blocks.</p>
<a name="3-lisp-00024"></a><p>The sources are in <a href="https://dspace.mit.edu/handle/1721.1/5718">CADR machine</a> dialect of LISP, which, save for some minimal and no longer relevant details, is equivalent to Maclisp.</p>
<a name="3-lisp-00025"></a><p>3-LISP implementation does not have its own parser or interpreter. Instead, it uses flexibility built in a LISP reader (see, <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node192.html">readtables</a>) to parse, interpret and even compile 3-LISP with a very small amount of additional code. Amazingly, this more than 40 years old code, which uses arcane features like readtable customisation, runs on a modern <a href="https://en.wikipedia.org/wiki/Common_Lisp">Common Lisp</a> platform after a very small set of changes: some functions got renamed (<code class="inline">CASEQ</code> to <code class="inline">CASE</code>, <code class="inline">*CATCH</code> to <code class="inline">CATCH</code>, <i>etc</i>.), some functions are missing (<code class="inline">MEMQ</code>, <code class="inline">FIXP</code>), some signatures changed (<code class="inline">TYPEP</code>, <code class="inline">BREAK</code>, <code class="inline">IF</code>). See <a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.cl">3-lisp.cl</a> for details.</p>
<a name="3-lisp-00026"></a><p>Unfortunately, the port does not run on <i>all</i> modern Common Lisp implementations, because it relies on the proper support for <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html">backquotes</a> across recursive reader <a href="https://github.com/nikitadanilov/3-lisp/blob/master/3-lisp.cl#L92">invocations</a>:</p>
<a name="3-lisp-00027"></a><pre><code>;;     Maclisp maintains backquote context across recursive parser
;;     invocations. For example in the expression (which happens within defun
;;     3-EXPAND-PAIR)
;;
;;         `\(PCONS ~,a ~,d)
;;
;;     the backquote is consumed by the top-level activation of READ. Backslash
;;     forces the switch to 3-lisp readtable and call to 3-READ to handle the
;;     rest of the expression. Within this 3-READ activation, the tilde forces
;;     switch back to L=READTABLE and a call to READ to handle &quot;,a&quot;. In Maclisp,
;;     this second READ activation re-uses the backquote context established by
;;     the top-level READ activation. Of all Common Lisp implementations that I
;;     tried, only sbcl correctly handles this situation. Lisp Works and clisp
;;     complain about &quot;comma outside of backquote&quot;. In clisp,
;;     clisp-2.49/src/io.d:read_top() explicitly binds BACKQUOTE-LEVEL to nil.</code></pre>
<a name="3-lisp-00028"></a><p>Among Common Lisp implementations I tried, only <a href="https://www.sbcl.org/">sbcl</a> supports it properly. After reading Common Lisp <a href="http://www.lispworks.com/documentation/common-lisp.html">Hyperspec</a>, I believe that it is Maclisp and <a href="https://www.sbcl.org/">sbcl</a> that implement the specification correctly and other implementations are faulty.</p>
<a name="3-lisp-00029"></a><h2>Conclusion</h2>
<a name="3-lisp-00030"></a><p>Procedural Reflection in Programming Languages is, in spite of its age, a very interesting read. Not only does it contain an implementation of a refreshingly new and bold idea (it is not even immediately obvious that infinite reflective towers can at all be implemented, not to say with any reasonable degree of efficiency), it is based on an interplay between mathematics and programming: the model of computation is proposed and afterward implemented in 3-LISP. Because the model is implemented in an actual running program, it has to be specified with extreme precision (which would make <a href="https://en.wikipedia.org/wiki/Alfred_Tarski">Tarski</a> and <a href="https://en.wikipedia.org/wiki/Jan_%C5%81ukasiewicz">Łukasiewicz</a> tremble), and any execution of the 3-LISP interpreter validates the model.</p><footer><a href="3-iamb.html#3-iamb">&lt;</a>&nbsp;<a href="series_blog_compact_reverse_flat.html">blog</a>&nbsp;<a href="adaptive-replacement.html#adaptive-replacement">&gt;</a>&nbsp;&nbsp;&nbsp;<a href="treadmill.html#treadmill">&lt;</a>&nbsp;<a href="series_timeline_compact_reverse_flat.html">timeline</a>&nbsp;<a href="usched.html#usched">&gt;</a>&nbsp;&nbsp;&nbsp;</footer></div>
 </body>
</html>
