<!DOCTYPE html>
<html>
 <head>
   <meta charset="UTF-8">
   <title>Vale of tears.</title>
   <link rel="stylesheet" href="style.css">
   <style></style>
   
 </head>
 <body>
   <a name="vale"></a><div class="column"><header>Vale of tears.</header>
<a name="vale-00000"></a><p>Consider a system describing possible computations (<i>e.g.</i>, a programming language or a state machine formalism) including interactions with the external world, that is, input and output facilities.</p>
<a name="vale-00001"></a><p>A pair of dual sub-classes of computational elements (values, objects, functions, <i>&amp;c</i>.) can be defined:</p>
<a name="vale-00002"></a><p style="margin-left: 3em;"><i>finitary</i> elements that are known to not depend on input and</p>
<a name="vale-00003"></a><p style="margin-left: 3em;"><i>ideal</i> elements that output is known to not depend on.</p>
<a name="vale-00004"></a><p>The rest of elements may depend on input and may affect output. Let&#x27;s call such elements <i>laic</i> (&quot;temporal&quot; might be a better word).</p>
<a name="vale-00005"></a><p>The class of finitary elements is well-known: because they can be computed without input, they can be computed before the program starts, <i>i.e.</i>, they correspond to various constants, including static entities like types (in statically typed languages), classes, function bodies and so on. Some languages have powerful finitary computations, for example, C++ template specialisation is Turing complete.</p>
<a name="vale-00006"></a><p>Laic elements are the most usual things like variables and objects.</p>
<a name="vale-00007"></a><p>Ideal elements are less known. They have a long history of use in the area of formal program verification where they are called <a href="http://www-sop.inria.fr/everest/personnel/Mariela.Pavlova/ghost.pdf"><i>ghost</i></a> or <i>auxiliary</i> variables.</p>
<a name="vale-00008"></a><p>There is an obvious restriction of data and control flow between various types of elements:</p>
<a name="vale-00009"></a><p style="margin-left: 3em;">finitary element may depend only on finitary elements;</p>
<a name="vale-00010"></a><p style="margin-left: 3em;">laic element may depend on laic and finitary elements (<i>e.g.</i>, normal function  can take a constant as a parameter, but constant cannot be initialised with the  value of a variable or function call);</p>
<a name="vale-00011"></a><p style="margin-left: 3em;">ideal element may depend on any element (<i>e.g.</i>, ideal variable can be assigned  the value of a laic variable, but not other way around).</p>
<a name="vale-00012"></a><p>The most important property of ideal elements is that, because they don&#x27;t affect observable program behaviour, there is no need to actually compute them! Yet, they are useful exactly because of this property: ideal elements are not computed and, hence, are not constrained by the limitations of actual computational environments. For example, an ideal variable can represent an infinite (even uncountable) collection or a real number (real real number, not approximation); an ideal function can be defined by the transfinite induction or by a formula involving quantifiers.</p>
<a name="vale-00013"></a><p>To use ideal elements, one assumes that they follow normal rules of the language (for example, axiomatic or denotational <a href="<a href="http://en.wikipedia.org/wiki/Semantics_(computer_science)">semantics</a>). This assumption doesn&#x27;t burden the implementors of the language precisely because the ideal elements are not computed. Under that assumption, one can reason about properties of ideal elements.</p>
<a name="vale-00014"></a><p>As a simplest example, an ideal variable can be used to record the sequence of calls to a certain function:</p>
<a name="vale-00015"></a><pre><code>ideal f_seq = {};
function f(arg) {
        f_seq := f_seq ++ arg;
        ...
};</code></pre>
<a name="vale-00016"></a><p>and then reason about <code class="inline">f_seq</code> using whatever method is used to reason about laic elements (<i>e.g.</i>, <a href="http://en.wikipedia.org/wiki/Predicate_transformer_semantics">weakest preconditions</a>, <a href="http://en.wikipedia.org/wiki/Hoare_triple">Hoare triples</a> or usual hand-waving), for example, to prove that messages delivered to a receiver were sent by the sender (that is, <code class="inline">deliver_seq</code> is a sub-sequence of <code class="inline">send_seq</code>).</p>
<a name="vale-00017"></a><p>It is interesting that both finitary elements (specifically, static types) and ideal elements help to reason about the behaviour of the laic world sandwiched between them.</p>
<a name="vale-00018"></a><p>Nothing in this short article is new, except for the (obvious) duality between ideal and finitary elements.</p>
<a name="vale-00019"></a><p><i>Exercise</i> 0: implement <a href="http://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems">linear types</a> by casting laic elements to ideal.</p>
<a name="vale-00020"></a><p><i>Exercise</i> 1: implement garbage collection similarly.</p><footer><a href="usched.update.html#usched.update">&lt;</a>&nbsp;<a href="series_blog.html">blog</a>&nbsp;<a href="zero.html#zero">&gt;</a>&nbsp;&nbsp;&nbsp;<a href="side-effete.html#side-effete">&lt;</a>&nbsp;<a href="series_timeline.html">timeline</a>&nbsp;<a href="affinity.html#affinity">&gt;</a>&nbsp;&nbsp;&nbsp;</footer></div>
 </body>
</html>
