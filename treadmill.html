<!DOCTYPE html>
<html>
 <head>
   <meta charset="UTF-8">
   <title>a very occasional diary @ Nikita Danilov | Treadmill</title>
   <link rel="stylesheet" href="style.css">
   <style></style>
   <script async src="https://www.googletagmanager.com/gtag/js?id=G-WEM34DWDR2"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WEM34DWDR2');
</script>
   
 </head>
 <body>
   <a name="treadmill"></a><div class="column"><header>Treadmill</header><p class="margin-left"><span class="annotation" data-uid="0">[<a href="https://dl.acm.org/doi/pdf/10.1145/130854.130862"><span style="color: orange">0</span></a>]</span>&nbsp;<span class="annotation" data-uid="1">[<a href="https://www.plover.com/~mjd/misc/hbaker-archive/NoMotionGC.ps.Z"><span style="color: blue">1</span></a>]</span>&nbsp;</p>
<a name="treadmill-00000"></a><p><i>Treadmill</i> is a &quot;real-time&quot; in-place garbage collection algorithm (<span class="linktarget" data-uid="0"><a href="https://dl.acm.org/doi/pdf/10.1145/130854.130862">PDF</a></span>, <span class="linktarget" data-uid="1"><a href="https://www.plover.com/~mjd/misc/hbaker-archive/NoMotionGC.ps.Z">Postscript</a></span>) designed by H. Baker. It is simple, elegant, efficient and surprisingly little known. Speaking of which, Mr. Baker&#x27;s Wikipedia <a href="https://en.wikipedia.org/wiki/Henry_Baker_(computer_scientist)">page</a> rivals one for an obscure Roman decadent poet in scarcity of information.</p>
<a name="treadmill-00001"></a><p>The general situation of garbage collection is that there is a program (called <i>a mutator</i> in this case) that allocates <i>objects</i> (that will also be called <i>nodes</i>) in a <i>heap</i>, which is a pool of memory managed by the garbage collector. The mutator can update objects to point to other earlier allocated objects so that objects form a graph, possibly with cycles. The mutator can store pointers to objects in some locations outside of the heap, for example in the stack or in the registers. These locations are called <i>roots</i>.</p>
<a name="treadmill-00002"></a><p>The mutator allocates objects, but does not frees them explicitly. It is the job of the garbage collector to return unreachable objects, that is, the objects that can not be reached by following pointers from the roots, back to the allocation pool.</p>
<a name="treadmill-00003"></a><p>It is assumed that the collector, by looking at an object, can identify all pointers to the heap stored in the object and that the collector knows all the roots. If either of these assumptions does not hold, one needs a <i>conservative collector</i> that can be implemented as a library for an uncooperative compiler and run-time (<i>e.g.</i>, <a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector">Boehm garbage collector</a> for C and C++).</p>
<a name="treadmill-00004"></a><p>The earliest garbage collectors were part of Lisp run-time. <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> programs tend to allocate a large number of <a href="https://en.wikipedia.org/wiki/Cons">cons cells</a> and organise them in complex structures with cycles and sub-structure sharing. In fact, some of the <a href="https://en.wikipedia.org/wiki/Lisp_machine">Lisp Machines</a> had garbage collection implemented in hardware and allocated everything including stack frames and binding environments in the heap. Even processor instructions were stored as <a href="https://en.wikipedia.org/wiki/Cons">cons cells</a> in the heap.</p>
<a name="treadmill-00005"></a><p>To allocate a new object, the mutator calls <code class="inline">alloc()</code>. Treadmill is &quot;real-time&quot; because the cost of <code class="inline">alloc()</code> in terms of processor cycles is independent of the number of allocated objects and the total size of the heap, in other words, <code class="inline">alloc()</code> is O(1) and this constant cost is not high. This means garbage collection without &quot;stop-the-world&quot; pauses, at least as long as the mutator does not genuinely exhaust the heap with reachable objects.</p>
<a name="treadmill-00006"></a><p>Treadmill is &quot;in-place&quot; because the address of an allocated object does not change. This is in contrast with <i>copying</i> garbage collectors that can move an object to a new place as part of the collection process (that implies some mechanism of updating the pointers to the moved object).</p><p class="margin-left"><span class="annotation" data-uid="0">[<a href="https://lamport.azurewebsites.net/pubs/garbage.pdf"><span style="color: orange">2</span></a>]</span>&nbsp;</p>
<a name="treadmill-00007"></a><p>All existing garbage collection algorithms involve some form of scanning of allocated objects and this scanning is usually described in terms of colours assigned to objects. In the standard 3-colour scheme (introduced together with the term &quot;mutator&quot; in <a href="https://lamport.azurewebsites.net/pubs/garbage.pdf"><span class="linktarget" data-uid="0">On-the-Fly Garbage Collection: An Exercise in Cooperation</span></a>), <b>black</b> objects have been completely scanned together with the objects they point to, <b>gray</b> objects have been scanned, but the objects they point to are not guaranteed to be scanned and <b>white</b> objects have not been scanned.</p>
<a name="treadmill-00008"></a><p>For historical reasons, Baker&#x27;s papers colour free (un-allocated) objects white and use black-gray-<a href="https://en.wikipedia.org/wiki/Ecru">ecru</a> instead of black-gray-white. We stick with <b>ecru</b>, at least to get a chance to learn a fancy word.</p>
<a name="treadmill-00009"></a><p>Consider the simplest case first:</p>
<a name="treadmill-00010"></a><p style="margin-left: 3em;">the heap has a fixed size;</p>
<a name="treadmill-00011"></a><p style="margin-left: 3em;">the mutator is single-threaded;</p>
<a name="treadmill-00012"></a><p style="margin-left: 3em;">allocated objects all have the same size (like cons cells).</p>
<a name="treadmill-00013"></a><p>(All these restrictions will be lifted eventually.)</p>
<a name="treadmill-00014"></a><p>The main idea of treadmill is that all objects in the heap are organised in a cyclic double-linked list, divided by 4 pointers into 4 segments (Figure 0):</p>
<a name="treadmill-00015"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/0-treadmill.png" border="0" width="50%"></center></p><p class="margin-left"><span class="annotation" data-uid="0">[<a href="https://dspace.mit.edu/bitstream/handle/1721.1/41976/AI_WP_139.pdf"><span style="color: orange">3</span></a>]</span>&nbsp;</p>
<a name="treadmill-00016"></a><p>Allocation of new objects happens at <code class="inline">free</code> (clockwise), scan advances at <code class="inline">scan</code> (counterclockwise), still non-scanned objects are between <code class="inline">bottom</code> and <code class="inline">top</code> (the latter 2 terms, somewhat confusing for a cyclic list of objects, are re-used from an earlier <a href="https://dspace.mit.edu/bitstream/handle/1721.1/41976/AI_WP_139.pdf"><span class="linktarget" data-uid="0">paper</span></a>, where a copying real-time garbage collector was introduced).</p>
<a name="treadmill-00017"></a><p>Remarkably, the entire description and the proof of correctness of Treadmill algorithm (and many other similar algorithms) depends on a single invariant:</p>
<a name="treadmill-00018"></a><p style="margin-left: 3em;"><b>Invariant</b>: there are no pointers from black to ecru nodes.</p>
<a name="treadmill-00019"></a><p>That is, a black node can contain a pointer to another black node or to a gray node. A non-black (that is, gray or ecru) node can point to any allocated node: black, gray or ecru. An ecru node can be reached from a black node only through at least one intermediate gray node.</p>
<a name="treadmill-00020"></a><p>Let&#x27;s for the time being postpone the explanation of why this invariant is important and instead discuss the usual 2 issues that any invariant introduces: how to establish it and how to maintain it.</p>
<a name="treadmill-00021"></a><p>Establishing is easy:</p>
<a name="treadmill-00022"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/4-init.png" border="0" width="50%"></center></p>
<a name="treadmill-00023"></a><p>In the initial state, all objects are un-allocated (white), except for the roots that are gray. The invariant is satisfied trivially because there are no black objects.</p>
<a name="treadmill-00024"></a><p>After some allocations by the mutator and scanning, the heap looks like the one in Figure 0. A call to <code class="inline">alloc()</code> advances <code class="inline">free</code> pointer clockwise, thus moving one object from <code class="inline">FREE</code> to <code class="inline">SCANNED</code> part of the heap. There is no need to update double-linked list pointers within the allocated object and, as we will see, there is no need to change the object colour. This makes the allocation fast path very quick: just a single pointer update: <code class="inline">free := free.next</code>.</p>
<a name="treadmill-00025"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/1-alloc.png" border="0" width="50%"></center></p><p class="margin-left"><span class="annotation" data-uid="0">[<a href="https://gchandbook.org/"><span style="color: orange">4</span></a>]</span>&nbsp;</p>
<a name="treadmill-00026"></a><p>Allocation cannot violate the invariant, because the newly allocated object does not point to anything. In addition to calls to <code class="inline">alloc()</code> the mutator can read pointer fields from nodes it already reached and update fields of reachable nodes to point to other reachable nodes. There is no pointer arithmetic (otherwise a conservative collector is needed). A reachable node is either black, gray or ecru, so it seems, at the first sight, that the only way the mutator can violate the invariant is by setting a field in a black object to point to an ecru object. This is indeed the case with some collection algorithms (called &quot;gray mutator algorithms&quot; in <span class="linktarget" data-uid="0">The Garbage Collection Handbook</span>). Such algorithms use a <i>write barrier</i>, which is a special code inserted by the compiler before (or instead of) updating a pointer field. The simplest write barrier prevents a violation of the 3-colour invariant by graying the ecru target object if necessary:</p>
<a name="treadmill-00027"></a><pre><code>writebarrier(obj, field, target) {
        obj.field := target;
        if black(obj) &amp;&amp; ecru(target) {
                darken(target);
        }
}
darken(obj) { /* Make an ecru object gray. */
        assert ecru(obj);
        unlink(obj); /* Remove the object from the treadmill list. */
        link(top, obj); /* Put it back at the tail of the gray list. */
}</code></pre>
<a name="treadmill-00028"></a><p>More sophisticated write barriers were studied that make use of the old value of <code class="inline">obj.field</code> or are integrated with virtual memory sub-system, see <a href="https://gchandbook.org/">The Garbage Collection Handbook</a> for details.</p>
<a name="treadmill-00029"></a><p>In our case, however, when the mutator reads a pointer field of an object, it effectively stores the read value in a register (or in a stack frame slot) and in Treadmill, registers can be black (Treadmill is a &quot;black mutator algorithm&quot;). That is, the mutator can violate the invariant simply by reading the pointer to an ecru object in a black register. To prevent this a <i>read barrier</i> is needed, executed on every read of a pointer field:</p>
<a name="treadmill-00030"></a><pre><code>readbarrier(obj, field) {
        if ecru(obj) {
                darken(obj);
        }
        return obj.field;
}</code></pre>
<a name="treadmill-00031"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/3-barrier.png" border="0" width="50%"></center></p>
<a name="treadmill-00032"></a><p>When a black or gray object is read, the read barrier leaves it in place. When an ecru object is read, the barrier un-links the object from the treadmill list (effectively removing it from <code class="inline">TOSCAN</code> section) and re-links it to the treadmill either at <code class="inline">top</code> or at <code class="inline">scan</code> thus making it gray. This barrier guarantees that the mutator cannot violate the invariant simply because the mutator never sees ecru objects (which are grayed by the barrier) and hence cannot store pointers to them anywhere. If the read barrier is present, the write barrier is not necessary.</p>
<a name="treadmill-00033"></a><p>That&#x27;s how the invariant is established and maintained by the mutator. We still haven&#x27;t discussed how the collector works and where these mysterious ecru objects appear from. The collector is very simple: it has a single entry point:</p>
<a name="treadmill-00034"></a><pre><code>advance() { /* Scan the object pointed to by &quot;scan&quot;. */
        for field in pointers(scan) {
                if ecru(scan.field) {
                        darken(scan.field);
                }
        }
        scan := scan.prev; /* Make it black. */
}</code></pre>
<a name="treadmill-00035"></a><p><code class="inline">advance()</code> takes the gray object pointed to by <code class="inline">scan</code>, which is the head of the <code class="inline">FRONT</code> list, and grays all ecru objects that this object points to. After that, <code class="inline">scan</code> is advanced (counterclockwise), effectively moving the scanned object into the <code class="inline">SCANNED</code> section and making it black.</p>
<a name="treadmill-00036"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/2-scan.png" border="0" width="50%"></center></p>
<a name="treadmill-00037"></a><p>It&#x27;s not important for now how and when exactly <code class="inline">advance()</code> is called. What matters is that it blackens an object while preserving the invariant.</p>
<a name="treadmill-00038"></a><p>Now comes the crucial part. An allocated object only darkens: the mutator (<code class="inline">readbarrier()</code>) and the collector (<code class="inline">advance()</code>) can gray an ecru object and <code class="inline">advance()</code> blackens a gray object. There is no way for a black object to turn gray or for a gray object to turn ecru. Hence, the total number of allocated non-black objects never increases. But <code class="inline">advance()</code> always blackens one object, which means that after some number of calls (interspersed with arbitrary mutator activity), <code class="inline">advance()</code> will run out of objects to process: the <code class="inline">FRONT</code> section will be empty and there will be no gray objects anymore:</p>
<a name="treadmill-00039"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/5-nogray.png" border="0" width="50%"></center></p>
<a name="treadmill-00040"></a><p>All roots were originally gray and could only darken, so they are now black. And an ecru object is reachable from a black object only through a gray object, but there are no gray objects, so ecru objects are not reachable from rootsâ€”they are garbage. This completes the collection cycle and, in principle, it is possible to move all ecru objects to the <code class="inline">FREE</code> list at that point and start the next collection cycle. But we can do better. Instead of replenishing the <code class="inline">FREE</code> list, wait until all objects are allocated and the <code class="inline">FREE</code> list is empty:</p>
<a name="treadmill-00041"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/6-end.png" border="0" width="50%"></center></p>
<a name="treadmill-00042"></a><p>Only black and ecru objects remain. <i>Flip</i> them: swap <code class="inline">top</code> and <code class="inline">bottom</code> pointers and redefine colours: the old black objects are now ecru and the old ecru objects (remember they are garbage) are now white:</p>
<a name="treadmill-00043"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/7-flip.png" border="0" width="50%"></center></p>
<a name="treadmill-00044"></a><p>The next collection cycle starts: put the roots between <code class="inline">top</code> and <code class="inline">scan</code> so that they are the new <code class="inline">FRONT</code>:</p>
<a name="treadmill-00045"></a><p style="margin-left: 6em;"><center>
<img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/master/treadmill/8-again.png" border="0" width="50%"></center></p>
<a name="treadmill-00046"></a><p>From this point <code class="inline">alloc()</code> and <code class="inline">advance()</code> can continue as before.</p>
<a name="treadmill-00047"></a><p>Note that <code class="inline">alloc()</code>, <code class="inline">advance()</code> and <code class="inline">readbarrier()</code> do not actually have to know object colour. They only should be able to tell an ecru (allocated) object from non-ecru, so 1 bit of information per object is required. By waiting until the <code class="inline">FREE</code> list is empty and re-defining colours Treadmill avoids the need to scan the objects and change their colours at the end of a collection cycle: it is completely O(1).</p>
<a name="treadmill-00048"></a><p>The last remaining bit of the puzzle is still lacking: how is it guaranteed that the collection is completed before the <code class="inline">FREE</code> list is empty? If the mutator runs out of free objects before the collection cycle is completed, then the only option is to force the cycle to completion by calling <code class="inline">advance()</code> repeatedly until there are no more gray objects and then flip, but that&#x27;s a stop-the-world situation.</p>
<a name="treadmill-00049"></a><p>The solution is to call <code class="inline">advance()</code> from within <code class="inline">alloc()</code> guaranteeing scan progress. Baker proved that if <code class="inline">advance()</code> is called <code class="inline">k</code> times for each <code class="inline">alloc()</code> call, then the algorithm never runs out of free objects, provided that the total heap size is at least <code class="inline">R*(1 + 1/k)</code> objects, where <code class="inline">R</code> is the number of reachable objects.</p>
<a name="treadmill-00050"></a><p>This completes the Treadmill description.</p>
<a name="treadmill-00051"></a><p>The algorithm is very flexible. First, the restriction of a single-threaded mutator is not really important: as long as <code class="inline">alloc()</code>, <code class="inline">advance()</code>, <code class="inline">readbarrier()</code> and flip are mutually exclusive, no further constraints on concurrency are necessary. The mutator can be multi-threaded. The collector can be multi-threaded. <code class="inline">advance()</code> can be called &quot;synchronously&quot; (from <code class="inline">alloc()</code>), explicitly from the mutator code or &quot;asynchronously&quot; from the dedicated collector threads. A feedback-based method can regulate the frequency of calls to <code class="inline">advance()</code> depending on the amount of free and garbage objects. <code class="inline">alloc()</code> can penalise heavy-allocating threads forcing them to do most of the scanning, <i>etc</i>.</p>
<a name="treadmill-00052"></a><p>Next, when an object is grayed by <code class="inline">darken()</code>, all that matter is that the object is placed in the <code class="inline">FRONT</code> section. If <code class="inline">darken()</code> places the object next to <code class="inline">top</code>, then <code class="inline">FRONT</code> acts as a FIFO queue and the scan proceeds in the breadth-first order. If the object is placed next to <code class="inline">scan</code> then the scan proceeds in the depth-first order, which might result in a better locality of reference and better performance of a heap in virtual memory. A multi-threaded collector can use multiple <code class="inline">FRONT</code> lists, <i>e.g.</i>, one per core and scan them concurrently.</p>
<a name="treadmill-00053"></a><p>New objects can be added to the heap at any time, by atomically linking them somewhere in the <code class="inline">FREE</code> list. Similarly, a bunch of objects can be at any moment atomically released from the <code class="inline">FREE</code> list with the usual considerations of fragmentation-avoidance in the lower layer allocator.</p>
<a name="treadmill-00054"></a><p>Support for variable-sized objects requires a separate cyclic list for each size (plus, perhaps an additional overflow list for very large objects). The <code class="inline">top</code>, <code class="inline">bottom</code>, <code class="inline">scan</code> and <code class="inline">free</code> pointers become arrays of pointers with an element for each size. If arbitrarily large objects (<i>e.g.</i>, arrays) are supported then atomicity of <code class="inline">advance()</code> will require additional work: large objects need to be multi-coloured and will blacken gradually.</p>
<a name="treadmill-00055"></a><p>Forward and backward links to the cyclic list can be embedded in the object header or they can be stored separately, the latter might improve cache utilisation by the scanner.</p><footer><a href="stack-queue.html#stack-queue">&lt;</a>&nbsp;<a href="series_blog_compact_reverse.html">blog</a>&nbsp;<a href="unintentionally.html#unintentionally">&gt;</a>&nbsp;&nbsp;&nbsp;<a href="later-360.html#later-360">&lt;</a>&nbsp;<a href="series_timeline_compact_reverse.html">timeline</a>&nbsp;<a href="3-lisp.html#3-lisp">&gt;</a>&nbsp;&nbsp;&nbsp;</footer></div>
 </body>
</html>
